var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name2 in all)
    __defProp(target, name2, {get: all[name2], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  __markAsModule(target);
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true}), module2);
};
var __decorate = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator2; i >= 0; i--)
    if (decorator2 = decorators[i])
      result = (kind ? decorator2(target, key, result) : decorator2(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports2, module2) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  module2.exports = {
    SEMVER_SPEC_VERSION,
    MAX_LENGTH,
    MAX_SAFE_INTEGER,
    MAX_SAFE_COMPONENT_LENGTH
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports2, module2) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module2.exports = debug;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports2, module2) => {
  var {MAX_SAFE_COMPONENT_LENGTH} = require_constants();
  var debug = require_debug();
  exports2 = module2.exports = {};
  var re = exports2.re = [];
  var src = exports2.src = [];
  var t = exports2.t = {};
  var R = 0;
  var createToken = (name2, value, isGlobal) => {
    const index = R++;
    debug(index, value);
    t[name2] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports2, module2) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module2.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports2, module2) => {
  var debug = require_debug();
  var {MAX_LENGTH, MAX_SAFE_INTEGER} = require_constants();
  var {re, t} = require_re();
  var {compareIdentifiers} = require_identifiers();
  var SemVer = class {
    constructor(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.format();
      this.raw = this.version;
      return this;
    }
  };
  module2.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports2, module2) => {
  var {MAX_LENGTH} = require_constants();
  var {re, t} = require_re();
  var SemVer = require_semver();
  var parse4 = (version2, options) => {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 !== "string") {
      return null;
    }
    if (version2.length > MAX_LENGTH) {
      return null;
    }
    const r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version2)) {
      return null;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      return null;
    }
  };
  module2.exports = parse4;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports2, module2) => {
  var parse4 = require_parse();
  var valid = (version2, options) => {
    const v = parse4(version2, options);
    return v ? v.version : null;
  };
  module2.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports2, module2) => {
  var parse4 = require_parse();
  var clean = (version2, options) => {
    const s = parse4(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module2.exports = clean;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var inc = (version2, release, options, identifier) => {
    if (typeof options === "string") {
      identifier = options;
      options = void 0;
    }
    try {
      return new SemVer(version2, options).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };
  module2.exports = inc;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module2.exports = compare;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module2.exports = eq;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports2, module2) => {
  var parse4 = require_parse();
  var eq = require_eq();
  var diff3 = (version1, version2) => {
    if (eq(version1, version2)) {
      return null;
    } else {
      const v12 = parse4(version1);
      const v2 = parse4(version2);
      const hasPre = v12.prerelease.length || v2.prerelease.length;
      const prefix = hasPre ? "pre" : "";
      const defaultResult = hasPre ? "prerelease" : "";
      for (const key in v12) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v12[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  };
  module2.exports = diff3;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module2.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module2.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module2.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports2, module2) => {
  var parse4 = require_parse();
  var prerelease = (version2, options) => {
    const parsed = parse4(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module2.exports = prerelease;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module2.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module2.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module2.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports2, module2) => {
  var compareBuild = require_compare_build();
  var sort = (list2, loose) => list2.sort((a, b) => compareBuild(a, b, loose));
  module2.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports2, module2) => {
  var compareBuild = require_compare_build();
  var rsort = (list2, loose) => list2.sort((a, b) => compareBuild(b, a, loose));
  module2.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module2.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module2.exports = lt;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module2.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module2.exports = gte;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module2.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports2, module2) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module2.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var parse4 = require_parse();
  var {re, t} = require_re();
  var coerce = (version2, options) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    let match3 = null;
    if (!options.rtl) {
      match3 = version2.match(re[t.COERCE]);
    } else {
      let next;
      while ((next = re[t.COERCERTL].exec(version2)) && (!match3 || match3.index + match3[0].length !== version2.length)) {
        if (!match3 || next.index + next[0].length !== match3.index + match3[0].length) {
          match3 = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match3 === null)
      return null;
    return parse4(`${match3[2]}.${match3[3] || "0"}.${match3[4] || "0"}`, options);
  };
  module2.exports = coerce;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports2, module2) => {
  var Range34 = class {
    constructor(range2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range2 instanceof Range34) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range34(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2;
      this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${range2}`);
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const loose = this.options.loose;
      range2 = range2.trim();
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range2);
      range2 = range2.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range2, re[t.COMPARATORTRIM]);
      range2 = range2.replace(re[t.TILDETRIM], tildeTrimReplace);
      range2 = range2.replace(re[t.CARETTRIM], caretTrimReplace);
      range2 = range2.split(/\s+/).join(" ");
      const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      return range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range34)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  };
  module2.exports = Range34;
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceTilde(comp2, options);
  }).join(" ");
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret2;
      if (isX(M)) {
        ret2 = "";
      } else if (isX(m)) {
        ret2 = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret2 = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret2 = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret2 = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret2);
      return ret2;
    });
  };
  var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceCaret(comp2, options);
  }).join(" ");
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret2;
      if (isX(M)) {
        ret2 = "";
      } else if (isX(m)) {
        ret2 = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret2 = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret2 = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret2 = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret2 = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret2 = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret2 = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret2 = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret2 = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret2);
      return ret2;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((comp2) => {
      return replaceXRange(comp2, options);
    }).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret2, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret2, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret2 = "<0.0.0-0";
        } else {
          ret2 = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<")
          pr = "-0";
        ret2 = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret2 = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret2 = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret2);
      return ret2;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version2, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports2, module2) => {
  var ANY = Symbol("SemVer ANY");
  var Comparator = class {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range34(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range34(this.value, options).test(comp.semver);
      }
      const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      const sameSemVer = this.semver.version === comp.semver.version;
      const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
      const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  };
  module2.exports = Comparator;
  var {re, t} = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range34 = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports2, module2) => {
  var Range34 = require_range();
  var satisfies = (version2, range2, options) => {
    try {
      range2 = new Range34(range2, options);
    } catch (er) {
      return false;
    }
    return range2.test(version2);
  };
  module2.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports2, module2) => {
  var Range34 = require_range();
  var toComparators = (range2, options) => new Range34(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module2.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range34 = require_range();
  var maxSatisfying = (versions, range2, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range34(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module2.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range34 = require_range();
  var minSatisfying = (versions, range2, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range34(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module2.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range34 = require_range();
  var gt = require_gt();
  var minVersion = (range2, loose) => {
    range2 = new Range34(range2, loose);
    let minver = new SemVer("0.0.0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
    }
    if (minver && range2.test(minver)) {
      return minver;
    }
    return null;
  };
  module2.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports2, module2) => {
  var Range34 = require_range();
  var validRange = (range2, options) => {
    try {
      return new Range34(range2, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module2.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var {ANY} = Comparator;
  var Range34 = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version2, range2, hilo, options) => {
    version2 = new SemVer(version2, options);
    range2 = new Range34(range2, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range2, options)) {
      return false;
    }
    for (let i = 0; i < range2.set.length; ++i) {
      const comparators = range2.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module2.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports2, module2) => {
  var outside = require_outside();
  var gtr = (version2, range2, options) => outside(version2, range2, ">", options);
  module2.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports2, module2) => {
  var outside = require_outside();
  var ltr = (version2, range2, options) => outside(version2, range2, "<", options);
  module2.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports2, module2) => {
  var Range34 = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range34(r1, options);
    r2 = new Range34(r2, options);
    return r1.intersects(r2);
  };
  module2.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports2, module2) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module2.exports = (versions, range2, options) => {
    const set = [];
    let min = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version2 of v) {
      const included = satisfies(version2, range2, options);
      if (included) {
        prev = version2;
        if (!min)
          min = version2;
      } else {
        if (prev) {
          set.push([min, prev]);
        }
        prev = null;
        min = null;
      }
    }
    if (min)
      set.push([min, null]);
    const ranges = [];
    for (const [min2, max] of set) {
      if (min2 === max)
        ranges.push(min2);
      else if (!max && min2 === v[0])
        ranges.push("*");
      else if (!max)
        ranges.push(`>=${min2}`);
      else if (min2 === v[0])
        ranges.push(`<=${max}`);
      else
        ranges.push(`${min2} - ${max}`);
    }
    const simplified = ranges.join(" || ");
    const original = typeof range2.raw === "string" ? range2.raw : String(range2);
    return simplified.length < original.length ? simplified : range2;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports2, module2) => {
  var Range34 = require_range();
  var {ANY} = require_comparator();
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options) => {
    sub = new Range34(sub, options);
    dom = new Range34(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub)
            continue OUTER;
        }
        if (sawNonNull)
          return false;
      }
    return true;
  };
  var simpleSubset = (sub, dom, options) => {
    if (sub.length === 1 && sub[0].semver === ANY)
      return dom.length === 1 && dom[0].semver === ANY;
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=")
        gt = higherGT(gt, c, options);
      else if (c.operator === "<" || c.operator === "<=")
        lt = lowerLT(lt, c, options);
      else
        eqSet.add(c.semver);
    }
    if (eqSet.size > 1)
      return null;
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0)
        return null;
      else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
        return null;
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options))
        return null;
      if (lt && !satisfies(eq, String(lt), options))
        return null;
      for (const c of dom) {
        if (!satisfies(eq, String(c), options))
          return false;
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c)
            return false;
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
          return false;
      }
      if (lt) {
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c)
            return false;
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
          return false;
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0)
        return false;
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0)
      return false;
    if (lt && hasDomGT && !gt && gtltComp !== 0)
      return false;
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a)
      return b;
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a)
      return b;
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module2.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports2, module2) => {
  var internalRe = require_re();
  module2.exports = {
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
    SemVer: require_semver(),
    compareIdentifiers: require_identifiers().compareIdentifiers,
    rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
    parse: require_parse(),
    valid: require_valid(),
    clean: require_clean(),
    inc: require_inc(),
    diff: require_diff(),
    major: require_major(),
    minor: require_minor(),
    patch: require_patch(),
    prerelease: require_prerelease(),
    compare: require_compare(),
    rcompare: require_rcompare(),
    compareLoose: require_compare_loose(),
    compareBuild: require_compare_build(),
    sort: require_sort(),
    rsort: require_rsort(),
    gt: require_gt(),
    lt: require_lt(),
    eq: require_eq(),
    neq: require_neq(),
    gte: require_gte(),
    lte: require_lte(),
    cmp: require_cmp(),
    coerce: require_coerce(),
    Comparator: require_comparator(),
    Range: require_range(),
    satisfies: require_satisfies(),
    toComparators: require_to_comparators(),
    maxSatisfying: require_max_satisfying(),
    minSatisfying: require_min_satisfying(),
    minVersion: require_min_version(),
    validRange: require_valid2(),
    outside: require_outside(),
    gtr: require_gtr(),
    ltr: require_ltr(),
    intersects: require_intersects(),
    simplifyRange: require_simplify(),
    subset: require_subset()
  };
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports2, module2) => {
  "use strict";
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice = Array.prototype.slice;
  var toStr = Object.prototype.toString;
  var funcType = "[object Function]";
  module2.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, args.concat(slice.call(arguments)));
        if (Object(result) === result) {
          return result;
        }
        return this;
      } else {
        return target.apply(that, args.concat(slice.call(arguments)));
      }
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs.push("$" + i);
    }
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports2, module2) => {
  "use strict";
  var implementation2 = require_implementation();
  module2.exports = Function.prototype.bind || implementation2;
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS((exports2, module2) => {
  "use strict";
  var toStr = Object.prototype.toString;
  module2.exports = function isArguments(value) {
    var str = toStr.call(value);
    var isArgs = str === "[object Arguments]";
    if (!isArgs) {
      isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
    }
    return isArgs;
  };
});

// node_modules/object-keys/implementation.js
var require_implementation2 = __commonJS((exports2, module2) => {
  "use strict";
  var keysShim;
  if (!Object.keys) {
    has = Object.prototype.hasOwnProperty;
    toStr = Object.prototype.toString;
    isArgs = require_isArguments();
    isEnumerable = Object.prototype.propertyIsEnumerable;
    hasDontEnumBug = !isEnumerable.call({toString: null}, "toString");
    hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim = function keys(object15) {
      var isObject2 = object15 !== null && typeof object15 === "object";
      var isFunction = toStr.call(object15) === "[object Function]";
      var isArguments = isArgs(object15);
      var isString = isObject2 && toStr.call(object15) === "[object String]";
      var theKeys = [];
      if (!isObject2 && !isFunction && !isArguments) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction;
      if (isString && object15.length > 0 && !has.call(object15, 0)) {
        for (var i = 0; i < object15.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments && object15.length > 0) {
        for (var j = 0; j < object15.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name2 in object15) {
          if (!(skipProto && name2 === "prototype") && has.call(object15, name2)) {
            theKeys.push(String(name2));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object15);
        for (var k = 0; k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object15, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  var has;
  var toStr;
  var isArgs;
  var isEnumerable;
  var hasDontEnumBug;
  var hasProtoEnumBug;
  var dontEnums;
  var equalsConstructorPrototype;
  var excludedKeys;
  var hasAutomationEqualityBug;
  var equalsConstructorPrototypeIfNotBuggy;
  module2.exports = keysShim;
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS((exports2, module2) => {
  "use strict";
  var slice = Array.prototype.slice;
  var isArgs = require_isArguments();
  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys(o) {
    return origKeys(o);
  } : require_implementation2();
  var originalKeys = Object.keys;
  keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args = Object.keys(arguments);
        return args && args.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments) {
        Object.keys = function keys(object15) {
          if (isArgs(object15)) {
            return originalKeys(slice.call(object15));
          }
          return originalKeys(object15);
        };
      }
    } else {
      Object.keys = keysShim;
    }
    return Object.keys || keysShim;
  };
  module2.exports = keysShim;
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS((exports2, module2) => {
  "use strict";
  var keys = require_object_keys();
  var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var origDefineProperty = Object.defineProperty;
  var isFunction = function(fn) {
    return typeof fn === "function" && toStr.call(fn) === "[object Function]";
  };
  var arePropertyDescriptorsSupported = function() {
    var obj = {};
    try {
      origDefineProperty(obj, "x", {enumerable: false, value: obj});
      for (var _ in obj) {
        return false;
      }
      return obj.x === obj;
    } catch (e) {
      return false;
    }
  };
  var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
  var defineProperty = function(object15, name2, value, predicate) {
    if (name2 in object15 && (!isFunction(predicate) || !predicate())) {
      return;
    }
    if (supportsDescriptors) {
      origDefineProperty(object15, name2, {
        configurable: true,
        enumerable: false,
        value,
        writable: true
      });
    } else {
      object15[name2] = value;
    }
  };
  var defineProperties = function(object15, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys(map);
    if (hasSymbols) {
      props = concat.call(props, Object.getOwnPropertySymbols(map));
    }
    for (var i = 0; i < props.length; i += 1) {
      defineProperty(object15, props[i], map[props[i]], predicates[props[i]]);
    }
  };
  defineProperties.supportsDescriptors = !!supportsDescriptors;
  module2.exports = defineProperties;
});

// node_modules/promise.prototype.finally/requirePromise.js
var require_requirePromise = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function requirePromise() {
    if (typeof Promise !== "function") {
      throw new TypeError("`Promise.prototype.finally` requires a global `Promise` be available.");
    }
  };
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS((exports2, module2) => {
  "use strict";
  var fnToStr = Function.prototype.toString;
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  module2.exports = function isCallable(value) {
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (typeof value === "function" && !value.prototype) {
      return true;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    return strClass === fnClass || strClass === genClass;
  };
});

// node_modules/es-abstract/2018/IsCallable.js
var require_IsCallable = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_is_callable();
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports2, module2) => {
  "use strict";
  var origSymbol = global.Symbol;
  var hasSymbolSham = require_shams();
  module2.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// node_modules/es-abstract/GetIntrinsic.js
var require_GetIntrinsic = __commonJS((exports2, module2) => {
  "use strict";
  var undefined2;
  var $TypeError = TypeError;
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var getProto = Object.getPrototypeOf || function(x) {
    return x.__proto__;
  };
  var generator;
  var generatorFunction = generator ? getProto(generator) : undefined2;
  var asyncFn;
  var asyncFunction = asyncFn ? asyncFn.constructor : undefined2;
  var asyncGen;
  var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined2;
  var asyncGenIterator = asyncGen ? asyncGen() : undefined2;
  var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer.prototype,
    "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
    "%ArrayPrototype%": Array.prototype,
    "%ArrayProto_entries%": Array.prototype.entries,
    "%ArrayProto_forEach%": Array.prototype.forEach,
    "%ArrayProto_keys%": Array.prototype.keys,
    "%ArrayProto_values%": Array.prototype.values,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": asyncFunction,
    "%AsyncFunctionPrototype%": asyncFunction ? asyncFunction.prototype : undefined2,
    "%AsyncGenerator%": asyncGen ? getProto(asyncGenIterator) : undefined2,
    "%AsyncGeneratorFunction%": asyncGenFunction,
    "%AsyncGeneratorPrototype%": asyncGenFunction ? asyncGenFunction.prototype : undefined2,
    "%AsyncIteratorPrototype%": asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined2,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%Boolean%": Boolean,
    "%BooleanPrototype%": Boolean.prototype,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%DataViewPrototype%": typeof DataView === "undefined" ? undefined2 : DataView.prototype,
    "%Date%": Date,
    "%DatePrototype%": Date.prototype,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%ErrorPrototype%": Error.prototype,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%EvalErrorPrototype%": EvalError.prototype,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined2 : Float32Array.prototype,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined2 : Float64Array.prototype,
    "%Function%": Function,
    "%FunctionPrototype%": Function.prototype,
    "%Generator%": generator ? getProto(generator()) : undefined2,
    "%GeneratorFunction%": generatorFunction,
    "%GeneratorPrototype%": generatorFunction ? generatorFunction.prototype : undefined2,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined2 : Int8Array.prototype,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined2 : Int8Array.prototype,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined2 : Int32Array.prototype,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%MapPrototype%": typeof Map === "undefined" ? undefined2 : Map.prototype,
    "%Math%": Math,
    "%Number%": Number,
    "%NumberPrototype%": Number.prototype,
    "%Object%": Object,
    "%ObjectPrototype%": Object.prototype,
    "%ObjProto_toString%": Object.prototype.toString,
    "%ObjProto_valueOf%": Object.prototype.valueOf,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%PromisePrototype%": typeof Promise === "undefined" ? undefined2 : Promise.prototype,
    "%PromiseProto_then%": typeof Promise === "undefined" ? undefined2 : Promise.prototype.then,
    "%Promise_all%": typeof Promise === "undefined" ? undefined2 : Promise.all,
    "%Promise_reject%": typeof Promise === "undefined" ? undefined2 : Promise.reject,
    "%Promise_resolve%": typeof Promise === "undefined" ? undefined2 : Promise.resolve,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": RangeError,
    "%RangeErrorPrototype%": RangeError.prototype,
    "%ReferenceError%": ReferenceError,
    "%ReferenceErrorPrototype%": ReferenceError.prototype,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%RegExpPrototype%": RegExp.prototype,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SetPrototype%": typeof Set === "undefined" ? undefined2 : Set.prototype,
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer.prototype,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
    "%StringPrototype%": String.prototype,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SymbolPrototype%": hasSymbols ? Symbol.prototype : undefined2,
    "%SyntaxError%": SyntaxError,
    "%SyntaxErrorPrototype%": SyntaxError.prototype,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypedArrayPrototype%": TypedArray ? TypedArray.prototype : undefined2,
    "%TypeError%": $TypeError,
    "%TypeErrorPrototype%": $TypeError.prototype,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array.prototype,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray.prototype,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array.prototype,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array.prototype,
    "%URIError%": URIError,
    "%URIErrorPrototype%": URIError.prototype,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined2 : WeakMap.prototype,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
    "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined2 : WeakSet.prototype
  };
  var bind = require_function_bind();
  var $replace = bind.call(Function.call, String.prototype.replace);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string23) {
    var result = [];
    $replace(string23, rePropName, function(match3, number2, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match3;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
    if (!(name2 in INTRINSICS)) {
      throw new SyntaxError("intrinsic " + name2 + " does not exist!");
    }
    if (typeof INTRINSICS[name2] === "undefined" && !allowMissing) {
      throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return INTRINSICS[name2];
  };
  module2.exports = function GetIntrinsic(name2, allowMissing) {
    if (typeof name2 !== "string" || name2.length === 0) {
      throw new TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new TypeError('"allowMissing" argument must be a boolean');
    }
    var parts = stringToPath(name2);
    var value = getBaseIntrinsic("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
    for (var i = 1; i < parts.length; i += 1) {
      if (value != null) {
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, parts[i]);
          if (!allowMissing && !(parts[i] in value)) {
            throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
          }
          value = desc ? desc.get || desc.value : value[parts[i]];
        } else {
          value = value[parts[i]];
        }
      }
    }
    return value;
  };
});

// node_modules/es-abstract/2018/IsConstructor.js
var require_IsConstructor = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function IsConstructor(argument) {
    return typeof argument === "function" && !!argument.prototype;
  };
});

// node_modules/es-abstract/5/Type.js
var require_Type = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function Type(x) {
    if (x === null) {
      return "Null";
    }
    if (typeof x === "undefined") {
      return "Undefined";
    }
    if (typeof x === "function" || typeof x === "object") {
      return "Object";
    }
    if (typeof x === "number") {
      return "Number";
    }
    if (typeof x === "boolean") {
      return "Boolean";
    }
    if (typeof x === "string") {
      return "String";
    }
  };
});

// node_modules/es-abstract/2018/Type.js
var require_Type2 = __commonJS((exports2, module2) => {
  "use strict";
  var ES5Type = require_Type();
  module2.exports = function Type(x) {
    if (typeof x === "symbol") {
      return "Symbol";
    }
    return ES5Type(x);
  };
});

// node_modules/es-abstract/2018/SpeciesConstructor.js
var require_SpeciesConstructor = __commonJS((exports2, module2) => {
  "use strict";
  var GetIntrinsic = require_GetIntrinsic();
  var $species = GetIntrinsic("%Symbol.species%", true);
  var $TypeError = GetIntrinsic("%TypeError%");
  var IsConstructor = require_IsConstructor();
  var Type = require_Type2();
  module2.exports = function SpeciesConstructor(O, defaultConstructor) {
    if (Type(O) !== "Object") {
      throw new $TypeError("Assertion failed: Type(O) is not Object");
    }
    var C = O.constructor;
    if (typeof C === "undefined") {
      return defaultConstructor;
    }
    if (Type(C) !== "Object") {
      throw new $TypeError("O.constructor is not an Object");
    }
    var S = $species ? C[$species] : void 0;
    if (S == null) {
      return defaultConstructor;
    }
    if (IsConstructor(S)) {
      return S;
    }
    throw new $TypeError("no constructor found");
  };
});

// node_modules/promise.prototype.finally/implementation.js
var require_implementation3 = __commonJS((exports2, module2) => {
  "use strict";
  var requirePromise = require_requirePromise();
  requirePromise();
  var IsCallable = require_IsCallable();
  var SpeciesConstructor = require_SpeciesConstructor();
  var Type = require_Type2();
  var promiseResolve = function PromiseResolve(C, value) {
    return new C(function(resolve3) {
      resolve3(value);
    });
  };
  var OriginalPromise = Promise;
  var createThenFinally = function CreateThenFinally(C, onFinally) {
    return function(value) {
      var result = onFinally();
      var promise = promiseResolve(C, result);
      var valueThunk = function() {
        return value;
      };
      return promise.then(valueThunk);
    };
  };
  var createCatchFinally = function CreateCatchFinally(C, onFinally) {
    return function(reason) {
      var result = onFinally();
      var promise = promiseResolve(C, result);
      var thrower2 = function() {
        throw reason;
      };
      return promise.then(thrower2);
    };
  };
  var promiseFinally2 = function finally_(onFinally) {
    var promise = this;
    if (Type(promise) !== "Object") {
      throw new TypeError("receiver is not an Object");
    }
    var C = SpeciesConstructor(promise, OriginalPromise);
    var thenFinally = onFinally;
    var catchFinally = onFinally;
    if (IsCallable(onFinally)) {
      thenFinally = createThenFinally(C, onFinally);
      catchFinally = createCatchFinally(C, onFinally);
    }
    return promise.then(thenFinally, catchFinally);
  };
  if (Object.getOwnPropertyDescriptor) {
    descriptor = Object.getOwnPropertyDescriptor(promiseFinally2, "name");
    if (descriptor && descriptor.configurable) {
      Object.defineProperty(promiseFinally2, "name", {configurable: true, value: "finally"});
    }
  }
  var descriptor;
  module2.exports = promiseFinally2;
});

// node_modules/promise.prototype.finally/polyfill.js
var require_polyfill = __commonJS((exports2, module2) => {
  "use strict";
  var requirePromise = require_requirePromise();
  var implementation2 = require_implementation3();
  module2.exports = function getPolyfill() {
    requirePromise();
    return typeof Promise.prototype["finally"] === "function" ? Promise.prototype["finally"] : implementation2;
  };
});

// node_modules/promise.prototype.finally/shim.js
var require_shim = __commonJS((exports2, module2) => {
  "use strict";
  var requirePromise = require_requirePromise();
  var getPolyfill = require_polyfill();
  var define2 = require_define_properties();
  module2.exports = function shimPromiseFinally() {
    requirePromise();
    var polyfill = getPolyfill();
    define2(Promise.prototype, {finally: polyfill}, {
      finally: function testFinally() {
        return Promise.prototype["finally"] !== polyfill;
      }
    });
    return polyfill;
  };
});

// node_modules/promise.prototype.finally/index.js
var require_promise_prototype = __commonJS((exports2, module2) => {
  "use strict";
  var bind = require_function_bind();
  var define2 = require_define_properties();
  var implementation2 = require_implementation3();
  var getPolyfill = require_polyfill();
  var shim = require_shim();
  var bound = bind.call(Function.call, getPolyfill());
  define2(bound, {
    getPolyfill,
    implementation: implementation2,
    shim
  });
  module2.exports = bound;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse4(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse4(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match3) {
      return;
    }
    var n = parseFloat(match3[1]);
    var type = (match3[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.instances = [];
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match3, format4) => {
          if (match3 === "%%") {
            return match3;
          }
          index++;
          const formatter2 = createDebug.formatters[format4];
          if (typeof formatter2 === "function") {
            const val = args[index];
            match3 = formatter2.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match3;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = createDebug.enabled(namespace);
      debug.useColors = createDebug.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      debug.extend = extend;
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      createDebug.instances.push(debug);
      return debug;
    }
    function destroy() {
      const index = createDebug.instances.indexOf(this);
      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }
      return false;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
      for (i = 0; i < createDebug.instances.length; i++) {
        const instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match3) => {
      if (match3 === "%%") {
        return;
      }
      index++;
      if (match3 === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log(...args) {
    return typeof console === "object" && console.log && console.log(...args);
  }
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position15 = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position15 !== -1 && (terminatorPosition === -1 || position15 < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  "use strict";
  var os15 = require("os");
  var tty = require("tty");
  var hasFlag = require_has_flag();
  var {env: env2} = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env2) {
    if (env2.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env2.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env2.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os15.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("GITHUB_ACTIONS" in env2) {
      return 1;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util54 = require("util");
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name2, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name2} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name2 + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util54.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util54.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, " ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util54.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node();
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = rfdc;
  function rfdc(opts) {
    opts = opts || {};
    if (opts.circles)
      return rfdcCircles(opts);
    return opts.proto ? cloneProto : clone;
    function cloneArray(a, fn) {
      var keys = Object.keys(a);
      var a2 = new Array(keys.length);
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        var cur = a[k];
        if (typeof cur !== "object" || cur === null) {
          a2[k] = cur;
        } else if (cur instanceof Date) {
          a2[k] = new Date(cur);
        } else {
          a2[k] = fn(cur);
        }
      }
      return a2;
    }
    function clone(o) {
      if (typeof o !== "object" || o === null)
        return o;
      if (o instanceof Date)
        return new Date(o);
      if (Array.isArray(o))
        return cloneArray(o, clone);
      var o2 = {};
      for (var k in o) {
        if (Object.hasOwnProperty.call(o, k) === false)
          continue;
        var cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur instanceof Date) {
          o2[k] = new Date(cur);
        } else {
          o2[k] = clone(cur);
        }
      }
      return o2;
    }
    function cloneProto(o) {
      if (typeof o !== "object" || o === null)
        return o;
      if (o instanceof Date)
        return new Date(o);
      if (Array.isArray(o))
        return cloneArray(o, cloneProto);
      var o2 = {};
      for (var k in o) {
        var cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur instanceof Date) {
          o2[k] = new Date(cur);
        } else {
          o2[k] = cloneProto(cur);
        }
      }
      return o2;
    }
  }
  function rfdcCircles(opts) {
    var refs = [];
    var refsNew = [];
    return opts.proto ? cloneProto : clone;
    function cloneArray(a, fn) {
      var keys = Object.keys(a);
      var a2 = new Array(keys.length);
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        var cur = a[k];
        if (typeof cur !== "object" || cur === null) {
          a2[k] = cur;
        } else if (cur instanceof Date) {
          a2[k] = new Date(cur);
        } else {
          var index = refs.indexOf(cur);
          if (index !== -1) {
            a2[k] = refsNew[index];
          } else {
            a2[k] = fn(cur);
          }
        }
      }
      return a2;
    }
    function clone(o) {
      if (typeof o !== "object" || o === null)
        return o;
      if (o instanceof Date)
        return new Date(o);
      if (Array.isArray(o))
        return cloneArray(o, clone);
      var o2 = {};
      refs.push(o);
      refsNew.push(o2);
      for (var k in o) {
        if (Object.hasOwnProperty.call(o, k) === false)
          continue;
        var cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur instanceof Date) {
          o2[k] = new Date(cur);
        } else {
          var i = refs.indexOf(cur);
          if (i !== -1) {
            o2[k] = refsNew[i];
          } else {
            o2[k] = clone(cur);
          }
        }
      }
      refs.pop();
      refsNew.pop();
      return o2;
    }
    function cloneProto(o) {
      if (typeof o !== "object" || o === null)
        return o;
      if (o instanceof Date)
        return new Date(o);
      if (Array.isArray(o))
        return cloneArray(o, cloneProto);
      var o2 = {};
      refs.push(o);
      refsNew.push(o2);
      for (var k in o) {
        var cur = o[k];
        if (typeof cur !== "object" || cur === null) {
          o2[k] = cur;
        } else if (cur instanceof Date) {
          o2[k] = new Date(cur);
        } else {
          var i = refs.indexOf(cur);
          if (i !== -1) {
            o2[k] = refsNew[i];
          } else {
            o2[k] = cloneProto(cur);
          }
        }
      }
      refs.pop();
      refsNew.pop();
      return o2;
    }
  }
});

// node_modules/log4js/lib/configuration.js
var require_configuration = __commonJS((exports2, module2) => {
  var util54 = require("util");
  var debug = require_src()("log4js:configuration");
  var preProcessingListeners = [];
  var listeners = [];
  var not = (thing) => !thing;
  var anObject = (thing) => thing && typeof thing === "object" && !Array.isArray(thing);
  var validIdentifier = (thing) => /^[A-Za-z][A-Za-z0-9_]*$/g.test(thing);
  var anInteger = (thing) => thing && typeof thing === "number" && Number.isInteger(thing);
  var addListener = (fn) => {
    listeners.push(fn);
    debug(`Added listener, now ${listeners.length} listeners`);
  };
  var addPreProcessingListener = (fn) => {
    preProcessingListeners.push(fn);
    debug(`Added pre-processing listener, now ${preProcessingListeners.length} listeners`);
  };
  var throwExceptionIf = (config, checks, message) => {
    const tests = Array.isArray(checks) ? checks : [checks];
    tests.forEach((test) => {
      if (test) {
        throw new Error(`Problem with log4js configuration: (${util54.inspect(config, {depth: 5})}) - ${message}`);
      }
    });
  };
  var configure = (candidate) => {
    debug("New configuration to be validated: ", candidate);
    throwExceptionIf(candidate, not(anObject(candidate)), "must be an object.");
    debug(`Calling pre-processing listeners (${preProcessingListeners.length})`);
    preProcessingListeners.forEach((listener) => listener(candidate));
    debug("Configuration pre-processing finished.");
    debug(`Calling configuration listeners (${listeners.length})`);
    listeners.forEach((listener) => listener(candidate));
    debug("Configuration finished.");
  };
  module2.exports = {
    configure,
    addListener,
    addPreProcessingListener,
    throwExceptionIf,
    anObject,
    anInteger,
    validIdentifier,
    not
  };
});

// node_modules/date-format/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  "use strict";
  function padWithZeros(vNumber, width) {
    var numAsString = vNumber.toString();
    while (numAsString.length < width) {
      numAsString = "0" + numAsString;
    }
    return numAsString;
  }
  function addZero(vNumber) {
    return padWithZeros(vNumber, 2);
  }
  function offset(timezoneOffset) {
    var os15 = Math.abs(timezoneOffset);
    var h = String(Math.floor(os15 / 60));
    var m = String(os15 % 60);
    if (h.length === 1) {
      h = "0" + h;
    }
    if (m.length === 1) {
      m = "0" + m;
    }
    return timezoneOffset < 0 ? "+" + h + m : "-" + h + m;
  }
  function asString(format4, date) {
    if (typeof format4 !== "string") {
      date = format4;
      format4 = module2.exports.ISO8601_FORMAT;
    }
    if (!date) {
      date = module2.exports.now();
    }
    var vDay = addZero(date.getDate());
    var vMonth = addZero(date.getMonth() + 1);
    var vYearLong = addZero(date.getFullYear());
    var vYearShort = addZero(vYearLong.substring(2, 4));
    var vYear = format4.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
    var vHour = addZero(date.getHours());
    var vMinute = addZero(date.getMinutes());
    var vSecond = addZero(date.getSeconds());
    var vMillisecond = padWithZeros(date.getMilliseconds(), 3);
    var vTimeZone = offset(date.getTimezoneOffset());
    var formatted = format4.replace(/dd/g, vDay).replace(/MM/g, vMonth).replace(/y{1,4}/g, vYear).replace(/hh/g, vHour).replace(/mm/g, vMinute).replace(/ss/g, vSecond).replace(/SSS/g, vMillisecond).replace(/O/g, vTimeZone);
    return formatted;
  }
  function setDatePart(date, part, value, local) {
    date["set" + (local ? "" : "UTC") + part](value);
  }
  function extractDateParts(pattern, str, missingValuesDate) {
    var local = pattern.indexOf("O") < 0;
    var matchers = [
      {
        pattern: /y{1,4}/,
        regexp: "\\d{1,4}",
        fn: function(date2, value) {
          setDatePart(date2, "FullYear", value, local);
        }
      },
      {
        pattern: /MM/,
        regexp: "\\d{1,2}",
        fn: function(date2, value) {
          setDatePart(date2, "Month", value - 1, local);
        }
      },
      {
        pattern: /dd/,
        regexp: "\\d{1,2}",
        fn: function(date2, value) {
          setDatePart(date2, "Date", value, local);
        }
      },
      {
        pattern: /hh/,
        regexp: "\\d{1,2}",
        fn: function(date2, value) {
          setDatePart(date2, "Hours", value, local);
        }
      },
      {
        pattern: /mm/,
        regexp: "\\d\\d",
        fn: function(date2, value) {
          setDatePart(date2, "Minutes", value, local);
        }
      },
      {
        pattern: /ss/,
        regexp: "\\d\\d",
        fn: function(date2, value) {
          setDatePart(date2, "Seconds", value, local);
        }
      },
      {
        pattern: /SSS/,
        regexp: "\\d\\d\\d",
        fn: function(date2, value) {
          setDatePart(date2, "Milliseconds", value, local);
        }
      },
      {
        pattern: /O/,
        regexp: "[+-]\\d{3,4}|Z",
        fn: function(date2, value) {
          if (value === "Z") {
            value = 0;
          }
          var offset2 = Math.abs(value);
          var timezoneOffset = (value > 0 ? -1 : 1) * (offset2 % 100 + Math.floor(offset2 / 100) * 60);
          date2.setUTCMinutes(date2.getUTCMinutes() + timezoneOffset);
        }
      }
    ];
    var parsedPattern = matchers.reduce(function(p, m) {
      if (m.pattern.test(p.regexp)) {
        m.index = p.regexp.match(m.pattern).index;
        p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
      } else {
        m.index = -1;
      }
      return p;
    }, {regexp: pattern, index: []});
    var dateFns = matchers.filter(function(m) {
      return m.index > -1;
    });
    dateFns.sort(function(a, b) {
      return a.index - b.index;
    });
    var matcher = new RegExp(parsedPattern.regexp);
    var matches = matcher.exec(str);
    if (matches) {
      var date = missingValuesDate || module2.exports.now();
      dateFns.forEach(function(f, i) {
        f.fn(date, matches[i + 1]);
      });
      return date;
    }
    throw new Error("String '" + str + "' could not be parsed as '" + pattern + "'");
  }
  function parse4(pattern, str, missingValuesDate) {
    if (!pattern) {
      throw new Error("pattern must be supplied");
    }
    return extractDateParts(pattern, str, missingValuesDate);
  }
  function now() {
    return new Date();
  }
  module2.exports = asString;
  module2.exports.asString = asString;
  module2.exports.parse = parse4;
  module2.exports.now = now;
  module2.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
  module2.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
  module2.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
  module2.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
});

// node_modules/log4js/lib/layouts.js
var require_layouts = __commonJS((exports2, module2) => {
  var dateFormat = require_lib();
  var os15 = require("os");
  var util54 = require("util");
  var path66 = require("path");
  var styles3 = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [90, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [91, 39],
    yellow: [33, 39]
  };
  function colorizeStart(style2) {
    return style2 ? `[${styles3[style2][0]}m` : "";
  }
  function colorizeEnd(style2) {
    return style2 ? `[${styles3[style2][1]}m` : "";
  }
  function colorize(str, style2) {
    return colorizeStart(style2) + str + colorizeEnd(style2);
  }
  function timestampLevelAndCategory(loggingEvent, colour) {
    return colorize(util54.format("[%s] [%s] %s - ", dateFormat.asString(loggingEvent.startTime), loggingEvent.level.toString(), loggingEvent.categoryName), colour);
  }
  function basicLayout(loggingEvent) {
    return timestampLevelAndCategory(loggingEvent) + util54.format(...loggingEvent.data);
  }
  function colouredLayout(loggingEvent) {
    return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util54.format(...loggingEvent.data);
  }
  function messagePassThroughLayout(loggingEvent) {
    return util54.format(...loggingEvent.data);
  }
  function dummyLayout(loggingEvent) {
    return loggingEvent.data[0];
  }
  function patternLayout(pattern, tokens) {
    const TTCC_CONVERSION_PATTERN = "%r %p %c - %m%n";
    const regex = /%(-?[0-9]+)?(\.?-?[0-9]+)?([[\]cdhmnprzxXyflos%])(\{([^}]+)\})?|([^%]+)/;
    pattern = pattern || TTCC_CONVERSION_PATTERN;
    function categoryName(loggingEvent, specifier) {
      let loggerName = loggingEvent.categoryName;
      if (specifier) {
        const precision = parseInt(specifier, 10);
        const loggerNameBits = loggerName.split(".");
        if (precision < loggerNameBits.length) {
          loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join(".");
        }
      }
      return loggerName;
    }
    function formatAsDate(loggingEvent, specifier) {
      let format4 = dateFormat.ISO8601_FORMAT;
      if (specifier) {
        format4 = specifier;
        if (format4 === "ISO8601") {
          format4 = dateFormat.ISO8601_FORMAT;
        } else if (format4 === "ISO8601_WITH_TZ_OFFSET") {
          format4 = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;
        } else if (format4 === "ABSOLUTE") {
          format4 = dateFormat.ABSOLUTETIME_FORMAT;
        } else if (format4 === "DATE") {
          format4 = dateFormat.DATETIME_FORMAT;
        }
      }
      return dateFormat.asString(format4, loggingEvent.startTime);
    }
    function hostname() {
      return os15.hostname().toString();
    }
    function formatMessage(loggingEvent) {
      return util54.format(...loggingEvent.data);
    }
    function endOfLine() {
      return os15.EOL;
    }
    function logLevel(loggingEvent) {
      return loggingEvent.level.toString();
    }
    function startTime(loggingEvent) {
      return dateFormat.asString("hh:mm:ss", loggingEvent.startTime);
    }
    function startColour(loggingEvent) {
      return colorizeStart(loggingEvent.level.colour);
    }
    function endColour(loggingEvent) {
      return colorizeEnd(loggingEvent.level.colour);
    }
    function percent() {
      return "%";
    }
    function pid(loggingEvent) {
      return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();
    }
    function clusterInfo() {
      return pid();
    }
    function userDefined(loggingEvent, specifier) {
      if (typeof tokens[specifier] !== "undefined") {
        return typeof tokens[specifier] === "function" ? tokens[specifier](loggingEvent) : tokens[specifier];
      }
      return null;
    }
    function contextDefined(loggingEvent, specifier) {
      const resolver2 = loggingEvent.context[specifier];
      if (typeof resolver2 !== "undefined") {
        return typeof resolver2 === "function" ? resolver2(loggingEvent) : resolver2;
      }
      return null;
    }
    function fileName(loggingEvent, specifier) {
      let filename = loggingEvent.fileName || "";
      if (specifier) {
        const fileDepth = parseInt(specifier, 10);
        const fileList = filename.split(path66.sep);
        if (fileList.length > fileDepth) {
          filename = fileList.slice(-fileDepth).join(path66.sep);
        }
      }
      return filename;
    }
    function lineNumber(loggingEvent) {
      return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : "";
    }
    function columnNumber(loggingEvent) {
      return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : "";
    }
    function callStack(loggingEvent) {
      return loggingEvent.callStack || "";
    }
    const replacers = {
      c: categoryName,
      d: formatAsDate,
      h: hostname,
      m: formatMessage,
      n: endOfLine,
      p: logLevel,
      r: startTime,
      "[": startColour,
      "]": endColour,
      y: clusterInfo,
      z: pid,
      "%": percent,
      x: userDefined,
      X: contextDefined,
      f: fileName,
      l: lineNumber,
      o: columnNumber,
      s: callStack
    };
    function replaceToken(conversionCharacter, loggingEvent, specifier) {
      return replacers[conversionCharacter](loggingEvent, specifier);
    }
    function truncate(truncation, toTruncate) {
      let len;
      if (truncation) {
        len = parseInt(truncation.substr(1), 10);
        return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);
      }
      return toTruncate;
    }
    function pad2(padding, toPad) {
      let len;
      if (padding) {
        if (padding.charAt(0) === "-") {
          len = parseInt(padding.substr(1), 10);
          while (toPad.length < len) {
            toPad += " ";
          }
        } else {
          len = parseInt(padding, 10);
          while (toPad.length < len) {
            toPad = ` ${toPad}`;
          }
        }
      }
      return toPad;
    }
    function truncateAndPad(toTruncAndPad, truncation, padding) {
      let replacement = toTruncAndPad;
      replacement = truncate(truncation, replacement);
      replacement = pad2(padding, replacement);
      return replacement;
    }
    return function(loggingEvent) {
      let formattedString = "";
      let result;
      let searchString = pattern;
      while ((result = regex.exec(searchString)) !== null) {
        const padding = result[1];
        const truncation = result[2];
        const conversionCharacter = result[3];
        const specifier = result[5];
        const text = result[6];
        if (text) {
          formattedString += text.toString();
        } else {
          const replacement = replaceToken(conversionCharacter, loggingEvent, specifier);
          formattedString += truncateAndPad(replacement, truncation, padding);
        }
        searchString = searchString.substr(result.index + result[0].length);
      }
      return formattedString;
    };
  }
  var layoutMakers = {
    messagePassThrough() {
      return messagePassThroughLayout;
    },
    basic() {
      return basicLayout;
    },
    colored() {
      return colouredLayout;
    },
    coloured() {
      return colouredLayout;
    },
    pattern(config) {
      return patternLayout(config && config.pattern, config && config.tokens);
    },
    dummy() {
      return dummyLayout;
    }
  };
  module2.exports = {
    basicLayout,
    messagePassThroughLayout,
    patternLayout,
    colouredLayout,
    coloredLayout: colouredLayout,
    dummyLayout,
    addLayout(name2, serializerGenerator) {
      layoutMakers[name2] = serializerGenerator;
    },
    layout(name2, config) {
      return layoutMakers[name2] && layoutMakers[name2](config);
    }
  };
});

// node_modules/log4js/lib/levels.js
var require_levels = __commonJS((exports2, module2) => {
  var configuration7 = require_configuration();
  var validColours = [
    "white",
    "grey",
    "black",
    "blue",
    "cyan",
    "green",
    "magenta",
    "red",
    "yellow"
  ];
  var Level = class {
    constructor(level, levelStr, colour) {
      this.level = level;
      this.levelStr = levelStr;
      this.colour = colour;
    }
    toString() {
      return this.levelStr;
    }
    static getLevel(sArg, defaultLevel) {
      if (!sArg) {
        return defaultLevel;
      }
      if (sArg instanceof Level) {
        return sArg;
      }
      if (sArg instanceof Object && sArg.levelStr) {
        sArg = sArg.levelStr;
      }
      return Level[sArg.toString().toUpperCase()] || defaultLevel;
    }
    static addLevels(customLevels) {
      if (customLevels) {
        const levels = Object.keys(customLevels);
        levels.forEach((l) => {
          const levelStr = l.toUpperCase();
          Level[levelStr] = new Level(customLevels[l].value, levelStr, customLevels[l].colour);
          const existingLevelIndex = Level.levels.findIndex((lvl) => lvl.levelStr === levelStr);
          if (existingLevelIndex > -1) {
            Level.levels[existingLevelIndex] = Level[levelStr];
          } else {
            Level.levels.push(Level[levelStr]);
          }
        });
        Level.levels.sort((a, b) => a.level - b.level);
      }
    }
    isLessThanOrEqualTo(otherLevel) {
      if (typeof otherLevel === "string") {
        otherLevel = Level.getLevel(otherLevel);
      }
      return this.level <= otherLevel.level;
    }
    isGreaterThanOrEqualTo(otherLevel) {
      if (typeof otherLevel === "string") {
        otherLevel = Level.getLevel(otherLevel);
      }
      return this.level >= otherLevel.level;
    }
    isEqualTo(otherLevel) {
      if (typeof otherLevel === "string") {
        otherLevel = Level.getLevel(otherLevel);
      }
      return this.level === otherLevel.level;
    }
  };
  Level.levels = [];
  Level.addLevels({
    ALL: {value: Number.MIN_VALUE, colour: "grey"},
    TRACE: {value: 5e3, colour: "blue"},
    DEBUG: {value: 1e4, colour: "cyan"},
    INFO: {value: 2e4, colour: "green"},
    WARN: {value: 3e4, colour: "yellow"},
    ERROR: {value: 4e4, colour: "red"},
    FATAL: {value: 5e4, colour: "magenta"},
    MARK: {value: 9007199254740992, colour: "grey"},
    OFF: {value: Number.MAX_VALUE, colour: "grey"}
  });
  configuration7.addListener((config) => {
    const levelConfig = config.levels;
    if (levelConfig) {
      configuration7.throwExceptionIf(config, configuration7.not(configuration7.anObject(levelConfig)), "levels must be an object");
      const newLevels = Object.keys(levelConfig);
      newLevels.forEach((l) => {
        configuration7.throwExceptionIf(config, configuration7.not(configuration7.validIdentifier(l)), `level name "${l}" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`);
        configuration7.throwExceptionIf(config, configuration7.not(configuration7.anObject(levelConfig[l])), `level "${l}" must be an object`);
        configuration7.throwExceptionIf(config, configuration7.not(levelConfig[l].value), `level "${l}" must have a 'value' property`);
        configuration7.throwExceptionIf(config, configuration7.not(configuration7.anInteger(levelConfig[l].value)), `level "${l}".value must have an integer value`);
        configuration7.throwExceptionIf(config, configuration7.not(levelConfig[l].colour), `level "${l}" must have a 'colour' property`);
        configuration7.throwExceptionIf(config, configuration7.not(validColours.indexOf(levelConfig[l].colour) > -1), `level "${l}".colour must be one of ${validColours.join(", ")}`);
      });
    }
  });
  configuration7.addListener((config) => {
    Level.addLevels(config.levels);
  });
  module2.exports = Level;
});

// node_modules/flatted/esm/index.js
var require_esm = __commonJS((exports2) => {
  __export(exports2, {
    default: () => esm_default,
    parse: () => parse4,
    stringify: () => stringify2
  });
  var Flatted = function(Primitive, primitive) {
    /*!
     * ISC License
     *
     * Copyright (c) 2018, Andrea Giammarchi, @WebReflection
     *
     * Permission to use, copy, modify, and/or distribute this software for any
     * purpose with or without fee is hereby granted, provided that the above
     * copyright notice and this permission notice appear in all copies.
     *
     * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
     * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
     * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
     * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
     * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
     * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
     * PERFORMANCE OF THIS SOFTWARE.
     */
    var Flatted2 = {
      parse: function parse5(text, reviver) {
        var input = JSON.parse(text, Primitives).map(primitives);
        var value = input[0];
        var $ = reviver || noop;
        var tmp = typeof value === "object" && value ? revive(input, new Set(), value, $) : value;
        return $.call({"": tmp}, "", tmp);
      },
      stringify: function stringify3(value, replacer, space) {
        for (var firstRun, known = new Map(), input = [], output = [], $ = replacer && typeof replacer === typeof input ? function(k, v) {
          if (k === "" || -1 < replacer.indexOf(k))
            return v;
        } : replacer || noop, i = +set(known, input, $.call({"": value}, "", value)), replace = function(key, value2) {
          if (firstRun) {
            firstRun = !firstRun;
            return value2;
          }
          var after = $.call(this, key, value2);
          switch (typeof after) {
            case "object":
              if (after === null)
                return after;
            case primitive:
              return known.get(after) || set(known, input, after);
          }
          return after;
        }; i < input.length; i++) {
          firstRun = true;
          output[i] = JSON.stringify(input[i], replace, space);
        }
        return "[" + output.join(",") + "]";
      }
    };
    return Flatted2;
    function noop(key, value) {
      return value;
    }
    function revive(input, parsed, output, $) {
      return Object.keys(output).reduce(function(output2, key) {
        var value = output2[key];
        if (value instanceof Primitive) {
          var tmp = input[value];
          if (typeof tmp === "object" && !parsed.has(tmp)) {
            parsed.add(tmp);
            output2[key] = $.call(output2, key, revive(input, parsed, tmp, $));
          } else {
            output2[key] = $.call(output2, key, tmp);
          }
        } else
          output2[key] = $.call(output2, key, value);
        return output2;
      }, output);
    }
    function set(known, input, value) {
      var index = Primitive(input.push(value) - 1);
      known.set(value, index);
      return index;
    }
    function primitives(value) {
      return value instanceof Primitive ? Primitive(value) : value;
    }
    function Primitives(key, value) {
      return typeof value === primitive ? new Primitive(value) : value;
    }
  }(String, "string");
  var esm_default = Flatted;
  var parse4 = Flatted.parse;
  var stringify2 = Flatted.stringify;
});

// node_modules/log4js/lib/LoggingEvent.js
var require_LoggingEvent = __commonJS((exports2, module2) => {
  var flatted = require_esm();
  var levels = require_levels();
  var LoggingEvent = class {
    constructor(categoryName, level, data, context, location5) {
      this.startTime = new Date();
      this.categoryName = categoryName;
      this.data = data;
      this.level = level;
      this.context = Object.assign({}, context);
      this.pid = process.pid;
      if (location5) {
        this.functionName = location5.functionName;
        this.fileName = location5.fileName;
        this.lineNumber = location5.lineNumber;
        this.columnNumber = location5.columnNumber;
        this.callStack = location5.callStack;
      }
    }
    serialise() {
      const logData = this.data.map((e) => {
        if (e && e.message && e.stack) {
          e = Object.assign({message: e.message, stack: e.stack}, e);
        }
        return e;
      });
      this.data = logData;
      return flatted.stringify(this);
    }
    static deserialise(serialised) {
      let event;
      try {
        const rehydratedEvent = flatted.parse(serialised);
        rehydratedEvent.data = rehydratedEvent.data.map((e) => {
          if (e && e.message && e.stack) {
            const fakeError = new Error(e);
            Object.keys(e).forEach((key) => {
              fakeError[key] = e[key];
            });
            e = fakeError;
          }
          return e;
        });
        event = new LoggingEvent(rehydratedEvent.categoryName, levels.getLevel(rehydratedEvent.level.levelStr), rehydratedEvent.data, rehydratedEvent.context);
        event.startTime = new Date(rehydratedEvent.startTime);
        event.pid = rehydratedEvent.pid;
        event.cluster = rehydratedEvent.cluster;
      } catch (e) {
        event = new LoggingEvent("log4js", levels.ERROR, ["Unable to parse log:", serialised, "because: ", e]);
      }
      return event;
    }
  };
  module2.exports = LoggingEvent;
});

// node_modules/log4js/lib/clustering.js
var require_clustering = __commonJS((exports2, module2) => {
  var debug = require_src()("log4js:clustering");
  var LoggingEvent = require_LoggingEvent();
  var configuration7 = require_configuration();
  var disabled = false;
  var cluster = null;
  try {
    cluster = require("cluster");
  } catch (e) {
    debug("cluster module not present");
    disabled = true;
  }
  var listeners = [];
  var pm2 = false;
  var pm2InstanceVar = "NODE_APP_INSTANCE";
  var isPM2Master = () => pm2 && process.env[pm2InstanceVar] === "0";
  var isMaster = () => disabled || cluster.isMaster || isPM2Master();
  var sendToListeners = (logEvent) => {
    listeners.forEach((l) => l(logEvent));
  };
  var receiver = (worker2, message) => {
    debug("cluster message received from worker ", worker2, ": ", message);
    if (worker2.topic && worker2.data) {
      message = worker2;
      worker2 = void 0;
    }
    if (message && message.topic && message.topic === "log4js:message") {
      debug("received message: ", message.data);
      const logEvent = LoggingEvent.deserialise(message.data);
      sendToListeners(logEvent);
    }
  };
  if (!disabled) {
    configuration7.addListener((config) => {
      listeners.length = 0;
      ({
        pm2,
        disableClustering: disabled,
        pm2InstanceVar = "NODE_APP_INSTANCE"
      } = config);
      debug(`clustering disabled ? ${disabled}`);
      debug(`cluster.isMaster ? ${cluster && cluster.isMaster}`);
      debug(`pm2 enabled ? ${pm2}`);
      debug(`pm2InstanceVar = ${pm2InstanceVar}`);
      debug(`process.env[${pm2InstanceVar}] = ${process.env[pm2InstanceVar]}`);
      if (pm2) {
        process.removeListener("message", receiver);
      }
      if (cluster && cluster.removeListener) {
        cluster.removeListener("message", receiver);
      }
      if (disabled || config.disableClustering) {
        debug("Not listening for cluster messages, because clustering disabled.");
      } else if (isPM2Master()) {
        debug("listening for PM2 broadcast messages");
        process.on("message", receiver);
      } else if (cluster.isMaster) {
        debug("listening for cluster messages");
        cluster.on("message", receiver);
      } else {
        debug("not listening for messages, because we are not a master process");
      }
    });
  }
  module2.exports = {
    onlyOnMaster: (fn, notMaster) => isMaster() ? fn() : notMaster,
    isMaster,
    send: (msg) => {
      if (isMaster()) {
        sendToListeners(msg);
      } else {
        if (!pm2) {
          msg.cluster = {
            workerId: cluster.worker.id,
            worker: process.pid
          };
        }
        process.send({topic: "log4js:message", data: msg.serialise()});
      }
    },
    onMessage: (listener) => {
      listeners.push(listener);
    }
  };
});

// node_modules/log4js/lib/appenders/adapters.js
var require_adapters = __commonJS((exports2, module2) => {
  function maxFileSizeUnitTransform(maxLogSize) {
    if (typeof maxLogSize === "number" && Number.isInteger(maxLogSize)) {
      return maxLogSize;
    }
    const units = {
      K: 1024,
      M: 1024 * 1024,
      G: 1024 * 1024 * 1024
    };
    const validUnit = Object.keys(units);
    const unit = maxLogSize.substr(maxLogSize.length - 1).toLocaleUpperCase();
    const value = maxLogSize.substring(0, maxLogSize.length - 1).trim();
    if (validUnit.indexOf(unit) < 0 || !Number.isInteger(Number(value))) {
      throw Error(`maxLogSize: "${maxLogSize}" is invalid`);
    } else {
      return value * units[unit];
    }
  }
  function adapter(configAdapter, config) {
    const newConfig = Object.assign({}, config);
    Object.keys(configAdapter).forEach((key) => {
      if (newConfig[key]) {
        newConfig[key] = configAdapter[key](config[key]);
      }
    });
    return newConfig;
  }
  function fileAppenderAdapter(config) {
    const configAdapter = {
      maxLogSize: maxFileSizeUnitTransform
    };
    return adapter(configAdapter, config);
  }
  var adapters = {
    file: fileAppenderAdapter,
    fileSync: fileAppenderAdapter
  };
  module2.exports.modifyConfig = (config) => adapters[config.type] ? adapters[config.type](config) : config;
});

// node_modules/log4js/lib/appenders/console.js
var require_console = __commonJS((exports2, module2) => {
  var consoleLog = console.log.bind(console);
  function consoleAppender(layout, timezoneOffset) {
    return (loggingEvent) => {
      consoleLog(layout(loggingEvent, timezoneOffset));
    };
  }
  function configure(config, layouts) {
    let layout = layouts.colouredLayout;
    if (config.layout) {
      layout = layouts.layout(config.layout.type, config.layout);
    }
    return consoleAppender(layout, config.timezoneOffset);
  }
  module2.exports.configure = configure;
});

// node_modules/log4js/lib/appenders/stdout.js
var require_stdout = __commonJS((exports2) => {
  function stdoutAppender(layout, timezoneOffset) {
    return (loggingEvent) => {
      process.stdout.write(`${layout(loggingEvent, timezoneOffset)}
`);
    };
  }
  function configure(config, layouts) {
    let layout = layouts.colouredLayout;
    if (config.layout) {
      layout = layouts.layout(config.layout.type, config.layout);
    }
    return stdoutAppender(layout, config.timezoneOffset);
  }
  exports2.configure = configure;
});

// node_modules/log4js/lib/appenders/stderr.js
var require_stderr = __commonJS((exports2, module2) => {
  function stderrAppender(layout, timezoneOffset) {
    return (loggingEvent) => {
      process.stderr.write(`${layout(loggingEvent, timezoneOffset)}
`);
    };
  }
  function configure(config, layouts) {
    let layout = layouts.colouredLayout;
    if (config.layout) {
      layout = layouts.layout(config.layout.type, config.layout);
    }
    return stderrAppender(layout, config.timezoneOffset);
  }
  module2.exports.configure = configure;
});

// node_modules/log4js/lib/appenders/logLevelFilter.js
var require_logLevelFilter = __commonJS((exports2, module2) => {
  function logLevelFilter(minLevelString, maxLevelString, appender, levels) {
    const minLevel = levels.getLevel(minLevelString);
    const maxLevel = levels.getLevel(maxLevelString, levels.FATAL);
    return (logEvent) => {
      const eventLevel = logEvent.level;
      if (eventLevel.isGreaterThanOrEqualTo(minLevel) && eventLevel.isLessThanOrEqualTo(maxLevel)) {
        appender(logEvent);
      }
    };
  }
  function configure(config, layouts, findAppender, levels) {
    const appender = findAppender(config.appender);
    return logLevelFilter(config.level, config.maxLevel, appender, levels);
  }
  module2.exports.configure = configure;
});

// node_modules/log4js/lib/appenders/categoryFilter.js
var require_categoryFilter = __commonJS((exports2, module2) => {
  var debug = require_src()("log4js:categoryFilter");
  function categoryFilter(excludes, appender) {
    if (typeof excludes === "string")
      excludes = [excludes];
    return (logEvent) => {
      debug(`Checking ${logEvent.categoryName} against ${excludes}`);
      if (excludes.indexOf(logEvent.categoryName) === -1) {
        debug("Not excluded, sending to appender");
        appender(logEvent);
      }
    };
  }
  function configure(config, layouts, findAppender) {
    const appender = findAppender(config.appender);
    return categoryFilter(config.exclude, appender);
  }
  module2.exports.configure = configure;
});

// node_modules/log4js/lib/appenders/noLogFilter.js
var require_noLogFilter = __commonJS((exports2, module2) => {
  var debug = require_src()("log4js:noLogFilter");
  function removeNullOrEmptyRegexp(regexp) {
    const filtered = regexp.filter((el) => el != null && el !== "");
    return filtered;
  }
  function noLogFilter(filters, appender) {
    return (logEvent) => {
      debug(`Checking data: ${logEvent.data} against filters: ${filters}`);
      if (typeof filters === "string") {
        filters = [filters];
      }
      filters = removeNullOrEmptyRegexp(filters);
      const regex = new RegExp(filters.join("|"), "i");
      if (filters.length === 0 || logEvent.data.findIndex((value) => regex.test(value)) < 0) {
        debug("Not excluded, sending to appender");
        appender(logEvent);
      }
    };
  }
  function configure(config, layouts, findAppender) {
    const appender = findAppender(config.appender);
    return noLogFilter(config.exclude, appender);
  }
  module2.exports.configure = configure;
});

// node_modules/streamroller/node_modules/universalify/index.js
var require_universalify = __commonJS((exports2) => {
  "use strict";
  exports2.fromCallback = function(fn) {
    return Object.defineProperty(function() {
      if (typeof arguments[arguments.length - 1] === "function")
        fn.apply(this, arguments);
      else {
        return new Promise((resolve3, reject) => {
          arguments[arguments.length] = (err, res) => {
            if (err)
              return reject(err);
            resolve3(res);
          };
          arguments.length++;
          fn.apply(this, arguments);
        });
      }
    }, "name", {value: fn.name});
  };
  exports2.fromPromise = function(fn) {
    return Object.defineProperty(function() {
      const cb = arguments[arguments.length - 1];
      if (typeof cb !== "function")
        return fn.apply(this, arguments);
      else
        fn.apply(this, arguments).then((r) => cb(null, r), cb);
    }, "name", {value: fn.name});
  };
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports2, module2) => {
  var constants = require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform3 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  var chdir = process.chdir;
  process.chdir = function(d) {
    cwd = null;
    chdir.call(process, d);
  };
  module2.exports = patch;
  function patch(fs55) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs55);
    }
    if (!fs55.lutimes) {
      patchLutimes(fs55);
    }
    fs55.chown = chownFix(fs55.chown);
    fs55.fchown = chownFix(fs55.fchown);
    fs55.lchown = chownFix(fs55.lchown);
    fs55.chmod = chmodFix(fs55.chmod);
    fs55.fchmod = chmodFix(fs55.fchmod);
    fs55.lchmod = chmodFix(fs55.lchmod);
    fs55.chownSync = chownFixSync(fs55.chownSync);
    fs55.fchownSync = chownFixSync(fs55.fchownSync);
    fs55.lchownSync = chownFixSync(fs55.lchownSync);
    fs55.chmodSync = chmodFixSync(fs55.chmodSync);
    fs55.fchmodSync = chmodFixSync(fs55.fchmodSync);
    fs55.lchmodSync = chmodFixSync(fs55.lchmodSync);
    fs55.stat = statFix(fs55.stat);
    fs55.fstat = statFix(fs55.fstat);
    fs55.lstat = statFix(fs55.lstat);
    fs55.statSync = statFixSync(fs55.statSync);
    fs55.fstatSync = statFixSync(fs55.fstatSync);
    fs55.lstatSync = statFixSync(fs55.lstatSync);
    if (!fs55.lchmod) {
      fs55.lchmod = function(path66, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs55.lchmodSync = function() {
      };
    }
    if (!fs55.lchown) {
      fs55.lchown = function(path66, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs55.lchownSync = function() {
      };
    }
    if (platform3 === "win32") {
      fs55.rename = function(fs$rename) {
        return function(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs55.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        };
      }(fs55.rename);
    }
    fs55.read = function(fs$read) {
      function read(fd, buffer4, offset, length, position15, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs55, fd, buffer4, offset, length, position15, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs55, fd, buffer4, offset, length, position15, callback);
      }
      read.__proto__ = fs$read;
      return read;
    }(fs55.read);
    fs55.readSync = function(fs$readSync) {
      return function(fd, buffer4, offset, length, position15) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs55, fd, buffer4, offset, length, position15);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs55.readSync);
    function patchLchmod(fs56) {
      fs56.lchmod = function(path66, mode, callback) {
        fs56.open(path66, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs56.fchmod(fd, mode, function(err2) {
            fs56.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs56.lchmodSync = function(path66, mode) {
        var fd = fs56.openSync(path66, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret2;
        try {
          ret2 = fs56.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs56.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs56.closeSync(fd);
          }
        }
        return ret2;
      };
    }
    function patchLutimes(fs56) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs56.lutimes = function(path66, at, mt, cb) {
          fs56.open(path66, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs56.futimes(fd, at, mt, function(er2) {
              fs56.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs56.lutimesSync = function(path66, at, mt) {
          var fd = fs56.openSync(path66, constants.O_SYMLINK);
          var ret2;
          var threw = true;
          try {
            ret2 = fs56.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs56.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs56.closeSync(fd);
            }
          }
          return ret2;
        };
      } else {
        fs56.lutimes = function(_a2, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs56.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs55, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs55, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs55, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs55, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs55, target, options, callback) : orig.call(fs55, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs55, target, options) : orig.call(fs55, target);
        if (stats.uid < 0)
          stats.uid += 4294967296;
        if (stats.gid < 0)
          stats.gid += 4294967296;
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports2, module2) => {
  var Stream = require("stream").Stream;
  module2.exports = legacy;
  function legacy(fs55) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path66, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path66, options);
      Stream.call(this);
      var self2 = this;
      this.path = path66;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs55.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path66, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path66, options);
      Stream.call(this);
      this.path = path66;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs55.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = clone;
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = {__proto__: obj.__proto__};
    else
      var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports2, module2) => {
  var fs55 = require("fs");
  var polyfills = require_polyfills();
  var legacy = require_legacy_streams();
  var clone = require_clone();
  var util54 = require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {
  }
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug = noop;
  if (util54.debuglog)
    debug = util54.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m = util54.format.apply(util54, arguments);
      m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
      console.error(m);
    };
  if (!fs55[gracefulQueue]) {
    queue = global[gracefulQueue] || [];
    publishQueue(fs55, queue);
    fs55.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs55, fd, function(err) {
          if (!err) {
            retry();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs55.close);
    fs55.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs55, arguments);
        retry();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs55.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs55[gracefulQueue]);
        require("assert").equal(fs55[gracefulQueue].length, 0);
      });
    }
  }
  var queue;
  if (!global[gracefulQueue]) {
    publishQueue(global, fs55[gracefulQueue]);
  }
  module2.exports = patch(clone(fs55));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs55.__patched) {
    module2.exports = patch(fs55);
    fs55.__patched = true;
  }
  function patch(fs56) {
    polyfills(fs56);
    fs56.gracefulify = patch;
    fs56.createReadStream = createReadStream;
    fs56.createWriteStream = createWriteStream;
    var fs$readFile = fs56.readFile;
    fs56.readFile = readFile2;
    function readFile2(path66, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path66, options, cb);
      function go$readFile(path67, options2, cb2) {
        return fs$readFile(path67, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path67, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$writeFile = fs56.writeFile;
    fs56.writeFile = writeFile2;
    function writeFile2(path66, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path66, data, options, cb);
      function go$writeFile(path67, data2, options2, cb2) {
        return fs$writeFile(path67, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path67, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$appendFile = fs56.appendFile;
    if (fs$appendFile)
      fs56.appendFile = appendFile;
    function appendFile(path66, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path66, data, options, cb);
      function go$appendFile(path67, data2, options2, cb2) {
        return fs$appendFile(path67, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path67, data2, options2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    var fs$readdir = fs56.readdir;
    fs56.readdir = readdir;
    function readdir(path66, options, cb) {
      var args = [path66];
      if (typeof options !== "function") {
        args.push(options);
      } else {
        cb = options;
      }
      args.push(go$readdir$cb);
      return go$readdir(args);
      function go$readdir$cb(err, files) {
        if (files && files.sort)
          files.sort();
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [args]]);
        else {
          if (typeof cb === "function")
            cb.apply(this, arguments);
          retry();
        }
      }
    }
    function go$readdir(args) {
      return fs$readdir.apply(fs56, args);
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs56);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs56.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs56.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs56, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs56, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs56, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs56, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path66, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path66, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path66, options) {
      return new fs56.ReadStream(path66, options);
    }
    function createWriteStream(path66, options) {
      return new fs56.WriteStream(path66, options);
    }
    var fs$open = fs56.open;
    fs56.open = open;
    function open(path66, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path66, flags, mode, cb);
      function go$open(path67, flags2, mode2, cb2) {
        return fs$open(path67, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path67, flags2, mode2, cb2]]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
            retry();
          }
        });
      }
    }
    return fs56;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs55[gracefulQueue].push(elem);
  }
  function retry() {
    var elem = fs55[gracefulQueue].shift();
    if (elem) {
      debug("RETRY", elem[0].name, elem[1]);
      elem[0].apply(null, elem[1]);
    }
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS((exports2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var fs55 = require_graceful_fs();
  var api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchown",
    "lchmod",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "readFile",
    "readdir",
    "readlink",
    "realpath",
    "rename",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs55[key] === "function";
  });
  Object.keys(fs55).forEach((key) => {
    if (key === "promises") {
      return;
    }
    exports2[key] = fs55[key];
  });
  api.forEach((method) => {
    exports2[method] = u(fs55[method]);
  });
  exports2.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs55.exists(filename, callback);
    }
    return new Promise((resolve3) => {
      return fs55.exists(filename, resolve3);
    });
  };
  exports2.read = function(fd, buffer4, offset, length, position15, callback) {
    if (typeof callback === "function") {
      return fs55.read(fd, buffer4, offset, length, position15, callback);
    }
    return new Promise((resolve3, reject) => {
      fs55.read(fd, buffer4, offset, length, position15, (err, bytesRead, buffer5) => {
        if (err)
          return reject(err);
        resolve3({bytesRead, buffer: buffer5});
      });
    });
  };
  exports2.write = function(fd, buffer4, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs55.write(fd, buffer4, ...args);
    }
    return new Promise((resolve3, reject) => {
      fs55.write(fd, buffer4, ...args, (err, bytesWritten, buffer5) => {
        if (err)
          return reject(err);
        resolve3({bytesWritten, buffer: buffer5});
      });
    });
  };
  if (typeof fs55.realpath.native === "function") {
    exports2.realpath.native = u(fs55.realpath.native);
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/win32.js
var require_win32 = __commonJS((exports2, module2) => {
  "use strict";
  var path66 = require("path");
  function getRootPath(p) {
    p = path66.normalize(path66.resolve(p)).split(path66.sep);
    if (p.length > 0)
      return p[0];
    return null;
  }
  var INVALID_PATH_CHARS = /[<>:"|?*]/;
  function invalidWin32Path(p) {
    const rp = getRootPath(p);
    p = p.replace(rp, "");
    return INVALID_PATH_CHARS.test(p);
  }
  module2.exports = {
    getRootPath,
    invalidWin32Path
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs.js
var require_mkdirs = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var invalidWin32Path = require_win32().invalidWin32Path;
  var o777 = parseInt("0777", 8);
  function mkdirs(p, opts, callback, made) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    } else if (!opts || typeof opts !== "object") {
      opts = {mode: opts};
    }
    if (process.platform === "win32" && invalidWin32Path(p)) {
      const errInval = new Error(p + " contains invalid WIN32 path characters.");
      errInval.code = "EINVAL";
      return callback(errInval);
    }
    let mode = opts.mode;
    const xfs = opts.fs || fs55;
    if (mode === void 0) {
      mode = o777 & ~process.umask();
    }
    if (!made)
      made = null;
    callback = callback || function() {
    };
    p = path66.resolve(p);
    xfs.mkdir(p, mode, (er) => {
      if (!er) {
        made = made || p;
        return callback(null, made);
      }
      switch (er.code) {
        case "ENOENT":
          if (path66.dirname(p) === p)
            return callback(er);
          mkdirs(path66.dirname(p), opts, (er2, made2) => {
            if (er2)
              callback(er2, made2);
            else
              mkdirs(p, opts, callback, made2);
          });
          break;
        default:
          xfs.stat(p, (er2, stat) => {
            if (er2 || !stat.isDirectory())
              callback(er, made);
            else
              callback(null, made);
          });
          break;
      }
    });
  }
  module2.exports = mkdirs;
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js
var require_mkdirs_sync = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var invalidWin32Path = require_win32().invalidWin32Path;
  var o777 = parseInt("0777", 8);
  function mkdirsSync(p, opts, made) {
    if (!opts || typeof opts !== "object") {
      opts = {mode: opts};
    }
    let mode = opts.mode;
    const xfs = opts.fs || fs55;
    if (process.platform === "win32" && invalidWin32Path(p)) {
      const errInval = new Error(p + " contains invalid WIN32 path characters.");
      errInval.code = "EINVAL";
      throw errInval;
    }
    if (mode === void 0) {
      mode = o777 & ~process.umask();
    }
    if (!made)
      made = null;
    p = path66.resolve(p);
    try {
      xfs.mkdirSync(p, mode);
      made = made || p;
    } catch (err0) {
      if (err0.code === "ENOENT") {
        if (path66.dirname(p) === p)
          throw err0;
        made = mkdirsSync(path66.dirname(p), opts, made);
        mkdirsSync(p, opts, made);
      } else {
        let stat;
        try {
          stat = xfs.statSync(p);
        } catch (err1) {
          throw err0;
        }
        if (!stat.isDirectory())
          throw err0;
      }
    }
    return made;
  }
  module2.exports = mkdirsSync;
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var mkdirs = u(require_mkdirs());
  var mkdirsSync = require_mkdirs_sync();
  module2.exports = {
    mkdirs,
    mkdirsSync,
    mkdirp: mkdirs,
    mkdirpSync: mkdirsSync,
    ensureDir: mkdirs,
    ensureDirSync: mkdirsSync
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var os15 = require("os");
  var path66 = require("path");
  function hasMillisResSync() {
    let tmpfile = path66.join("millis-test-sync" + Date.now().toString() + Math.random().toString().slice(2));
    tmpfile = path66.join(os15.tmpdir(), tmpfile);
    const d = new Date(1435410243862);
    fs55.writeFileSync(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141");
    const fd = fs55.openSync(tmpfile, "r+");
    fs55.futimesSync(fd, d, d);
    fs55.closeSync(fd);
    return fs55.statSync(tmpfile).mtime > 1435410243e3;
  }
  function hasMillisRes(callback) {
    let tmpfile = path66.join("millis-test" + Date.now().toString() + Math.random().toString().slice(2));
    tmpfile = path66.join(os15.tmpdir(), tmpfile);
    const d = new Date(1435410243862);
    fs55.writeFile(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141", (err) => {
      if (err)
        return callback(err);
      fs55.open(tmpfile, "r+", (err2, fd) => {
        if (err2)
          return callback(err2);
        fs55.futimes(fd, d, d, (err3) => {
          if (err3)
            return callback(err3);
          fs55.close(fd, (err4) => {
            if (err4)
              return callback(err4);
            fs55.stat(tmpfile, (err5, stats) => {
              if (err5)
                return callback(err5);
              callback(null, stats.mtime > 1435410243e3);
            });
          });
        });
      });
    });
  }
  function timeRemoveMillis(timestamp) {
    if (typeof timestamp === "number") {
      return Math.floor(timestamp / 1e3) * 1e3;
    } else if (timestamp instanceof Date) {
      return new Date(Math.floor(timestamp.getTime() / 1e3) * 1e3);
    } else {
      throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
    }
  }
  function utimesMillis(path67, atime, mtime, callback) {
    fs55.open(path67, "r+", (err, fd) => {
      if (err)
        return callback(err);
      fs55.futimes(fd, atime, mtime, (futimesErr) => {
        fs55.close(fd, (closeErr) => {
          if (callback)
            callback(futimesErr || closeErr);
        });
      });
    });
  }
  function utimesMillisSync(path67, atime, mtime) {
    const fd = fs55.openSync(path67, "r+");
    fs55.futimesSync(fd, atime, mtime);
    return fs55.closeSync(fd);
  }
  module2.exports = {
    hasMillisRes,
    hasMillisResSync,
    timeRemoveMillis,
    utimesMillis,
    utimesMillisSync
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var NODE_VERSION_MAJOR_WITH_BIGINT = 10;
  var NODE_VERSION_MINOR_WITH_BIGINT = 5;
  var NODE_VERSION_PATCH_WITH_BIGINT = 0;
  var nodeVersion = process.versions.node.split(".");
  var nodeVersionMajor = Number.parseInt(nodeVersion[0], 10);
  var nodeVersionMinor = Number.parseInt(nodeVersion[1], 10);
  var nodeVersionPatch = Number.parseInt(nodeVersion[2], 10);
  function nodeSupportsBigInt() {
    if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
      return true;
    } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
      if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
        return true;
      } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
        if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
          return true;
        }
      }
    }
    return false;
  }
  function getStats(src, dest, cb) {
    if (nodeSupportsBigInt()) {
      fs55.stat(src, {bigint: true}, (err, srcStat) => {
        if (err)
          return cb(err);
        fs55.stat(dest, {bigint: true}, (err2, destStat) => {
          if (err2) {
            if (err2.code === "ENOENT")
              return cb(null, {srcStat, destStat: null});
            return cb(err2);
          }
          return cb(null, {srcStat, destStat});
        });
      });
    } else {
      fs55.stat(src, (err, srcStat) => {
        if (err)
          return cb(err);
        fs55.stat(dest, (err2, destStat) => {
          if (err2) {
            if (err2.code === "ENOENT")
              return cb(null, {srcStat, destStat: null});
            return cb(err2);
          }
          return cb(null, {srcStat, destStat});
        });
      });
    }
  }
  function getStatsSync(src, dest) {
    let srcStat, destStat;
    if (nodeSupportsBigInt()) {
      srcStat = fs55.statSync(src, {bigint: true});
    } else {
      srcStat = fs55.statSync(src);
    }
    try {
      if (nodeSupportsBigInt()) {
        destStat = fs55.statSync(dest, {bigint: true});
      } else {
        destStat = fs55.statSync(dest);
      }
    } catch (err) {
      if (err.code === "ENOENT")
        return {srcStat, destStat: null};
      throw err;
    }
    return {srcStat, destStat};
  }
  function checkPaths(src, dest, funcName, cb) {
    getStats(src, dest, (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat, destStat} = stats;
      if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        return cb(new Error(errMsg(src, dest, funcName)));
      }
      return cb(null, {srcStat, destStat});
    });
  }
  function checkPathsSync(src, dest, funcName) {
    const {srcStat, destStat} = getStatsSync(src, dest);
    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return {srcStat, destStat};
  }
  function checkParentPaths(src, srcStat, dest, funcName, cb) {
    const srcParent = path66.resolve(path66.dirname(src));
    const destParent = path66.resolve(path66.dirname(dest));
    if (destParent === srcParent || destParent === path66.parse(destParent).root)
      return cb();
    if (nodeSupportsBigInt()) {
      fs55.stat(destParent, {bigint: true}, (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      });
    } else {
      fs55.stat(destParent, (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      });
    }
  }
  function checkParentPathsSync(src, srcStat, dest, funcName) {
    const srcParent = path66.resolve(path66.dirname(src));
    const destParent = path66.resolve(path66.dirname(dest));
    if (destParent === srcParent || destParent === path66.parse(destParent).root)
      return;
    let destStat;
    try {
      if (nodeSupportsBigInt()) {
        destStat = fs55.statSync(destParent, {bigint: true});
      } else {
        destStat = fs55.statSync(destParent);
      }
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
  }
  function isSrcSubdir(src, dest) {
    const srcArr = path66.resolve(src).split(path66.sep).filter((i) => i);
    const destArr = path66.resolve(dest).split(path66.sep).filter((i) => i);
    return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
  }
  function errMsg(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
  }
  module2.exports = {
    checkPaths,
    checkPathsSync,
    checkParentPaths,
    checkParentPathsSync,
    isSrcSubdir
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/util/buffer.js
var require_buffer = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(size) {
    if (typeof Buffer.allocUnsafe === "function") {
      try {
        return Buffer.allocUnsafe(size);
      } catch (e) {
        return new Buffer(size);
      }
    }
    return new Buffer(size);
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var mkdirpSync = require_mkdirs2().mkdirsSync;
  var utimesSync = require_utimes().utimesMillisSync;
  var stat = require_stat();
  function copySync(src, dest, opts) {
    if (typeof opts === "function") {
      opts = {filter: opts};
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
    }
    const {srcStat, destStat} = stat.checkPathsSync(src, dest, "copy");
    stat.checkParentPathsSync(src, srcStat, dest, "copy");
    return handleFilterAndCopy(destStat, src, dest, opts);
  }
  function handleFilterAndCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest))
      return;
    const destParent = path66.dirname(dest);
    if (!fs55.existsSync(destParent))
      mkdirpSync(destParent);
    return startCopy(destStat, src, dest, opts);
  }
  function startCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest))
      return;
    return getStats(destStat, src, dest, opts);
  }
  function getStats(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs55.statSync : fs55.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    else if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
  }
  function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    return mayCopyFile(srcStat, src, dest, opts);
  }
  function mayCopyFile(srcStat, src, dest, opts) {
    if (opts.overwrite) {
      fs55.unlinkSync(dest);
      return copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile(srcStat, src, dest, opts) {
    if (typeof fs55.copyFileSync === "function") {
      fs55.copyFileSync(src, dest);
      fs55.chmodSync(dest, srcStat.mode);
      if (opts.preserveTimestamps) {
        return utimesSync(dest, srcStat.atime, srcStat.mtime);
      }
      return;
    }
    return copyFileFallback(srcStat, src, dest, opts);
  }
  function copyFileFallback(srcStat, src, dest, opts) {
    const BUF_LENGTH = 64 * 1024;
    const _buff = require_buffer()(BUF_LENGTH);
    const fdr = fs55.openSync(src, "r");
    const fdw = fs55.openSync(dest, "w", srcStat.mode);
    let pos = 0;
    while (pos < srcStat.size) {
      const bytesRead = fs55.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
      fs55.writeSync(fdw, _buff, 0, bytesRead);
      pos += bytesRead;
    }
    if (opts.preserveTimestamps)
      fs55.futimesSync(fdw, srcStat.atime, srcStat.mtime);
    fs55.closeSync(fdr);
    fs55.closeSync(fdw);
  }
  function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return mkDirAndCopy(srcStat, src, dest, opts);
    if (destStat && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    return copyDir(src, dest, opts);
  }
  function mkDirAndCopy(srcStat, src, dest, opts) {
    fs55.mkdirSync(dest);
    copyDir(src, dest, opts);
    return fs55.chmodSync(dest, srcStat.mode);
  }
  function copyDir(src, dest, opts) {
    fs55.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
  }
  function copyDirItem(item, src, dest, opts) {
    const srcItem = path66.join(src, item);
    const destItem = path66.join(dest, item);
    const {destStat} = stat.checkPathsSync(srcItem, destItem, "copy");
    return startCopy(destStat, srcItem, destItem, opts);
  }
  function onLink(destStat, src, dest, opts) {
    let resolvedSrc = fs55.readlinkSync(src);
    if (opts.dereference) {
      resolvedSrc = path66.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs55.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs55.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN")
          return fs55.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path66.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (fs55.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink(resolvedSrc, dest);
    }
  }
  function copyLink(resolvedSrc, dest) {
    fs55.unlinkSync(dest);
    return fs55.symlinkSync(resolvedSrc, dest);
  }
  module2.exports = copySync;
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    copySync: require_copy_sync()
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromPromise;
  var fs55 = require_fs();
  function pathExists(path66) {
    return fs55.access(path66).then(() => true).catch(() => false);
  }
  module2.exports = {
    pathExists: u(pathExists),
    pathExistsSync: fs55.existsSync
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var mkdirp = require_mkdirs2().mkdirs;
  var pathExists = require_path_exists().pathExists;
  var utimes = require_utimes().utimesMillis;
  var stat = require_stat();
  function copy(src, dest, opts, cb) {
    if (typeof opts === "function" && !cb) {
      cb = opts;
      opts = {};
    } else if (typeof opts === "function") {
      opts = {filter: opts};
    }
    cb = cb || function() {
    };
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
    }
    stat.checkPaths(src, dest, "copy", (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat, destStat} = stats;
      stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
        if (err2)
          return cb(err2);
        if (opts.filter)
          return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
        return checkParentDir(destStat, src, dest, opts, cb);
      });
    });
  }
  function checkParentDir(destStat, src, dest, opts, cb) {
    const destParent = path66.dirname(dest);
    pathExists(destParent, (err, dirExists) => {
      if (err)
        return cb(err);
      if (dirExists)
        return startCopy(destStat, src, dest, opts, cb);
      mkdirp(destParent, (err2) => {
        if (err2)
          return cb(err2);
        return startCopy(destStat, src, dest, opts, cb);
      });
    });
  }
  function handleFilter(onInclude, destStat, src, dest, opts, cb) {
    Promise.resolve(opts.filter(src, dest)).then((include) => {
      if (include)
        return onInclude(destStat, src, dest, opts, cb);
      return cb();
    }, (error) => cb(error));
  }
  function startCopy(destStat, src, dest, opts, cb) {
    if (opts.filter)
      return handleFilter(getStats, destStat, src, dest, opts, cb);
    return getStats(destStat, src, dest, opts, cb);
  }
  function getStats(destStat, src, dest, opts, cb) {
    const stat2 = opts.dereference ? fs55.stat : fs55.lstat;
    stat2(src, (err, srcStat) => {
      if (err)
        return cb(err);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts, cb);
    });
  }
  function onFile(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts, cb);
    return mayCopyFile(srcStat, src, dest, opts, cb);
  }
  function mayCopyFile(srcStat, src, dest, opts, cb) {
    if (opts.overwrite) {
      fs55.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return copyFile(srcStat, src, dest, opts, cb);
      });
    } else if (opts.errorOnExist) {
      return cb(new Error(`'${dest}' already exists`));
    } else
      return cb();
  }
  function copyFile(srcStat, src, dest, opts, cb) {
    if (typeof fs55.copyFile === "function") {
      return fs55.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestModeAndTimestamps(srcStat, dest, opts, cb);
      });
    }
    return copyFileFallback(srcStat, src, dest, opts, cb);
  }
  function copyFileFallback(srcStat, src, dest, opts, cb) {
    const rs = fs55.createReadStream(src);
    rs.on("error", (err) => cb(err)).once("open", () => {
      const ws = fs55.createWriteStream(dest, {mode: srcStat.mode});
      ws.on("error", (err) => cb(err)).on("open", () => rs.pipe(ws)).once("close", () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
    });
  }
  function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
    fs55.chmod(dest, srcStat.mode, (err) => {
      if (err)
        return cb(err);
      if (opts.preserveTimestamps) {
        return utimes(dest, srcStat.atime, srcStat.mtime, cb);
      }
      return cb();
    });
  }
  function onDir(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat)
      return mkDirAndCopy(srcStat, src, dest, opts, cb);
    if (destStat && !destStat.isDirectory()) {
      return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
    }
    return copyDir(src, dest, opts, cb);
  }
  function mkDirAndCopy(srcStat, src, dest, opts, cb) {
    fs55.mkdir(dest, (err) => {
      if (err)
        return cb(err);
      copyDir(src, dest, opts, (err2) => {
        if (err2)
          return cb(err2);
        return fs55.chmod(dest, srcStat.mode, cb);
      });
    });
  }
  function copyDir(src, dest, opts, cb) {
    fs55.readdir(src, (err, items) => {
      if (err)
        return cb(err);
      return copyDirItems(items, src, dest, opts, cb);
    });
  }
  function copyDirItems(items, src, dest, opts, cb) {
    const item = items.pop();
    if (!item)
      return cb();
    return copyDirItem(items, item, src, dest, opts, cb);
  }
  function copyDirItem(items, item, src, dest, opts, cb) {
    const srcItem = path66.join(src, item);
    const destItem = path66.join(dest, item);
    stat.checkPaths(srcItem, destItem, "copy", (err, stats) => {
      if (err)
        return cb(err);
      const {destStat} = stats;
      startCopy(destStat, srcItem, destItem, opts, (err2) => {
        if (err2)
          return cb(err2);
        return copyDirItems(items, src, dest, opts, cb);
      });
    });
  }
  function onLink(destStat, src, dest, opts, cb) {
    fs55.readlink(src, (err, resolvedSrc) => {
      if (err)
        return cb(err);
      if (opts.dereference) {
        resolvedSrc = path66.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs55.symlink(resolvedSrc, dest, cb);
      } else {
        fs55.readlink(dest, (err2, resolvedDest) => {
          if (err2) {
            if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
              return fs55.symlink(resolvedSrc, dest, cb);
            return cb(err2);
          }
          if (opts.dereference) {
            resolvedDest = path66.resolve(process.cwd(), resolvedDest);
          }
          if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
            return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
          }
          if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
            return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
          }
          return copyLink(resolvedSrc, dest, cb);
        });
      }
    });
  }
  function copyLink(resolvedSrc, dest, cb) {
    fs55.unlink(dest, (err) => {
      if (err)
        return cb(err);
      return fs55.symlink(resolvedSrc, dest, cb);
    });
  }
  module2.exports = copy;
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  module2.exports = {
    copy: u(require_copy())
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var assert = require("assert");
  var isWindows4 = process.platform === "win32";
  function defaults2(options) {
    const methods2 = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods2.forEach((m) => {
      options[m] = options[m] || fs55[m];
      m = m + "Sync";
      options[m] = options[m] || fs55[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
  }
  function rimraf(p, options, cb) {
    let busyTries = 0;
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    defaults2(options);
    rimraf_(p, options, function CB(er) {
      if (er) {
        if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
          busyTries++;
          const time = busyTries * 100;
          return setTimeout(() => rimraf_(p, options, CB), time);
        }
        if (er.code === "ENOENT")
          er = null;
      }
      cb(er);
    });
  }
  function rimraf_(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT") {
        return cb(null);
      }
      if (er && er.code === "EPERM" && isWindows4) {
        return fixWinEPERM(p, options, er, cb);
      }
      if (st && st.isDirectory()) {
        return rmdir(p, options, er, cb);
      }
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT") {
            return cb(null);
          }
          if (er2.code === "EPERM") {
            return isWindows4 ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          }
          if (er2.code === "EISDIR") {
            return rmdir(p, options, er2, cb);
          }
        }
        return cb(er2);
      });
    });
  }
  function fixWinEPERM(p, options, er, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    if (er) {
      assert(er instanceof Error);
    }
    options.chmod(p, 438, (er2) => {
      if (er2) {
        cb(er2.code === "ENOENT" ? null : er);
      } else {
        options.stat(p, (er3, stats) => {
          if (er3) {
            cb(er3.code === "ENOENT" ? null : er);
          } else if (stats.isDirectory()) {
            rmdir(p, options, er, cb);
          } else {
            options.unlink(p, cb);
          }
        });
      }
    });
  }
  function fixWinEPERMSync(p, options, er) {
    let stats;
    assert(p);
    assert(options);
    if (er) {
      assert(er instanceof Error);
    }
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    if (stats.isDirectory()) {
      rmdirSync(p, options, er);
    } else {
      options.unlinkSync(p);
    }
  }
  function rmdir(p, options, originalEr, cb) {
    assert(p);
    assert(options);
    if (originalEr) {
      assert(originalEr instanceof Error);
    }
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
        rmkids(p, options, cb);
      } else if (er && er.code === "ENOTDIR") {
        cb(originalEr);
      } else {
        cb(er);
      }
    });
  }
  function rmkids(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er)
        return cb(er);
      let n = files.length;
      let errState;
      if (n === 0)
        return options.rmdir(p, cb);
      files.forEach((f) => {
        rimraf(path66.join(p, f), options, (er2) => {
          if (errState) {
            return;
          }
          if (er2)
            return cb(errState = er2);
          if (--n === 0) {
            options.rmdir(p, cb);
          }
        });
      });
    });
  }
  function rimrafSync(p, options) {
    let st;
    options = options || {};
    defaults2(options);
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    try {
      st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      }
      if (er.code === "EPERM" && isWindows4) {
        fixWinEPERMSync(p, options, er);
      }
    }
    try {
      if (st && st.isDirectory()) {
        rmdirSync(p, options, null);
      } else {
        options.unlinkSync(p);
      }
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      } else if (er.code === "EPERM") {
        return isWindows4 ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
      } else if (er.code !== "EISDIR") {
        throw er;
      }
      rmdirSync(p, options, er);
    }
  }
  function rmdirSync(p, options, originalEr) {
    assert(p);
    assert(options);
    if (originalEr) {
      assert(originalEr instanceof Error);
    }
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOTDIR") {
        throw originalEr;
      } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
        rmkidsSync(p, options);
      } else if (er.code !== "ENOENT") {
        throw er;
      }
    }
  }
  function rmkidsSync(p, options) {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path66.join(p, f), options));
    if (isWindows4) {
      const startTime = Date.now();
      do {
        try {
          const ret2 = options.rmdirSync(p, options);
          return ret2;
        } catch (er) {
        }
      } while (Date.now() - startTime < 500);
    } else {
      const ret2 = options.rmdirSync(p, options);
      return ret2;
    }
  }
  module2.exports = rimraf;
  rimraf.sync = rimrafSync;
});

// node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var rimraf = require_rimraf();
  module2.exports = {
    remove: u(rimraf),
    removeSync: rimraf.sync
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var mkdir = require_mkdirs2();
  var remove = require_remove();
  var emptyDir = u(function emptyDir2(dir, callback) {
    callback = callback || function() {
    };
    fs55.readdir(dir, (err, items) => {
      if (err)
        return mkdir.mkdirs(dir, callback);
      items = items.map((item) => path66.join(dir, item));
      deleteItem();
      function deleteItem() {
        const item = items.pop();
        if (!item)
          return callback();
        remove.remove(item, (err2) => {
          if (err2)
            return callback(err2);
          deleteItem();
        });
      }
    });
  });
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs55.readdirSync(dir);
    } catch (err) {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path66.join(dir, item);
      remove.removeSync(item);
    });
  }
  module2.exports = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var path66 = require("path");
  var fs55 = require_graceful_fs();
  var mkdir = require_mkdirs2();
  var pathExists = require_path_exists().pathExists;
  function createFile(file, callback) {
    function makeFile() {
      fs55.writeFile(file, "", (err) => {
        if (err)
          return callback(err);
        callback();
      });
    }
    fs55.stat(file, (err, stats) => {
      if (!err && stats.isFile())
        return callback();
      const dir = path66.dirname(file);
      pathExists(dir, (err2, dirExists) => {
        if (err2)
          return callback(err2);
        if (dirExists)
          return makeFile();
        mkdir.mkdirs(dir, (err3) => {
          if (err3)
            return callback(err3);
          makeFile();
        });
      });
    });
  }
  function createFileSync(file) {
    let stats;
    try {
      stats = fs55.statSync(file);
    } catch (e) {
    }
    if (stats && stats.isFile())
      return;
    const dir = path66.dirname(file);
    if (!fs55.existsSync(dir)) {
      mkdir.mkdirsSync(dir);
    }
    fs55.writeFileSync(file, "");
  }
  module2.exports = {
    createFile: u(createFile),
    createFileSync
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var path66 = require("path");
  var fs55 = require_graceful_fs();
  var mkdir = require_mkdirs2();
  var pathExists = require_path_exists().pathExists;
  function createLink(srcpath, dstpath, callback) {
    function makeLink(srcpath2, dstpath2) {
      fs55.link(srcpath2, dstpath2, (err) => {
        if (err)
          return callback(err);
        callback(null);
      });
    }
    pathExists(dstpath, (err, destinationExists) => {
      if (err)
        return callback(err);
      if (destinationExists)
        return callback(null);
      fs55.lstat(srcpath, (err2) => {
        if (err2) {
          err2.message = err2.message.replace("lstat", "ensureLink");
          return callback(err2);
        }
        const dir = path66.dirname(dstpath);
        pathExists(dir, (err3, dirExists) => {
          if (err3)
            return callback(err3);
          if (dirExists)
            return makeLink(srcpath, dstpath);
          mkdir.mkdirs(dir, (err4) => {
            if (err4)
              return callback(err4);
            makeLink(srcpath, dstpath);
          });
        });
      });
    });
  }
  function createLinkSync(srcpath, dstpath) {
    const destinationExists = fs55.existsSync(dstpath);
    if (destinationExists)
      return void 0;
    try {
      fs55.lstatSync(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path66.dirname(dstpath);
    const dirExists = fs55.existsSync(dir);
    if (dirExists)
      return fs55.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs55.linkSync(srcpath, dstpath);
  }
  module2.exports = {
    createLink: u(createLink),
    createLinkSync
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS((exports2, module2) => {
  "use strict";
  var path66 = require("path");
  var fs55 = require_graceful_fs();
  var pathExists = require_path_exists().pathExists;
  function symlinkPaths(srcpath, dstpath, callback) {
    if (path66.isAbsolute(srcpath)) {
      return fs55.lstat(srcpath, (err) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          return callback(err);
        }
        return callback(null, {
          toCwd: srcpath,
          toDst: srcpath
        });
      });
    } else {
      const dstdir = path66.dirname(dstpath);
      const relativeToDst = path66.join(dstdir, srcpath);
      return pathExists(relativeToDst, (err, exists) => {
        if (err)
          return callback(err);
        if (exists) {
          return callback(null, {
            toCwd: relativeToDst,
            toDst: srcpath
          });
        } else {
          return fs55.lstat(srcpath, (err2) => {
            if (err2) {
              err2.message = err2.message.replace("lstat", "ensureSymlink");
              return callback(err2);
            }
            return callback(null, {
              toCwd: srcpath,
              toDst: path66.relative(dstdir, srcpath)
            });
          });
        }
      });
    }
  }
  function symlinkPathsSync(srcpath, dstpath) {
    let exists;
    if (path66.isAbsolute(srcpath)) {
      exists = fs55.existsSync(srcpath);
      if (!exists)
        throw new Error("absolute srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    } else {
      const dstdir = path66.dirname(dstpath);
      const relativeToDst = path66.join(dstdir, srcpath);
      exists = fs55.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      } else {
        exists = fs55.existsSync(srcpath);
        if (!exists)
          throw new Error("relative srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: path66.relative(dstdir, srcpath)
        };
      }
    }
  }
  module2.exports = {
    symlinkPaths,
    symlinkPathsSync
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  function symlinkType(srcpath, type, callback) {
    callback = typeof type === "function" ? type : callback;
    type = typeof type === "function" ? false : type;
    if (type)
      return callback(null, type);
    fs55.lstat(srcpath, (err, stats) => {
      if (err)
        return callback(null, "file");
      type = stats && stats.isDirectory() ? "dir" : "file";
      callback(null, type);
    });
  }
  function symlinkTypeSync(srcpath, type) {
    let stats;
    if (type)
      return type;
    try {
      stats = fs55.lstatSync(srcpath);
    } catch (e) {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  module2.exports = {
    symlinkType,
    symlinkTypeSync
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var path66 = require("path");
  var fs55 = require_graceful_fs();
  var _mkdirs = require_mkdirs2();
  var mkdirs = _mkdirs.mkdirs;
  var mkdirsSync = _mkdirs.mkdirsSync;
  var _symlinkPaths = require_symlink_paths();
  var symlinkPaths = _symlinkPaths.symlinkPaths;
  var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
  var _symlinkType = require_symlink_type();
  var symlinkType = _symlinkType.symlinkType;
  var symlinkTypeSync = _symlinkType.symlinkTypeSync;
  var pathExists = require_path_exists().pathExists;
  function createSymlink(srcpath, dstpath, type, callback) {
    callback = typeof type === "function" ? type : callback;
    type = typeof type === "function" ? false : type;
    pathExists(dstpath, (err, destinationExists) => {
      if (err)
        return callback(err);
      if (destinationExists)
        return callback(null);
      symlinkPaths(srcpath, dstpath, (err2, relative) => {
        if (err2)
          return callback(err2);
        srcpath = relative.toDst;
        symlinkType(relative.toCwd, type, (err3, type2) => {
          if (err3)
            return callback(err3);
          const dir = path66.dirname(dstpath);
          pathExists(dir, (err4, dirExists) => {
            if (err4)
              return callback(err4);
            if (dirExists)
              return fs55.symlink(srcpath, dstpath, type2, callback);
            mkdirs(dir, (err5) => {
              if (err5)
                return callback(err5);
              fs55.symlink(srcpath, dstpath, type2, callback);
            });
          });
        });
      });
    });
  }
  function createSymlinkSync(srcpath, dstpath, type) {
    const destinationExists = fs55.existsSync(dstpath);
    if (destinationExists)
      return void 0;
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type = symlinkTypeSync(relative.toCwd, type);
    const dir = path66.dirname(dstpath);
    const exists = fs55.existsSync(dir);
    if (exists)
      return fs55.symlinkSync(srcpath, dstpath, type);
    mkdirsSync(dir);
    return fs55.symlinkSync(srcpath, dstpath, type);
  }
  module2.exports = {
    createSymlink: u(createSymlink),
    createSymlinkSync
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS((exports2, module2) => {
  "use strict";
  var file = require_file();
  var link = require_link();
  var symlink = require_symlink();
  module2.exports = {
    createFile: file.createFile,
    createFileSync: file.createFileSync,
    ensureFile: file.createFile,
    ensureFileSync: file.createFileSync,
    createLink: link.createLink,
    createLinkSync: link.createLinkSync,
    ensureLink: link.createLink,
    ensureLinkSync: link.createLinkSync,
    createSymlink: symlink.createSymlink,
    createSymlinkSync: symlink.createSymlinkSync,
    ensureSymlink: symlink.createSymlink,
    ensureSymlinkSync: symlink.createSymlinkSync
  };
});

// node_modules/streamroller/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS((exports2, module2) => {
  var _fs;
  try {
    _fs = require_graceful_fs();
  } catch (_) {
    _fs = require("fs");
  }
  function readFile2(file, options, callback) {
    if (callback == null) {
      callback = options;
      options = {};
    }
    if (typeof options === "string") {
      options = {encoding: options};
    }
    options = options || {};
    var fs55 = options.fs || _fs;
    var shouldThrow = true;
    if ("throws" in options) {
      shouldThrow = options.throws;
    }
    fs55.readFile(file, options, function(err, data) {
      if (err)
        return callback(err);
      data = stripBom(data);
      var obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err2) {
        if (shouldThrow) {
          err2.message = file + ": " + err2.message;
          return callback(err2);
        } else {
          return callback(null, null);
        }
      }
      callback(null, obj);
    });
  }
  function readFileSync(file, options) {
    options = options || {};
    if (typeof options === "string") {
      options = {encoding: options};
    }
    var fs55 = options.fs || _fs;
    var shouldThrow = true;
    if ("throws" in options) {
      shouldThrow = options.throws;
    }
    try {
      var content = fs55.readFileSync(file, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = file + ": " + err.message;
        throw err;
      } else {
        return null;
      }
    }
  }
  function stringify2(obj, options) {
    var spaces;
    var EOL = "\n";
    if (typeof options === "object" && options !== null) {
      if (options.spaces) {
        spaces = options.spaces;
      }
      if (options.EOL) {
        EOL = options.EOL;
      }
    }
    var str = JSON.stringify(obj, options ? options.replacer : null, spaces);
    return str.replace(/\n/g, EOL) + EOL;
  }
  function writeFile2(file, obj, options, callback) {
    if (callback == null) {
      callback = options;
      options = {};
    }
    options = options || {};
    var fs55 = options.fs || _fs;
    var str = "";
    try {
      str = stringify2(obj, options);
    } catch (err) {
      if (callback)
        callback(err, null);
      return;
    }
    fs55.writeFile(file, str, options, callback);
  }
  function writeFileSync(file, obj, options) {
    options = options || {};
    var fs55 = options.fs || _fs;
    var str = stringify2(obj, options);
    return fs55.writeFileSync(file, str, options);
  }
  function stripBom(content) {
    if (Buffer.isBuffer(content))
      content = content.toString("utf8");
    content = content.replace(/^\uFEFF/, "");
    return content;
  }
  var jsonfile = {
    readFile: readFile2,
    readFileSync,
    writeFile: writeFile2,
    writeFileSync
  };
  module2.exports = jsonfile;
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var jsonFile = require_jsonfile();
  module2.exports = {
    readJson: u(jsonFile.readFile),
    readJsonSync: jsonFile.readFileSync,
    writeJson: u(jsonFile.writeFile),
    writeJsonSync: jsonFile.writeFileSync
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS((exports2, module2) => {
  "use strict";
  var path66 = require("path");
  var mkdir = require_mkdirs2();
  var pathExists = require_path_exists().pathExists;
  var jsonFile = require_jsonfile2();
  function outputJson(file, data, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    const dir = path66.dirname(file);
    pathExists(dir, (err, itDoes) => {
      if (err)
        return callback(err);
      if (itDoes)
        return jsonFile.writeJson(file, data, options, callback);
      mkdir.mkdirs(dir, (err2) => {
        if (err2)
          return callback(err2);
        jsonFile.writeJson(file, data, options, callback);
      });
    });
  }
  module2.exports = outputJson;
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var mkdir = require_mkdirs2();
  var jsonFile = require_jsonfile2();
  function outputJsonSync(file, data, options) {
    const dir = path66.dirname(file);
    if (!fs55.existsSync(dir)) {
      mkdir.mkdirsSync(dir);
    }
    jsonFile.writeJsonSync(file, data, options);
  }
  module2.exports = outputJsonSync;
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var jsonFile = require_jsonfile2();
  jsonFile.outputJson = u(require_output_json());
  jsonFile.outputJsonSync = require_output_json_sync();
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  module2.exports = jsonFile;
});

// node_modules/streamroller/node_modules/fs-extra/lib/move-sync/move-sync.js
var require_move_sync = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var copySync = require_copy_sync2().copySync;
  var removeSync = require_remove().removeSync;
  var mkdirpSync = require_mkdirs2().mkdirpSync;
  var stat = require_stat();
  function moveSync(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const {srcStat} = stat.checkPathsSync(src, dest, "move");
    stat.checkParentPathsSync(src, srcStat, dest, "move");
    mkdirpSync(path66.dirname(dest));
    return doRename(src, dest, overwrite);
  }
  function doRename(src, dest, overwrite) {
    if (overwrite) {
      removeSync(dest);
      return rename(src, dest, overwrite);
    }
    if (fs55.existsSync(dest))
      throw new Error("dest already exists.");
    return rename(src, dest, overwrite);
  }
  function rename(src, dest, overwrite) {
    try {
      fs55.renameSync(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV")
        throw err;
      return moveAcrossDevice(src, dest, overwrite);
    }
  }
  function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copySync(src, dest, opts);
    return removeSync(src);
  }
  module2.exports = moveSync;
});

// node_modules/streamroller/node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    moveSync: require_move_sync()
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var copy = require_copy2().copy;
  var remove = require_remove().remove;
  var mkdirp = require_mkdirs2().mkdirp;
  var pathExists = require_path_exists().pathExists;
  var stat = require_stat();
  function move(src, dest, opts, cb) {
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    const overwrite = opts.overwrite || opts.clobber || false;
    stat.checkPaths(src, dest, "move", (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat} = stats;
      stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
        if (err2)
          return cb(err2);
        mkdirp(path66.dirname(dest), (err3) => {
          if (err3)
            return cb(err3);
          return doRename(src, dest, overwrite, cb);
        });
      });
    });
  }
  function doRename(src, dest, overwrite, cb) {
    if (overwrite) {
      return remove(dest, (err) => {
        if (err)
          return cb(err);
        return rename(src, dest, overwrite, cb);
      });
    }
    pathExists(dest, (err, destExists) => {
      if (err)
        return cb(err);
      if (destExists)
        return cb(new Error("dest already exists."));
      return rename(src, dest, overwrite, cb);
    });
  }
  function rename(src, dest, overwrite, cb) {
    fs55.rename(src, dest, (err) => {
      if (!err)
        return cb();
      if (err.code !== "EXDEV")
        return cb(err);
      return moveAcrossDevice(src, dest, overwrite, cb);
    });
  }
  function moveAcrossDevice(src, dest, overwrite, cb) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copy(src, dest, opts, (err) => {
      if (err)
        return cb(err);
      return remove(src, cb);
    });
  }
  module2.exports = move;
});

// node_modules/streamroller/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  module2.exports = {
    move: u(require_move())
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/output/index.js
var require_output = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var mkdir = require_mkdirs2();
  var pathExists = require_path_exists().pathExists;
  function outputFile(file, data, encoding, callback) {
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = "utf8";
    }
    const dir = path66.dirname(file);
    pathExists(dir, (err, itDoes) => {
      if (err)
        return callback(err);
      if (itDoes)
        return fs55.writeFile(file, data, encoding, callback);
      mkdir.mkdirs(dir, (err2) => {
        if (err2)
          return callback(err2);
        fs55.writeFile(file, data, encoding, callback);
      });
    });
  }
  function outputFileSync(file, ...args) {
    const dir = path66.dirname(file);
    if (fs55.existsSync(dir)) {
      return fs55.writeFileSync(file, ...args);
    }
    mkdir.mkdirsSync(dir);
    fs55.writeFileSync(file, ...args);
  }
  module2.exports = {
    outputFile: u(outputFile),
    outputFileSync
  };
});

// node_modules/streamroller/node_modules/fs-extra/lib/index.js
var require_lib2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Object.assign({}, require_fs(), require_copy_sync2(), require_copy2(), require_empty(), require_ensure(), require_json(), require_mkdirs2(), require_move_sync2(), require_move2(), require_output(), require_path_exists(), require_remove());
  var fs55 = require("fs");
  if (Object.getOwnPropertyDescriptor(fs55, "promises")) {
    Object.defineProperty(module2.exports, "promises", {
      get() {
        return fs55.promises;
      }
    });
  }
});

// node_modules/streamroller/lib/now.js
var require_now = __commonJS((exports2, module2) => {
  module2.exports = () => new Date();
});

// node_modules/streamroller/node_modules/date-format/lib/index.js
var require_lib3 = __commonJS((exports2, module2) => {
  "use strict";
  function padWithZeros(vNumber, width) {
    var numAsString = vNumber.toString();
    while (numAsString.length < width) {
      numAsString = "0" + numAsString;
    }
    return numAsString;
  }
  function addZero(vNumber) {
    return padWithZeros(vNumber, 2);
  }
  function offset(timezoneOffset) {
    var os15 = Math.abs(timezoneOffset);
    var h = String(Math.floor(os15 / 60));
    var m = String(os15 % 60);
    if (h.length === 1) {
      h = "0" + h;
    }
    if (m.length === 1) {
      m = "0" + m;
    }
    return timezoneOffset < 0 ? "+" + h + m : "-" + h + m;
  }
  function datePart(date, displayUTC, part) {
    return displayUTC ? date["getUTC" + part]() : date["get" + part]();
  }
  function asString(format4, date) {
    if (typeof format4 !== "string") {
      date = format4;
      format4 = module2.exports.ISO8601_FORMAT;
    }
    if (!date) {
      date = module2.exports.now();
    }
    var displayUTC = format4.indexOf("O") > -1;
    var vDay = addZero(datePart(date, displayUTC, "Date"));
    var vMonth = addZero(datePart(date, displayUTC, "Month") + 1);
    var vYearLong = addZero(datePart(date, displayUTC, "FullYear"));
    var vYearShort = addZero(vYearLong.substring(2, 4));
    var vYear = format4.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
    var vHour = addZero(datePart(date, displayUTC, "Hours"));
    var vMinute = addZero(datePart(date, displayUTC, "Minutes"));
    var vSecond = addZero(datePart(date, displayUTC, "Seconds"));
    var vMillisecond = padWithZeros(datePart(date, displayUTC, "Milliseconds"), 3);
    var vTimeZone = offset(date.getTimezoneOffset());
    var formatted = format4.replace(/dd/g, vDay).replace(/MM/g, vMonth).replace(/y{1,4}/g, vYear).replace(/hh/g, vHour).replace(/mm/g, vMinute).replace(/ss/g, vSecond).replace(/SSS/g, vMillisecond).replace(/O/g, vTimeZone);
    return formatted;
  }
  function extractDateParts(pattern, str, missingValuesDate) {
    var matchers = [
      {
        pattern: /y{1,4}/,
        regexp: "\\d{1,4}",
        fn: function(date2, value) {
          date2.setFullYear(value);
        }
      },
      {
        pattern: /MM/,
        regexp: "\\d{1,2}",
        fn: function(date2, value) {
          date2.setMonth(value - 1);
        }
      },
      {
        pattern: /dd/,
        regexp: "\\d{1,2}",
        fn: function(date2, value) {
          date2.setDate(value);
        }
      },
      {
        pattern: /hh/,
        regexp: "\\d{1,2}",
        fn: function(date2, value) {
          date2.setHours(value);
        }
      },
      {
        pattern: /mm/,
        regexp: "\\d\\d",
        fn: function(date2, value) {
          date2.setMinutes(value);
        }
      },
      {
        pattern: /ss/,
        regexp: "\\d\\d",
        fn: function(date2, value) {
          date2.setSeconds(value);
        }
      },
      {
        pattern: /SSS/,
        regexp: "\\d\\d\\d",
        fn: function(date2, value) {
          date2.setMilliseconds(value);
        }
      },
      {
        pattern: /O/,
        regexp: "[+-]\\d{3,4}|Z",
        fn: function(date2, value) {
          if (value === "Z") {
            value = 0;
          }
          var offset2 = Math.abs(value);
          var minutes = offset2 % 100 + Math.floor(offset2 / 100) * 60;
          date2.setMinutes(date2.getMinutes() + (value > 0 ? minutes : -minutes));
        }
      }
    ];
    var parsedPattern = matchers.reduce(function(p, m) {
      if (m.pattern.test(p.regexp)) {
        m.index = p.regexp.match(m.pattern).index;
        p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
      } else {
        m.index = -1;
      }
      return p;
    }, {regexp: pattern, index: []});
    var dateFns = matchers.filter(function(m) {
      return m.index > -1;
    });
    dateFns.sort(function(a, b) {
      return a.index - b.index;
    });
    var matcher = new RegExp(parsedPattern.regexp);
    var matches = matcher.exec(str);
    if (matches) {
      var date = missingValuesDate || module2.exports.now();
      dateFns.forEach(function(f, i) {
        f.fn(date, matches[i + 1]);
      });
      return date;
    }
    throw new Error("String '" + str + "' could not be parsed as '" + pattern + "'");
  }
  function parse4(pattern, str, missingValuesDate) {
    if (!pattern) {
      throw new Error("pattern must be supplied");
    }
    return extractDateParts(pattern, str, missingValuesDate);
  }
  function now() {
    return new Date();
  }
  module2.exports = asString;
  module2.exports.asString = asString;
  module2.exports.parse = parse4;
  module2.exports.now = now;
  module2.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
  module2.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
  module2.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
  module2.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
});

// node_modules/streamroller/lib/fileNameFormatter.js
var require_fileNameFormatter = __commonJS((exports2, module2) => {
  var debug = require_src()("streamroller:fileNameFormatter");
  var path66 = require("path");
  var FILENAME_SEP = ".";
  var ZIP_EXT = ".gz";
  module2.exports = ({
    file,
    keepFileExt,
    needsIndex,
    alwaysIncludeDate,
    compress
  }) => {
    const dirAndName = path66.join(file.dir, file.name);
    const ext = (f) => f + file.ext;
    const index = (f, i, d) => (needsIndex || !d) && i ? f + FILENAME_SEP + i : f;
    const date = (f, i, d) => {
      return (i > 0 || alwaysIncludeDate) && d ? f + FILENAME_SEP + d : f;
    };
    const gzip = (f, i) => i && compress ? f + ZIP_EXT : f;
    const parts = keepFileExt ? [date, index, ext, gzip] : [ext, date, index, gzip];
    return ({date: date2, index: index2}) => {
      debug(`_formatFileName: date=${date2}, index=${index2}`);
      return parts.reduce((filename, part) => part(filename, index2, date2), dirAndName);
    };
  };
});

// node_modules/streamroller/lib/fileNameParser.js
var require_fileNameParser = __commonJS((exports2, module2) => {
  var debug = require_src()("streamroller:fileNameParser");
  var FILENAME_SEP = ".";
  var ZIP_EXT = ".gz";
  var format4 = require_lib3();
  module2.exports = ({file, keepFileExt, pattern}) => {
    const zip = (f, p) => {
      if (f.endsWith(ZIP_EXT)) {
        debug("it is gzipped");
        p.isCompressed = true;
        return f.slice(0, -1 * ZIP_EXT.length);
      }
      return f;
    };
    const __NOT_MATCHING__ = "__NOT_MATCHING__";
    const extAtEnd = (f) => {
      if (f.startsWith(file.name) && f.endsWith(file.ext)) {
        debug("it starts and ends with the right things");
        return f.slice(file.name.length + 1, -1 * file.ext.length);
      }
      return __NOT_MATCHING__;
    };
    const extInMiddle = (f) => {
      if (f.startsWith(file.base)) {
        debug("it starts with the right things");
        return f.slice(file.base.length + 1);
      }
      return __NOT_MATCHING__;
    };
    const dateAndIndex = (f, p) => {
      const items = f.split(FILENAME_SEP);
      let indexStr = items[items.length - 1];
      debug("items: ", items, ", indexStr: ", indexStr);
      let dateStr = f;
      if (indexStr !== void 0 && indexStr.match(/^\d+$/)) {
        dateStr = f.slice(0, -1 * (indexStr.length + 1));
        debug(`dateStr is ${dateStr}`);
        if (pattern && !dateStr) {
          dateStr = indexStr;
          indexStr = "0";
        }
      } else {
        indexStr = "0";
      }
      try {
        const date = format4.parse(pattern, dateStr, new Date(0, 0));
        if (format4.asString(pattern, date) !== dateStr)
          return f;
        p.index = parseInt(indexStr, 10);
        p.date = dateStr;
        p.timestamp = date.getTime();
        return "";
      } catch (e) {
        debug(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);
        return f;
      }
    };
    const index = (f, p) => {
      if (f.match(/^\d+$/)) {
        debug("it has an index");
        p.index = parseInt(f, 10);
        return "";
      }
      return f;
    };
    let parts = [
      zip,
      keepFileExt ? extAtEnd : extInMiddle,
      pattern ? dateAndIndex : index
    ];
    return (filename) => {
      let result = {filename, index: 0, isCompressed: false};
      let whatsLeftOver = parts.reduce((remains, part) => part(remains, result), filename);
      return whatsLeftOver ? null : result;
    };
  };
});

// node_modules/streamroller/lib/moveAndMaybeCompressFile.js
var require_moveAndMaybeCompressFile = __commonJS((exports2, module2) => {
  var debug = require_src()("streamroller:moveAndMaybeCompressFile");
  var fs55 = require_lib2();
  var zlib3 = require("zlib");
  var moveAndMaybeCompressFile = async (sourceFilePath, targetFilePath, needCompress) => {
    if (sourceFilePath === targetFilePath) {
      debug(`moveAndMaybeCompressFile: source and target are the same, not doing anything`);
      return;
    }
    if (await fs55.pathExists(sourceFilePath)) {
      debug(`moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${needCompress ? "with" : "without"} compress`);
      if (needCompress) {
        await new Promise((resolve3, reject) => {
          fs55.createReadStream(sourceFilePath).pipe(zlib3.createGzip()).pipe(fs55.createWriteStream(targetFilePath)).on("finish", () => {
            debug(`moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`);
            fs55.unlink(sourceFilePath).then(resolve3).catch(() => {
              debug(`Deleting ${sourceFilePath} failed, truncating instead`);
              fs55.truncate(sourceFilePath).then(resolve3).catch(reject);
            });
          });
        });
      } else {
        debug(`moveAndMaybeCompressFile: deleting file=${targetFilePath}, renaming ${sourceFilePath} to ${targetFilePath}`);
        try {
          await fs55.move(sourceFilePath, targetFilePath, {overwrite: true});
        } catch (e) {
          debug(`moveAndMaybeCompressFile: error moving ${sourceFilePath} to ${targetFilePath}`, e);
          debug(`Trying copy+truncate instead`);
          await fs55.copy(sourceFilePath, targetFilePath, {overwrite: true});
          await fs55.truncate(sourceFilePath);
        }
      }
    }
  };
  module2.exports = moveAndMaybeCompressFile;
});

// node_modules/streamroller/lib/RollingFileWriteStream.js
var require_RollingFileWriteStream = __commonJS((exports2, module2) => {
  var debug = require_src()("streamroller:RollingFileWriteStream");
  var fs55 = require_lib2();
  var path66 = require("path");
  var newNow = require_now();
  var format4 = require_lib3();
  var {Writable} = require("stream");
  var fileNameFormatter = require_fileNameFormatter();
  var fileNameParser = require_fileNameParser();
  var moveAndMaybeCompressFile = require_moveAndMaybeCompressFile();
  var RollingFileWriteStream = class extends Writable {
    constructor(filePath, options) {
      debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);
      super(options);
      this.options = this._parseOption(options);
      this.fileObject = path66.parse(filePath);
      if (this.fileObject.dir === "") {
        this.fileObject = path66.parse(path66.join(process.cwd(), filePath));
      }
      this.fileFormatter = fileNameFormatter({
        file: this.fileObject,
        alwaysIncludeDate: this.options.alwaysIncludePattern,
        needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,
        compress: this.options.compress,
        keepFileExt: this.options.keepFileExt
      });
      this.fileNameParser = fileNameParser({
        file: this.fileObject,
        keepFileExt: this.options.keepFileExt,
        pattern: this.options.pattern
      });
      this.state = {
        currentSize: 0
      };
      if (this.options.pattern) {
        this.state.currentDate = format4(this.options.pattern, newNow());
      }
      this.filename = this.fileFormatter({
        index: 0,
        date: this.state.currentDate
      });
      if (["a", "a+", "as", "as+"].includes(this.options.flags)) {
        this._setExistingSizeAndDate();
      }
      debug(`constructor: create new file ${this.filename}, state=${JSON.stringify(this.state)}`);
      this._renewWriteStream();
    }
    _setExistingSizeAndDate() {
      try {
        const stats = fs55.statSync(this.filename);
        this.state.currentSize = stats.size;
        if (this.options.pattern) {
          this.state.currentDate = format4(this.options.pattern, stats.mtime);
        }
      } catch (e) {
        return;
      }
    }
    _parseOption(rawOptions) {
      const defaultOptions2 = {
        maxSize: Number.MAX_SAFE_INTEGER,
        numToKeep: Number.MAX_SAFE_INTEGER,
        encoding: "utf8",
        mode: parseInt("0644", 8),
        flags: "a",
        compress: false,
        keepFileExt: false,
        alwaysIncludePattern: false
      };
      const options = Object.assign({}, defaultOptions2, rawOptions);
      if (options.maxSize <= 0) {
        throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);
      }
      if (options.numToKeep <= 0) {
        throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);
      }
      debug(`_parseOption: creating stream with option=${JSON.stringify(options)}`);
      return options;
    }
    _final(callback) {
      this.currentFileStream.end("", this.options.encoding, callback);
    }
    _write(chunk, encoding, callback) {
      this._shouldRoll().then(() => {
        debug(`_write: writing chunk. file=${this.currentFileStream.path} state=${JSON.stringify(this.state)} chunk=${chunk}`);
        this.currentFileStream.write(chunk, encoding, (e) => {
          this.state.currentSize += chunk.length;
          callback(e);
        });
      });
    }
    async _shouldRoll() {
      if (this._dateChanged() || this._tooBig()) {
        debug(`_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`);
        await this._roll();
      }
    }
    _dateChanged() {
      return this.state.currentDate && this.state.currentDate !== format4(this.options.pattern, newNow());
    }
    _tooBig() {
      return this.state.currentSize >= this.options.maxSize;
    }
    _roll() {
      debug(`_roll: closing the current stream`);
      return new Promise((resolve3, reject) => {
        this.currentFileStream.end("", this.options.encoding, () => {
          this._moveOldFiles().then(resolve3).catch(reject);
        });
      });
    }
    async _moveOldFiles() {
      const files = await this._getExistingFiles();
      const todaysFiles = this.state.currentDate ? files.filter((f) => f.date === this.state.currentDate) : files;
      for (let i = todaysFiles.length; i >= 0; i--) {
        debug(`_moveOldFiles: i = ${i}`);
        const sourceFilePath = this.fileFormatter({
          date: this.state.currentDate,
          index: i
        });
        const targetFilePath = this.fileFormatter({
          date: this.state.currentDate,
          index: i + 1
        });
        await moveAndMaybeCompressFile(sourceFilePath, targetFilePath, this.options.compress && i === 0);
      }
      this.state.currentSize = 0;
      this.state.currentDate = this.state.currentDate ? format4(this.options.pattern, newNow()) : null;
      debug(`_moveOldFiles: finished rolling files. state=${JSON.stringify(this.state)}`);
      this._renewWriteStream();
      await new Promise((resolve3, reject) => {
        this.currentFileStream.write("", "utf8", () => {
          this._clean().then(resolve3).catch(reject);
        });
      });
    }
    async _getExistingFiles() {
      const files = await fs55.readdir(this.fileObject.dir).catch(() => []);
      debug(`_getExistingFiles: files=${files}`);
      const existingFileDetails = files.map((n) => this.fileNameParser(n)).filter((n) => n);
      const getKey = (n) => (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;
      existingFileDetails.sort((a, b) => getKey(a) - getKey(b));
      return existingFileDetails;
    }
    _renewWriteStream() {
      fs55.ensureDirSync(this.fileObject.dir);
      const filePath = this.fileFormatter({
        date: this.state.currentDate,
        index: 0
      });
      const ops = {
        flags: this.options.flags,
        encoding: this.options.encoding,
        mode: this.options.mode
      };
      this.currentFileStream = fs55.createWriteStream(filePath, ops);
      this.currentFileStream.on("error", (e) => {
        this.emit("error", e);
      });
    }
    async _clean() {
      const existingFileDetails = await this._getExistingFiles();
      debug(`_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`);
      debug("_clean: existing files are: ", existingFileDetails);
      if (this._tooManyFiles(existingFileDetails.length)) {
        const fileNamesToRemove = existingFileDetails.slice(0, existingFileDetails.length - this.options.numToKeep - 1).map((f) => path66.format({dir: this.fileObject.dir, base: f.filename}));
        await deleteFiles(fileNamesToRemove);
      }
    }
    _tooManyFiles(numFiles) {
      return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;
    }
  };
  var deleteFiles = (fileNames) => {
    debug(`deleteFiles: files to delete: ${fileNames}`);
    return Promise.all(fileNames.map((f) => fs55.unlink(f).catch((e) => {
      debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);
    })));
  };
  module2.exports = RollingFileWriteStream;
});

// node_modules/streamroller/lib/RollingFileStream.js
var require_RollingFileStream = __commonJS((exports2, module2) => {
  var RollingFileWriteStream = require_RollingFileWriteStream();
  var RollingFileStream = class extends RollingFileWriteStream {
    constructor(filename, size, backups, options) {
      if (!options) {
        options = {};
      }
      if (size) {
        options.maxSize = size;
      }
      if (!backups) {
        backups = 1;
      }
      options.numToKeep = backups;
      super(filename, options);
      this.backups = this.options.numToKeep;
      this.size = this.options.maxSize;
    }
    get theStream() {
      return this.currentFileStream;
    }
  };
  module2.exports = RollingFileStream;
});

// node_modules/streamroller/lib/DateRollingFileStream.js
var require_DateRollingFileStream = __commonJS((exports2, module2) => {
  var RollingFileWriteStream = require_RollingFileWriteStream();
  var DateRollingFileStream = class extends RollingFileWriteStream {
    constructor(filename, pattern, options) {
      if (pattern && typeof pattern === "object") {
        options = pattern;
        pattern = null;
      }
      if (!options) {
        options = {};
      }
      if (!pattern) {
        pattern = "yyyy-MM-dd";
      }
      if (options.daysToKeep) {
        options.numToKeep = options.daysToKeep;
      }
      if (pattern.startsWith(".")) {
        pattern = pattern.substring(1);
      }
      options.pattern = pattern;
      super(filename, options);
      this.mode = this.options.mode;
    }
    get theStream() {
      return this.currentFileStream;
    }
  };
  module2.exports = DateRollingFileStream;
});

// node_modules/streamroller/lib/index.js
var require_lib4 = __commonJS((exports2, module2) => {
  module2.exports = {
    RollingFileWriteStream: require_RollingFileWriteStream(),
    RollingFileStream: require_RollingFileStream(),
    DateRollingFileStream: require_DateRollingFileStream()
  };
});

// node_modules/log4js/lib/appenders/file.js
var require_file2 = __commonJS((exports2, module2) => {
  var debug = require_src()("log4js:file");
  var path66 = require("path");
  var streams = require_lib4();
  var os15 = require("os");
  var eol = os15.EOL;
  function openTheStream(file, fileSize, numFiles, options) {
    const stream = new streams.RollingFileStream(file, fileSize, numFiles, options);
    stream.on("error", (err) => {
      console.error("log4js.fileAppender - Writing to file %s, error happened ", file, err);
    });
    stream.on("drain", () => {
      process.emit("log4js:pause", false);
    });
    return stream;
  }
  function fileAppender(file, layout, logSize, numBackups, options, timezoneOffset) {
    file = path66.normalize(file);
    numBackups = numBackups === void 0 ? 5 : numBackups;
    numBackups = numBackups === 0 ? 1 : numBackups;
    debug("Creating file appender (", file, ", ", logSize, ", ", numBackups, ", ", options, ", ", timezoneOffset, ")");
    let writer = openTheStream(file, logSize, numBackups, options);
    const app = function(loggingEvent) {
      if (options.removeColor === true) {
        const regex = /\x1b[[0-9;]*m/g;
        loggingEvent.data = loggingEvent.data.map((d) => {
          if (typeof d === "string")
            return d.replace(regex, "");
          return d;
        });
      }
      if (!writer.write(layout(loggingEvent, timezoneOffset) + eol, "utf8")) {
        process.emit("log4js:pause", true);
      }
    };
    app.reopen = function() {
      writer.end(() => {
        writer = openTheStream(file, logSize, numBackups, options);
      });
    };
    app.sighupHandler = function() {
      debug("SIGHUP handler called.");
      app.reopen();
    };
    app.shutdown = function(complete3) {
      process.removeListener("SIGHUP", app.sighupHandler);
      writer.end("", "utf-8", complete3);
    };
    process.on("SIGHUP", app.sighupHandler);
    return app;
  }
  function configure(config, layouts) {
    let layout = layouts.basicLayout;
    if (config.layout) {
      layout = layouts.layout(config.layout.type, config.layout);
    }
    return fileAppender(config.filename, layout, config.maxLogSize, config.backups, config, config.timezoneOffset);
  }
  module2.exports.configure = configure;
});

// node_modules/log4js/lib/appenders/dateFile.js
var require_dateFile = __commonJS((exports2, module2) => {
  var streams = require_lib4();
  var os15 = require("os");
  var eol = os15.EOL;
  function appender(filename, pattern, layout, options, timezoneOffset) {
    options.maxSize = options.maxLogSize;
    const logFile = new streams.DateRollingFileStream(filename, pattern, options);
    logFile.on("drain", () => {
      process.emit("log4js:pause", false);
    });
    const app = function(logEvent) {
      if (!logFile.write(layout(logEvent, timezoneOffset) + eol, "utf8")) {
        process.emit("log4js:pause", true);
      }
    };
    app.shutdown = function(complete3) {
      logFile.write("", "utf-8", () => {
        logFile.end(complete3);
      });
    };
    return app;
  }
  function configure(config, layouts) {
    let layout = layouts.basicLayout;
    if (config.layout) {
      layout = layouts.layout(config.layout.type, config.layout);
    }
    if (!config.alwaysIncludePattern) {
      config.alwaysIncludePattern = false;
    }
    return appender(config.filename, config.pattern, layout, config, config.timezoneOffset);
  }
  module2.exports.configure = configure;
});

// node_modules/log4js/lib/appenders/fileSync.js
var require_fileSync = __commonJS((exports2, module2) => {
  var debug = require_src()("log4js:fileSync");
  var path66 = require("path");
  var fs55 = require("fs");
  var os15 = require("os");
  var eol = os15.EOL || "\n";
  function touchFile(file, options) {
    if (fs55.existsSync(file)) {
      return;
    }
    const id = fs55.openSync(file, options.flags, options.mode);
    fs55.closeSync(id);
  }
  var RollingFileSync = class {
    constructor(filename, size, backups, options) {
      debug("In RollingFileStream");
      function throwErrorIfArgumentsAreNotValid() {
        if (!filename || !size || size <= 0) {
          throw new Error("You must specify a filename and file size");
        }
      }
      throwErrorIfArgumentsAreNotValid();
      this.filename = filename;
      this.size = size;
      this.backups = backups || 1;
      this.options = options;
      this.currentSize = 0;
      function currentFileSize(file) {
        let fileSize = 0;
        try {
          fileSize = fs55.statSync(file).size;
        } catch (e) {
          touchFile(file, options);
        }
        return fileSize;
      }
      this.currentSize = currentFileSize(this.filename);
    }
    shouldRoll() {
      debug("should roll with current size %d, and max size %d", this.currentSize, this.size);
      return this.currentSize >= this.size;
    }
    roll(filename) {
      const that = this;
      const nameMatcher = new RegExp(`^${path66.basename(filename)}`);
      function justTheseFiles(item) {
        return nameMatcher.test(item);
      }
      function index(filename_) {
        return parseInt(filename_.substring(`${path66.basename(filename)}.`.length), 10) || 0;
      }
      function byIndex(a, b) {
        if (index(a) > index(b)) {
          return 1;
        }
        if (index(a) < index(b)) {
          return -1;
        }
        return 0;
      }
      function increaseFileIndex(fileToRename) {
        const idx = index(fileToRename);
        debug(`Index of ${fileToRename} is ${idx}`);
        if (idx < that.backups) {
          try {
            fs55.unlinkSync(`${filename}.${idx + 1}`);
          } catch (e) {
          }
          debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);
          fs55.renameSync(path66.join(path66.dirname(filename), fileToRename), `${filename}.${idx + 1}`);
        }
      }
      function renameTheFiles() {
        debug("Renaming the old files");
        const files = fs55.readdirSync(path66.dirname(filename));
        files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);
      }
      debug("Rolling, rolling, rolling");
      renameTheFiles();
    }
    write(chunk, encoding) {
      const that = this;
      function writeTheChunk() {
        debug("writing the chunk to the file");
        that.currentSize += chunk.length;
        fs55.appendFileSync(that.filename, chunk);
      }
      debug("in write");
      if (this.shouldRoll()) {
        this.currentSize = 0;
        this.roll(this.filename);
      }
      writeTheChunk();
    }
  };
  function fileAppender(file, layout, logSize, numBackups, timezoneOffset, options) {
    debug("fileSync appender created");
    file = path66.normalize(file);
    numBackups = numBackups === void 0 ? 5 : numBackups;
    numBackups = numBackups === 0 ? 1 : numBackups;
    function openTheStream(filePath, fileSize, numFiles) {
      let stream;
      if (fileSize) {
        stream = new RollingFileSync(filePath, fileSize, numFiles, options);
      } else {
        stream = ((f) => {
          touchFile(f, options);
          return {
            write(data) {
              fs55.appendFileSync(f, data);
            }
          };
        })(filePath);
      }
      return stream;
    }
    const logFile = openTheStream(file, logSize, numBackups);
    return (loggingEvent) => {
      logFile.write(layout(loggingEvent, timezoneOffset) + eol);
    };
  }
  function configure(config, layouts) {
    let layout = layouts.basicLayout;
    if (config.layout) {
      layout = layouts.layout(config.layout.type, config.layout);
    }
    const options = {
      flags: config.flags || "a",
      encoding: config.encoding || "utf8",
      mode: config.mode || 420
    };
    return fileAppender(config.filename, layout, config.maxLogSize, config.backups, config.timezoneOffset, options);
  }
  module2.exports.configure = configure;
});

// node_modules/log4js/lib/appenders/index.js
var require_appenders = __commonJS((exports2, module2) => {
  var path66 = require("path");
  var debug = require_src()("log4js:appenders");
  var configuration7 = require_configuration();
  var clustering = require_clustering();
  var levels = require_levels();
  var layouts = require_layouts();
  var adapters = require_adapters();
  var coreAppenders = new Map();
  coreAppenders.set("console", require_console());
  coreAppenders.set("stdout", require_stdout());
  coreAppenders.set("stderr", require_stderr());
  coreAppenders.set("logLevelFilter", require_logLevelFilter());
  coreAppenders.set("categoryFilter", require_categoryFilter());
  coreAppenders.set("noLogFilter", require_noLogFilter());
  coreAppenders.set("file", require_file2());
  coreAppenders.set("dateFile", require_dateFile());
  coreAppenders.set("fileSync", require_fileSync());
  var appenders = new Map();
  var tryLoading = (modulePath, config) => {
    debug("Loading module from ", modulePath);
    try {
      return require(modulePath);
    } catch (e) {
      configuration7.throwExceptionIf(config, e.code !== "MODULE_NOT_FOUND", `appender "${modulePath}" could not be loaded (error was: ${e})`);
      return void 0;
    }
  };
  var loadAppenderModule = (type, config) => coreAppenders.get(type) || tryLoading(`./${type}`, config) || tryLoading(type, config) || require.main && tryLoading(path66.join(path66.dirname(require.main.filename), type), config) || tryLoading(path66.join(process.cwd(), type), config);
  var appendersLoading = new Set();
  var getAppender = (name2, config) => {
    if (appenders.has(name2))
      return appenders.get(name2);
    if (!config.appenders[name2])
      return false;
    if (appendersLoading.has(name2))
      throw new Error(`Dependency loop detected for appender ${name2}.`);
    appendersLoading.add(name2);
    debug(`Creating appender ${name2}`);
    const appender = createAppender(name2, config);
    appendersLoading.delete(name2);
    appenders.set(name2, appender);
    return appender;
  };
  var createAppender = (name2, config) => {
    const appenderConfig = config.appenders[name2];
    const appenderModule = appenderConfig.type.configure ? appenderConfig.type : loadAppenderModule(appenderConfig.type, config);
    configuration7.throwExceptionIf(config, configuration7.not(appenderModule), `appender "${name2}" is not valid (type "${appenderConfig.type}" could not be found)`);
    if (appenderModule.appender) {
      debug(`DEPRECATION: Appender ${appenderConfig.type} exports an appender function.`);
    }
    if (appenderModule.shutdown) {
      debug(`DEPRECATION: Appender ${appenderConfig.type} exports a shutdown function.`);
    }
    debug(`${name2}: clustering.isMaster ? ${clustering.isMaster()}`);
    debug(`${name2}: appenderModule is ${require("util").inspect(appenderModule)}`);
    return clustering.onlyOnMaster(() => {
      debug(`calling appenderModule.configure for ${name2} / ${appenderConfig.type}`);
      return appenderModule.configure(adapters.modifyConfig(appenderConfig), layouts, (appender) => getAppender(appender, config), levels);
    }, () => {
    });
  };
  var setup = (config) => {
    appenders.clear();
    appendersLoading.clear();
    const usedAppenders = [];
    Object.values(config.categories).forEach((category) => {
      usedAppenders.push(...category.appenders);
    });
    Object.keys(config.appenders).forEach((name2) => {
      if (usedAppenders.includes(name2) || config.appenders[name2].type === "tcp-server") {
        getAppender(name2, config);
      }
    });
  };
  setup({appenders: {out: {type: "stdout"}}, categories: {default: {appenders: ["out"], level: "trace"}}});
  configuration7.addListener((config) => {
    configuration7.throwExceptionIf(config, configuration7.not(configuration7.anObject(config.appenders)), 'must have a property "appenders" of type object.');
    const appenderNames = Object.keys(config.appenders);
    configuration7.throwExceptionIf(config, configuration7.not(appenderNames.length), "must define at least one appender.");
    appenderNames.forEach((name2) => {
      configuration7.throwExceptionIf(config, configuration7.not(config.appenders[name2].type), `appender "${name2}" is not valid (must be an object with property "type")`);
    });
  });
  configuration7.addListener(setup);
  module2.exports = appenders;
});

// node_modules/log4js/lib/categories.js
var require_categories = __commonJS((exports2, module2) => {
  var debug = require_src()("log4js:categories");
  var configuration7 = require_configuration();
  var levels = require_levels();
  var appenders = require_appenders();
  var categories = new Map();
  function inheritFromParent(config, category, categoryName) {
    if (category.inherit === false)
      return;
    const lastDotIndex = categoryName.lastIndexOf(".");
    if (lastDotIndex < 0)
      return;
    const parentCategoryName = categoryName.substring(0, lastDotIndex);
    let parentCategory = config.categories[parentCategoryName];
    if (!parentCategory) {
      parentCategory = {inherit: true, appenders: []};
    }
    inheritFromParent(config, parentCategory, parentCategoryName);
    if (!config.categories[parentCategoryName] && parentCategory.appenders && parentCategory.appenders.length && parentCategory.level) {
      config.categories[parentCategoryName] = parentCategory;
    }
    category.appenders = category.appenders || [];
    category.level = category.level || parentCategory.level;
    parentCategory.appenders.forEach((ap) => {
      if (!category.appenders.includes(ap)) {
        category.appenders.push(ap);
      }
    });
    category.parent = parentCategory;
  }
  function addCategoryInheritance(config) {
    if (!config.categories)
      return;
    const categoryNames = Object.keys(config.categories);
    categoryNames.forEach((name2) => {
      const category = config.categories[name2];
      inheritFromParent(config, category, name2);
    });
  }
  configuration7.addPreProcessingListener((config) => addCategoryInheritance(config));
  configuration7.addListener((config) => {
    configuration7.throwExceptionIf(config, configuration7.not(configuration7.anObject(config.categories)), 'must have a property "categories" of type object.');
    const categoryNames = Object.keys(config.categories);
    configuration7.throwExceptionIf(config, configuration7.not(categoryNames.length), "must define at least one category.");
    categoryNames.forEach((name2) => {
      const category = config.categories[name2];
      configuration7.throwExceptionIf(config, [
        configuration7.not(category.appenders),
        configuration7.not(category.level)
      ], `category "${name2}" is not valid (must be an object with properties "appenders" and "level")`);
      configuration7.throwExceptionIf(config, configuration7.not(Array.isArray(category.appenders)), `category "${name2}" is not valid (appenders must be an array of appender names)`);
      configuration7.throwExceptionIf(config, configuration7.not(category.appenders.length), `category "${name2}" is not valid (appenders must contain at least one appender name)`);
      if (Object.prototype.hasOwnProperty.call(category, "enableCallStack")) {
        configuration7.throwExceptionIf(config, typeof category.enableCallStack !== "boolean", `category "${name2}" is not valid (enableCallStack must be boolean type)`);
      }
      category.appenders.forEach((appender) => {
        configuration7.throwExceptionIf(config, configuration7.not(appenders.get(appender)), `category "${name2}" is not valid (appender "${appender}" is not defined)`);
      });
      configuration7.throwExceptionIf(config, configuration7.not(levels.getLevel(category.level)), `category "${name2}" is not valid (level "${category.level}" not recognised; valid levels are ${levels.levels.join(", ")})`);
    });
    configuration7.throwExceptionIf(config, configuration7.not(config.categories.default), 'must define a "default" category.');
  });
  var setup = (config) => {
    categories.clear();
    const categoryNames = Object.keys(config.categories);
    categoryNames.forEach((name2) => {
      const category = config.categories[name2];
      const categoryAppenders = [];
      category.appenders.forEach((appender) => {
        categoryAppenders.push(appenders.get(appender));
        debug(`Creating category ${name2}`);
        categories.set(name2, {
          appenders: categoryAppenders,
          level: levels.getLevel(category.level),
          enableCallStack: category.enableCallStack || false
        });
      });
    });
  };
  setup({categories: {default: {appenders: ["out"], level: "OFF"}}});
  configuration7.addListener(setup);
  var configForCategory = (category) => {
    debug(`configForCategory: searching for config for ${category}`);
    if (categories.has(category)) {
      debug(`configForCategory: ${category} exists in config, returning it`);
      return categories.get(category);
    }
    if (category.indexOf(".") > 0) {
      debug(`configForCategory: ${category} has hierarchy, searching for parents`);
      return configForCategory(category.substring(0, category.lastIndexOf(".")));
    }
    debug("configForCategory: returning config for default category");
    return configForCategory("default");
  };
  var appendersForCategory = (category) => configForCategory(category).appenders;
  var getLevelForCategory = (category) => configForCategory(category).level;
  var setLevelForCategory = (category, level) => {
    let categoryConfig = categories.get(category);
    debug(`setLevelForCategory: found ${categoryConfig} for ${category}`);
    if (!categoryConfig) {
      const sourceCategoryConfig = configForCategory(category);
      debug(`setLevelForCategory: no config found for category, found ${sourceCategoryConfig} for parents of ${category}`);
      categoryConfig = {appenders: sourceCategoryConfig.appenders};
    }
    categoryConfig.level = level;
    categories.set(category, categoryConfig);
  };
  var getEnableCallStackForCategory = (category) => configForCategory(category).enableCallStack === true;
  var setEnableCallStackForCategory = (category, useCallStack) => {
    configForCategory(category).enableCallStack = useCallStack;
  };
  module2.exports = {
    appendersForCategory,
    getLevelForCategory,
    setLevelForCategory,
    getEnableCallStackForCategory,
    setEnableCallStackForCategory
  };
});

// node_modules/log4js/lib/logger.js
var require_logger = __commonJS((exports2, module2) => {
  var debug = require_src()("log4js:logger");
  var LoggingEvent = require_LoggingEvent();
  var levels = require_levels();
  var clustering = require_clustering();
  var categories = require_categories();
  var configuration7 = require_configuration();
  var stackReg = /at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/;
  function defaultParseCallStack(data, skipIdx = 4) {
    const stacklines = data.stack.split("\n").slice(skipIdx);
    const lineMatch = stackReg.exec(stacklines[0]);
    if (lineMatch && lineMatch.length === 6) {
      return {
        functionName: lineMatch[1],
        fileName: lineMatch[2],
        lineNumber: parseInt(lineMatch[3], 10),
        columnNumber: parseInt(lineMatch[4], 10),
        callStack: stacklines.join("\n")
      };
    }
    return null;
  }
  var Logger2 = class {
    constructor(name2) {
      if (!name2) {
        throw new Error("No category provided.");
      }
      this.category = name2;
      this.context = {};
      this.parseCallStack = defaultParseCallStack;
      debug(`Logger created (${this.category}, ${this.level})`);
    }
    get level() {
      return levels.getLevel(categories.getLevelForCategory(this.category), levels.TRACE);
    }
    set level(level) {
      categories.setLevelForCategory(this.category, levels.getLevel(level, this.level));
    }
    get useCallStack() {
      return categories.getEnableCallStackForCategory(this.category);
    }
    set useCallStack(bool) {
      categories.setEnableCallStackForCategory(this.category, bool === true);
    }
    log(level, ...args) {
      const logLevel = levels.getLevel(level, levels.INFO);
      if (this.isLevelEnabled(logLevel)) {
        this._log(logLevel, args);
      }
    }
    isLevelEnabled(otherLevel) {
      return this.level.isLessThanOrEqualTo(otherLevel);
    }
    _log(level, data) {
      debug(`sending log data (${level}) to appenders`);
      const loggingEvent = new LoggingEvent(this.category, level, data, this.context, this.useCallStack && this.parseCallStack(new Error()));
      clustering.send(loggingEvent);
    }
    addContext(key, value) {
      this.context[key] = value;
    }
    removeContext(key) {
      delete this.context[key];
    }
    clearContext() {
      this.context = {};
    }
    setParseCallStackFunction(parseFunction) {
      this.parseCallStack = parseFunction;
    }
  };
  function addLevelMethods(target) {
    const level = levels.getLevel(target);
    const levelStrLower = level.toString().toLowerCase();
    const levelMethod = levelStrLower.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
    const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);
    Logger2.prototype[`is${isLevelMethod}Enabled`] = function() {
      return this.isLevelEnabled(level);
    };
    Logger2.prototype[levelMethod] = function(...args) {
      this.log(level, ...args);
    };
  }
  levels.levels.forEach(addLevelMethods);
  configuration7.addListener(() => {
    levels.levels.forEach(addLevelMethods);
  });
  module2.exports = Logger2;
});

// node_modules/log4js/lib/connect-logger.js
var require_connect_logger = __commonJS((exports2, module2) => {
  var levels = require_levels();
  var DEFAULT_FORMAT = ':remote-addr - - ":method :url HTTP/:http-version" :status :content-length ":referrer" ":user-agent"';
  function getUrl(req) {
    return req.originalUrl || req.url;
  }
  function assembleTokens(req, res, customTokens) {
    const arrayUniqueTokens = (array6) => {
      const a = array6.concat();
      for (let i = 0; i < a.length; ++i) {
        for (let j = i + 1; j < a.length; ++j) {
          if (a[i].token == a[j].token) {
            a.splice(j--, 1);
          }
        }
      }
      return a;
    };
    const defaultTokens = [];
    defaultTokens.push({token: ":url", replacement: getUrl(req)});
    defaultTokens.push({token: ":protocol", replacement: req.protocol});
    defaultTokens.push({token: ":hostname", replacement: req.hostname});
    defaultTokens.push({token: ":method", replacement: req.method});
    defaultTokens.push({
      token: ":status",
      replacement: res.__statusCode || res.statusCode
    });
    defaultTokens.push({
      token: ":response-time",
      replacement: res.responseTime
    });
    defaultTokens.push({token: ":date", replacement: new Date().toUTCString()});
    defaultTokens.push({
      token: ":referrer",
      replacement: req.headers.referer || req.headers.referrer || ""
    });
    defaultTokens.push({
      token: ":http-version",
      replacement: `${req.httpVersionMajor}.${req.httpVersionMinor}`
    });
    defaultTokens.push({
      token: ":remote-addr",
      replacement: req.headers["x-forwarded-for"] || req.ip || req._remoteAddress || req.socket && (req.socket.remoteAddress || req.socket.socket && req.socket.socket.remoteAddress)
    });
    defaultTokens.push({
      token: ":user-agent",
      replacement: req.headers["user-agent"]
    });
    defaultTokens.push({
      token: ":content-length",
      replacement: res.getHeader("content-length") || res.__headers && res.__headers["Content-Length"] || "-"
    });
    defaultTokens.push({
      token: /:req\[([^\]]+)]/g,
      replacement(_, field) {
        return req.headers[field.toLowerCase()];
      }
    });
    defaultTokens.push({
      token: /:res\[([^\]]+)]/g,
      replacement(_, field) {
        return res.getHeader(field.toLowerCase()) || res.__headers && res.__headers[field];
      }
    });
    return arrayUniqueTokens(customTokens.concat(defaultTokens));
  }
  function format4(str, tokens) {
    for (let i = 0; i < tokens.length; i++) {
      str = str.replace(tokens[i].token, tokens[i].replacement);
    }
    return str;
  }
  function createNoLogCondition(nolog) {
    let regexp = null;
    if (nolog instanceof RegExp) {
      regexp = nolog;
    }
    if (typeof nolog === "string") {
      regexp = new RegExp(nolog);
    }
    if (Array.isArray(nolog)) {
      const regexpsAsStrings = nolog.map((reg) => reg.source ? reg.source : reg);
      regexp = new RegExp(regexpsAsStrings.join("|"));
    }
    return regexp;
  }
  function matchRules(statusCode, currentLevel, ruleSet) {
    let level = currentLevel;
    if (ruleSet) {
      const matchedRule = ruleSet.find((rule) => {
        let ruleMatched = false;
        if (rule.from && rule.to) {
          ruleMatched = statusCode >= rule.from && statusCode <= rule.to;
        } else {
          ruleMatched = rule.codes.indexOf(statusCode) !== -1;
        }
        return ruleMatched;
      });
      if (matchedRule) {
        level = levels.getLevel(matchedRule.level, level);
      }
    }
    return level;
  }
  module2.exports = function getLogger(logger4js, options) {
    if (typeof options === "string" || typeof options === "function") {
      options = {format: options};
    } else {
      options = options || {};
    }
    const thisLogger = logger4js;
    let level = levels.getLevel(options.level, levels.INFO);
    const fmt = options.format || DEFAULT_FORMAT;
    const nolog = createNoLogCondition(options.nolog);
    return (req, res, next) => {
      if (req._logging)
        return next();
      if (nolog && nolog.test(req.originalUrl))
        return next();
      if (thisLogger.isLevelEnabled(level) || options.level === "auto") {
        const start = new Date();
        const {writeHead} = res;
        req._logging = true;
        res.writeHead = (code, headers) => {
          res.writeHead = writeHead;
          res.writeHead(code, headers);
          res.__statusCode = code;
          res.__headers = headers || {};
        };
        res.on("finish", () => {
          res.responseTime = new Date() - start;
          if (res.statusCode && options.level === "auto") {
            level = levels.INFO;
            if (res.statusCode >= 300)
              level = levels.WARN;
            if (res.statusCode >= 400)
              level = levels.ERROR;
          }
          level = matchRules(res.statusCode, level, options.statusRules);
          const combinedTokens = assembleTokens(req, res, options.tokens || []);
          if (options.context)
            thisLogger.addContext("res", res);
          if (typeof fmt === "function") {
            const line = fmt(req, res, (str) => format4(str, combinedTokens));
            if (line)
              thisLogger.log(level, line);
          } else {
            thisLogger.log(level, format4(fmt, combinedTokens));
          }
          if (options.context)
            thisLogger.removeContext("res");
        });
      }
      return next();
    };
  };
});

// node_modules/log4js/lib/log4js.js
var require_log4js = __commonJS((exports2, module2) => {
  var debug = require_src()("log4js:main");
  var fs55 = require("fs");
  var deepClone2 = require_rfdc()({proto: true});
  var configuration7 = require_configuration();
  var layouts = require_layouts();
  var levels = require_levels();
  var appenders = require_appenders();
  var categories = require_categories();
  var Logger2 = require_logger();
  var clustering = require_clustering();
  var connectLogger = require_connect_logger();
  var enabled = false;
  function sendLogEventToAppender(logEvent) {
    if (!enabled)
      return;
    debug("Received log event ", logEvent);
    const categoryAppenders = categories.appendersForCategory(logEvent.categoryName);
    categoryAppenders.forEach((appender) => {
      appender(logEvent);
    });
  }
  function loadConfigurationFile(filename) {
    debug(`Loading configuration from ${filename}`);
    try {
      return JSON.parse(fs55.readFileSync(filename, "utf8"));
    } catch (e) {
      throw new Error(`Problem reading config from file "${filename}". Error was ${e.message}`, e);
    }
  }
  function configure(configurationFileOrObject) {
    let configObject = configurationFileOrObject;
    if (typeof configObject === "string") {
      configObject = loadConfigurationFile(configurationFileOrObject);
    }
    debug(`Configuration is ${configObject}`);
    configuration7.configure(deepClone2(configObject));
    clustering.onMessage(sendLogEventToAppender);
    enabled = true;
    return log4js;
  }
  function shutdown(cb) {
    debug("Shutdown called. Disabling all log writing.");
    enabled = false;
    const appendersToCheck = Array.from(appenders.values());
    const shutdownFunctions = appendersToCheck.reduceRight((accum, next) => next.shutdown ? accum + 1 : accum, 0);
    let completed = 0;
    let error;
    debug(`Found ${shutdownFunctions} appenders with shutdown functions.`);
    function complete3(err) {
      error = error || err;
      completed += 1;
      debug(`Appender shutdowns complete: ${completed} / ${shutdownFunctions}`);
      if (completed >= shutdownFunctions) {
        debug("All shutdown functions completed.");
        if (cb) {
          cb(error);
        }
      }
    }
    if (shutdownFunctions === 0) {
      debug("No appenders with shutdown functions found.");
      return cb !== void 0 && cb();
    }
    appendersToCheck.filter((a) => a.shutdown).forEach((a) => a.shutdown(complete3));
    return null;
  }
  function getLogger(category) {
    if (!enabled) {
      configure(process.env.LOG4JS_CONFIG || {
        appenders: {out: {type: "stdout"}},
        categories: {default: {appenders: ["out"], level: "OFF"}}
      });
    }
    return new Logger2(category || "default");
  }
  var log4js = {
    getLogger,
    configure,
    shutdown,
    connectLogger,
    levels,
    addLayout: layouts.addLayout
  };
  module2.exports = log4js;
});

// src/util/logger.ts
var require_logger2 = __commonJS((exports2, module2) => {
  var fs56 = __toModule(require("fs"));
  var log4js2 = __toModule(require_log4js());
  var path67 = __toModule(require("path"));
  var os16 = __toModule(require("os"));
  function getLogFile() {
    let file = process.env.NVIM_COC_LOG_FILE;
    if (file)
      return file;
    let dir = process.env.XDG_RUNTIME_DIR;
    if (dir) {
      try {
        fs56.default.accessSync(dir, fs56.default.constants.R_OK | fs56.default.constants.W_OK);
        return path67.default.join(dir, `coc-nvim-${process.pid}.log`);
      } catch (err) {
      }
    }
    dir = path67.default.join(process.env.TMPDIR, `coc.nvim-${process.pid}`);
    if (os16.default.platform() == "win32") {
      dir = path67.default.win32.normalize(dir);
    }
    if (!fs56.default.existsSync(dir))
      fs56.default.mkdirSync(dir, {recursive: true});
    return path67.default.join(dir, `coc-nvim.log`);
  }
  var MAX_LOG_SIZE = 1024 * 1024;
  var MAX_LOG_BACKUPS = 10;
  var logfile = getLogFile();
  var level = process.env.NVIM_COC_LOG_LEVEL || "info";
  if (fs56.default.existsSync(logfile)) {
    try {
      fs56.default.writeFileSync(logfile, "", {encoding: "utf8", mode: 438});
    } catch (e) {
    }
  }
  log4js2.default.configure({
    disableClustering: true,
    appenders: {
      out: {
        type: "file",
        mode: 438,
        filename: logfile,
        maxLogSize: MAX_LOG_SIZE,
        backups: MAX_LOG_BACKUPS,
        layout: {
          type: "pattern",
          pattern: `%d{ISO8601} %p (pid:${process.pid}) [%c] - %m`
        }
      }
    },
    categories: {
      default: {appenders: ["out"], level}
    }
  });
  module2.exports = (name2 = "coc-nvim") => {
    let logger93 = log4js2.default.getLogger(name2);
    logger93.getLogFile = () => logfile;
    return logger93;
  };
});

// node_modules/msgpack-lite/lib/buffer-global.js
var require_buffer_global = __commonJS((exports2, module2) => {
  module2.exports = c(typeof Buffer !== "undefined" && Buffer) || c(exports2.Buffer) || c(typeof window !== "undefined" && window.Buffer) || exports2.Buffer;
  function c(B) {
    return B && B.isBuffer && B;
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS((exports2, module2) => {
  var toString = {}.toString;
  module2.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// node_modules/msgpack-lite/lib/bufferish-array.js
var require_bufferish_array = __commonJS((exports2, module2) => {
  var Bufferish = require_bufferish();
  var exports2 = module2.exports = alloc(0);
  exports2.alloc = alloc;
  exports2.concat = Bufferish.concat;
  exports2.from = from;
  function alloc(size) {
    return new Array(size);
  }
  function from(value) {
    if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
      value = Bufferish.Uint8Array.from(value);
    } else if (Bufferish.isArrayBuffer(value)) {
      value = new Uint8Array(value);
    } else if (typeof value === "string") {
      return Bufferish.from.call(exports2, value);
    } else if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    return Array.prototype.slice.call(value);
  }
});

// node_modules/msgpack-lite/lib/bufferish-buffer.js
var require_bufferish_buffer = __commonJS((exports2, module2) => {
  var Bufferish = require_bufferish();
  var Buffer2 = Bufferish.global;
  var exports2 = module2.exports = Bufferish.hasBuffer ? alloc(0) : [];
  exports2.alloc = Bufferish.hasBuffer && Buffer2.alloc || alloc;
  exports2.concat = Bufferish.concat;
  exports2.from = from;
  function alloc(size) {
    return new Buffer2(size);
  }
  function from(value) {
    if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
      value = Bufferish.Uint8Array.from(value);
    } else if (Bufferish.isArrayBuffer(value)) {
      value = new Uint8Array(value);
    } else if (typeof value === "string") {
      return Bufferish.from.call(exports2, value);
    } else if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (Buffer2.from && Buffer2.from.length !== 1) {
      return Buffer2.from(value);
    } else {
      return new Buffer2(value);
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-uint8array.js
var require_bufferish_uint8array = __commonJS((exports2, module2) => {
  var Bufferish = require_bufferish();
  var exports2 = module2.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];
  exports2.alloc = alloc;
  exports2.concat = Bufferish.concat;
  exports2.from = from;
  function alloc(size) {
    return new Uint8Array(size);
  }
  function from(value) {
    if (Bufferish.isView(value)) {
      var byteOffset = value.byteOffset;
      var byteLength2 = value.byteLength;
      value = value.buffer;
      if (value.byteLength !== byteLength2) {
        if (value.slice) {
          value = value.slice(byteOffset, byteOffset + byteLength2);
        } else {
          value = new Uint8Array(value);
          if (value.byteLength !== byteLength2) {
            value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength2);
          }
        }
      }
    } else if (typeof value === "string") {
      return Bufferish.from.call(exports2, value);
    } else if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    return new Uint8Array(value);
  }
});

// node_modules/msgpack-lite/lib/buffer-lite.js
var require_buffer_lite = __commonJS((exports2) => {
  exports2.copy = copy;
  exports2.toString = toString;
  exports2.write = write;
  function write(string23, offset) {
    var buffer4 = this;
    var index = offset || (offset |= 0);
    var length = string23.length;
    var chr = 0;
    var i = 0;
    while (i < length) {
      chr = string23.charCodeAt(i++);
      if (chr < 128) {
        buffer4[index++] = chr;
      } else if (chr < 2048) {
        buffer4[index++] = 192 | chr >>> 6;
        buffer4[index++] = 128 | chr & 63;
      } else if (chr < 55296 || chr > 57343) {
        buffer4[index++] = 224 | chr >>> 12;
        buffer4[index++] = 128 | chr >>> 6 & 63;
        buffer4[index++] = 128 | chr & 63;
      } else {
        chr = (chr - 55296 << 10 | string23.charCodeAt(i++) - 56320) + 65536;
        buffer4[index++] = 240 | chr >>> 18;
        buffer4[index++] = 128 | chr >>> 12 & 63;
        buffer4[index++] = 128 | chr >>> 6 & 63;
        buffer4[index++] = 128 | chr & 63;
      }
    }
    return index - offset;
  }
  function toString(encoding, start, end) {
    var buffer4 = this;
    var index = start | 0;
    if (!end)
      end = buffer4.length;
    var string23 = "";
    var chr = 0;
    while (index < end) {
      chr = buffer4[index++];
      if (chr < 128) {
        string23 += String.fromCharCode(chr);
        continue;
      }
      if ((chr & 224) === 192) {
        chr = (chr & 31) << 6 | buffer4[index++] & 63;
      } else if ((chr & 240) === 224) {
        chr = (chr & 15) << 12 | (buffer4[index++] & 63) << 6 | buffer4[index++] & 63;
      } else if ((chr & 248) === 240) {
        chr = (chr & 7) << 18 | (buffer4[index++] & 63) << 12 | (buffer4[index++] & 63) << 6 | buffer4[index++] & 63;
      }
      if (chr >= 65536) {
        chr -= 65536;
        string23 += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
      } else {
        string23 += String.fromCharCode(chr);
      }
    }
    return string23;
  }
  function copy(target, targetStart, start, end) {
    var i;
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (!targetStart)
      targetStart = 0;
    var len = end - start;
    if (target === this && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    }
    return len;
  }
});

// node_modules/msgpack-lite/lib/bufferish-proto.js
var require_bufferish_proto = __commonJS((exports2) => {
  var BufferLite = require_buffer_lite();
  exports2.copy = copy;
  exports2.slice = slice;
  exports2.toString = toString;
  exports2.write = gen("write");
  var Bufferish = require_bufferish();
  var Buffer2 = Bufferish.global;
  var isBufferShim = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer2;
  var brokenTypedArray = isBufferShim && !Buffer2.TYPED_ARRAY_SUPPORT;
  function copy(target, targetStart, start, end) {
    var thisIsBuffer = Bufferish.isBuffer(this);
    var targetIsBuffer = Bufferish.isBuffer(target);
    if (thisIsBuffer && targetIsBuffer) {
      return this.copy(target, targetStart, start, end);
    } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish.isView(this) && Bufferish.isView(target)) {
      var buffer4 = start || end != null ? slice.call(this, start, end) : this;
      target.set(buffer4, targetStart);
      return buffer4.length;
    } else {
      return BufferLite.copy.call(this, target, targetStart, start, end);
    }
  }
  function slice(start, end) {
    var f = this.slice || !brokenTypedArray && this.subarray;
    if (f)
      return f.call(this, start, end);
    var target = Bufferish.alloc.call(this, end - start);
    copy.call(this, target, 0, start, end);
    return target;
  }
  function toString(encoding, start, end) {
    var f = !isBufferShim && Bufferish.isBuffer(this) ? this.toString : BufferLite.toString;
    return f.apply(this, arguments);
  }
  function gen(method) {
    return wrap;
    function wrap() {
      var f = this[method] || BufferLite[method];
      return f.apply(this, arguments);
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish.js
var require_bufferish = __commonJS((exports2) => {
  var Buffer2 = exports2.global = require_buffer_global();
  var hasBuffer = exports2.hasBuffer = Buffer2 && !!Buffer2.isBuffer;
  var hasArrayBuffer = exports2.hasArrayBuffer = typeof ArrayBuffer !== "undefined";
  var isArray = exports2.isArray = require_isarray();
  exports2.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
  var isBuffer = exports2.isBuffer = hasBuffer ? Buffer2.isBuffer : _false;
  var isView = exports2.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
  exports2.alloc = alloc;
  exports2.concat = concat;
  exports2.from = from;
  var BufferArray = exports2.Array = require_bufferish_array();
  var BufferBuffer = exports2.Buffer = require_bufferish_buffer();
  var BufferUint8Array = exports2.Uint8Array = require_bufferish_uint8array();
  var BufferProto = exports2.prototype = require_bufferish_proto();
  function from(value) {
    if (typeof value === "string") {
      return fromString.call(this, value);
    } else {
      return auto(this).from(value);
    }
  }
  function alloc(size) {
    return auto(this).alloc(size);
  }
  function concat(list2, length) {
    if (!length) {
      length = 0;
      Array.prototype.forEach.call(list2, dryrun);
    }
    var ref = this !== exports2 && this || list2[0];
    var result = alloc.call(ref, length);
    var offset = 0;
    Array.prototype.forEach.call(list2, append);
    return result;
    function dryrun(buffer4) {
      length += buffer4.length;
    }
    function append(buffer4) {
      offset += BufferProto.copy.call(buffer4, result, offset);
    }
  }
  var _isArrayBuffer = _is("ArrayBuffer");
  function isArrayBuffer(value) {
    return value instanceof ArrayBuffer || _isArrayBuffer(value);
  }
  function fromString(value) {
    var expected = value.length * 3;
    var that = alloc.call(this, expected);
    var actual = BufferProto.write.call(that, value);
    if (expected !== actual) {
      that = BufferProto.slice.call(that, 0, actual);
    }
    return that;
  }
  function auto(that) {
    return isBuffer(that) ? BufferBuffer : isView(that) ? BufferUint8Array : isArray(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
  }
  function _false() {
    return false;
  }
  function _is(name2, key) {
    name2 = "[object " + name2 + "]";
    return function(value) {
      return value != null && {}.toString.call(key ? value[key] : value) === name2;
    };
  }
});

// node_modules/msgpack-lite/lib/ext-buffer.js
var require_ext_buffer = __commonJS((exports2) => {
  exports2.ExtBuffer = ExtBuffer;
  var Bufferish = require_bufferish();
  function ExtBuffer(buffer4, type) {
    if (!(this instanceof ExtBuffer))
      return new ExtBuffer(buffer4, type);
    this.buffer = Bufferish.from(buffer4);
    this.type = type;
  }
});

// node_modules/msgpack-lite/lib/ext-packer.js
var require_ext_packer = __commonJS((exports2) => {
  exports2.setExtPackers = setExtPackers;
  var Bufferish = require_bufferish();
  var Buffer2 = Bufferish.global;
  var packTypedArray = Bufferish.Uint8Array.from;
  var _encode;
  var ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};
  function setExtPackers(codec) {
    codec.addExtPacker(14, Error, [packError, encode]);
    codec.addExtPacker(1, EvalError, [packError, encode]);
    codec.addExtPacker(2, RangeError, [packError, encode]);
    codec.addExtPacker(3, ReferenceError, [packError, encode]);
    codec.addExtPacker(4, SyntaxError, [packError, encode]);
    codec.addExtPacker(5, TypeError, [packError, encode]);
    codec.addExtPacker(6, URIError, [packError, encode]);
    codec.addExtPacker(10, RegExp, [packRegExp, encode]);
    codec.addExtPacker(11, Boolean, [packValueOf, encode]);
    codec.addExtPacker(12, String, [packValueOf, encode]);
    codec.addExtPacker(13, Date, [Number, encode]);
    codec.addExtPacker(15, Number, [packValueOf, encode]);
    if (typeof Uint8Array !== "undefined") {
      codec.addExtPacker(17, Int8Array, packTypedArray);
      codec.addExtPacker(18, Uint8Array, packTypedArray);
      codec.addExtPacker(19, Int16Array, packTypedArray);
      codec.addExtPacker(20, Uint16Array, packTypedArray);
      codec.addExtPacker(21, Int32Array, packTypedArray);
      codec.addExtPacker(22, Uint32Array, packTypedArray);
      codec.addExtPacker(23, Float32Array, packTypedArray);
      if (typeof Float64Array !== "undefined") {
        codec.addExtPacker(24, Float64Array, packTypedArray);
      }
      if (typeof Uint8ClampedArray !== "undefined") {
        codec.addExtPacker(25, Uint8ClampedArray, packTypedArray);
      }
      codec.addExtPacker(26, ArrayBuffer, packTypedArray);
      codec.addExtPacker(29, DataView, packTypedArray);
    }
    if (Bufferish.hasBuffer) {
      codec.addExtPacker(27, Buffer2, Bufferish.from);
    }
  }
  function encode(input) {
    if (!_encode)
      _encode = require_encode().encode;
    return _encode(input);
  }
  function packValueOf(value) {
    return value.valueOf();
  }
  function packRegExp(value) {
    value = RegExp.prototype.toString.call(value).split("/");
    value.shift();
    var out = [value.pop()];
    out.unshift(value.join("/"));
    return out;
  }
  function packError(value) {
    var out = {};
    for (var key in ERROR_COLUMNS) {
      out[key] = value[key];
    }
    return out;
  }
});

// node_modules/int64-buffer/int64-buffer.js
var require_int64_buffer = __commonJS((exports2) => {
  var Uint64BE;
  var Int64BE;
  var Uint64LE;
  var Int64LE;
  !function(exports3) {
    var UNDEFINED = "undefined";
    var BUFFER = UNDEFINED !== typeof Buffer && Buffer;
    var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
    var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
    var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
    var isArray = Array.isArray || _isArray;
    var BIT32 = 4294967296;
    var BIT24 = 16777216;
    var storage;
    Uint64BE = factory2("Uint64BE", true, true);
    Int64BE = factory2("Int64BE", true, false);
    Uint64LE = factory2("Uint64LE", false, true);
    Int64LE = factory2("Int64LE", false, false);
    function factory2(name2, bigendian, unsigned) {
      var posH = bigendian ? 0 : 4;
      var posL = bigendian ? 4 : 0;
      var pos0 = bigendian ? 0 : 3;
      var pos1 = bigendian ? 1 : 2;
      var pos2 = bigendian ? 2 : 1;
      var pos3 = bigendian ? 3 : 0;
      var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
      var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
      var proto = Int64.prototype;
      var isName = "is" + name2;
      var _isInt64 = "_" + isName;
      proto.buffer = void 0;
      proto.offset = 0;
      proto[_isInt64] = true;
      proto.toNumber = toNumber;
      proto.toString = toString;
      proto.toJSON = toNumber;
      proto.toArray = toArray;
      if (BUFFER)
        proto.toBuffer = toBuffer;
      if (UINT8ARRAY)
        proto.toArrayBuffer = toArrayBuffer;
      Int64[isName] = isInt64;
      exports3[name2] = Int64;
      return Int64;
      function Int64(buffer4, offset, value, raddix) {
        if (!(this instanceof Int64))
          return new Int64(buffer4, offset, value, raddix);
        return init(this, buffer4, offset, value, raddix);
      }
      function isInt64(b) {
        return !!(b && b[_isInt64]);
      }
      function init(that, buffer4, offset, value, raddix) {
        if (UINT8ARRAY && ARRAYBUFFER) {
          if (buffer4 instanceof ARRAYBUFFER)
            buffer4 = new UINT8ARRAY(buffer4);
          if (value instanceof ARRAYBUFFER)
            value = new UINT8ARRAY(value);
        }
        if (!buffer4 && !offset && !value && !storage) {
          that.buffer = newArray(ZERO, 0);
          return;
        }
        if (!isValidBuffer(buffer4, offset)) {
          var _storage = storage || Array;
          raddix = offset;
          value = buffer4;
          offset = 0;
          buffer4 = new _storage(8);
        }
        that.buffer = buffer4;
        that.offset = offset |= 0;
        if (UNDEFINED === typeof value)
          return;
        if (typeof value === "string") {
          fromString(buffer4, offset, value, raddix || 10);
        } else if (isValidBuffer(value, raddix)) {
          fromArray(buffer4, offset, value, raddix);
        } else if (typeof raddix === "number") {
          writeInt32(buffer4, offset + posH, value);
          writeInt32(buffer4, offset + posL, raddix);
        } else if (value > 0) {
          fromPositive(buffer4, offset, value);
        } else if (value < 0) {
          fromNegative(buffer4, offset, value);
        } else {
          fromArray(buffer4, offset, ZERO, 0);
        }
      }
      function fromString(buffer4, offset, str, raddix) {
        var pos = 0;
        var len = str.length;
        var high = 0;
        var low = 0;
        if (str[0] === "-")
          pos++;
        var sign = pos;
        while (pos < len) {
          var chr = parseInt(str[pos++], raddix);
          if (!(chr >= 0))
            break;
          low = low * raddix + chr;
          high = high * raddix + Math.floor(low / BIT32);
          low %= BIT32;
        }
        if (sign) {
          high = ~high;
          if (low) {
            low = BIT32 - low;
          } else {
            high++;
          }
        }
        writeInt32(buffer4, offset + posH, high);
        writeInt32(buffer4, offset + posL, low);
      }
      function toNumber() {
        var buffer4 = this.buffer;
        var offset = this.offset;
        var high = readInt32(buffer4, offset + posH);
        var low = readInt32(buffer4, offset + posL);
        if (!unsigned)
          high |= 0;
        return high ? high * BIT32 + low : low;
      }
      function toString(radix) {
        var buffer4 = this.buffer;
        var offset = this.offset;
        var high = readInt32(buffer4, offset + posH);
        var low = readInt32(buffer4, offset + posL);
        var str = "";
        var sign = !unsigned && high & 2147483648;
        if (sign) {
          high = ~high;
          low = BIT32 - low;
        }
        radix = radix || 10;
        while (1) {
          var mod = high % radix * BIT32 + low;
          high = Math.floor(high / radix);
          low = Math.floor(mod / radix);
          str = (mod % radix).toString(radix) + str;
          if (!high && !low)
            break;
        }
        if (sign) {
          str = "-" + str;
        }
        return str;
      }
      function writeInt32(buffer4, offset, value) {
        buffer4[offset + pos3] = value & 255;
        value = value >> 8;
        buffer4[offset + pos2] = value & 255;
        value = value >> 8;
        buffer4[offset + pos1] = value & 255;
        value = value >> 8;
        buffer4[offset + pos0] = value & 255;
      }
      function readInt32(buffer4, offset) {
        return buffer4[offset + pos0] * BIT24 + (buffer4[offset + pos1] << 16) + (buffer4[offset + pos2] << 8) + buffer4[offset + pos3];
      }
    }
    function toArray(raw) {
      var buffer4 = this.buffer;
      var offset = this.offset;
      storage = null;
      if (raw !== false && offset === 0 && buffer4.length === 8 && isArray(buffer4))
        return buffer4;
      return newArray(buffer4, offset);
    }
    function toBuffer(raw) {
      var buffer4 = this.buffer;
      var offset = this.offset;
      storage = BUFFER;
      if (raw !== false && offset === 0 && buffer4.length === 8 && Buffer.isBuffer(buffer4))
        return buffer4;
      var dest = new BUFFER(8);
      fromArray(dest, 0, buffer4, offset);
      return dest;
    }
    function toArrayBuffer(raw) {
      var buffer4 = this.buffer;
      var offset = this.offset;
      var arrbuf = buffer4.buffer;
      storage = UINT8ARRAY;
      if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
        return arrbuf;
      var dest = new UINT8ARRAY(8);
      fromArray(dest, 0, buffer4, offset);
      return dest.buffer;
    }
    function isValidBuffer(buffer4, offset) {
      var len = buffer4 && buffer4.length;
      offset |= 0;
      return len && offset + 8 <= len && typeof buffer4[offset] !== "string";
    }
    function fromArray(destbuf, destoff, srcbuf, srcoff) {
      destoff |= 0;
      srcoff |= 0;
      for (var i = 0; i < 8; i++) {
        destbuf[destoff++] = srcbuf[srcoff++] & 255;
      }
    }
    function newArray(buffer4, offset) {
      return Array.prototype.slice.call(buffer4, offset, offset + 8);
    }
    function fromPositiveBE(buffer4, offset, value) {
      var pos = offset + 8;
      while (pos > offset) {
        buffer4[--pos] = value & 255;
        value /= 256;
      }
    }
    function fromNegativeBE(buffer4, offset, value) {
      var pos = offset + 8;
      value++;
      while (pos > offset) {
        buffer4[--pos] = -value & 255 ^ 255;
        value /= 256;
      }
    }
    function fromPositiveLE(buffer4, offset, value) {
      var end = offset + 8;
      while (offset < end) {
        buffer4[offset++] = value & 255;
        value /= 256;
      }
    }
    function fromNegativeLE(buffer4, offset, value) {
      var end = offset + 8;
      value++;
      while (offset < end) {
        buffer4[offset++] = -value & 255 ^ 255;
        value /= 256;
      }
    }
    function _isArray(val) {
      return !!val && Object.prototype.toString.call(val) == "[object Array]";
    }
  }(typeof exports2 === "object" && typeof exports2.nodeName !== "string" ? exports2 : exports2 || {});
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS((exports2) => {
  exports2.read = function(buffer4, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer4[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer4[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer4[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports2.write = function(buffer4, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer4[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer4[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer4[offset + i - d] |= s * 128;
  };
});

// node_modules/msgpack-lite/lib/write-uint8.js
var require_write_uint8 = __commonJS((exports2) => {
  var constant = exports2.uint8 = new Array(256);
  for (var i = 0; i <= 255; i++) {
    constant[i] = write0(i);
  }
  function write0(type) {
    return function(encoder) {
      var offset = encoder.reserve(1);
      encoder.buffer[offset] = type;
    };
  }
});

// node_modules/msgpack-lite/lib/write-token.js
var require_write_token = __commonJS((exports2) => {
  var ieee754 = require_ieee754();
  var Int64Buffer = require_int64_buffer();
  var Uint64BE = Int64Buffer.Uint64BE;
  var Int64BE = Int64Buffer.Int64BE;
  var uint8 = require_write_uint8().uint8;
  var Bufferish = require_bufferish();
  var Buffer2 = Bufferish.global;
  var IS_BUFFER_SHIM = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer2;
  var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer2.TYPED_ARRAY_SUPPORT;
  var Buffer_prototype = Bufferish.hasBuffer && Buffer2.prototype || {};
  exports2.getWriteToken = getWriteToken;
  function getWriteToken(options) {
    if (options && options.uint8array) {
      return init_uint8array();
    } else if (NO_TYPED_ARRAY || Bufferish.hasBuffer && options && options.safe) {
      return init_safe();
    } else {
      return init_token();
    }
  }
  function init_uint8array() {
    var token = init_token();
    token[202] = writeN(202, 4, writeFloatBE);
    token[203] = writeN(203, 8, writeDoubleBE);
    return token;
  }
  function init_token() {
    var token = uint8.slice();
    token[196] = write1(196);
    token[197] = write2(197);
    token[198] = write4(198);
    token[199] = write1(199);
    token[200] = write2(200);
    token[201] = write4(201);
    token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE, true);
    token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE, true);
    token[204] = write1(204);
    token[205] = write2(205);
    token[206] = write4(206);
    token[207] = writeN(207, 8, writeUInt64BE);
    token[208] = write1(208);
    token[209] = write2(209);
    token[210] = write4(210);
    token[211] = writeN(211, 8, writeInt64BE);
    token[217] = write1(217);
    token[218] = write2(218);
    token[219] = write4(219);
    token[220] = write2(220);
    token[221] = write4(221);
    token[222] = write2(222);
    token[223] = write4(223);
    return token;
  }
  function init_safe() {
    var token = uint8.slice();
    token[196] = writeN(196, 1, Buffer2.prototype.writeUInt8);
    token[197] = writeN(197, 2, Buffer2.prototype.writeUInt16BE);
    token[198] = writeN(198, 4, Buffer2.prototype.writeUInt32BE);
    token[199] = writeN(199, 1, Buffer2.prototype.writeUInt8);
    token[200] = writeN(200, 2, Buffer2.prototype.writeUInt16BE);
    token[201] = writeN(201, 4, Buffer2.prototype.writeUInt32BE);
    token[202] = writeN(202, 4, Buffer2.prototype.writeFloatBE);
    token[203] = writeN(203, 8, Buffer2.prototype.writeDoubleBE);
    token[204] = writeN(204, 1, Buffer2.prototype.writeUInt8);
    token[205] = writeN(205, 2, Buffer2.prototype.writeUInt16BE);
    token[206] = writeN(206, 4, Buffer2.prototype.writeUInt32BE);
    token[207] = writeN(207, 8, writeUInt64BE);
    token[208] = writeN(208, 1, Buffer2.prototype.writeInt8);
    token[209] = writeN(209, 2, Buffer2.prototype.writeInt16BE);
    token[210] = writeN(210, 4, Buffer2.prototype.writeInt32BE);
    token[211] = writeN(211, 8, writeInt64BE);
    token[217] = writeN(217, 1, Buffer2.prototype.writeUInt8);
    token[218] = writeN(218, 2, Buffer2.prototype.writeUInt16BE);
    token[219] = writeN(219, 4, Buffer2.prototype.writeUInt32BE);
    token[220] = writeN(220, 2, Buffer2.prototype.writeUInt16BE);
    token[221] = writeN(221, 4, Buffer2.prototype.writeUInt32BE);
    token[222] = writeN(222, 2, Buffer2.prototype.writeUInt16BE);
    token[223] = writeN(223, 4, Buffer2.prototype.writeUInt32BE);
    return token;
  }
  function write1(type) {
    return function(encoder, value) {
      var offset = encoder.reserve(2);
      var buffer4 = encoder.buffer;
      buffer4[offset++] = type;
      buffer4[offset] = value;
    };
  }
  function write2(type) {
    return function(encoder, value) {
      var offset = encoder.reserve(3);
      var buffer4 = encoder.buffer;
      buffer4[offset++] = type;
      buffer4[offset++] = value >>> 8;
      buffer4[offset] = value;
    };
  }
  function write4(type) {
    return function(encoder, value) {
      var offset = encoder.reserve(5);
      var buffer4 = encoder.buffer;
      buffer4[offset++] = type;
      buffer4[offset++] = value >>> 24;
      buffer4[offset++] = value >>> 16;
      buffer4[offset++] = value >>> 8;
      buffer4[offset] = value;
    };
  }
  function writeN(type, len, method, noAssert) {
    return function(encoder, value) {
      var offset = encoder.reserve(len + 1);
      encoder.buffer[offset++] = type;
      method.call(encoder.buffer, value, offset, noAssert);
    };
  }
  function writeUInt64BE(value, offset) {
    new Uint64BE(this, offset, value);
  }
  function writeInt64BE(value, offset) {
    new Int64BE(this, offset, value);
  }
  function writeFloatBE(value, offset) {
    ieee754.write(this, value, offset, false, 23, 4);
  }
  function writeDoubleBE(value, offset) {
    ieee754.write(this, value, offset, false, 52, 8);
  }
});

// node_modules/msgpack-lite/lib/write-type.js
var require_write_type = __commonJS((exports2) => {
  var IS_ARRAY = require_isarray();
  var Int64Buffer = require_int64_buffer();
  var Uint64BE = Int64Buffer.Uint64BE;
  var Int64BE = Int64Buffer.Int64BE;
  var Bufferish = require_bufferish();
  var BufferProto = require_bufferish_proto();
  var WriteToken = require_write_token();
  var uint8 = require_write_uint8().uint8;
  var ExtBuffer = require_ext_buffer().ExtBuffer;
  var HAS_UINT8ARRAY = typeof Uint8Array !== "undefined";
  var HAS_MAP = typeof Map !== "undefined";
  var extmap = [];
  extmap[1] = 212;
  extmap[2] = 213;
  extmap[4] = 214;
  extmap[8] = 215;
  extmap[16] = 216;
  exports2.getWriteType = getWriteType;
  function getWriteType(options) {
    var token = WriteToken.getWriteToken(options);
    var useraw = options && options.useraw;
    var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
    var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
    var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
    var usemap = HAS_MAP && options && options.usemap;
    var map = usemap ? map_to_map : obj_to_map;
    var writeType = {
      boolean: bool,
      function: nil,
      number: number2,
      object: useraw ? object_raw : object15,
      string: _string(useraw ? raw_head_size : str_head_size),
      symbol: nil,
      undefined: nil
    };
    return writeType;
    function bool(encoder, value) {
      var type = value ? 195 : 194;
      token[type](encoder, value);
    }
    function number2(encoder, value) {
      var ivalue = value | 0;
      var type;
      if (value !== ivalue) {
        type = 203;
        token[type](encoder, value);
        return;
      } else if (-32 <= ivalue && ivalue <= 127) {
        type = ivalue & 255;
      } else if (0 <= ivalue) {
        type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
      } else {
        type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
      }
      token[type](encoder, ivalue);
    }
    function uint64(encoder, value) {
      var type = 207;
      token[type](encoder, value.toArray());
    }
    function int64(encoder, value) {
      var type = 211;
      token[type](encoder, value.toArray());
    }
    function str_head_size(length) {
      return length < 32 ? 1 : length <= 255 ? 2 : length <= 65535 ? 3 : 5;
    }
    function raw_head_size(length) {
      return length < 32 ? 1 : length <= 65535 ? 3 : 5;
    }
    function _string(head_size) {
      return string23;
      function string23(encoder, value) {
        var length = value.length;
        var maxsize = 5 + length * 3;
        encoder.offset = encoder.reserve(maxsize);
        var buffer4 = encoder.buffer;
        var expected = head_size(length);
        var start = encoder.offset + expected;
        length = BufferProto.write.call(buffer4, value, start);
        var actual = head_size(length);
        if (expected !== actual) {
          var targetStart = start + actual - expected;
          var end = start + length;
          BufferProto.copy.call(buffer4, buffer4, targetStart, start, end);
        }
        var type = actual === 1 ? 160 + length : actual <= 3 ? 215 + actual : 219;
        token[type](encoder, length);
        encoder.offset += length;
      }
    }
    function object15(encoder, value) {
      if (value === null)
        return nil(encoder, value);
      if (isBuffer(value))
        return bin(encoder, value);
      if (IS_ARRAY(value))
        return array6(encoder, value);
      if (Uint64BE.isUint64BE(value))
        return uint64(encoder, value);
      if (Int64BE.isInt64BE(value))
        return int64(encoder, value);
      var packer = encoder.codec.getExtPacker(value);
      if (packer)
        value = packer(value);
      if (value instanceof ExtBuffer)
        return ext(encoder, value);
      map(encoder, value);
    }
    function object_raw(encoder, value) {
      if (isBuffer(value))
        return raw(encoder, value);
      object15(encoder, value);
    }
    function nil(encoder, value) {
      var type = 192;
      token[type](encoder, value);
    }
    function array6(encoder, value) {
      var length = value.length;
      var type = length < 16 ? 144 + length : length <= 65535 ? 220 : 221;
      token[type](encoder, length);
      var encode = encoder.codec.encode;
      for (var i = 0; i < length; i++) {
        encode(encoder, value[i]);
      }
    }
    function bin_buffer(encoder, value) {
      var length = value.length;
      var type = length < 255 ? 196 : length <= 65535 ? 197 : 198;
      token[type](encoder, length);
      encoder.send(value);
    }
    function bin_arraybuffer(encoder, value) {
      bin_buffer(encoder, new Uint8Array(value));
    }
    function ext(encoder, value) {
      var buffer4 = value.buffer;
      var length = buffer4.length;
      var type = extmap[length] || (length < 255 ? 199 : length <= 65535 ? 200 : 201);
      token[type](encoder, length);
      uint8[value.type](encoder);
      encoder.send(buffer4);
    }
    function obj_to_map(encoder, value) {
      var keys = Object.keys(value);
      var length = keys.length;
      var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
      token[type](encoder, length);
      var encode = encoder.codec.encode;
      keys.forEach(function(key) {
        encode(encoder, key);
        encode(encoder, value[key]);
      });
    }
    function map_to_map(encoder, value) {
      if (!(value instanceof Map))
        return obj_to_map(encoder, value);
      var length = value.size;
      var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
      token[type](encoder, length);
      var encode = encoder.codec.encode;
      value.forEach(function(val, key, m) {
        encode(encoder, key);
        encode(encoder, val);
      });
    }
    function raw(encoder, value) {
      var length = value.length;
      var type = length < 32 ? 160 + length : length <= 65535 ? 218 : 219;
      token[type](encoder, length);
      encoder.send(value);
    }
  }
});

// node_modules/msgpack-lite/lib/codec-base.js
var require_codec_base = __commonJS((exports2) => {
  var IS_ARRAY = require_isarray();
  exports2.createCodec = createCodec;
  exports2.install = install;
  exports2.filter = filter;
  var Bufferish = require_bufferish();
  function Codec(options) {
    if (!(this instanceof Codec))
      return new Codec(options);
    this.options = options;
    this.init();
  }
  Codec.prototype.init = function() {
    var options = this.options;
    if (options && options.uint8array) {
      this.bufferish = Bufferish.Uint8Array;
    }
    return this;
  };
  function install(props) {
    for (var key in props) {
      Codec.prototype[key] = add(Codec.prototype[key], props[key]);
    }
  }
  function add(a, b) {
    return a && b ? ab : a || b;
    function ab() {
      a.apply(this, arguments);
      return b.apply(this, arguments);
    }
  }
  function join2(filters) {
    filters = filters.slice();
    return function(value) {
      return filters.reduce(iterator, value);
    };
    function iterator(value, filter2) {
      return filter2(value);
    }
  }
  function filter(filter2) {
    return IS_ARRAY(filter2) ? join2(filter2) : filter2;
  }
  function createCodec(options) {
    return new Codec(options);
  }
  exports2.preset = createCodec({preset: true});
});

// node_modules/msgpack-lite/lib/write-core.js
var require_write_core = __commonJS((exports2) => {
  var ExtBuffer = require_ext_buffer().ExtBuffer;
  var ExtPacker = require_ext_packer();
  var WriteType = require_write_type();
  var CodecBase = require_codec_base();
  CodecBase.install({
    addExtPacker,
    getExtPacker,
    init
  });
  exports2.preset = init.call(CodecBase.preset);
  function getEncoder(options) {
    var writeType = WriteType.getWriteType(options);
    return encode;
    function encode(encoder, value) {
      var func2 = writeType[typeof value];
      if (!func2)
        throw new Error('Unsupported type "' + typeof value + '": ' + value);
      func2(encoder, value);
    }
  }
  function init() {
    var options = this.options;
    this.encode = getEncoder(options);
    if (options && options.preset) {
      ExtPacker.setExtPackers(this);
    }
    return this;
  }
  function addExtPacker(etype, Class, packer) {
    packer = CodecBase.filter(packer);
    var name2 = Class.name;
    if (name2 && name2 !== "Object") {
      var packers = this.extPackers || (this.extPackers = {});
      packers[name2] = extPacker;
    } else {
      var list2 = this.extEncoderList || (this.extEncoderList = []);
      list2.unshift([Class, extPacker]);
    }
    function extPacker(value) {
      if (packer)
        value = packer(value);
      return new ExtBuffer(value, etype);
    }
  }
  function getExtPacker(value) {
    var packers = this.extPackers || (this.extPackers = {});
    var c = value.constructor;
    var e = c && c.name && packers[c.name];
    if (e)
      return e;
    var list2 = this.extEncoderList || (this.extEncoderList = []);
    var len = list2.length;
    for (var i = 0; i < len; i++) {
      var pair = list2[i];
      if (c === pair[0])
        return pair[1];
    }
  }
});

// node_modules/msgpack-lite/lib/flex-buffer.js
var require_flex_buffer = __commonJS((exports2) => {
  exports2.FlexDecoder = FlexDecoder;
  exports2.FlexEncoder = FlexEncoder;
  var Bufferish = require_bufferish();
  var MIN_BUFFER_SIZE = 2048;
  var MAX_BUFFER_SIZE = 65536;
  var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
  function FlexDecoder() {
    if (!(this instanceof FlexDecoder))
      return new FlexDecoder();
  }
  function FlexEncoder() {
    if (!(this instanceof FlexEncoder))
      return new FlexEncoder();
  }
  FlexDecoder.mixin = mixinFactory(getDecoderMethods());
  FlexDecoder.mixin(FlexDecoder.prototype);
  FlexEncoder.mixin = mixinFactory(getEncoderMethods());
  FlexEncoder.mixin(FlexEncoder.prototype);
  function getDecoderMethods() {
    return {
      bufferish: Bufferish,
      write: write2,
      fetch: fetch4,
      flush,
      push,
      pull,
      read,
      reserve,
      offset: 0
    };
    function write2(chunk) {
      var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
      this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
      this.offset = 0;
    }
    function flush() {
      while (this.offset < this.buffer.length) {
        var start = this.offset;
        var value;
        try {
          value = this.fetch();
        } catch (e) {
          if (e && e.message != BUFFER_SHORTAGE)
            throw e;
          this.offset = start;
          break;
        }
        this.push(value);
      }
    }
    function reserve(length) {
      var start = this.offset;
      var end = start + length;
      if (end > this.buffer.length)
        throw new Error(BUFFER_SHORTAGE);
      this.offset = end;
      return start;
    }
  }
  function getEncoderMethods() {
    return {
      bufferish: Bufferish,
      write,
      fetch: fetch5,
      flush,
      push,
      pull: pull2,
      read,
      reserve,
      send,
      maxBufferSize: MAX_BUFFER_SIZE,
      minBufferSize: MIN_BUFFER_SIZE,
      offset: 0,
      start: 0
    };
    function fetch5() {
      var start = this.start;
      if (start < this.offset) {
        var end = this.start = this.offset;
        return Bufferish.prototype.slice.call(this.buffer, start, end);
      }
    }
    function flush() {
      while (this.start < this.offset) {
        var value = this.fetch();
        if (value)
          this.push(value);
      }
    }
    function pull2() {
      var buffers = this.buffers || (this.buffers = []);
      var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
      buffers.length = 0;
      return chunk;
    }
    function reserve(length) {
      var req = length | 0;
      if (this.buffer) {
        var size = this.buffer.length;
        var start = this.offset | 0;
        var end = start + req;
        if (end < size) {
          this.offset = end;
          return start;
        }
        this.flush();
        length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
      }
      length = Math.max(length, this.minBufferSize);
      this.buffer = this.bufferish.alloc(length);
      this.start = 0;
      this.offset = req;
      return 0;
    }
    function send(buffer4) {
      var length = buffer4.length;
      if (length > this.minBufferSize) {
        this.flush();
        this.push(buffer4);
      } else {
        var offset = this.reserve(length);
        Bufferish.prototype.copy.call(buffer4, this.buffer, offset);
      }
    }
  }
  function write() {
    throw new Error("method not implemented: write()");
  }
  function fetch4() {
    throw new Error("method not implemented: fetch()");
  }
  function read() {
    var length = this.buffers && this.buffers.length;
    if (!length)
      return this.fetch();
    this.flush();
    return this.pull();
  }
  function push(chunk) {
    var buffers = this.buffers || (this.buffers = []);
    buffers.push(chunk);
  }
  function pull() {
    var buffers = this.buffers || (this.buffers = []);
    return buffers.shift();
  }
  function mixinFactory(source3) {
    return mixin2;
    function mixin2(target) {
      for (var key in source3) {
        target[key] = source3[key];
      }
      return target;
    }
  }
});

// node_modules/msgpack-lite/lib/encode-buffer.js
var require_encode_buffer = __commonJS((exports2) => {
  exports2.EncodeBuffer = EncodeBuffer;
  var preset = require_write_core().preset;
  var FlexEncoder = require_flex_buffer().FlexEncoder;
  FlexEncoder.mixin(EncodeBuffer.prototype);
  function EncodeBuffer(options) {
    if (!(this instanceof EncodeBuffer))
      return new EncodeBuffer(options);
    if (options) {
      this.options = options;
      if (options.codec) {
        var codec = this.codec = options.codec;
        if (codec.bufferish)
          this.bufferish = codec.bufferish;
      }
    }
  }
  EncodeBuffer.prototype.codec = preset;
  EncodeBuffer.prototype.write = function(input) {
    this.codec.encode(this, input);
  };
});

// node_modules/msgpack-lite/lib/encode.js
var require_encode = __commonJS((exports2) => {
  exports2.encode = encode;
  var EncodeBuffer = require_encode_buffer().EncodeBuffer;
  function encode(input, options) {
    var encoder = new EncodeBuffer(options);
    encoder.write(input);
    return encoder.read();
  }
});

// node_modules/msgpack-lite/lib/ext-unpacker.js
var require_ext_unpacker = __commonJS((exports2) => {
  exports2.setExtUnpackers = setExtUnpackers;
  var Bufferish = require_bufferish();
  var Buffer2 = Bufferish.global;
  var _decode;
  var ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};
  function setExtUnpackers(codec) {
    codec.addExtUnpacker(14, [decode, unpackError(Error)]);
    codec.addExtUnpacker(1, [decode, unpackError(EvalError)]);
    codec.addExtUnpacker(2, [decode, unpackError(RangeError)]);
    codec.addExtUnpacker(3, [decode, unpackError(ReferenceError)]);
    codec.addExtUnpacker(4, [decode, unpackError(SyntaxError)]);
    codec.addExtUnpacker(5, [decode, unpackError(TypeError)]);
    codec.addExtUnpacker(6, [decode, unpackError(URIError)]);
    codec.addExtUnpacker(10, [decode, unpackRegExp]);
    codec.addExtUnpacker(11, [decode, unpackClass(Boolean)]);
    codec.addExtUnpacker(12, [decode, unpackClass(String)]);
    codec.addExtUnpacker(13, [decode, unpackClass(Date)]);
    codec.addExtUnpacker(15, [decode, unpackClass(Number)]);
    if (typeof Uint8Array !== "undefined") {
      codec.addExtUnpacker(17, unpackClass(Int8Array));
      codec.addExtUnpacker(18, unpackClass(Uint8Array));
      codec.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
      codec.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
      codec.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
      codec.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
      codec.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
      if (typeof Float64Array !== "undefined") {
        codec.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
      }
      if (typeof Uint8ClampedArray !== "undefined") {
        codec.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
      }
      codec.addExtUnpacker(26, unpackArrayBuffer);
      codec.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
    }
    if (Bufferish.hasBuffer) {
      codec.addExtUnpacker(27, unpackClass(Buffer2));
    }
  }
  function decode(input) {
    if (!_decode)
      _decode = require_decode().decode;
    return _decode(input);
  }
  function unpackRegExp(value) {
    return RegExp.apply(null, value);
  }
  function unpackError(Class) {
    return function(value) {
      var out = new Class();
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    };
  }
  function unpackClass(Class) {
    return function(value) {
      return new Class(value);
    };
  }
  function unpackArrayBuffer(value) {
    return new Uint8Array(value).buffer;
  }
});

// node_modules/msgpack-lite/lib/read-format.js
var require_read_format = __commonJS((exports2) => {
  var ieee754 = require_ieee754();
  var Int64Buffer = require_int64_buffer();
  var Uint64BE = Int64Buffer.Uint64BE;
  var Int64BE = Int64Buffer.Int64BE;
  exports2.getReadFormat = getReadFormat;
  exports2.readUint8 = uint8;
  var Bufferish = require_bufferish();
  var BufferProto = require_bufferish_proto();
  var HAS_MAP = typeof Map !== "undefined";
  var NO_ASSERT = true;
  function getReadFormat(options) {
    var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
    var int64 = options && options.int64;
    var usemap = HAS_MAP && options && options.usemap;
    var readFormat = {
      map: usemap ? map_to_map : map_to_obj,
      array: array6,
      str,
      bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
      ext,
      uint8,
      uint16,
      uint32,
      uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
      int8,
      int16,
      int32,
      int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
      float32: read(4, readFloatBE),
      float64: read(8, readDoubleBE)
    };
    return readFormat;
  }
  function map_to_obj(decoder, len) {
    var value = {};
    var i;
    var k = new Array(len);
    var v = new Array(len);
    var decode = decoder.codec.decode;
    for (i = 0; i < len; i++) {
      k[i] = decode(decoder);
      v[i] = decode(decoder);
    }
    for (i = 0; i < len; i++) {
      value[k[i]] = v[i];
    }
    return value;
  }
  function map_to_map(decoder, len) {
    var value = new Map();
    var i;
    var k = new Array(len);
    var v = new Array(len);
    var decode = decoder.codec.decode;
    for (i = 0; i < len; i++) {
      k[i] = decode(decoder);
      v[i] = decode(decoder);
    }
    for (i = 0; i < len; i++) {
      value.set(k[i], v[i]);
    }
    return value;
  }
  function array6(decoder, len) {
    var value = new Array(len);
    var decode = decoder.codec.decode;
    for (var i = 0; i < len; i++) {
      value[i] = decode(decoder);
    }
    return value;
  }
  function str(decoder, len) {
    var start = decoder.reserve(len);
    var end = start + len;
    return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
  }
  function bin_buffer(decoder, len) {
    var start = decoder.reserve(len);
    var end = start + len;
    var buf = BufferProto.slice.call(decoder.buffer, start, end);
    return Bufferish.from(buf);
  }
  function bin_arraybuffer(decoder, len) {
    var start = decoder.reserve(len);
    var end = start + len;
    var buf = BufferProto.slice.call(decoder.buffer, start, end);
    return Bufferish.Uint8Array.from(buf).buffer;
  }
  function ext(decoder, len) {
    var start = decoder.reserve(len + 1);
    var type = decoder.buffer[start++];
    var end = start + len;
    var unpack = decoder.codec.getExtUnpacker(type);
    if (!unpack)
      throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
    var buf = BufferProto.slice.call(decoder.buffer, start, end);
    return unpack(buf);
  }
  function uint8(decoder) {
    var start = decoder.reserve(1);
    return decoder.buffer[start];
  }
  function int8(decoder) {
    var start = decoder.reserve(1);
    var value = decoder.buffer[start];
    return value & 128 ? value - 256 : value;
  }
  function uint16(decoder) {
    var start = decoder.reserve(2);
    var buffer4 = decoder.buffer;
    return buffer4[start++] << 8 | buffer4[start];
  }
  function int16(decoder) {
    var start = decoder.reserve(2);
    var buffer4 = decoder.buffer;
    var value = buffer4[start++] << 8 | buffer4[start];
    return value & 32768 ? value - 65536 : value;
  }
  function uint32(decoder) {
    var start = decoder.reserve(4);
    var buffer4 = decoder.buffer;
    return buffer4[start++] * 16777216 + (buffer4[start++] << 16) + (buffer4[start++] << 8) + buffer4[start];
  }
  function int32(decoder) {
    var start = decoder.reserve(4);
    var buffer4 = decoder.buffer;
    return buffer4[start++] << 24 | buffer4[start++] << 16 | buffer4[start++] << 8 | buffer4[start];
  }
  function read(len, method) {
    return function(decoder) {
      var start = decoder.reserve(len);
      return method.call(decoder.buffer, start, NO_ASSERT);
    };
  }
  function readUInt64BE(start) {
    return new Uint64BE(this, start).toNumber();
  }
  function readInt64BE(start) {
    return new Int64BE(this, start).toNumber();
  }
  function readUInt64BE_int64(start) {
    return new Uint64BE(this, start);
  }
  function readInt64BE_int64(start) {
    return new Int64BE(this, start);
  }
  function readFloatBE(start) {
    return ieee754.read(this, start, false, 23, 4);
  }
  function readDoubleBE(start) {
    return ieee754.read(this, start, false, 52, 8);
  }
});

// node_modules/msgpack-lite/lib/read-token.js
var require_read_token = __commonJS((exports2) => {
  var ReadFormat = require_read_format();
  exports2.getReadToken = getReadToken;
  function getReadToken(options) {
    var format4 = ReadFormat.getReadFormat(options);
    if (options && options.useraw) {
      return init_useraw(format4);
    } else {
      return init_token(format4);
    }
  }
  function init_token(format4) {
    var i;
    var token = new Array(256);
    for (i = 0; i <= 127; i++) {
      token[i] = constant(i);
    }
    for (i = 128; i <= 143; i++) {
      token[i] = fix(i - 128, format4.map);
    }
    for (i = 144; i <= 159; i++) {
      token[i] = fix(i - 144, format4.array);
    }
    for (i = 160; i <= 191; i++) {
      token[i] = fix(i - 160, format4.str);
    }
    token[192] = constant(null);
    token[193] = null;
    token[194] = constant(false);
    token[195] = constant(true);
    token[196] = flex(format4.uint8, format4.bin);
    token[197] = flex(format4.uint16, format4.bin);
    token[198] = flex(format4.uint32, format4.bin);
    token[199] = flex(format4.uint8, format4.ext);
    token[200] = flex(format4.uint16, format4.ext);
    token[201] = flex(format4.uint32, format4.ext);
    token[202] = format4.float32;
    token[203] = format4.float64;
    token[204] = format4.uint8;
    token[205] = format4.uint16;
    token[206] = format4.uint32;
    token[207] = format4.uint64;
    token[208] = format4.int8;
    token[209] = format4.int16;
    token[210] = format4.int32;
    token[211] = format4.int64;
    token[212] = fix(1, format4.ext);
    token[213] = fix(2, format4.ext);
    token[214] = fix(4, format4.ext);
    token[215] = fix(8, format4.ext);
    token[216] = fix(16, format4.ext);
    token[217] = flex(format4.uint8, format4.str);
    token[218] = flex(format4.uint16, format4.str);
    token[219] = flex(format4.uint32, format4.str);
    token[220] = flex(format4.uint16, format4.array);
    token[221] = flex(format4.uint32, format4.array);
    token[222] = flex(format4.uint16, format4.map);
    token[223] = flex(format4.uint32, format4.map);
    for (i = 224; i <= 255; i++) {
      token[i] = constant(i - 256);
    }
    return token;
  }
  function init_useraw(format4) {
    var i;
    var token = init_token(format4).slice();
    token[217] = token[196];
    token[218] = token[197];
    token[219] = token[198];
    for (i = 160; i <= 191; i++) {
      token[i] = fix(i - 160, format4.bin);
    }
    return token;
  }
  function constant(value) {
    return function() {
      return value;
    };
  }
  function flex(lenFunc, decodeFunc) {
    return function(decoder) {
      var len = lenFunc(decoder);
      return decodeFunc(decoder, len);
    };
  }
  function fix(len, method) {
    return function(decoder) {
      return method(decoder, len);
    };
  }
});

// node_modules/msgpack-lite/lib/read-core.js
var require_read_core = __commonJS((exports2) => {
  var ExtBuffer = require_ext_buffer().ExtBuffer;
  var ExtUnpacker = require_ext_unpacker();
  var readUint8 = require_read_format().readUint8;
  var ReadToken = require_read_token();
  var CodecBase = require_codec_base();
  CodecBase.install({
    addExtUnpacker,
    getExtUnpacker,
    init
  });
  exports2.preset = init.call(CodecBase.preset);
  function getDecoder(options) {
    var readToken = ReadToken.getReadToken(options);
    return decode;
    function decode(decoder) {
      var type = readUint8(decoder);
      var func2 = readToken[type];
      if (!func2)
        throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
      return func2(decoder);
    }
  }
  function init() {
    var options = this.options;
    this.decode = getDecoder(options);
    if (options && options.preset) {
      ExtUnpacker.setExtUnpackers(this);
    }
    return this;
  }
  function addExtUnpacker(etype, unpacker) {
    var unpackers = this.extUnpackers || (this.extUnpackers = []);
    unpackers[etype] = CodecBase.filter(unpacker);
  }
  function getExtUnpacker(type) {
    var unpackers = this.extUnpackers || (this.extUnpackers = []);
    return unpackers[type] || extUnpacker;
    function extUnpacker(buffer4) {
      return new ExtBuffer(buffer4, type);
    }
  }
});

// node_modules/msgpack-lite/lib/decode-buffer.js
var require_decode_buffer = __commonJS((exports2) => {
  exports2.DecodeBuffer = DecodeBuffer;
  var preset = require_read_core().preset;
  var FlexDecoder = require_flex_buffer().FlexDecoder;
  FlexDecoder.mixin(DecodeBuffer.prototype);
  function DecodeBuffer(options) {
    if (!(this instanceof DecodeBuffer))
      return new DecodeBuffer(options);
    if (options) {
      this.options = options;
      if (options.codec) {
        var codec = this.codec = options.codec;
        if (codec.bufferish)
          this.bufferish = codec.bufferish;
      }
    }
  }
  DecodeBuffer.prototype.codec = preset;
  DecodeBuffer.prototype.fetch = function() {
    return this.codec.decode(this);
  };
});

// node_modules/msgpack-lite/lib/decode.js
var require_decode = __commonJS((exports2) => {
  exports2.decode = decode;
  var DecodeBuffer = require_decode_buffer().DecodeBuffer;
  function decode(input, options) {
    var decoder = new DecodeBuffer(options);
    decoder.write(input);
    return decoder.read();
  }
});

// node_modules/event-lite/event-lite.js
var require_event_lite = __commonJS((exports2, module2) => {
  /**
   * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
   *
   * @copyright Yusuke Kawasaki
   * @license MIT
   * @constructor
   * @see https://github.com/kawanet/event-lite
   * @see http://kawanet.github.io/event-lite/EventLite.html
   * @example
   * var EventLite = require("event-lite");
   *
   * function MyClass() {...}             // your class
   *
   * EventLite.mixin(MyClass.prototype);  // import event methods
   *
   * var obj = new MyClass();
   * obj.on("foo", function() {...});     // add event listener
   * obj.once("bar", function() {...});   // add one-time event listener
   * obj.emit("foo");                     // dispatch event
   * obj.emit("bar");                     // dispatch another event
   * obj.off("foo");                      // remove event listener
   */
  function EventLite() {
    if (!(this instanceof EventLite))
      return new EventLite();
  }
  (function(EventLite2) {
    if (typeof module2 !== "undefined")
      module2.exports = EventLite2;
    var LISTENERS = "listeners";
    var methods2 = {
      on,
      once,
      off,
      emit
    };
    mixin2(EventLite2.prototype);
    EventLite2.mixin = mixin2;
    function mixin2(target) {
      for (var key in methods2) {
        target[key] = methods2[key];
      }
      return target;
    }
    function on(type, func2) {
      getListeners(this, type).push(func2);
      return this;
    }
    function once(type, func2) {
      var that = this;
      wrap.originalListener = func2;
      getListeners(that, type).push(wrap);
      return that;
      function wrap() {
        off.call(that, type, wrap);
        func2.apply(this, arguments);
      }
    }
    function off(type, func2) {
      var that = this;
      var listners;
      if (!arguments.length) {
        delete that[LISTENERS];
      } else if (!func2) {
        listners = that[LISTENERS];
        if (listners) {
          delete listners[type];
          if (!Object.keys(listners).length)
            return off.call(that);
        }
      } else {
        listners = getListeners(that, type, true);
        if (listners) {
          listners = listners.filter(ne);
          if (!listners.length)
            return off.call(that, type);
          that[LISTENERS][type] = listners;
        }
      }
      return that;
      function ne(test) {
        return test !== func2 && test.originalListener !== func2;
      }
    }
    function emit(type, value) {
      var that = this;
      var listeners = getListeners(that, type, true);
      if (!listeners)
        return false;
      var arglen = arguments.length;
      if (arglen === 1) {
        listeners.forEach(zeroarg);
      } else if (arglen === 2) {
        listeners.forEach(onearg);
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        listeners.forEach(moreargs);
      }
      return !!listeners.length;
      function zeroarg(func2) {
        func2.call(that);
      }
      function onearg(func2) {
        func2.call(that, value);
      }
      function moreargs(func2) {
        func2.apply(that, args);
      }
    }
    function getListeners(that, type, readonly) {
      if (readonly && !that[LISTENERS])
        return;
      var listeners = that[LISTENERS] || (that[LISTENERS] = {});
      return listeners[type] || (listeners[type] = []);
    }
  })(EventLite);
});

// node_modules/msgpack-lite/lib/encoder.js
var require_encoder = __commonJS((exports2) => {
  exports2.Encoder = Encoder;
  var EventLite = require_event_lite();
  var EncodeBuffer = require_encode_buffer().EncodeBuffer;
  function Encoder(options) {
    if (!(this instanceof Encoder))
      return new Encoder(options);
    EncodeBuffer.call(this, options);
  }
  Encoder.prototype = new EncodeBuffer();
  EventLite.mixin(Encoder.prototype);
  Encoder.prototype.encode = function(chunk) {
    this.write(chunk);
    this.emit("data", this.read());
  };
  Encoder.prototype.end = function(chunk) {
    if (arguments.length)
      this.encode(chunk);
    this.flush();
    this.emit("end");
  };
});

// node_modules/msgpack-lite/lib/decoder.js
var require_decoder = __commonJS((exports2) => {
  exports2.Decoder = Decoder;
  var EventLite = require_event_lite();
  var DecodeBuffer = require_decode_buffer().DecodeBuffer;
  function Decoder(options) {
    if (!(this instanceof Decoder))
      return new Decoder(options);
    DecodeBuffer.call(this, options);
  }
  Decoder.prototype = new DecodeBuffer();
  EventLite.mixin(Decoder.prototype);
  Decoder.prototype.decode = function(chunk) {
    if (arguments.length)
      this.write(chunk);
    this.flush();
  };
  Decoder.prototype.push = function(chunk) {
    this.emit("data", chunk);
  };
  Decoder.prototype.end = function(chunk) {
    this.decode(chunk);
    this.emit("end");
  };
});

// node_modules/msgpack-lite/lib/encode-stream.js
var require_encode_stream = __commonJS((exports2) => {
  exports2.createEncodeStream = EncodeStream;
  var util54 = require("util");
  var Transform2 = require("stream").Transform;
  var EncodeBuffer = require_encode_buffer().EncodeBuffer;
  util54.inherits(EncodeStream, Transform2);
  var DEFAULT_OPTIONS = {objectMode: true};
  function EncodeStream(options) {
    if (!(this instanceof EncodeStream))
      return new EncodeStream(options);
    if (options) {
      options.objectMode = true;
    } else {
      options = DEFAULT_OPTIONS;
    }
    Transform2.call(this, options);
    var stream = this;
    var encoder = this.encoder = new EncodeBuffer(options);
    encoder.push = function(chunk) {
      stream.push(chunk);
    };
  }
  EncodeStream.prototype._transform = function(chunk, encoding, callback) {
    this.encoder.write(chunk);
    if (callback)
      callback();
  };
  EncodeStream.prototype._flush = function(callback) {
    this.encoder.flush();
    if (callback)
      callback();
  };
});

// node_modules/msgpack-lite/lib/decode-stream.js
var require_decode_stream = __commonJS((exports2) => {
  exports2.createDecodeStream = DecodeStream;
  var util54 = require("util");
  var Transform2 = require("stream").Transform;
  var DecodeBuffer = require_decode_buffer().DecodeBuffer;
  util54.inherits(DecodeStream, Transform2);
  var DEFAULT_OPTIONS = {objectMode: true};
  function DecodeStream(options) {
    if (!(this instanceof DecodeStream))
      return new DecodeStream(options);
    if (options) {
      options.objectMode = true;
    } else {
      options = DEFAULT_OPTIONS;
    }
    Transform2.call(this, options);
    var stream = this;
    var decoder = this.decoder = new DecodeBuffer(options);
    decoder.push = function(chunk) {
      stream.push(chunk);
    };
  }
  DecodeStream.prototype._transform = function(chunk, encoding, callback) {
    this.decoder.write(chunk);
    this.decoder.flush();
    if (callback)
      callback();
  };
});

// node_modules/msgpack-lite/lib/ext.js
var require_ext = __commonJS((exports2) => {
  require_read_core();
  require_write_core();
  exports2.createCodec = require_codec_base().createCodec;
});

// node_modules/msgpack-lite/lib/codec.js
var require_codec = __commonJS((exports2) => {
  require_read_core();
  require_write_core();
  exports2.codec = {
    preset: require_codec_base().preset
  };
});

// node_modules/msgpack-lite/index.js
var require_msgpack_lite = __commonJS((exports2) => {
  exports2.encode = require_encode().encode;
  exports2.decode = require_decode().decode;
  exports2.Encoder = require_encoder().Encoder;
  exports2.Decoder = require_decoder().Decoder;
  exports2.createEncodeStream = require_encode_stream().createEncodeStream;
  exports2.createDecodeStream = require_decode_stream().createDecodeStream;
  exports2.createCodec = require_ext().createCodec;
  exports2.codec = require_codec().codec;
});

// node_modules/@chemzqm/neovim/lib/utils/buffered.js
var require_buffered = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var stream_1 = require("stream");
  var Buffered = class extends stream_1.Transform {
    constructor() {
      super({
        readableHighWaterMark: 10 * 1024 * 1024,
        writableHighWaterMark: 10 * 1024 * 1024
      });
      this.chunks = null;
      this.timer = null;
    }
    sendData() {
      const {chunks} = this;
      if (chunks) {
        this.chunks = null;
        const buf = Buffer.concat(chunks);
        this.push(buf);
      }
    }
    _transform(chunk, _encoding, callback) {
      const {chunks, timer} = this;
      const MIN_SIZE = Buffer.poolSize;
      if (timer)
        clearTimeout(timer);
      if (chunk.length < MIN_SIZE) {
        if (!chunks)
          return callback(null, chunk);
        chunks.push(chunk);
        this.sendData();
        callback();
      } else {
        if (!chunks) {
          this.chunks = [chunk];
        } else {
          chunks.push(chunk);
        }
        this.timer = setTimeout(this.sendData.bind(this), 20);
        callback();
      }
    }
    _flush(callback) {
      const {chunks} = this;
      if (chunks) {
        this.chunks = null;
        const buf = Buffer.concat(chunks);
        callback(null, buf);
      } else {
        callback();
      }
    }
  };
  exports2.default = Buffered;
});

// node_modules/@chemzqm/neovim/lib/api/Base.js
var require_Base = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.BaseApi = void 0;
  var events_1 = require("events");
  var isVim5 = process.env.VIM_NODE_RPC == "1";
  var BaseApi = class extends events_1.EventEmitter {
    constructor({transport, data, client: client8}) {
      super();
      this.setTransport(transport);
      this.data = data;
      this.client = client8;
    }
    setTransport(transport) {
      this.transport = transport;
    }
    equals(other) {
      try {
        return String(this.data) === String(other.data);
      } catch (e) {
        return false;
      }
    }
    async request(name2, args = []) {
      let stack = Error().stack;
      return new Promise((resolve3, reject) => {
        this.transport.request(name2, this.getArgsByPrefix(args), (err, res) => {
          if (err) {
            let e = new Error(`request error ${name2} - ${err[1]}`);
            e.stack = stack;
            if (!name2.endsWith("get_var")) {
              this.client.logError(`request error on "${name2}"`, args, err[1], stack);
            }
            reject(e);
          } else {
            resolve3(res);
          }
        });
      });
    }
    getArgsByPrefix(args) {
      if (this.prefix !== "nvim_" && args[0] != this) {
        let id = isVim5 ? this.data : this;
        return [id, ...args];
      }
      return args;
    }
    getVar(name2) {
      return this.request(`${this.prefix}get_var`, [name2]).then((res) => res, (_err) => {
        return null;
      });
    }
    setVar(name2, value, isNotify = false) {
      if (isNotify) {
        this.notify(`${this.prefix}set_var`, [name2, value]);
        return;
      }
      return this.request(`${this.prefix}set_var`, [name2, value]);
    }
    deleteVar(name2) {
      this.notify(`${this.prefix}del_var`, [name2]);
    }
    getOption(name2) {
      return this.request(`${this.prefix}get_option`, [name2]);
    }
    setOption(name2, value, isNotify) {
      if (isNotify) {
        this.notify(`${this.prefix}set_option`, [name2, value]);
        return;
      }
      return this.request(`${this.prefix}set_option`, [name2, value]);
    }
    notify(name2, args = []) {
      this.transport.notify(name2, this.getArgsByPrefix(args));
    }
  };
  exports2.BaseApi = BaseApi;
});

// node_modules/@chemzqm/neovim/lib/api/Buffer.js
var require_Buffer = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Buffer = void 0;
  var Base_1 = require_Base();
  var Buffer2 = class extends Base_1.BaseApi {
    constructor() {
      super(...arguments);
      this.prefix = "nvim_buf_";
    }
    async attach(sendBuffer = false, options = {}) {
      return await this.request(`${this.prefix}attach`, [sendBuffer, options]);
    }
    async detach() {
      return await this.request(`${this.prefix}detach`, []);
    }
    get id() {
      return this.data;
    }
    get length() {
      return this.request(`${this.prefix}line_count`, []);
    }
    get lines() {
      return this.getLines();
    }
    get changedtick() {
      return this.request(`${this.prefix}get_changedtick`, []);
    }
    get commands() {
      return this.getCommands();
    }
    getCommands(options = {}) {
      return this.request(`${this.prefix}get_commands`, [options]);
    }
    getLines({start, end, strictIndexing} = {start: 0, end: -1, strictIndexing: true}) {
      const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
      return this.request(`${this.prefix}get_lines`, [
        start,
        end,
        indexing
      ]);
    }
    setLines(_lines, {start: _start, end: _end, strictIndexing} = {
      strictIndexing: true
    }, notify = false) {
      const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
      const lines = typeof _lines === "string" ? [_lines] : _lines;
      const end = typeof _end !== "undefined" ? _end : _start + 1;
      const method = notify ? "notify" : "request";
      return this[method](`${this.prefix}set_lines`, [
        _start,
        end,
        indexing,
        lines
      ]);
    }
    setVirtualText(src_id, line, chunks, opts = {}) {
      this.notify(`${this.prefix}set_virtual_text`, [
        src_id,
        line,
        chunks,
        opts
      ]);
      return Promise.resolve(src_id);
    }
    insert(lines, start) {
      return this.setLines(lines, {
        start,
        end: start,
        strictIndexing: true
      });
    }
    replace(_lines, start) {
      const lines = typeof _lines === "string" ? [_lines] : _lines;
      return this.setLines(lines, {
        start,
        end: start + lines.length,
        strictIndexing: false
      });
    }
    remove(start, end, strictIndexing = false) {
      return this.setLines([], {start, end, strictIndexing});
    }
    append(lines) {
      return this.setLines(lines, {
        start: -1,
        end: -1,
        strictIndexing: false
      });
    }
    get name() {
      return this.request(`${this.prefix}get_name`, []);
    }
    setName(value) {
      return this.request(`${this.prefix}set_name`, [value]);
    }
    get valid() {
      return this.request(`${this.prefix}is_valid`, []);
    }
    mark(name2) {
      return this.request(`${this.prefix}get_mark`, [name2]);
    }
    getKeymap(mode) {
      return this.request(`${this.prefix}get_keymap`, [mode]);
    }
    get loaded() {
      return this.request(`${this.prefix}is_loaded`, []);
    }
    getOffset(index) {
      return this.request(`${this.prefix}get_offset`, [index]);
    }
    addHighlight({hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId}) {
      if (!hlGroup)
        throw new Error("hlGroup should not empty");
      const colEnd = typeof _end !== "undefined" ? _end : -1;
      const colStart = typeof _start !== "undefined" ? _start : -0;
      const srcId = typeof _srcId !== "undefined" ? _srcId : -1;
      const method = srcId == 0 ? "request" : "notify";
      let res = this[method](`${this.prefix}add_highlight`, [
        srcId,
        hlGroup,
        line,
        colStart,
        colEnd
      ]);
      return method === "request" ? res : Promise.resolve(null);
    }
    clearHighlight(args = {}) {
      const defaults2 = {
        srcId: -1,
        lineStart: 0,
        lineEnd: -1
      };
      const {srcId, lineStart, lineEnd} = Object.assign({}, defaults2, args);
      return this.notify(`${this.prefix}clear_highlight`, [
        srcId,
        lineStart,
        lineEnd
      ]);
    }
    highlightRanges(srcId, hlGroup, ranges) {
      this.client.call("coc#highlight#ranges", [this.id, srcId, hlGroup, ranges], true);
    }
    clearNamespace(key, lineStart = 0, lineEnd = -1) {
      this.client.call("coc#highlight#clear_highlight", [this.id, key, lineStart, lineEnd]);
    }
    listen(eventName, cb, disposables) {
      this.client.attachBufferEvent(this, eventName, cb);
      if (disposables) {
        disposables.push({
          dispose: () => {
            this.client.detachBufferEvent(this, eventName, cb);
          }
        });
      }
    }
  };
  exports2.Buffer = Buffer2;
});

// node_modules/@chemzqm/neovim/lib/api/Window.js
var require_Window = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Window = void 0;
  var Base_1 = require_Base();
  var timers_1 = require("timers");
  var Window2 = class extends Base_1.BaseApi {
    constructor() {
      super(...arguments);
      this.prefix = "nvim_win_";
    }
    get id() {
      return this.data;
    }
    get buffer() {
      return this.request(`${this.prefix}get_buf`, []);
    }
    get tabpage() {
      return this.request(`${this.prefix}get_tabpage`, []);
    }
    get cursor() {
      return this.request(`${this.prefix}get_cursor`, []);
    }
    setCursor(pos, isNotify = false) {
      let method = isNotify ? "notify" : "request";
      return this[method](`${this.prefix}set_cursor`, [pos]);
    }
    get height() {
      return this.request(`${this.prefix}get_height`, []);
    }
    setHeight(height, isNotify = false) {
      let method = isNotify ? "notify" : "request";
      return this[method](`${this.prefix}set_height`, [height]);
    }
    get width() {
      return this.request(`${this.prefix}get_width`, []);
    }
    setWidth(width, isNotify = false) {
      let method = isNotify ? "notify" : "request";
      return this[method](`${this.prefix}set_height`, [width]);
    }
    get position() {
      return this.request(`${this.prefix}get_position`, []);
    }
    get row() {
      return this.request(`${this.prefix}get_position`, []).then((position15) => position15[0]);
    }
    get col() {
      return this.request(`${this.prefix}get_position`, []).then((position15) => position15[1]);
    }
    get valid() {
      return this.request(`${this.prefix}is_valid`, []);
    }
    get number() {
      return this.request(`${this.prefix}get_number`, []);
    }
    setConfig(options, isNotify) {
      let method = isNotify ? "notify" : "request";
      return this[method](`${this.prefix}set_config`, [options]);
    }
    getConfig() {
      return this.request(`${this.prefix}get_config`, []);
    }
    close(force, isNotify) {
      if (isNotify) {
        this.notify(`${this.prefix}close`, [force]);
        let count = 0;
        let interval = setInterval(() => {
          if (count == 5)
            return timers_1.clearInterval(interval);
          this.request(`${this.prefix}is_valid`, []).then((valid) => {
            if (!valid) {
              timers_1.clearInterval(interval);
            } else {
              this.notify(`${this.prefix}close`, [force]);
            }
          }, () => {
            timers_1.clearInterval(interval);
          });
          count++;
        }, 50);
        return null;
      }
      return this.request(`${this.prefix}close`, [force]);
    }
    highlightRanges(hlGroup, ranges, priority = 10, isNotify) {
      if (isNotify) {
        this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority], true);
        return void 0;
      }
      return this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority]);
    }
    clearMatchGroup(hlGroup) {
      this.client.call("coc#highlight#clear_match_group", [this.id, hlGroup], true);
    }
    clearMatches(ids) {
      this.client.call("coc#highlight#clear_matches", [this.id, ids], true);
    }
  };
  exports2.Window = Window2;
});

// node_modules/@chemzqm/neovim/lib/api/Tabpage.js
var require_Tabpage = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Tabpage = void 0;
  var Base_1 = require_Base();
  var Tabpage = class extends Base_1.BaseApi {
    constructor() {
      super(...arguments);
      this.prefix = "nvim_tabpage_";
    }
    get windows() {
      return this.request(`${this.prefix}list_wins`, []);
    }
    get window() {
      return this.request(`${this.prefix}get_win`, []);
    }
    get valid() {
      return this.request(`${this.prefix}is_valid`, []);
    }
    get number() {
      return this.request(`${this.prefix}get_number`, []);
    }
    getOption() {
      throw new Error("Tabpage does not have `getOption`");
    }
    setOption() {
      throw new Error("Tabpage does not have `setOption`");
    }
  };
  exports2.Tabpage = Tabpage;
});

// node_modules/@chemzqm/neovim/lib/api/types.js
var require_types = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Metadata = exports2.ExtType = void 0;
  var Buffer_1 = require_Buffer();
  var Window_1 = require_Window();
  var Tabpage_1 = require_Tabpage();
  var ExtType;
  (function(ExtType2) {
    ExtType2[ExtType2["Buffer"] = 0] = "Buffer";
    ExtType2[ExtType2["Window"] = 1] = "Window";
    ExtType2[ExtType2["Tabpage"] = 2] = "Tabpage";
  })(ExtType = exports2.ExtType || (exports2.ExtType = {}));
  exports2.Metadata = [
    {
      constructor: Buffer_1.Buffer,
      name: "Buffer",
      prefix: "nvim_buf_"
    },
    {
      constructor: Window_1.Window,
      name: "Window",
      prefix: "nvim_win_"
    },
    {
      constructor: Tabpage_1.Tabpage,
      name: "Tabpage",
      prefix: "nvim_tabpage_"
    }
  ];
});

// node_modules/@chemzqm/neovim/lib/utils/logger.js
var require_logger3 = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createLogger = void 0;
  var fs_1 = __importDefault(require("fs"));
  var os_1 = __importDefault(require("os"));
  var path_1 = __importDefault(require("path"));
  function getLogFile() {
    let file = process.env.NODE_CLIENT_LOG_FILE;
    if (file)
      return file;
    let dir = process.env.XDG_RUNTIME_DIR;
    if (dir)
      return path_1.default.join(dir, "node-client.log");
    return path_1.default.join(os_1.default.tmpdir(), `node-client-${process.pid}.log`);
  }
  var LOG_FILE_PATH = getLogFile();
  var level = process.env.NODE_CLIENT_LOG_LEVEL || "info";
  var invalid = process.getuid && process.getuid() == 0;
  if (!invalid) {
    try {
      fs_1.default.mkdirSync(path_1.default.dirname(LOG_FILE_PATH), {recursive: true});
      fs_1.default.writeFileSync(LOG_FILE_PATH, "", {encoding: "utf8", mode: 438});
    } catch (_e) {
      invalid = true;
    }
  }
  function toObject(arg) {
    if (arg == null) {
      return arg;
    }
    if (Array.isArray(arg)) {
      return arg.map((o) => toObject(o));
    }
    if (typeof arg == "object" && typeof arg.prefix == "string" && typeof arg.data == "number") {
      return "[" + arg.prefix + arg.data + "]";
    }
    return arg;
  }
  function toString(arg) {
    if (arg == null)
      return String(arg);
    if (typeof arg == "object")
      return JSON.stringify(arg, null, 2);
    return String(arg);
  }
  var Logger2 = class {
    constructor(name2) {
      this.name = name2;
    }
    get stream() {
      if (invalid)
        return null;
      if (this._stream)
        return this._stream;
      this._stream = fs_1.default.createWriteStream(LOG_FILE_PATH, {encoding: "utf8"});
      return this._stream;
    }
    getText(level2, data, meta) {
      let more = "";
      if (meta.length) {
        let arr = toObject(meta);
        more = " " + arr.map((o) => toString(o));
      }
      return `${new Date().toLocaleTimeString()} ${level2.toUpperCase()} [${this.name}] - ${data}${more}
`;
    }
    debug(data, ...meta) {
      if (level != "debug" || this.stream == null)
        return;
      this.stream.write(this.getText("debug", data, meta));
    }
    info(data, ...meta) {
      if (this.stream == null)
        return;
      this.stream.write(this.getText("info", data, meta));
    }
    error(data, ...meta) {
      if (this.stream == null)
        return;
      this.stream.write(this.getText("error", data, meta));
    }
    trace(data, ...meta) {
      if (level != "trace" || this.stream == null)
        return;
      this.stream.write(this.getText("trace", data, meta));
    }
  };
  function createLogger3(name2) {
    return new Logger2(name2);
  }
  exports2.createLogger = createLogger3;
});

// node_modules/@chemzqm/neovim/lib/transport/base.js
var require_base = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require("events");
  var logger_1 = require_logger3();
  var debug = process.env.NODE_CLIENT_LOG_LEVEL == "debug";
  var logger93 = logger_1.createLogger("transport");
  var Transport3 = class extends events_1.EventEmitter {
    constructor(logger94) {
      super();
      this.logger = logger94;
      this.pauseLevel = 0;
      this.paused = new Map();
    }
    debug(key, ...meta) {
      if (!debug)
        return;
      logger93.debug(key, ...meta);
    }
    info(key, ...meta) {
      logger93.info(key, ...meta);
    }
    debugMessage(msg) {
      if (!debug)
        return;
      const msgType = msg[0];
      if (msgType == 0) {
        logger93.debug("receive request:", msg.slice(1));
      } else if (msgType == 1) {
      } else if (msgType == 2) {
        logger93.debug("receive notification:", msg.slice(1));
      } else {
        logger93.debug("unknown message:", msg);
      }
    }
    pauseNotification() {
      this.pauseLevel = this.pauseLevel + 1;
      this.paused.set(this.pauseLevel, []);
    }
    cancelNotification() {
      let {pauseLevel} = this;
      if (pauseLevel > 0) {
        this.paused.delete(pauseLevel);
        this.pauseLevel = pauseLevel - 1;
      }
    }
    resumeNotification(isNotify = false) {
      let {pauseLevel} = this;
      if (pauseLevel == 0)
        return isNotify ? null : Promise.resolve([null, null]);
      let stack = Error().stack;
      this.pauseLevel = pauseLevel - 1;
      let list2 = this.paused.get(pauseLevel);
      this.paused.delete(pauseLevel);
      if (list2 && list2.length) {
        return new Promise((resolve3, reject) => {
          if (!isNotify) {
            return this.request("nvim_call_atomic", [list2], (err, res) => {
              if (err) {
                let e = new Error(`call_atomic error: ${err[1]}`);
                e.stack = stack;
                return reject(e);
              }
              if (Array.isArray(res) && res[1] != null) {
                let [index, errType, message] = res[1];
                let [fname, args] = list2[index];
                this.logger.error(`request error ${errType} on "${fname}"`, args, message, stack);
              }
              resolve3(res);
            });
          }
          this.notify("nvim_call_atomic", [list2]);
          resolve3();
        });
      }
      return isNotify ? null : Promise.resolve([[], void 0]);
    }
  };
  exports2.default = Transport3;
});

// node_modules/@chemzqm/neovim/lib/transport/nvim.js
var require_nvim = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable: true, value: v});
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.NvimTransport = void 0;
  var msgpack = __importStar(require_msgpack_lite());
  var buffered_1 = __importDefault(require_buffered());
  var types_1 = require_types();
  var base_1 = __importDefault(require_base());
  var NvimTransport = class extends base_1.default {
    constructor(logger93) {
      super(logger93);
      this.pending = new Map();
      this.nextRequestId = 1;
      this.attached = false;
      const codec = this.setupCodec();
      this.encodeStream = msgpack.createEncodeStream({codec});
      this.decodeStream = msgpack.createDecodeStream({codec});
      this.decodeStream.on("data", (msg) => {
        this.parseMessage(msg);
      });
      this.decodeStream.on("end", () => {
        this.detach();
        this.emit("detach");
      });
    }
    parseMessage(msg) {
      const msgType = msg[0];
      this.debugMessage(msg);
      if (msgType === 0) {
        this.emit("request", msg[2].toString(), msg[3], this.createResponse(msg[1]));
      } else if (msgType === 1) {
        const id = msg[1];
        const handler2 = this.pending.get(id);
        if (handler2) {
          this.pending.delete(id);
          let err = msg[2];
          if (err && err.length != 2) {
            err = [0, err instanceof Error ? err.message : err];
          }
          handler2(err, msg[3]);
        }
      } else if (msgType === 2) {
        this.emit("notification", msg[1].toString(), msg[2]);
      } else {
        console.error(`Invalid message type ${msgType}`);
      }
    }
    setupCodec() {
      const codec = msgpack.createCodec();
      types_1.Metadata.forEach(({constructor}, id) => {
        codec.addExtPacker(id, constructor, (obj) => msgpack.encode(obj.data));
        codec.addExtUnpacker(id, (data) => new constructor({
          transport: this,
          client: this.client,
          data: msgpack.decode(data)
        }));
      });
      this.codec = codec;
      return this.codec;
    }
    attach(writer, reader, client8) {
      this.encodeStream = this.encodeStream.pipe(writer);
      const buffered = new buffered_1.default();
      reader.pipe(buffered).pipe(this.decodeStream);
      this.writer = writer;
      this.reader = reader;
      this.client = client8;
      this.attached = true;
    }
    detach() {
      if (!this.attached)
        return;
      this.attached = false;
      this.encodeStream.unpipe(this.writer);
      this.reader.unpipe(this.decodeStream);
    }
    request(method, args, cb) {
      if (!this.attached)
        return;
      let id = this.nextRequestId;
      this.nextRequestId = this.nextRequestId + 1;
      let startTs = Date.now();
      this.debug("request to nvim:", id, method, args);
      this.encodeStream.write(msgpack.encode([0, id, method, args], {
        codec: this.codec
      }));
      let stack = Error().stack;
      let timer = setTimeout(() => {
        this.debug(`request to vim blocked more than 1s: ${method}`, args, stack);
      }, 1e3);
      this.pending.set(id, (err, res) => {
        clearTimeout(timer);
        this.debug("response of nvim:", id, `${Date.now() - startTs}ms`, res, err);
        cb(err, res);
      });
    }
    notify(method, args) {
      if (!this.attached)
        return;
      if (this.pauseLevel != 0) {
        let arr = this.paused.get(this.pauseLevel);
        if (arr) {
          arr.push([method, args]);
          return;
        }
      }
      this.debug("nvim notification:", method, args);
      this.encodeStream.write(msgpack.encode([2, method, args], {
        codec: this.codec
      }));
    }
    send(arr) {
      this.encodeStream.write(msgpack.encode(arr, {
        codec: this.codec
      }));
    }
    createResponse(requestId) {
      let {encodeStream} = this;
      let startTs = Date.now();
      let called = false;
      let timer = setTimeout(() => {
        this.debug(`request to client cost more than 1s`, requestId);
      }, 1e3);
      return {
        send: (resp, isError2) => {
          clearTimeout(timer);
          if (called || !this.attached)
            return;
          this.debug("response of client:", requestId, `${Date.now() - startTs}ms`, resp, isError2 == true);
          called = true;
          encodeStream.write(msgpack.encode([
            1,
            requestId,
            isError2 ? resp : null,
            !isError2 ? resp : null
          ]));
        }
      };
    }
  };
  exports2.NvimTransport = NvimTransport;
});

// node_modules/@chemzqm/neovim/lib/transport/connection.js
var require_connection = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = __importDefault(require("events"));
  var readline_1 = __importDefault(require("readline"));
  var logger_1 = require_logger3();
  var logger93 = logger_1.createLogger("connection");
  var debug = process.env.NODE_CLIENT_LOG_LEVEL == "debug";
  var Connection = class extends events_1.default {
    constructor(readable, writeable) {
      super();
      this.readable = readable;
      this.writeable = writeable;
      const rl = readline_1.default.createInterface(this.readable);
      rl.on("line", (line) => {
        this.parseData(line);
      });
      rl.on("close", () => {
        logger93.error("connection closed");
        process.exit(0);
      });
    }
    parseData(str) {
      if (str.length == 0)
        return;
      let arr;
      try {
        arr = JSON.parse(str);
      } catch (e) {
        console.error(`Invalid data from vim: ${str}`);
        return;
      }
      let [id, obj] = arr;
      if (id > 0) {
        logger93.debug("received request:", id, obj);
        this.emit("request", id, obj);
      } else if (id == 0) {
        logger93.debug("received notification:", obj);
        this.emit("notification", obj);
      } else {
        logger93.debug("received response:", id, obj);
        this.emit("response", id, obj);
      }
    }
    response(requestId, data) {
      this.send([requestId, data || null]);
    }
    notify(event, data) {
      this.send([0, [event, data || null]]);
    }
    send(arr) {
      logger93.debug("send to vim:", arr);
      try {
        this.writeable.write(JSON.stringify(arr) + "\n");
      } catch (e) {
        logger93.error("Send error:", arr);
      }
    }
    redraw(force = false) {
      this.send(["redraw", force ? "force" : ""]);
    }
    commmand(cmd) {
      this.send(["ex", cmd]);
    }
    expr(expr) {
      this.send(["expr", expr]);
    }
    call(func2, args, requestId) {
      if (!requestId) {
        this.send(["call", func2, args]);
        return;
      }
      this.send(["call", func2, args, requestId]);
    }
    dispose() {
      this.removeAllListeners();
    }
  };
  exports2.default = Connection;
});

// node_modules/@chemzqm/neovim/lib/transport/request.js
var require_request = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var logger_1 = require_logger3();
  var logger93 = logger_1.createLogger("request");
  var debug = process.env.NODE_CLIENT_LOG_LEVEL == "debug";
  var func2 = process.env.COC_NVIM == "1" ? "coc#api#call" : "nvim#api#call";
  var Request = class {
    constructor(connection, cb, id) {
      this.connection = connection;
      this.cb = cb;
      this.id = id;
    }
    request(method, args = []) {
      this.method = method;
      this.args = args;
      this.connection.call(func2, [method.slice(5), args], this.id);
    }
    callback(client8, err, result) {
      let {method, cb} = this;
      if (debug && err) {
        logger93.debug(`request ${this.method} error:`, err, this.args);
      }
      if (err)
        return cb([0, err.toString()]);
      switch (method) {
        case "nvim_list_wins":
        case "nvim_tabpage_list_wins":
          return cb(null, result.map((o) => client8.createWindow(o)));
        case "nvim_tabpage_get_win":
        case "nvim_get_current_win":
        case "nvim_open_win":
          return cb(null, client8.createWindow(result));
        case "nvim_list_bufs":
          return cb(null, result.map((o) => client8.createBuffer(o)));
        case "nvim_win_get_buf":
        case "nvim_create_buf":
        case "nvim_get_current_buf":
          return cb(null, client8.createBuffer(result));
        case "nvim_list_tabpages":
          return cb(null, result.map((o) => client8.createTabpage(o)));
        case "nvim_get_current_tabpage":
          return cb(null, client8.createTabpage(result));
        default:
          return cb(null, result);
      }
    }
  };
  exports2.default = Request;
});

// node_modules/@chemzqm/neovim/lib/transport/vim.js
var require_vim = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.VimTransport = void 0;
  var base_1 = __importDefault(require_base());
  var connection_1 = __importDefault(require_connection());
  var request_1 = __importDefault(require_request());
  var VimTransport = class extends base_1.default {
    constructor(logger93) {
      super(logger93);
      this.pending = new Map();
      this.nextRequestId = -1;
      this.attached = false;
      this.notifyMethod = process.env.COC_NVIM == "1" ? "coc#api#notify" : "nvim#api#notify";
    }
    attach(writer, reader, client8) {
      let connection = this.connection = new connection_1.default(reader, writer);
      this.attached = true;
      this.client = client8;
      connection.on("request", (id, obj) => {
        let [method, args] = obj;
        this.emit("request", method, args, this.createResponse(id));
      });
      connection.on("notification", (obj) => {
        let [event, args] = obj;
        this.emit("notification", event.toString(), args);
      });
      connection.on("response", (id, obj) => {
        let req = this.pending.get(id);
        if (req) {
          this.pending.delete(id);
          let err = null;
          let result = null;
          if (!Array.isArray(obj)) {
            err = obj;
          } else {
            err = obj[0];
            result = obj[1];
          }
          req.callback(this.client, err, result);
        }
      });
    }
    send(arr) {
      this.connection.send(arr);
    }
    detach() {
      if (!this.attached)
        return;
      this.attached = false;
      this.connection.dispose();
    }
    request(method, args, cb) {
      if (!this.attached)
        return cb([0, "transport disconnected"]);
      let id = this.nextRequestId;
      this.nextRequestId = this.nextRequestId - 1;
      let startTs = Date.now();
      this.debug("request to vim:", id, method, args);
      let timer = setTimeout(() => {
        this.debug(`request to vim cost more than 1s`, method, args);
      }, 1e3);
      let req = new request_1.default(this.connection, (err, res) => {
        clearTimeout(timer);
        this.debug(`response from vim cost:`, id, `${Date.now() - startTs}ms`);
        cb(err, res);
      }, id);
      this.pending.set(id, req);
      req.request(method, args);
    }
    notify(method, args) {
      if (!this.attached)
        return;
      if (this.pauseLevel != 0) {
        let arr = this.paused.get(this.pauseLevel);
        if (arr) {
          arr.push([method, args]);
          return;
        }
      }
      this.connection.call(this.notifyMethod, [method.slice(5), args]);
    }
    createResponse(requestId) {
      let called = false;
      let {connection} = this;
      let startTs = Date.now();
      let timer = setTimeout(() => {
        this.debug(`request to client cost more than 1s`, requestId);
      }, 1e3);
      return {
        send: (resp, isError2) => {
          clearTimeout(timer);
          if (called || !this.attached)
            return;
          called = true;
          let err = null;
          if (isError2)
            err = typeof resp === "string" ? resp : resp.toString();
          this.debug("response of client cost:", requestId, `${Date.now() - startTs}ms`);
          connection.response(requestId, [err, isError2 ? null : resp]);
        }
      };
    }
  };
  exports2.VimTransport = VimTransport;
});

// node_modules/@chemzqm/neovim/lib/api/Neovim.js
var require_Neovim = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Neovim = void 0;
  var Base_1 = require_Base();
  var Buffer_1 = require_Buffer();
  var Tabpage_1 = require_Tabpage();
  var Window_1 = require_Window();
  var isVim5 = process.env.VIM_NODE_RPC == "1";
  var Neovim = class extends Base_1.BaseApi {
    constructor() {
      super(...arguments);
      this.prefix = "nvim_";
      this.Buffer = Buffer_1.Buffer;
      this.Window = Window_1.Window;
      this.Tabpage = Tabpage_1.Tabpage;
    }
    getArgs(args) {
      if (!args)
        return [];
      if (Array.isArray(args))
        return args;
      return [args];
    }
    get apiInfo() {
      return this.request(`${this.prefix}get_api_info`);
    }
    get buffers() {
      return this.request(`${this.prefix}list_bufs`);
    }
    get buffer() {
      return this.request(`${this.prefix}get_current_buf`);
    }
    async setBuffer(buffer4) {
      await this.request(`${this.prefix}set_current_buf`, [buffer4]);
    }
    get chans() {
      return this.request(`${this.prefix}list_chans`);
    }
    getChanInfo(chan) {
      return this.request(`${this.prefix}get_chan_info`, [chan]);
    }
    createNamespace(name2 = "") {
      return this.request(`${this.prefix}create_namespace`, [name2]);
    }
    get namespaces() {
      return this.request(`${this.prefix}get_namespaces`, []);
    }
    get commands() {
      return this.getCommands();
    }
    getCommands(options = {}) {
      return this.request(`${this.prefix}get_commands`, [options]);
    }
    get tabpages() {
      return this.request(`${this.prefix}list_tabpages`);
    }
    get tabpage() {
      return this.request(`${this.prefix}get_current_tabpage`);
    }
    async setTabpage(tabpage) {
      await this.request(`${this.prefix}set_current_tabpage`, [tabpage]);
    }
    get windows() {
      return this.getWindows();
    }
    get window() {
      return this.request(`${this.prefix}get_current_win`);
    }
    getWindows() {
      return this.request(`${this.prefix}list_wins`);
    }
    async setWindow(win) {
      await this.request(`${this.prefix}set_current_win`, [win]);
    }
    get runtimePaths() {
      return this.request(`${this.prefix}list_runtime_paths`);
    }
    setDirectory(dir) {
      return this.request(`${this.prefix}set_current_dir`, [dir]);
    }
    get line() {
      return this.getLine();
    }
    createNewBuffer(listed = false, scratch = false) {
      return this.request(`${this.prefix}create_buf`, [listed, scratch]);
    }
    openFloatWindow(buffer4, enter, options) {
      return this.request(`${this.prefix}open_win`, [buffer4, enter, options]);
    }
    getLine() {
      return this.request(`${this.prefix}get_current_line`);
    }
    setLine(line) {
      return this.request(`${this.prefix}set_current_line`, [line]);
    }
    getKeymap(mode) {
      return this.request(`${this.prefix}get_keymap`, [mode]);
    }
    get mode() {
      return this.request(`${this.prefix}get_mode`);
    }
    get colorMap() {
      return this.request(`${this.prefix}get_color_map`);
    }
    getColorByName(name2) {
      return this.request(`${this.prefix}get_color_by_name`, [name2]);
    }
    getHighlight(nameOrId, isRgb = true) {
      const functionName = typeof nameOrId === "string" ? "by_name" : "by_id";
      return this.request(`${this.prefix}get_hl_${functionName}`, [
        nameOrId,
        isRgb
      ]);
    }
    getHighlightByName(name2, isRgb = true) {
      return this.request(`${this.prefix}get_hl_by_name`, [name2, isRgb]);
    }
    getHighlightById(id, isRgb = true) {
      return this.request(`${this.prefix}get_hl_by_id`, [id, isRgb]);
    }
    deleteCurrentLine() {
      return this.request(`${this.prefix}del_current_line`);
    }
    eval(expr) {
      return this.request(`${this.prefix}eval`, [expr]);
    }
    lua(code, args = []) {
      const _args = this.getArgs(args);
      return this.request(`${this.prefix}execute_lua`, [code, _args]);
    }
    executeLua(code, args = []) {
      return this.lua(code, args);
    }
    callDictFunction(dict, fname, args = []) {
      const _args = this.getArgs(args);
      return this.request(`${this.prefix}call_dict_function`, [
        dict,
        fname,
        _args
      ]);
    }
    call(fname, args = [], isNotify) {
      const _args = this.getArgs(args);
      if (isNotify) {
        this.notify(`${this.prefix}call_function`, [fname, _args]);
        return null;
      }
      return this.request(`${this.prefix}call_function`, [fname, _args]);
    }
    callTimer(fname, args = [], isNotify) {
      const _args = this.getArgs(args);
      if (isNotify) {
        this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
        return null;
      }
      if (isVim5) {
        this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
        return new Promise((resolve3) => {
          setTimeout(() => {
            resolve3(null);
          }, 20);
        });
      }
      return this.request(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
    }
    callAsync(fname, args = []) {
      const _args = this.getArgs(args);
      return this.client.sendAsyncRequest(fname, _args);
    }
    callFunction(fname, args = []) {
      return this.call(fname, args);
    }
    callAtomic(calls) {
      return this.request(`${this.prefix}call_atomic`, [calls]);
    }
    command(arg, isNotify) {
      if (isNotify) {
        this.notify(`${this.prefix}command`, [arg]);
        return null;
      }
      return this.request(`${this.prefix}command`, [arg]);
    }
    commandOutput(arg) {
      return this.request(`${this.prefix}command_output`, [arg]);
    }
    getVvar(name2) {
      return this.request(`${this.prefix}get_vvar`, [name2]);
    }
    feedKeys(keys, mode, escapeCsi) {
      return this.request(`${this.prefix}feedkeys`, [keys, mode, escapeCsi]);
    }
    input(keys) {
      return this.request(`${this.prefix}input`, [keys]);
    }
    parseExpression(expr, flags, highlight) {
      return this.request(`${this.prefix}parse_expression`, [
        expr,
        flags,
        highlight
      ]);
    }
    getProc(pid) {
      return this.request(`${this.prefix}get_proc`, [pid]);
    }
    getProcChildren(pid) {
      return this.request(`${this.prefix}get_proc_children`, [pid]);
    }
    replaceTermcodes(str, fromPart, doIt, special) {
      return this.request(`${this.prefix}replace_termcodes`, [
        str,
        fromPart,
        doIt,
        special
      ]);
    }
    strWidth(str) {
      return this.request(`${this.prefix}strwidth`, [str]);
    }
    outWrite(str) {
      this.notify(`${this.prefix}out_write`, [str]);
    }
    outWriteLine(str) {
      this.outWrite(`${str}
`);
    }
    errWrite(str) {
      this.notify(`${this.prefix}err_write`, [str]);
    }
    errWriteLine(str) {
      this.notify(`${this.prefix}err_writeln`, [str]);
    }
    get uis() {
      return this.request(`${this.prefix}list_uis`);
    }
    uiAttach(width, height, options) {
      return this.request(`${this.prefix}ui_attach`, [width, height, options]);
    }
    uiDetach() {
      return this.request(`${this.prefix}ui_detach`, []);
    }
    uiTryResize(width, height) {
      return this.request(`${this.prefix}ui_try_resize`, [width, height]);
    }
    uiSetOption(name2, value) {
      return this.request(`${this.prefix}ui_set_option`, [name2, value]);
    }
    subscribe(event) {
      return this.request(`${this.prefix}subscribe`, [event]);
    }
    unsubscribe(event) {
      return this.request(`${this.prefix}unsubscribe`, [event]);
    }
    setClientInfo(name2, version2, type, methods2, attributes) {
      this.notify(`${this.prefix}set_client_info`, [
        name2,
        version2,
        type,
        methods2,
        attributes
      ]);
    }
    async quit() {
      this.command("qa!", true);
      if (this.transport) {
        this.transport.detach();
      }
    }
  };
  exports2.Neovim = Neovim;
});

// node_modules/@chemzqm/neovim/lib/api/client.js
var require_client = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.NeovimClient = exports2.AsyncResponse = void 0;
  var nvim_1 = require_nvim();
  var vim_1 = require_vim();
  var Neovim_1 = require_Neovim();
  var Buffer_1 = require_Buffer();
  var Window_1 = require_Window();
  var Tabpage_1 = require_Tabpage();
  var logger_1 = require_logger3();
  var logger93 = logger_1.createLogger("client");
  var isVim5 = process.env.VIM_NODE_RPC == "1";
  var AsyncResponse = class {
    constructor(requestId, cb) {
      this.requestId = requestId;
      this.cb = cb;
      this.finished = false;
    }
    finish(err, res) {
      if (this.finished)
        return;
      this.finished = true;
      if (err) {
        this.cb(new Error(err));
        return;
      }
      this.cb(null, res);
    }
  };
  exports2.AsyncResponse = AsyncResponse;
  var NeovimClient = class extends Neovim_1.Neovim {
    constructor(logger94) {
      super({});
      this.logger = logger94;
      this.requestId = 1;
      this.responses = new Map();
      this.attachedBuffers = new Map();
      Object.defineProperty(this, "client", {
        value: this
      });
      let transport = isVim5 ? new vim_1.VimTransport(logger94) : new nvim_1.NvimTransport(logger94);
      this.setTransport(transport);
      this.transportAttached = false;
      this.handleRequest = this.handleRequest.bind(this);
      this.handleNotification = this.handleNotification.bind(this);
    }
    logError(msg, ...args) {
      if (!this.logger)
        return;
      this.logger.error(msg, ...args);
    }
    createBuffer(id) {
      return new Buffer_1.Buffer({
        transport: this.transport,
        data: id,
        client: this
      });
    }
    createWindow(id) {
      return new Window_1.Window({
        transport: this.transport,
        data: id,
        client: this
      });
    }
    createTabpage(id) {
      return new Tabpage_1.Tabpage({
        transport: this.transport,
        data: id,
        client: this
      });
    }
    send(arr) {
      this.transport.send(arr);
    }
    attach({reader, writer}, requestApi = true) {
      this.transport.attach(writer, reader, this);
      this.transportAttached = true;
      this.setupTransport(requestApi);
    }
    detach() {
      this.transport.detach();
      this.transportAttached = false;
    }
    get isApiReady() {
      return this.transportAttached && typeof this._channelId !== "undefined";
    }
    get channelId() {
      return this._isReady.then(() => {
        return this._channelId;
      });
    }
    isAttached(bufnr) {
      return this.attachedBuffers.has(bufnr);
    }
    handleRequest(method, args, resp) {
      this.emit("request", method, args, resp);
    }
    sendAsyncRequest(method, args) {
      let id = this.requestId;
      this.requestId = id + 1;
      this.notify("nvim_call_function", ["coc#rpc#async_request", [id, method, args || []]]);
      return new Promise((resolve3, reject) => {
        let response = new AsyncResponse(id, (err, res) => {
          if (err)
            return reject(err);
          resolve3(res);
        });
        this.responses.set(id, response);
      });
    }
    emitNotification(method, args) {
      if (method.endsWith("_event")) {
        if (method.startsWith("nvim_buf_")) {
          const shortName = method.replace(/nvim_buf_(.*)_event/, "$1");
          const {id} = args[0];
          if (!this.attachedBuffers.has(id))
            return;
          const bufferMap = this.attachedBuffers.get(id);
          const cbs = bufferMap.get(shortName) || [];
          cbs.forEach((cb) => cb(...args));
          if (shortName === "detach") {
            this.attachedBuffers.delete(id);
          }
          return;
        }
        if (method.startsWith("nvim_async_request")) {
          const [id, method2, arr] = args;
          this.handleRequest(method2, arr, {
            send: (resp, isError2) => {
              this.notify("nvim_call_function", ["coc#rpc#async_response", [id, resp, isError2]]);
            }
          });
        }
        if (method.startsWith("nvim_async_response")) {
          const [id, err, res] = args;
          const response = this.responses.get(id);
          if (!response) {
            console.error(`Response not found for request ${id}`);
            return;
          }
          this.responses.delete(id);
          response.finish(err, res);
          return;
        }
      } else {
        this.emit("notification", method, args);
      }
    }
    handleNotification(method, args) {
      this.emitNotification(method, args);
    }
    setupTransport(requestApi = true) {
      if (!this.transportAttached) {
        throw new Error("Not attached to input/output");
      }
      this.transport.on("request", this.handleRequest);
      this.transport.on("notification", this.handleNotification);
      this.transport.on("detach", () => {
        this.emit("disconnect");
        this.transport.removeAllListeners("request");
        this.transport.removeAllListeners("notification");
        this.transport.removeAllListeners("detach");
      });
      if (requestApi) {
        this._isReady = this.generateApi();
      } else {
        this._channelId = 0;
        this._isReady = Promise.resolve(true);
      }
    }
    requestApi() {
      return new Promise((resolve3, reject) => {
        this.transport.request("nvim_get_api_info", [], (err, res) => {
          if (err) {
            reject(new Error(Array.isArray(err) ? err[1] : err.message || err.toString()));
          } else {
            resolve3(res);
          }
        });
      });
    }
    async generateApi() {
      let results;
      try {
        results = await this.requestApi();
      } catch (err) {
        console.error("Could not get vim api results");
        logger93.error(err);
      }
      if (results) {
        try {
          const [channelId, metadata] = results;
          this.functions = metadata.functions.map((f) => f.name);
          this._channelId = channelId;
          return true;
        } catch (err) {
          logger93.error(err.stack);
          return null;
        }
      }
      return null;
    }
    attachBufferEvent(buffer4, eventName, cb) {
      const bufferMap = this.attachedBuffers.get(buffer4.id) || new Map();
      const cbs = bufferMap.get(eventName) || [];
      if (cbs.includes(cb))
        return;
      cbs.push(cb);
      bufferMap.set(eventName, cbs);
      this.attachedBuffers.set(buffer4.id, bufferMap);
      return;
    }
    detachBufferEvent(buffer4, eventName, cb) {
      const bufferMap = this.attachedBuffers.get(buffer4.id);
      if (!bufferMap || !bufferMap.has(eventName))
        return;
      const handlers = bufferMap.get(eventName).filter((handler2) => handler2 !== cb);
      bufferMap.set(eventName, handlers);
    }
    pauseNotification() {
      this.transport.pauseNotification();
      let stack = Error().stack;
      process.nextTick(() => {
        if (this.transport.pauseLevel > 0) {
          this.logError(`resumeNotification not called within same tick:`, stack);
        }
      });
    }
    resumeNotification(cancel, notify) {
      if (cancel)
        return Promise.resolve(this.transport.cancelNotification());
      if (notify) {
        return Promise.resolve(this.transport.resumeNotification(true));
      }
      return Promise.resolve(this.transport.resumeNotification());
    }
    hasFunction(name2) {
      if (!this.functions)
        return true;
      return this.functions.indexOf(name2) !== -1;
    }
  };
  exports2.NeovimClient = NeovimClient;
});

// node_modules/@chemzqm/neovim/lib/attach/attach.js
var require_attach = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.attach = void 0;
  var net_1 = require("net");
  var client_1 = require_client();
  function attach2({reader: _reader, writer: _writer, proc, socket}, logger93 = null, requestApi = true) {
    let writer;
    let reader;
    let neovim;
    if (socket) {
      const client8 = net_1.createConnection(socket);
      writer = client8;
      reader = client8;
      client8.once("close", () => {
        neovim.detach();
      });
    } else if (_reader && _writer) {
      writer = _writer;
      reader = _reader;
    } else if (proc) {
      writer = proc.stdin;
      reader = proc.stdout;
      proc.once("disconnect", () => {
        neovim.detach();
      });
    }
    writer.on("error", (err) => {
      if (err.code == "EPIPE") {
        neovim.detach();
      }
    });
    if (writer && reader) {
      neovim = new client_1.NeovimClient(logger93);
      neovim.attach({
        writer,
        reader
      }, requestApi);
      return neovim;
    }
    throw new Error("Invalid arguments, could not attach");
  }
  exports2.attach = attach2;
});

// node_modules/@chemzqm/neovim/lib/api/index.js
var require_api = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Tabpage = exports2.Window = exports2.Buffer = exports2.NeovimClient = exports2.Neovim = void 0;
  var client_1 = require_client();
  Object.defineProperty(exports2, "Neovim", {enumerable: true, get: function() {
    return client_1.NeovimClient;
  }});
  var client_2 = require_client();
  Object.defineProperty(exports2, "NeovimClient", {enumerable: true, get: function() {
    return client_2.NeovimClient;
  }});
  var Buffer_1 = require_Buffer();
  Object.defineProperty(exports2, "Buffer", {enumerable: true, get: function() {
    return Buffer_1.Buffer;
  }});
  var Window_1 = require_Window();
  Object.defineProperty(exports2, "Window", {enumerable: true, get: function() {
    return Window_1.Window;
  }});
  var Tabpage_1 = require_Tabpage();
  Object.defineProperty(exports2, "Tabpage", {enumerable: true, get: function() {
    return Tabpage_1.Tabpage;
  }});
});

// node_modules/@chemzqm/neovim/lib/index.js
var require_lib5 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Window = exports2.Tabpage = exports2.Buffer = exports2.NeovimClient = exports2.Neovim = exports2.attach = void 0;
  var attach_1 = require_attach();
  Object.defineProperty(exports2, "attach", {enumerable: true, get: function() {
    return attach_1.attach;
  }});
  var index_1 = require_api();
  Object.defineProperty(exports2, "Neovim", {enumerable: true, get: function() {
    return index_1.Neovim;
  }});
  Object.defineProperty(exports2, "NeovimClient", {enumerable: true, get: function() {
    return index_1.NeovimClient;
  }});
  Object.defineProperty(exports2, "Buffer", {enumerable: true, get: function() {
    return index_1.Buffer;
  }});
  Object.defineProperty(exports2, "Tabpage", {enumerable: true, get: function() {
    return index_1.Tabpage;
  }});
  Object.defineProperty(exports2, "Window", {enumerable: true, get: function() {
    return index_1.Window;
  }});
});

// node_modules/vscode-jsonrpc/lib/is.js
var require_is = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function boolean2(value) {
    return value === true || value === false;
  }
  exports2.boolean = boolean2;
  function string23(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports2.string = string23;
  function number2(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports2.number = number2;
  function error(value) {
    return value instanceof Error;
  }
  exports2.error = error;
  function func2(value) {
    return typeof value === "function";
  }
  exports2.func = func2;
  function array6(value) {
    return Array.isArray(value);
  }
  exports2.array = array6;
  function stringArray(value) {
    return array6(value) && value.every((elem) => string23(elem));
  }
  exports2.stringArray = stringArray;
});

// node_modules/vscode-jsonrpc/lib/messages.js
var require_messages = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var is6 = require_is();
  var ErrorCodes2;
  (function(ErrorCodes3) {
    ErrorCodes3.ParseError = -32700;
    ErrorCodes3.InvalidRequest = -32600;
    ErrorCodes3.MethodNotFound = -32601;
    ErrorCodes3.InvalidParams = -32602;
    ErrorCodes3.InternalError = -32603;
    ErrorCodes3.serverErrorStart = -32099;
    ErrorCodes3.serverErrorEnd = -32e3;
    ErrorCodes3.ServerNotInitialized = -32002;
    ErrorCodes3.UnknownErrorCode = -32001;
    ErrorCodes3.RequestCancelled = -32800;
    ErrorCodes3.ContentModified = -32801;
    ErrorCodes3.MessageWriteError = 1;
    ErrorCodes3.MessageReadError = 2;
  })(ErrorCodes2 = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
  var ResponseError2 = class extends Error {
    constructor(code, message, data) {
      super(message);
      this.code = is6.number(code) ? code : ErrorCodes2.UnknownErrorCode;
      this.data = data;
      Object.setPrototypeOf(this, ResponseError2.prototype);
    }
    toJson() {
      return {
        code: this.code,
        message: this.message,
        data: this.data
      };
    }
  };
  exports2.ResponseError = ResponseError2;
  var AbstractMessageType = class {
    constructor(_method, _numberOfParams) {
      this._method = _method;
      this._numberOfParams = _numberOfParams;
    }
    get method() {
      return this._method;
    }
    get numberOfParams() {
      return this._numberOfParams;
    }
  };
  exports2.AbstractMessageType = AbstractMessageType;
  var RequestType02 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 0);
    }
  };
  exports2.RequestType0 = RequestType02;
  var RequestType2 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
    }
  };
  exports2.RequestType = RequestType2;
  var RequestType1 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
    }
  };
  exports2.RequestType1 = RequestType1;
  var RequestType22 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 2);
    }
  };
  exports2.RequestType2 = RequestType22;
  var RequestType3 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 3);
    }
  };
  exports2.RequestType3 = RequestType3;
  var RequestType4 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 4);
    }
  };
  exports2.RequestType4 = RequestType4;
  var RequestType5 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 5);
    }
  };
  exports2.RequestType5 = RequestType5;
  var RequestType6 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 6);
    }
  };
  exports2.RequestType6 = RequestType6;
  var RequestType7 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 7);
    }
  };
  exports2.RequestType7 = RequestType7;
  var RequestType8 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 8);
    }
  };
  exports2.RequestType8 = RequestType8;
  var RequestType9 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 9);
    }
  };
  exports2.RequestType9 = RequestType9;
  var NotificationType3 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
      this._ = void 0;
    }
  };
  exports2.NotificationType = NotificationType3;
  var NotificationType02 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 0);
    }
  };
  exports2.NotificationType0 = NotificationType02;
  var NotificationType1 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
    }
  };
  exports2.NotificationType1 = NotificationType1;
  var NotificationType22 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 2);
    }
  };
  exports2.NotificationType2 = NotificationType22;
  var NotificationType32 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 3);
    }
  };
  exports2.NotificationType3 = NotificationType32;
  var NotificationType4 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 4);
    }
  };
  exports2.NotificationType4 = NotificationType4;
  var NotificationType5 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 5);
    }
  };
  exports2.NotificationType5 = NotificationType5;
  var NotificationType6 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 6);
    }
  };
  exports2.NotificationType6 = NotificationType6;
  var NotificationType7 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 7);
    }
  };
  exports2.NotificationType7 = NotificationType7;
  var NotificationType8 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 8);
    }
  };
  exports2.NotificationType8 = NotificationType8;
  var NotificationType9 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 9);
    }
  };
  exports2.NotificationType9 = NotificationType9;
  function isRequestMessage(message) {
    let candidate = message;
    return candidate && is6.string(candidate.method) && (is6.string(candidate.id) || is6.number(candidate.id));
  }
  exports2.isRequestMessage = isRequestMessage;
  function isNotificationMessage(message) {
    let candidate = message;
    return candidate && is6.string(candidate.method) && message.id === void 0;
  }
  exports2.isNotificationMessage = isNotificationMessage;
  function isResponseMessage(message) {
    let candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is6.string(candidate.id) || is6.number(candidate.id) || candidate.id === null);
  }
  exports2.isResponseMessage = isResponseMessage;
});

// node_modules/vscode-jsonrpc/lib/events.js
var require_events = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Disposable63;
  (function(Disposable64) {
    function create(func2) {
      return {
        dispose: func2
      };
    }
    Disposable64.create = create;
  })(Disposable63 = exports2.Disposable || (exports2.Disposable = {}));
  var Event21;
  (function(Event22) {
    const _disposable = {dispose() {
    }};
    Event22.None = function() {
      return _disposable;
    };
  })(Event21 = exports2.Event || (exports2.Event = {}));
  var CallbackList = class {
    add(callback, context = null, bucket) {
      if (!this._callbacks) {
        this._callbacks = [];
        this._contexts = [];
      }
      this._callbacks.push(callback);
      this._contexts.push(context);
      if (Array.isArray(bucket)) {
        bucket.push({dispose: () => this.remove(callback, context)});
      }
    }
    remove(callback, context = null) {
      if (!this._callbacks) {
        return;
      }
      var foundCallbackWithDifferentContext = false;
      for (var i = 0, len = this._callbacks.length; i < len; i++) {
        if (this._callbacks[i] === callback) {
          if (this._contexts[i] === context) {
            this._callbacks.splice(i, 1);
            this._contexts.splice(i, 1);
            return;
          } else {
            foundCallbackWithDifferentContext = true;
          }
        }
      }
      if (foundCallbackWithDifferentContext) {
        throw new Error("When adding a listener with a context, you should remove it with the same context");
      }
    }
    invoke(...args) {
      if (!this._callbacks) {
        return [];
      }
      var ret2 = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
      for (var i = 0, len = callbacks.length; i < len; i++) {
        try {
          ret2.push(callbacks[i].apply(contexts[i], args));
        } catch (e) {
          console.error(e);
        }
      }
      return ret2;
    }
    isEmpty() {
      return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
      this._callbacks = void 0;
      this._contexts = void 0;
    }
  };
  var Emitter21 = class {
    constructor(_options) {
      this._options = _options;
    }
    get event() {
      if (!this._event) {
        this._event = (listener, thisArgs, disposables) => {
          if (!this._callbacks) {
            this._callbacks = new CallbackList();
          }
          if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
            this._options.onFirstListenerAdd(this);
          }
          this._callbacks.add(listener, thisArgs);
          let result;
          result = {
            dispose: () => {
              this._callbacks.remove(listener, thisArgs);
              result.dispose = Emitter21._noop;
              if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                this._options.onLastListenerRemove(this);
              }
            }
          };
          if (Array.isArray(disposables)) {
            disposables.push(result);
          }
          return result;
        };
      }
      return this._event;
    }
    fire(event) {
      if (this._callbacks) {
        this._callbacks.invoke.call(this._callbacks, event);
      }
    }
    dispose() {
      if (this._callbacks) {
        this._callbacks.dispose();
        this._callbacks = void 0;
      }
    }
  };
  exports2.Emitter = Emitter21;
  Emitter21._noop = function() {
  };
});

// node_modules/vscode-jsonrpc/lib/messageReader.js
var require_messageReader = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require_events();
  var Is4 = require_is();
  var DefaultSize = 8192;
  var CR = Buffer.from("\r", "ascii")[0];
  var LF = Buffer.from("\n", "ascii")[0];
  var CRLF = "\r\n";
  var MessageBuffer = class {
    constructor(encoding = "utf8") {
      this.encoding = encoding;
      this.index = 0;
      this.buffer = Buffer.allocUnsafe(DefaultSize);
    }
    append(chunk) {
      var toAppend = chunk;
      if (typeof chunk === "string") {
        var str = chunk;
        var bufferLen = Buffer.byteLength(str, this.encoding);
        toAppend = Buffer.allocUnsafe(bufferLen);
        toAppend.write(str, 0, bufferLen, this.encoding);
      }
      if (this.buffer.length - this.index >= toAppend.length) {
        toAppend.copy(this.buffer, this.index, 0, toAppend.length);
      } else {
        var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
        if (this.index === 0) {
          this.buffer = Buffer.allocUnsafe(newSize);
          toAppend.copy(this.buffer, 0, 0, toAppend.length);
        } else {
          this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
        }
      }
      this.index += toAppend.length;
    }
    tryReadHeaders() {
      let result = void 0;
      let current = 0;
      while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
        current++;
      }
      if (current + 3 >= this.index) {
        return result;
      }
      result = Object.create(null);
      let headers = this.buffer.toString("ascii", 0, current).split(CRLF);
      headers.forEach((header) => {
        let index = header.indexOf(":");
        if (index === -1) {
          throw new Error("Message header must separate key and value using :");
        }
        let key = header.substr(0, index);
        let value = header.substr(index + 1).trim();
        result[key] = value;
      });
      let nextStart = current + 4;
      this.buffer = this.buffer.slice(nextStart);
      this.index = this.index - nextStart;
      return result;
    }
    tryReadContent(length) {
      if (this.index < length) {
        return null;
      }
      let result = this.buffer.toString(this.encoding, 0, length);
      let nextStart = length;
      this.buffer.copy(this.buffer, 0, nextStart);
      this.index = this.index - nextStart;
      return result;
    }
    get numberOfBytes() {
      return this.index;
    }
  };
  var MessageReader2;
  (function(MessageReader3) {
    function is6(value) {
      let candidate = value;
      return candidate && Is4.func(candidate.listen) && Is4.func(candidate.dispose) && Is4.func(candidate.onError) && Is4.func(candidate.onClose) && Is4.func(candidate.onPartialMessage);
    }
    MessageReader3.is = is6;
  })(MessageReader2 = exports2.MessageReader || (exports2.MessageReader = {}));
  var AbstractMessageReader = class {
    constructor() {
      this.errorEmitter = new events_1.Emitter();
      this.closeEmitter = new events_1.Emitter();
      this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error) {
      this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    get onPartialMessage() {
      return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
      this.partialMessageEmitter.fire(info);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Reader received error. Reason: ${Is4.string(error.message) ? error.message : "unknown"}`);
      }
    }
  };
  exports2.AbstractMessageReader = AbstractMessageReader;
  var StreamMessageReader2 = class extends AbstractMessageReader {
    constructor(readable, encoding = "utf8") {
      super();
      this.readable = readable;
      this.buffer = new MessageBuffer(encoding);
      this._partialMessageTimeout = 1e4;
    }
    set partialMessageTimeout(timeout) {
      this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
      return this._partialMessageTimeout;
    }
    listen(callback) {
      this.nextMessageLength = -1;
      this.messageToken = 0;
      this.partialMessageTimer = void 0;
      this.callback = callback;
      this.readable.on("data", (data) => {
        this.onData(data);
      });
      this.readable.on("error", (error) => this.fireError(error));
      this.readable.on("close", () => this.fireClose());
    }
    onData(data) {
      this.buffer.append(data);
      while (true) {
        if (this.nextMessageLength === -1) {
          let headers = this.buffer.tryReadHeaders();
          if (!headers) {
            return;
          }
          let contentLength = headers["Content-Length"];
          if (!contentLength) {
            throw new Error("Header must provide a Content-Length property.");
          }
          let length = parseInt(contentLength);
          if (isNaN(length)) {
            throw new Error("Content-Length value must be a number.");
          }
          this.nextMessageLength = length;
        }
        var msg = this.buffer.tryReadContent(this.nextMessageLength);
        if (msg === null) {
          this.setPartialMessageTimer();
          return;
        }
        this.clearPartialMessageTimer();
        this.nextMessageLength = -1;
        this.messageToken++;
        var json = JSON.parse(msg);
        this.callback(json);
      }
    }
    clearPartialMessageTimer() {
      if (this.partialMessageTimer) {
        clearTimeout(this.partialMessageTimer);
        this.partialMessageTimer = void 0;
      }
    }
    setPartialMessageTimer() {
      this.clearPartialMessageTimer();
      if (this._partialMessageTimeout <= 0) {
        return;
      }
      this.partialMessageTimer = setTimeout((token, timeout) => {
        this.partialMessageTimer = void 0;
        if (token === this.messageToken) {
          this.firePartialMessage({messageToken: token, waitingTime: timeout});
          this.setPartialMessageTimer();
        }
      }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
  };
  exports2.StreamMessageReader = StreamMessageReader2;
  var IPCMessageReader2 = class extends AbstractMessageReader {
    constructor(process2) {
      super();
      this.process = process2;
      let eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose());
    }
    listen(callback) {
      this.process.on("message", callback);
    }
  };
  exports2.IPCMessageReader = IPCMessageReader2;
  var SocketMessageReader = class extends StreamMessageReader2 {
    constructor(socket, encoding = "utf-8") {
      super(socket, encoding);
    }
  };
  exports2.SocketMessageReader = SocketMessageReader;
});

// node_modules/vscode-jsonrpc/lib/messageWriter.js
var require_messageWriter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require_events();
  var Is4 = require_is();
  var ContentLength = "Content-Length: ";
  var CRLF = "\r\n";
  var MessageWriter2;
  (function(MessageWriter3) {
    function is6(value) {
      let candidate = value;
      return candidate && Is4.func(candidate.dispose) && Is4.func(candidate.onClose) && Is4.func(candidate.onError) && Is4.func(candidate.write);
    }
    MessageWriter3.is = is6;
  })(MessageWriter2 = exports2.MessageWriter || (exports2.MessageWriter = {}));
  var AbstractMessageWriter = class {
    constructor() {
      this.errorEmitter = new events_1.Emitter();
      this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error, message, count) {
      this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Writer received error. Reason: ${Is4.string(error.message) ? error.message : "unknown"}`);
      }
    }
  };
  exports2.AbstractMessageWriter = AbstractMessageWriter;
  var StreamMessageWriter2 = class extends AbstractMessageWriter {
    constructor(writable, encoding = "utf8") {
      super();
      this.writable = writable;
      this.encoding = encoding;
      this.errorCount = 0;
      this.writable.on("error", (error) => this.fireError(error));
      this.writable.on("close", () => this.fireClose());
    }
    write(msg) {
      let json = JSON.stringify(msg);
      let contentLength = Buffer.byteLength(json, this.encoding);
      let headers = [
        ContentLength,
        contentLength.toString(),
        CRLF,
        CRLF
      ];
      try {
        this.writable.write(headers.join(""), "ascii");
        this.writable.write(json, this.encoding);
        this.errorCount = 0;
      } catch (error) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
    }
  };
  exports2.StreamMessageWriter = StreamMessageWriter2;
  var IPCMessageWriter2 = class extends AbstractMessageWriter {
    constructor(process2) {
      super();
      this.process = process2;
      this.errorCount = 0;
      this.queue = [];
      this.sending = false;
      let eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose);
    }
    write(msg) {
      if (!this.sending && this.queue.length === 0) {
        this.doWriteMessage(msg);
      } else {
        this.queue.push(msg);
      }
    }
    doWriteMessage(msg) {
      try {
        if (this.process.send) {
          this.sending = true;
          this.process.send(msg, void 0, void 0, (error) => {
            this.sending = false;
            if (error) {
              this.errorCount++;
              this.fireError(error, msg, this.errorCount);
            } else {
              this.errorCount = 0;
            }
            if (this.queue.length > 0) {
              this.doWriteMessage(this.queue.shift());
            }
          });
        }
      } catch (error) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
    }
  };
  exports2.IPCMessageWriter = IPCMessageWriter2;
  var SocketMessageWriter = class extends AbstractMessageWriter {
    constructor(socket, encoding = "utf8") {
      super();
      this.socket = socket;
      this.queue = [];
      this.sending = false;
      this.encoding = encoding;
      this.errorCount = 0;
      this.socket.on("error", (error) => this.fireError(error));
      this.socket.on("close", () => this.fireClose());
    }
    dispose() {
      super.dispose();
      this.socket.destroy();
    }
    write(msg) {
      if (!this.sending && this.queue.length === 0) {
        this.doWriteMessage(msg);
      } else {
        this.queue.push(msg);
      }
    }
    doWriteMessage(msg) {
      let json = JSON.stringify(msg);
      let contentLength = Buffer.byteLength(json, this.encoding);
      let headers = [
        ContentLength,
        contentLength.toString(),
        CRLF,
        CRLF
      ];
      try {
        this.sending = true;
        this.socket.write(headers.join(""), "ascii", (error) => {
          if (error) {
            this.handleError(error, msg);
          }
          try {
            this.socket.write(json, this.encoding, (error2) => {
              this.sending = false;
              if (error2) {
                this.handleError(error2, msg);
              } else {
                this.errorCount = 0;
              }
              if (this.queue.length > 0) {
                this.doWriteMessage(this.queue.shift());
              }
            });
          } catch (error2) {
            this.handleError(error2, msg);
          }
        });
      } catch (error) {
        this.handleError(error, msg);
      }
    }
    handleError(error, msg) {
      this.errorCount++;
      this.fireError(error, msg, this.errorCount);
    }
  };
  exports2.SocketMessageWriter = SocketMessageWriter;
});

// node_modules/vscode-jsonrpc/lib/cancellation.js
var require_cancellation = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require_events();
  var Is4 = require_is();
  var CancellationToken43;
  (function(CancellationToken44) {
    CancellationToken44.None = Object.freeze({
      isCancellationRequested: false,
      onCancellationRequested: events_1.Event.None
    });
    CancellationToken44.Cancelled = Object.freeze({
      isCancellationRequested: true,
      onCancellationRequested: events_1.Event.None
    });
    function is6(value) {
      let candidate = value;
      return candidate && (candidate === CancellationToken44.None || candidate === CancellationToken44.Cancelled || Is4.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
    }
    CancellationToken44.is = is6;
  })(CancellationToken43 = exports2.CancellationToken || (exports2.CancellationToken = {}));
  var shortcutEvent = Object.freeze(function(callback, context) {
    let handle = setTimeout(callback.bind(context), 0);
    return {dispose() {
      clearTimeout(handle);
    }};
  });
  var MutableToken = class {
    constructor() {
      this._isCancelled = false;
    }
    cancel() {
      if (!this._isCancelled) {
        this._isCancelled = true;
        if (this._emitter) {
          this._emitter.fire(void 0);
          this.dispose();
        }
      }
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      if (this._isCancelled) {
        return shortcutEvent;
      }
      if (!this._emitter) {
        this._emitter = new events_1.Emitter();
      }
      return this._emitter.event;
    }
    dispose() {
      if (this._emitter) {
        this._emitter.dispose();
        this._emitter = void 0;
      }
    }
  };
  var CancellationTokenSource21 = class {
    get token() {
      if (!this._token) {
        this._token = new MutableToken();
      }
      return this._token;
    }
    cancel() {
      if (!this._token) {
        this._token = CancellationToken43.Cancelled;
      } else {
        this._token.cancel();
      }
    }
    dispose() {
      if (!this._token) {
        this._token = CancellationToken43.None;
      } else if (this._token instanceof MutableToken) {
        this._token.dispose();
      }
    }
  };
  exports2.CancellationTokenSource = CancellationTokenSource21;
});

// node_modules/vscode-jsonrpc/lib/linkedMap.js
var require_linkedMap = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Touch;
  (function(Touch2) {
    Touch2.None = 0;
    Touch2.First = 1;
    Touch2.Last = 2;
  })(Touch = exports2.Touch || (exports2.Touch = {}));
  var LinkedMap = class {
    constructor() {
      this._map = new Map();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    clear() {
      this._map.clear();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      return item.value;
    }
    set(key, value, touch = Touch.None) {
      let item = this._map.get(key);
      if (item) {
        item.value = value;
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
      } else {
        item = {key, value, next: void 0, previous: void 0};
        switch (touch) {
          case Touch.None:
            this.addItemLast(item);
            break;
          case Touch.First:
            this.addItemFirst(item);
            break;
          case Touch.Last:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
            break;
        }
        this._map.set(key, item);
        this._size++;
      }
    }
    delete(key) {
      const item = this._map.get(key);
      if (!item) {
        return false;
      }
      this._map.delete(key);
      this.removeItem(item);
      this._size--;
      return true;
    }
    shift() {
      if (!this._head && !this._tail) {
        return void 0;
      }
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      const item = this._head;
      this._map.delete(item.key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    forEach(callbackfn, thisArg) {
      let current = this._head;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        current = current.next;
      }
    }
    forEachReverse(callbackfn, thisArg) {
      let current = this._tail;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        current = current.previous;
      }
    }
    values() {
      let result = [];
      let current = this._head;
      while (current) {
        result.push(current.value);
        current = current.next;
      }
      return result;
    }
    keys() {
      let result = [];
      let current = this._head;
      while (current) {
        result.push(current.key);
        current = current.next;
      }
      return result;
    }
    addItemFirst(item) {
      if (!this._head && !this._tail) {
        this._tail = item;
      } else if (!this._head) {
        throw new Error("Invalid list");
      } else {
        item.next = this._head;
        this._head.previous = item;
      }
      this._head = item;
    }
    addItemLast(item) {
      if (!this._head && !this._tail) {
        this._head = item;
      } else if (!this._tail) {
        throw new Error("Invalid list");
      } else {
        item.previous = this._tail;
        this._tail.next = item;
      }
      this._tail = item;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) {
        this._head = void 0;
        this._tail = void 0;
      } else if (item === this._head) {
        this._head = item.next;
      } else if (item === this._tail) {
        this._tail = item.previous;
      } else {
        const next = item.next;
        const previous = item.previous;
        if (!next || !previous) {
          throw new Error("Invalid list");
        }
        next.previous = previous;
        previous.next = next;
      }
    }
    touch(item, touch) {
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      if (touch !== Touch.First && touch !== Touch.Last) {
        return;
      }
      if (touch === Touch.First) {
        if (item === this._head) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._tail) {
          previous.next = void 0;
          this._tail = previous;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.previous = void 0;
        item.next = this._head;
        this._head.previous = item;
        this._head = item;
      } else if (touch === Touch.Last) {
        if (item === this._tail) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._head) {
          next.previous = void 0;
          this._head = next;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = this._tail;
        this._tail.next = item;
        this._tail = item;
      }
    }
  };
  exports2.LinkedMap = LinkedMap;
});

// node_modules/vscode-jsonrpc/lib/pipeSupport.js
var require_pipeSupport = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path_1 = require("path");
  var os_1 = require("os");
  var crypto_1 = require("crypto");
  var net_1 = require("net");
  var messageReader_1 = require_messageReader();
  var messageWriter_1 = require_messageWriter();
  function generateRandomPipeName2() {
    const randomSuffix = crypto_1.randomBytes(21).toString("hex");
    if (process.platform === "win32") {
      return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    } else {
      return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
  }
  exports2.generateRandomPipeName = generateRandomPipeName2;
  function createClientPipeTransport2(pipeName, encoding = "utf-8") {
    let connectResolve;
    let connected = new Promise((resolve3, _reject) => {
      connectResolve = resolve3;
    });
    return new Promise((resolve3, reject) => {
      let server = net_1.createServer((socket) => {
        server.close();
        connectResolve([
          new messageReader_1.SocketMessageReader(socket, encoding),
          new messageWriter_1.SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(pipeName, () => {
        server.removeListener("error", reject);
        resolve3({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports2.createClientPipeTransport = createClientPipeTransport2;
  function createServerPipeTransport(pipeName, encoding = "utf-8") {
    const socket = net_1.createConnection(pipeName);
    return [
      new messageReader_1.SocketMessageReader(socket, encoding),
      new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
  }
  exports2.createServerPipeTransport = createServerPipeTransport;
});

// node_modules/vscode-jsonrpc/lib/socketSupport.js
var require_socketSupport = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var net_1 = require("net");
  var messageReader_1 = require_messageReader();
  var messageWriter_1 = require_messageWriter();
  function createClientSocketTransport2(port, encoding = "utf-8") {
    let connectResolve;
    let connected = new Promise((resolve3, _reject) => {
      connectResolve = resolve3;
    });
    return new Promise((resolve3, reject) => {
      let server = net_1.createServer((socket) => {
        server.close();
        connectResolve([
          new messageReader_1.SocketMessageReader(socket, encoding),
          new messageWriter_1.SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(port, "127.0.0.1", () => {
        server.removeListener("error", reject);
        resolve3({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports2.createClientSocketTransport = createClientSocketTransport2;
  function createServerSocketTransport(port, encoding = "utf-8") {
    const socket = net_1.createConnection(port, "127.0.0.1");
    return [
      new messageReader_1.SocketMessageReader(socket, encoding),
      new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
  }
  exports2.createServerSocketTransport = createServerSocketTransport;
});

// node_modules/vscode-jsonrpc/lib/main.js
var require_main = __commonJS((exports2) => {
  "use strict";
  function __export2(m) {
    for (var p in m)
      if (!exports2.hasOwnProperty(p))
        exports2[p] = m[p];
  }
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Is4 = require_is();
  var messages_1 = require_messages();
  exports2.RequestType = messages_1.RequestType;
  exports2.RequestType0 = messages_1.RequestType0;
  exports2.RequestType1 = messages_1.RequestType1;
  exports2.RequestType2 = messages_1.RequestType2;
  exports2.RequestType3 = messages_1.RequestType3;
  exports2.RequestType4 = messages_1.RequestType4;
  exports2.RequestType5 = messages_1.RequestType5;
  exports2.RequestType6 = messages_1.RequestType6;
  exports2.RequestType7 = messages_1.RequestType7;
  exports2.RequestType8 = messages_1.RequestType8;
  exports2.RequestType9 = messages_1.RequestType9;
  exports2.ResponseError = messages_1.ResponseError;
  exports2.ErrorCodes = messages_1.ErrorCodes;
  exports2.NotificationType = messages_1.NotificationType;
  exports2.NotificationType0 = messages_1.NotificationType0;
  exports2.NotificationType1 = messages_1.NotificationType1;
  exports2.NotificationType2 = messages_1.NotificationType2;
  exports2.NotificationType3 = messages_1.NotificationType3;
  exports2.NotificationType4 = messages_1.NotificationType4;
  exports2.NotificationType5 = messages_1.NotificationType5;
  exports2.NotificationType6 = messages_1.NotificationType6;
  exports2.NotificationType7 = messages_1.NotificationType7;
  exports2.NotificationType8 = messages_1.NotificationType8;
  exports2.NotificationType9 = messages_1.NotificationType9;
  var messageReader_1 = require_messageReader();
  exports2.MessageReader = messageReader_1.MessageReader;
  exports2.StreamMessageReader = messageReader_1.StreamMessageReader;
  exports2.IPCMessageReader = messageReader_1.IPCMessageReader;
  exports2.SocketMessageReader = messageReader_1.SocketMessageReader;
  var messageWriter_1 = require_messageWriter();
  exports2.MessageWriter = messageWriter_1.MessageWriter;
  exports2.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
  exports2.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
  exports2.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
  var events_1 = require_events();
  exports2.Disposable = events_1.Disposable;
  exports2.Event = events_1.Event;
  exports2.Emitter = events_1.Emitter;
  var cancellation_1 = require_cancellation();
  exports2.CancellationTokenSource = cancellation_1.CancellationTokenSource;
  exports2.CancellationToken = cancellation_1.CancellationToken;
  var linkedMap_1 = require_linkedMap();
  __export2(require_pipeSupport());
  __export2(require_socketSupport());
  var CancelNotification;
  (function(CancelNotification2) {
    CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
  })(CancelNotification || (CancelNotification = {}));
  var ProgressNotification2;
  (function(ProgressNotification3) {
    ProgressNotification3.type = new messages_1.NotificationType("$/progress");
  })(ProgressNotification2 || (ProgressNotification2 = {}));
  var ProgressType3 = class {
    constructor() {
    }
  };
  exports2.ProgressType = ProgressType3;
  exports2.NullLogger = Object.freeze({
    error: () => {
    },
    warn: () => {
    },
    info: () => {
    },
    log: () => {
    }
  });
  var Trace2;
  (function(Trace3) {
    Trace3[Trace3["Off"] = 0] = "Off";
    Trace3[Trace3["Messages"] = 1] = "Messages";
    Trace3[Trace3["Verbose"] = 2] = "Verbose";
  })(Trace2 = exports2.Trace || (exports2.Trace = {}));
  (function(Trace3) {
    function fromString(value) {
      if (!Is4.string(value)) {
        return Trace3.Off;
      }
      value = value.toLowerCase();
      switch (value) {
        case "off":
          return Trace3.Off;
        case "messages":
          return Trace3.Messages;
        case "verbose":
          return Trace3.Verbose;
        default:
          return Trace3.Off;
      }
    }
    Trace3.fromString = fromString;
    function toString(value) {
      switch (value) {
        case Trace3.Off:
          return "off";
        case Trace3.Messages:
          return "messages";
        case Trace3.Verbose:
          return "verbose";
        default:
          return "off";
      }
    }
    Trace3.toString = toString;
  })(Trace2 = exports2.Trace || (exports2.Trace = {}));
  var TraceFormat2;
  (function(TraceFormat3) {
    TraceFormat3["Text"] = "text";
    TraceFormat3["JSON"] = "json";
  })(TraceFormat2 = exports2.TraceFormat || (exports2.TraceFormat = {}));
  (function(TraceFormat3) {
    function fromString(value) {
      value = value.toLowerCase();
      if (value === "json") {
        return TraceFormat3.JSON;
      } else {
        return TraceFormat3.Text;
      }
    }
    TraceFormat3.fromString = fromString;
  })(TraceFormat2 = exports2.TraceFormat || (exports2.TraceFormat = {}));
  var SetTraceNotification;
  (function(SetTraceNotification2) {
    SetTraceNotification2.type = new messages_1.NotificationType("$/setTraceNotification");
  })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
  var LogTraceNotification;
  (function(LogTraceNotification2) {
    LogTraceNotification2.type = new messages_1.NotificationType("$/logTraceNotification");
  })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
  var ConnectionErrors;
  (function(ConnectionErrors2) {
    ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
    ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
    ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
  })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
  var ConnectionError = class extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
      Object.setPrototypeOf(this, ConnectionError.prototype);
    }
  };
  exports2.ConnectionError = ConnectionError;
  var ConnectionStrategy;
  (function(ConnectionStrategy2) {
    function is6(value) {
      let candidate = value;
      return candidate && Is4.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy2.is = is6;
  })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2[ConnectionState2["New"] = 1] = "New";
    ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
    ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
    ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
  })(ConnectionState || (ConnectionState = {}));
  function _createMessageConnection(messageReader, messageWriter, logger93, strategy) {
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version2 = "2.0";
    let starRequestHandler = void 0;
    let requestHandlers = Object.create(null);
    let starNotificationHandler = void 0;
    let notificationHandlers = Object.create(null);
    let progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace2.Off;
    let traceFormat = TraceFormat2.Text;
    let tracer;
    let state = ConnectionState.New;
    let errorEmitter = new events_1.Emitter();
    let closeEmitter = new events_1.Emitter();
    let unhandledNotificationEmitter = new events_1.Emitter();
    let unhandledProgressEmitter = new events_1.Emitter();
    let disposeEmitter = new events_1.Emitter();
    function createRequestQueueKey(id) {
      return "req-" + id.toString();
    }
    function createResponseQueueKey(id) {
      if (id === null) {
        return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
      } else {
        return "res-" + id.toString();
      }
    }
    function createNotificationQueueKey() {
      return "not-" + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
      if (messages_1.isRequestMessage(message)) {
        queue.set(createRequestQueueKey(message.id), message);
      } else if (messages_1.isResponseMessage(message)) {
        queue.set(createResponseQueueKey(message.id), message);
      } else {
        queue.set(createNotificationQueueKey(), message);
      }
    }
    function cancelUndispatched(_message) {
      return void 0;
    }
    function isListening() {
      return state === ConnectionState.Listening;
    }
    function isClosed() {
      return state === ConnectionState.Closed;
    }
    function isDisposed() {
      return state === ConnectionState.Disposed;
    }
    function closeHandler() {
      if (state === ConnectionState.New || state === ConnectionState.Listening) {
        state = ConnectionState.Closed;
        closeEmitter.fire(void 0);
      }
    }
    function readErrorHandler(error) {
      errorEmitter.fire([error, void 0, void 0]);
    }
    function writeErrorHandler(data) {
      errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
      if (timer || messageQueue.size === 0) {
        return;
      }
      timer = setImmediate(() => {
        timer = void 0;
        processMessageQueue();
      });
    }
    function processMessageQueue() {
      if (messageQueue.size === 0) {
        return;
      }
      let message = messageQueue.shift();
      try {
        if (messages_1.isRequestMessage(message)) {
          handleRequest(message);
        } else if (messages_1.isNotificationMessage(message)) {
          handleNotification(message);
        } else if (messages_1.isResponseMessage(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      } finally {
        triggerMessageQueue();
      }
    }
    let callback = (message) => {
      try {
        if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
          let key = createRequestQueueKey(message.params.id);
          let toCancel = messageQueue.get(key);
          if (messages_1.isRequestMessage(toCancel)) {
            let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
            if (response && (response.error !== void 0 || response.result !== void 0)) {
              messageQueue.delete(key);
              response.id = toCancel.id;
              traceSendingResponse(response, message.method, Date.now());
              messageWriter.write(response);
              return;
            }
          }
        }
        addMessageToQueue(messageQueue, message);
      } finally {
        triggerMessageQueue();
      }
    };
    function handleRequest(requestMessage) {
      if (isDisposed()) {
        return;
      }
      function reply(resultOrError, method, startTime2) {
        let message = {
          jsonrpc: version2,
          id: requestMessage.id
        };
        if (resultOrError instanceof messages_1.ResponseError) {
          message.error = resultOrError.toJson();
        } else {
          message.result = resultOrError === void 0 ? null : resultOrError;
        }
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message);
      }
      function replyError(error, method, startTime2) {
        let message = {
          jsonrpc: version2,
          id: requestMessage.id,
          error: error.toJson()
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message);
      }
      function replySuccess(result, method, startTime2) {
        if (result === void 0) {
          result = null;
        }
        let message = {
          jsonrpc: version2,
          id: requestMessage.id,
          result
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message);
      }
      traceReceivedRequest(requestMessage);
      let element = requestHandlers[requestMessage.method];
      let type;
      let requestHandler;
      if (element) {
        type = element.type;
        requestHandler = element.handler;
      }
      let startTime = Date.now();
      if (requestHandler || starRequestHandler) {
        let cancellationSource = new cancellation_1.CancellationTokenSource();
        let tokenKey = String(requestMessage.id);
        requestTokens[tokenKey] = cancellationSource;
        try {
          let handlerResult;
          if (requestMessage.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
            handlerResult = requestHandler ? requestHandler(cancellationSource.token) : starRequestHandler(requestMessage.method, cancellationSource.token);
          } else if (Is4.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
            handlerResult = requestHandler ? requestHandler(...requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
          } else {
            handlerResult = requestHandler ? requestHandler(requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
          }
          let promise = handlerResult;
          if (!handlerResult) {
            delete requestTokens[tokenKey];
            replySuccess(handlerResult, requestMessage.method, startTime);
          } else if (promise.then) {
            promise.then((resultOrError) => {
              delete requestTokens[tokenKey];
              reply(resultOrError, requestMessage.method, startTime);
            }, (error) => {
              delete requestTokens[tokenKey];
              if (error instanceof messages_1.ResponseError) {
                replyError(error, requestMessage.method, startTime);
              } else if (error && Is4.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            });
          } else {
            delete requestTokens[tokenKey];
            reply(handlerResult, requestMessage.method, startTime);
          }
        } catch (error) {
          delete requestTokens[tokenKey];
          if (error instanceof messages_1.ResponseError) {
            reply(error, requestMessage.method, startTime);
          } else if (error && Is4.string(error.message)) {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
          }
        }
      } else {
        replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
      }
    }
    function handleResponse(responseMessage) {
      if (isDisposed()) {
        return;
      }
      if (responseMessage.id === null) {
        if (responseMessage.error) {
          logger93.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
        } else {
          logger93.error(`Received response message without id. No further error information provided.`);
        }
      } else {
        let key = String(responseMessage.id);
        let responsePromise = responsePromises[key];
        traceReceivedResponse(responseMessage, responsePromise);
        if (responsePromise) {
          delete responsePromises[key];
          try {
            if (responseMessage.error) {
              let error = responseMessage.error;
              responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
            } else if (responseMessage.result !== void 0) {
              responsePromise.resolve(responseMessage.result);
            } else {
              throw new Error("Should never happen.");
            }
          } catch (error) {
            if (error.message) {
              logger93.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
            } else {
              logger93.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
            }
          }
        }
      }
    }
    function handleNotification(message) {
      if (isDisposed()) {
        return;
      }
      let type = void 0;
      let notificationHandler;
      if (message.method === CancelNotification.type.method) {
        notificationHandler = (params) => {
          let id = params.id;
          let source3 = requestTokens[String(id)];
          if (source3) {
            source3.cancel();
          }
        };
      } else {
        let element = notificationHandlers[message.method];
        if (element) {
          notificationHandler = element.handler;
          type = element.type;
        }
      }
      if (notificationHandler || starNotificationHandler) {
        try {
          traceReceivedNotification(message);
          if (message.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
            notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
          } else if (Is4.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
            notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
          } else {
            notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
          }
        } catch (error) {
          if (error.message) {
            logger93.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
          } else {
            logger93.error(`Notification handler '${message.method}' failed unexpectedly.`);
          }
        }
      } else {
        unhandledNotificationEmitter.fire(message);
      }
    }
    function handleInvalidMessage(message) {
      if (!message) {
        logger93.error("Received empty message.");
        return;
      }
      logger93.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
      let responseMessage = message;
      if (Is4.string(responseMessage.id) || Is4.number(responseMessage.id)) {
        let key = String(responseMessage.id);
        let responseHandler = responsePromises[key];
        if (responseHandler) {
          responseHandler.reject(new Error("The received response has neither a result nor an error property."));
        }
      }
    }
    function traceSendingRequest(message) {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat2.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose && message.params) {
          data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
        }
        tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("send-request", message);
      }
    }
    function traceSendingNotification(message) {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat2.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose) {
          if (message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log(`Sending notification '${message.method}'.`, data);
      } else {
        logLSPMessage("send-notification", message);
      }
    }
    function traceSendingResponse(message, method, startTime) {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat2.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose) {
          if (message.error && message.error.data) {
            data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
          } else {
            if (message.result) {
              data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
      } else {
        logLSPMessage("send-response", message);
      }
    }
    function traceReceivedRequest(message) {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat2.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose && message.params) {
          data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
        }
        tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("receive-request", message);
      }
    }
    function traceReceivedNotification(message) {
      if (trace === Trace2.Off || !tracer || message.method === LogTraceNotification.type.method) {
        return;
      }
      if (traceFormat === TraceFormat2.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose) {
          if (message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log(`Received notification '${message.method}'.`, data);
      } else {
        logLSPMessage("receive-notification", message);
      }
    }
    function traceReceivedResponse(message, responsePromise) {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat2.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose) {
          if (message.error && message.error.data) {
            data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
          } else {
            if (message.result) {
              data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        if (responsePromise) {
          let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
          tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
        } else {
          tracer.log(`Received response ${message.id} without active response promise.`, data);
        }
      } else {
        logLSPMessage("receive-response", message);
      }
    }
    function logLSPMessage(type, message) {
      if (!tracer || trace === Trace2.Off) {
        return;
      }
      const lspMessage = {
        isLSPMessage: true,
        type,
        message,
        timestamp: Date.now()
      };
      tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
      if (isClosed()) {
        throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
      }
      if (isDisposed()) {
        throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
      }
    }
    function throwIfListening() {
      if (isListening()) {
        throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
      }
    }
    function throwIfNotListening() {
      if (!isListening()) {
        throw new Error("Call listen() first.");
      }
    }
    function undefinedToNull(param) {
      if (param === void 0) {
        return null;
      } else {
        return param;
      }
    }
    function computeMessageParams(type, params) {
      let result;
      let numberOfParams = type.numberOfParams;
      switch (numberOfParams) {
        case 0:
          result = null;
          break;
        case 1:
          result = undefinedToNull(params[0]);
          break;
        default:
          result = [];
          for (let i = 0; i < params.length && i < numberOfParams; i++) {
            result.push(undefinedToNull(params[i]));
          }
          if (params.length < numberOfParams) {
            for (let i = params.length; i < numberOfParams; i++) {
              result.push(null);
            }
          }
          break;
      }
      return result;
    }
    let connection = {
      sendNotification: (type, ...params) => {
        throwIfClosedOrDisposed();
        let method;
        let messageParams;
        if (Is4.string(type)) {
          method = type;
          switch (params.length) {
            case 0:
              messageParams = null;
              break;
            case 1:
              messageParams = params[0];
              break;
            default:
              messageParams = params;
              break;
          }
        } else {
          method = type.method;
          messageParams = computeMessageParams(type, params);
        }
        let notificationMessage = {
          jsonrpc: version2,
          method,
          params: messageParams
        };
        traceSendingNotification(notificationMessage);
        messageWriter.write(notificationMessage);
      },
      onNotification: (type, handler2) => {
        throwIfClosedOrDisposed();
        if (Is4.func(type)) {
          starNotificationHandler = type;
        } else if (handler2) {
          if (Is4.string(type)) {
            notificationHandlers[type] = {type: void 0, handler: handler2};
          } else {
            notificationHandlers[type.method] = {type, handler: handler2};
          }
        }
      },
      onProgress: (_type, token, handler2) => {
        if (progressHandlers.has(token)) {
          throw new Error(`Progress handler for token ${token} already registered`);
        }
        progressHandlers.set(token, handler2);
        return {
          dispose: () => {
            progressHandlers.delete(token);
          }
        };
      },
      sendProgress: (_type, token, value) => {
        connection.sendNotification(ProgressNotification2.type, {token, value});
      },
      onUnhandledProgress: unhandledProgressEmitter.event,
      sendRequest: (type, ...params) => {
        throwIfClosedOrDisposed();
        throwIfNotListening();
        let method;
        let messageParams;
        let token = void 0;
        if (Is4.string(type)) {
          method = type;
          switch (params.length) {
            case 0:
              messageParams = null;
              break;
            case 1:
              if (cancellation_1.CancellationToken.is(params[0])) {
                messageParams = null;
                token = params[0];
              } else {
                messageParams = undefinedToNull(params[0]);
              }
              break;
            default:
              const last = params.length - 1;
              if (cancellation_1.CancellationToken.is(params[last])) {
                token = params[last];
                if (params.length === 2) {
                  messageParams = undefinedToNull(params[0]);
                } else {
                  messageParams = params.slice(0, last).map((value) => undefinedToNull(value));
                }
              } else {
                messageParams = params.map((value) => undefinedToNull(value));
              }
              break;
          }
        } else {
          method = type.method;
          messageParams = computeMessageParams(type, params);
          let numberOfParams = type.numberOfParams;
          token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
        }
        let id = sequenceNumber++;
        let result = new Promise((resolve3, reject) => {
          let requestMessage = {
            jsonrpc: version2,
            id,
            method,
            params: messageParams
          };
          let responsePromise = {method, timerStart: Date.now(), resolve: resolve3, reject};
          traceSendingRequest(requestMessage);
          try {
            messageWriter.write(requestMessage);
          } catch (e) {
            responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
            responsePromise = null;
          }
          if (responsePromise) {
            responsePromises[String(id)] = responsePromise;
          }
        });
        if (token) {
          token.onCancellationRequested(() => {
            connection.sendNotification(CancelNotification.type, {id});
          });
        }
        return result;
      },
      onRequest: (type, handler2) => {
        throwIfClosedOrDisposed();
        if (Is4.func(type)) {
          starRequestHandler = type;
        } else if (handler2) {
          if (Is4.string(type)) {
            requestHandlers[type] = {type: void 0, handler: handler2};
          } else {
            requestHandlers[type.method] = {type, handler: handler2};
          }
        }
      },
      trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
        let _sendNotification = false;
        let _traceFormat = TraceFormat2.Text;
        if (sendNotificationOrTraceOptions !== void 0) {
          if (Is4.boolean(sendNotificationOrTraceOptions)) {
            _sendNotification = sendNotificationOrTraceOptions;
          } else {
            _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
            _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat2.Text;
          }
        }
        trace = _value;
        traceFormat = _traceFormat;
        if (trace === Trace2.Off) {
          tracer = void 0;
        } else {
          tracer = _tracer;
        }
        if (_sendNotification && !isClosed() && !isDisposed()) {
          connection.sendNotification(SetTraceNotification.type, {value: Trace2.toString(_value)});
        }
      },
      onError: errorEmitter.event,
      onClose: closeEmitter.event,
      onUnhandledNotification: unhandledNotificationEmitter.event,
      onDispose: disposeEmitter.event,
      dispose: () => {
        if (isDisposed()) {
          return;
        }
        state = ConnectionState.Disposed;
        disposeEmitter.fire(void 0);
        let error = new Error("Connection got disposed.");
        Object.keys(responsePromises).forEach((key) => {
          responsePromises[key].reject(error);
        });
        responsePromises = Object.create(null);
        requestTokens = Object.create(null);
        messageQueue = new linkedMap_1.LinkedMap();
        if (Is4.func(messageWriter.dispose)) {
          messageWriter.dispose();
        }
        if (Is4.func(messageReader.dispose)) {
          messageReader.dispose();
        }
      },
      listen: () => {
        throwIfClosedOrDisposed();
        throwIfListening();
        state = ConnectionState.Listening;
        messageReader.listen(callback);
      },
      inspect: () => {
        console.log("inspect");
      }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      tracer.log(params.message, trace === Trace2.Verbose ? params.verbose : void 0);
    });
    connection.onNotification(ProgressNotification2.type, (params) => {
      const handler2 = progressHandlers.get(params.token);
      if (handler2) {
        handler2(params.value);
      } else {
        unhandledProgressEmitter.fire(params);
      }
    });
    return connection;
  }
  function isMessageReader(value) {
    return value.listen !== void 0 && value.read === void 0;
  }
  function isMessageWriter(value) {
    return value.write !== void 0 && value.end === void 0;
  }
  function createMessageConnection(input, output, logger93, strategy) {
    if (!logger93) {
      logger93 = exports2.NullLogger;
    }
    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
    return _createMessageConnection(reader, writer, logger93, strategy);
  }
  exports2.createMessageConnection = createMessageConnection;
});

// node_modules/vscode-languageserver-types/lib/esm/main.js
var require_main2 = __commonJS((exports2) => {
  __export(exports2, {
    CodeAction: () => CodeAction3,
    CodeActionContext: () => CodeActionContext5,
    CodeActionKind: () => CodeActionKind6,
    CodeLens: () => CodeLens5,
    Color: () => Color4,
    ColorInformation: () => ColorInformation6,
    ColorPresentation: () => ColorPresentation4,
    Command: () => Command3,
    CompletionItem: () => CompletionItem4,
    CompletionItemKind: () => CompletionItemKind4,
    CompletionItemTag: () => CompletionItemTag2,
    CompletionList: () => CompletionList3,
    CreateFile: () => CreateFile2,
    DeleteFile: () => DeleteFile2,
    Diagnostic: () => Diagnostic6,
    DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
    DiagnosticSeverity: () => DiagnosticSeverity5,
    DiagnosticTag: () => DiagnosticTag3,
    DocumentHighlight: () => DocumentHighlight5,
    DocumentHighlightKind: () => DocumentHighlightKind2,
    DocumentLink: () => DocumentLink6,
    DocumentSymbol: () => DocumentSymbol8,
    EOL: () => EOL,
    FoldingRange: () => FoldingRange4,
    FoldingRangeKind: () => FoldingRangeKind,
    FormattingOptions: () => FormattingOptions6,
    Hover: () => Hover5,
    InsertTextFormat: () => InsertTextFormat3,
    Location: () => Location20,
    LocationLink: () => LocationLink6,
    MarkedString: () => MarkedString2,
    MarkupContent: () => MarkupContent4,
    MarkupKind: () => MarkupKind4,
    ParameterInformation: () => ParameterInformation,
    Position: () => Position35,
    Range: () => Range34,
    RenameFile: () => RenameFile2,
    SelectionRange: () => SelectionRange5,
    SignatureInformation: () => SignatureInformation,
    SymbolInformation: () => SymbolInformation7,
    SymbolKind: () => SymbolKind3,
    SymbolTag: () => SymbolTag2,
    TextDocument: () => TextDocument5,
    TextDocumentEdit: () => TextDocumentEdit5,
    TextDocumentIdentifier: () => TextDocumentIdentifier,
    TextDocumentItem: () => TextDocumentItem,
    TextEdit: () => TextEdit18,
    VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
    WorkspaceChange: () => WorkspaceChange,
    WorkspaceEdit: () => WorkspaceEdit8
  });
  "use strict";
  var Position35;
  (function(Position36) {
    function create(line, character) {
      return {line, character};
    }
    Position36.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.objectLiteral(candidate) && Is4.number(candidate.line) && Is4.number(candidate.character);
    }
    Position36.is = is6;
  })(Position35 || (Position35 = {}));
  var Range34;
  (function(Range35) {
    function create(one, two, three, four) {
      if (Is4.number(one) && Is4.number(two) && Is4.number(three) && Is4.number(four)) {
        return {start: Position35.create(one, two), end: Position35.create(three, four)};
      } else if (Position35.is(one) && Position35.is(two)) {
        return {start: one, end: two};
      } else {
        throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
      }
    }
    Range35.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.objectLiteral(candidate) && Position35.is(candidate.start) && Position35.is(candidate.end);
    }
    Range35.is = is6;
  })(Range34 || (Range34 = {}));
  var Location20;
  (function(Location21) {
    function create(uri, range2) {
      return {uri, range: range2};
    }
    Location21.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Range34.is(candidate.range) && (Is4.string(candidate.uri) || Is4.undefined(candidate.uri));
    }
    Location21.is = is6;
  })(Location20 || (Location20 = {}));
  var LocationLink6;
  (function(LocationLink7) {
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
      return {targetUri, targetRange, targetSelectionRange, originSelectionRange};
    }
    LocationLink7.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Range34.is(candidate.targetRange) && Is4.string(candidate.targetUri) && (Range34.is(candidate.targetSelectionRange) || Is4.undefined(candidate.targetSelectionRange)) && (Range34.is(candidate.originSelectionRange) || Is4.undefined(candidate.originSelectionRange));
    }
    LocationLink7.is = is6;
  })(LocationLink6 || (LocationLink6 = {}));
  var Color4;
  (function(Color5) {
    function create(red, green, blue2, alpha) {
      return {
        red,
        green,
        blue: blue2,
        alpha
      };
    }
    Color5.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.number(candidate.red) && Is4.number(candidate.green) && Is4.number(candidate.blue) && Is4.number(candidate.alpha);
    }
    Color5.is = is6;
  })(Color4 || (Color4 = {}));
  var ColorInformation6;
  (function(ColorInformation7) {
    function create(range2, color) {
      return {
        range: range2,
        color
      };
    }
    ColorInformation7.create = create;
    function is6(value) {
      var candidate = value;
      return Range34.is(candidate.range) && Color4.is(candidate.color);
    }
    ColorInformation7.is = is6;
  })(ColorInformation6 || (ColorInformation6 = {}));
  var ColorPresentation4;
  (function(ColorPresentation5) {
    function create(label, textEdit, additionalTextEdits) {
      return {
        label,
        textEdit,
        additionalTextEdits
      };
    }
    ColorPresentation5.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.string(candidate.label) && (Is4.undefined(candidate.textEdit) || TextEdit18.is(candidate)) && (Is4.undefined(candidate.additionalTextEdits) || Is4.typedArray(candidate.additionalTextEdits, TextEdit18.is));
    }
    ColorPresentation5.is = is6;
  })(ColorPresentation4 || (ColorPresentation4 = {}));
  var FoldingRangeKind;
  (function(FoldingRangeKind2) {
    FoldingRangeKind2["Comment"] = "comment";
    FoldingRangeKind2["Imports"] = "imports";
    FoldingRangeKind2["Region"] = "region";
  })(FoldingRangeKind || (FoldingRangeKind = {}));
  var FoldingRange4;
  (function(FoldingRange5) {
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
      var result = {
        startLine,
        endLine
      };
      if (Is4.defined(startCharacter)) {
        result.startCharacter = startCharacter;
      }
      if (Is4.defined(endCharacter)) {
        result.endCharacter = endCharacter;
      }
      if (Is4.defined(kind)) {
        result.kind = kind;
      }
      return result;
    }
    FoldingRange5.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.number(candidate.startLine) && Is4.number(candidate.startLine) && (Is4.undefined(candidate.startCharacter) || Is4.number(candidate.startCharacter)) && (Is4.undefined(candidate.endCharacter) || Is4.number(candidate.endCharacter)) && (Is4.undefined(candidate.kind) || Is4.string(candidate.kind));
    }
    FoldingRange5.is = is6;
  })(FoldingRange4 || (FoldingRange4 = {}));
  var DiagnosticRelatedInformation;
  (function(DiagnosticRelatedInformation2) {
    function create(location5, message) {
      return {
        location: location5,
        message
      };
    }
    DiagnosticRelatedInformation2.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Location20.is(candidate.location) && Is4.string(candidate.message);
    }
    DiagnosticRelatedInformation2.is = is6;
  })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
  var DiagnosticSeverity5;
  (function(DiagnosticSeverity6) {
    DiagnosticSeverity6.Error = 1;
    DiagnosticSeverity6.Warning = 2;
    DiagnosticSeverity6.Information = 3;
    DiagnosticSeverity6.Hint = 4;
  })(DiagnosticSeverity5 || (DiagnosticSeverity5 = {}));
  var DiagnosticTag3;
  (function(DiagnosticTag4) {
    DiagnosticTag4.Unnecessary = 1;
    DiagnosticTag4.Deprecated = 2;
  })(DiagnosticTag3 || (DiagnosticTag3 = {}));
  var Diagnostic6;
  (function(Diagnostic7) {
    function create(range2, message, severity, code, source3, relatedInformation) {
      var result = {range: range2, message};
      if (Is4.defined(severity)) {
        result.severity = severity;
      }
      if (Is4.defined(code)) {
        result.code = code;
      }
      if (Is4.defined(source3)) {
        result.source = source3;
      }
      if (Is4.defined(relatedInformation)) {
        result.relatedInformation = relatedInformation;
      }
      return result;
    }
    Diagnostic7.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Range34.is(candidate.range) && Is4.string(candidate.message) && (Is4.number(candidate.severity) || Is4.undefined(candidate.severity)) && (Is4.number(candidate.code) || Is4.string(candidate.code) || Is4.undefined(candidate.code)) && (Is4.string(candidate.source) || Is4.undefined(candidate.source)) && (Is4.undefined(candidate.relatedInformation) || Is4.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic7.is = is6;
  })(Diagnostic6 || (Diagnostic6 = {}));
  var Command3;
  (function(Command4) {
    function create(title, command) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var result = {title, command};
      if (Is4.defined(args) && args.length > 0) {
        result.arguments = args;
      }
      return result;
    }
    Command4.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Is4.string(candidate.title) && Is4.string(candidate.command);
    }
    Command4.is = is6;
  })(Command3 || (Command3 = {}));
  var TextEdit18;
  (function(TextEdit19) {
    function replace(range2, newText) {
      return {range: range2, newText};
    }
    TextEdit19.replace = replace;
    function insert(position15, newText) {
      return {range: {start: position15, end: position15}, newText};
    }
    TextEdit19.insert = insert;
    function del(range2) {
      return {range: range2, newText: ""};
    }
    TextEdit19.del = del;
    function is6(value) {
      var candidate = value;
      return Is4.objectLiteral(candidate) && Is4.string(candidate.newText) && Range34.is(candidate.range);
    }
    TextEdit19.is = is6;
  })(TextEdit18 || (TextEdit18 = {}));
  var TextDocumentEdit5;
  (function(TextDocumentEdit6) {
    function create(textDocument, edits) {
      return {textDocument, edits};
    }
    TextDocumentEdit6.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && VersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
    }
    TextDocumentEdit6.is = is6;
  })(TextDocumentEdit5 || (TextDocumentEdit5 = {}));
  var CreateFile2;
  (function(CreateFile3) {
    function create(uri, options) {
      var result = {
        kind: "create",
        uri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      return result;
    }
    CreateFile3.create = create;
    function is6(value) {
      var candidate = value;
      return candidate && candidate.kind === "create" && Is4.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is4.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is4.boolean(candidate.options.ignoreIfExists)));
    }
    CreateFile3.is = is6;
  })(CreateFile2 || (CreateFile2 = {}));
  var RenameFile2;
  (function(RenameFile3) {
    function create(oldUri, newUri, options) {
      var result = {
        kind: "rename",
        oldUri,
        newUri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      return result;
    }
    RenameFile3.create = create;
    function is6(value) {
      var candidate = value;
      return candidate && candidate.kind === "rename" && Is4.string(candidate.oldUri) && Is4.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is4.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is4.boolean(candidate.options.ignoreIfExists)));
    }
    RenameFile3.is = is6;
  })(RenameFile2 || (RenameFile2 = {}));
  var DeleteFile2;
  (function(DeleteFile3) {
    function create(uri, options) {
      var result = {
        kind: "delete",
        uri
      };
      if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
        result.options = options;
      }
      return result;
    }
    DeleteFile3.create = create;
    function is6(value) {
      var candidate = value;
      return candidate && candidate.kind === "delete" && Is4.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is4.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is4.boolean(candidate.options.ignoreIfNotExists)));
    }
    DeleteFile3.is = is6;
  })(DeleteFile2 || (DeleteFile2 = {}));
  var WorkspaceEdit8;
  (function(WorkspaceEdit9) {
    function is6(value) {
      var candidate = value;
      return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
        if (Is4.string(change.kind)) {
          return CreateFile2.is(change) || RenameFile2.is(change) || DeleteFile2.is(change);
        } else {
          return TextDocumentEdit5.is(change);
        }
      }));
    }
    WorkspaceEdit9.is = is6;
  })(WorkspaceEdit8 || (WorkspaceEdit8 = {}));
  var TextEditChangeImpl = function() {
    function TextEditChangeImpl2(edits) {
      this.edits = edits;
    }
    TextEditChangeImpl2.prototype.insert = function(position15, newText) {
      this.edits.push(TextEdit18.insert(position15, newText));
    };
    TextEditChangeImpl2.prototype.replace = function(range2, newText) {
      this.edits.push(TextEdit18.replace(range2, newText));
    };
    TextEditChangeImpl2.prototype.delete = function(range2) {
      this.edits.push(TextEdit18.del(range2));
    };
    TextEditChangeImpl2.prototype.add = function(edit2) {
      this.edits.push(edit2);
    };
    TextEditChangeImpl2.prototype.all = function() {
      return this.edits;
    };
    TextEditChangeImpl2.prototype.clear = function() {
      this.edits.splice(0, this.edits.length);
    };
    return TextEditChangeImpl2;
  }();
  var WorkspaceChange = function() {
    function WorkspaceChange2(workspaceEdit) {
      var _this = this;
      this._textEditChanges = Object.create(null);
      if (workspaceEdit) {
        this._workspaceEdit = workspaceEdit;
        if (workspaceEdit.documentChanges) {
          workspaceEdit.documentChanges.forEach(function(change) {
            if (TextDocumentEdit5.is(change)) {
              var textEditChange = new TextEditChangeImpl(change.edits);
              _this._textEditChanges[change.textDocument.uri] = textEditChange;
            }
          });
        } else if (workspaceEdit.changes) {
          Object.keys(workspaceEdit.changes).forEach(function(key) {
            var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
            _this._textEditChanges[key] = textEditChange;
          });
        }
      }
    }
    Object.defineProperty(WorkspaceChange2.prototype, "edit", {
      get: function() {
        return this._workspaceEdit;
      },
      enumerable: true,
      configurable: true
    });
    WorkspaceChange2.prototype.getTextEditChange = function(key) {
      if (VersionedTextDocumentIdentifier.is(key)) {
        if (!this._workspaceEdit) {
          this._workspaceEdit = {
            documentChanges: []
          };
        }
        if (!this._workspaceEdit.documentChanges) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var textDocument = key;
        var result = this._textEditChanges[textDocument.uri];
        if (!result) {
          var edits = [];
          var textDocumentEdit = {
            textDocument,
            edits
          };
          this._workspaceEdit.documentChanges.push(textDocumentEdit);
          result = new TextEditChangeImpl(edits);
          this._textEditChanges[textDocument.uri] = result;
        }
        return result;
      } else {
        if (!this._workspaceEdit) {
          this._workspaceEdit = {
            changes: Object.create(null)
          };
        }
        if (!this._workspaceEdit.changes) {
          throw new Error("Workspace edit is not configured for normal text edit changes.");
        }
        var result = this._textEditChanges[key];
        if (!result) {
          var edits = [];
          this._workspaceEdit.changes[key] = edits;
          result = new TextEditChangeImpl(edits);
          this._textEditChanges[key] = result;
        }
        return result;
      }
    };
    WorkspaceChange2.prototype.createFile = function(uri, options) {
      this.checkDocumentChanges();
      this._workspaceEdit.documentChanges.push(CreateFile2.create(uri, options));
    };
    WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, options) {
      this.checkDocumentChanges();
      this._workspaceEdit.documentChanges.push(RenameFile2.create(oldUri, newUri, options));
    };
    WorkspaceChange2.prototype.deleteFile = function(uri, options) {
      this.checkDocumentChanges();
      this._workspaceEdit.documentChanges.push(DeleteFile2.create(uri, options));
    };
    WorkspaceChange2.prototype.checkDocumentChanges = function() {
      if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
    };
    return WorkspaceChange2;
  }();
  var TextDocumentIdentifier;
  (function(TextDocumentIdentifier2) {
    function create(uri) {
      return {uri};
    }
    TextDocumentIdentifier2.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Is4.string(candidate.uri);
    }
    TextDocumentIdentifier2.is = is6;
  })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
  var VersionedTextDocumentIdentifier;
  (function(VersionedTextDocumentIdentifier2) {
    function create(uri, version2) {
      return {uri, version: version2};
    }
    VersionedTextDocumentIdentifier2.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Is4.string(candidate.uri) && (candidate.version === null || Is4.number(candidate.version));
    }
    VersionedTextDocumentIdentifier2.is = is6;
  })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
  var TextDocumentItem;
  (function(TextDocumentItem2) {
    function create(uri, languageId, version2, text) {
      return {uri, languageId, version: version2, text};
    }
    TextDocumentItem2.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Is4.string(candidate.uri) && Is4.string(candidate.languageId) && Is4.number(candidate.version) && Is4.string(candidate.text);
    }
    TextDocumentItem2.is = is6;
  })(TextDocumentItem || (TextDocumentItem = {}));
  var MarkupKind4;
  (function(MarkupKind5) {
    MarkupKind5.PlainText = "plaintext";
    MarkupKind5.Markdown = "markdown";
  })(MarkupKind4 || (MarkupKind4 = {}));
  (function(MarkupKind5) {
    function is6(value) {
      var candidate = value;
      return candidate === MarkupKind5.PlainText || candidate === MarkupKind5.Markdown;
    }
    MarkupKind5.is = is6;
  })(MarkupKind4 || (MarkupKind4 = {}));
  var MarkupContent4;
  (function(MarkupContent5) {
    function is6(value) {
      var candidate = value;
      return Is4.objectLiteral(value) && MarkupKind4.is(candidate.kind) && Is4.string(candidate.value);
    }
    MarkupContent5.is = is6;
  })(MarkupContent4 || (MarkupContent4 = {}));
  var CompletionItemKind4;
  (function(CompletionItemKind5) {
    CompletionItemKind5.Text = 1;
    CompletionItemKind5.Method = 2;
    CompletionItemKind5.Function = 3;
    CompletionItemKind5.Constructor = 4;
    CompletionItemKind5.Field = 5;
    CompletionItemKind5.Variable = 6;
    CompletionItemKind5.Class = 7;
    CompletionItemKind5.Interface = 8;
    CompletionItemKind5.Module = 9;
    CompletionItemKind5.Property = 10;
    CompletionItemKind5.Unit = 11;
    CompletionItemKind5.Value = 12;
    CompletionItemKind5.Enum = 13;
    CompletionItemKind5.Keyword = 14;
    CompletionItemKind5.Snippet = 15;
    CompletionItemKind5.Color = 16;
    CompletionItemKind5.File = 17;
    CompletionItemKind5.Reference = 18;
    CompletionItemKind5.Folder = 19;
    CompletionItemKind5.EnumMember = 20;
    CompletionItemKind5.Constant = 21;
    CompletionItemKind5.Struct = 22;
    CompletionItemKind5.Event = 23;
    CompletionItemKind5.Operator = 24;
    CompletionItemKind5.TypeParameter = 25;
  })(CompletionItemKind4 || (CompletionItemKind4 = {}));
  var InsertTextFormat3;
  (function(InsertTextFormat4) {
    InsertTextFormat4.PlainText = 1;
    InsertTextFormat4.Snippet = 2;
  })(InsertTextFormat3 || (InsertTextFormat3 = {}));
  var CompletionItemTag2;
  (function(CompletionItemTag3) {
    CompletionItemTag3.Deprecated = 1;
  })(CompletionItemTag2 || (CompletionItemTag2 = {}));
  var CompletionItem4;
  (function(CompletionItem5) {
    function create(label) {
      return {label};
    }
    CompletionItem5.create = create;
  })(CompletionItem4 || (CompletionItem4 = {}));
  var CompletionList3;
  (function(CompletionList4) {
    function create(items, isIncomplete) {
      return {items: items ? items : [], isIncomplete: !!isIncomplete};
    }
    CompletionList4.create = create;
  })(CompletionList3 || (CompletionList3 = {}));
  var MarkedString2;
  (function(MarkedString3) {
    function fromPlainText(plainText) {
      return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
    }
    MarkedString3.fromPlainText = fromPlainText;
    function is6(value) {
      var candidate = value;
      return Is4.string(candidate) || Is4.objectLiteral(candidate) && Is4.string(candidate.language) && Is4.string(candidate.value);
    }
    MarkedString3.is = is6;
  })(MarkedString2 || (MarkedString2 = {}));
  var Hover5;
  (function(Hover6) {
    function is6(value) {
      var candidate = value;
      return !!candidate && Is4.objectLiteral(candidate) && (MarkupContent4.is(candidate.contents) || MarkedString2.is(candidate.contents) || Is4.typedArray(candidate.contents, MarkedString2.is)) && (value.range === void 0 || Range34.is(value.range));
    }
    Hover6.is = is6;
  })(Hover5 || (Hover5 = {}));
  var ParameterInformation;
  (function(ParameterInformation2) {
    function create(label, documentation) {
      return documentation ? {label, documentation} : {label};
    }
    ParameterInformation2.create = create;
  })(ParameterInformation || (ParameterInformation = {}));
  var SignatureInformation;
  (function(SignatureInformation2) {
    function create(label, documentation) {
      var parameters = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        parameters[_i - 2] = arguments[_i];
      }
      var result = {label};
      if (Is4.defined(documentation)) {
        result.documentation = documentation;
      }
      if (Is4.defined(parameters)) {
        result.parameters = parameters;
      } else {
        result.parameters = [];
      }
      return result;
    }
    SignatureInformation2.create = create;
  })(SignatureInformation || (SignatureInformation = {}));
  var DocumentHighlightKind2;
  (function(DocumentHighlightKind3) {
    DocumentHighlightKind3.Text = 1;
    DocumentHighlightKind3.Read = 2;
    DocumentHighlightKind3.Write = 3;
  })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
  var DocumentHighlight5;
  (function(DocumentHighlight6) {
    function create(range2, kind) {
      var result = {range: range2};
      if (Is4.number(kind)) {
        result.kind = kind;
      }
      return result;
    }
    DocumentHighlight6.create = create;
  })(DocumentHighlight5 || (DocumentHighlight5 = {}));
  var SymbolKind3;
  (function(SymbolKind4) {
    SymbolKind4.File = 1;
    SymbolKind4.Module = 2;
    SymbolKind4.Namespace = 3;
    SymbolKind4.Package = 4;
    SymbolKind4.Class = 5;
    SymbolKind4.Method = 6;
    SymbolKind4.Property = 7;
    SymbolKind4.Field = 8;
    SymbolKind4.Constructor = 9;
    SymbolKind4.Enum = 10;
    SymbolKind4.Interface = 11;
    SymbolKind4.Function = 12;
    SymbolKind4.Variable = 13;
    SymbolKind4.Constant = 14;
    SymbolKind4.String = 15;
    SymbolKind4.Number = 16;
    SymbolKind4.Boolean = 17;
    SymbolKind4.Array = 18;
    SymbolKind4.Object = 19;
    SymbolKind4.Key = 20;
    SymbolKind4.Null = 21;
    SymbolKind4.EnumMember = 22;
    SymbolKind4.Struct = 23;
    SymbolKind4.Event = 24;
    SymbolKind4.Operator = 25;
    SymbolKind4.TypeParameter = 26;
  })(SymbolKind3 || (SymbolKind3 = {}));
  var SymbolTag2;
  (function(SymbolTag3) {
    SymbolTag3.Deprecated = 1;
  })(SymbolTag2 || (SymbolTag2 = {}));
  var SymbolInformation7;
  (function(SymbolInformation8) {
    function create(name2, kind, range2, uri, containerName) {
      var result = {
        name: name2,
        kind,
        location: {uri, range: range2}
      };
      if (containerName) {
        result.containerName = containerName;
      }
      return result;
    }
    SymbolInformation8.create = create;
  })(SymbolInformation7 || (SymbolInformation7 = {}));
  var DocumentSymbol8;
  (function(DocumentSymbol9) {
    function create(name2, detail, kind, range2, selectionRange2, children) {
      var result = {
        name: name2,
        detail,
        kind,
        range: range2,
        selectionRange: selectionRange2
      };
      if (children !== void 0) {
        result.children = children;
      }
      return result;
    }
    DocumentSymbol9.create = create;
    function is6(value) {
      var candidate = value;
      return candidate && Is4.string(candidate.name) && Is4.number(candidate.kind) && Range34.is(candidate.range) && Range34.is(candidate.selectionRange) && (candidate.detail === void 0 || Is4.string(candidate.detail)) && (candidate.deprecated === void 0 || Is4.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children));
    }
    DocumentSymbol9.is = is6;
  })(DocumentSymbol8 || (DocumentSymbol8 = {}));
  var CodeActionKind6;
  (function(CodeActionKind7) {
    CodeActionKind7.Empty = "";
    CodeActionKind7.QuickFix = "quickfix";
    CodeActionKind7.Refactor = "refactor";
    CodeActionKind7.RefactorExtract = "refactor.extract";
    CodeActionKind7.RefactorInline = "refactor.inline";
    CodeActionKind7.RefactorRewrite = "refactor.rewrite";
    CodeActionKind7.Source = "source";
    CodeActionKind7.SourceOrganizeImports = "source.organizeImports";
    CodeActionKind7.SourceFixAll = "source.fixAll";
  })(CodeActionKind6 || (CodeActionKind6 = {}));
  var CodeActionContext5;
  (function(CodeActionContext6) {
    function create(diagnostics2, only) {
      var result = {diagnostics: diagnostics2};
      if (only !== void 0 && only !== null) {
        result.only = only;
      }
      return result;
    }
    CodeActionContext6.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Is4.typedArray(candidate.diagnostics, Diagnostic6.is) && (candidate.only === void 0 || Is4.typedArray(candidate.only, Is4.string));
    }
    CodeActionContext6.is = is6;
  })(CodeActionContext5 || (CodeActionContext5 = {}));
  var CodeAction3;
  (function(CodeAction4) {
    function create(title, commandOrEdit, kind) {
      var result = {title};
      if (Command3.is(commandOrEdit)) {
        result.command = commandOrEdit;
      } else {
        result.edit = commandOrEdit;
      }
      if (kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    CodeAction4.create = create;
    function is6(value) {
      var candidate = value;
      return candidate && Is4.string(candidate.title) && (candidate.diagnostics === void 0 || Is4.typedArray(candidate.diagnostics, Diagnostic6.is)) && (candidate.kind === void 0 || Is4.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command3.is(candidate.command)) && (candidate.isPreferred === void 0 || Is4.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit8.is(candidate.edit));
    }
    CodeAction4.is = is6;
  })(CodeAction3 || (CodeAction3 = {}));
  var CodeLens5;
  (function(CodeLens6) {
    function create(range2, data) {
      var result = {range: range2};
      if (Is4.defined(data)) {
        result.data = data;
      }
      return result;
    }
    CodeLens6.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Range34.is(candidate.range) && (Is4.undefined(candidate.command) || Command3.is(candidate.command));
    }
    CodeLens6.is = is6;
  })(CodeLens5 || (CodeLens5 = {}));
  var FormattingOptions6;
  (function(FormattingOptions7) {
    function create(tabSize, insertSpaces) {
      return {tabSize, insertSpaces};
    }
    FormattingOptions7.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Is4.number(candidate.tabSize) && Is4.boolean(candidate.insertSpaces);
    }
    FormattingOptions7.is = is6;
  })(FormattingOptions6 || (FormattingOptions6 = {}));
  var DocumentLink6;
  (function(DocumentLink7) {
    function create(range2, target, data) {
      return {range: range2, target, data};
    }
    DocumentLink7.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Range34.is(candidate.range) && (Is4.undefined(candidate.target) || Is4.string(candidate.target));
    }
    DocumentLink7.is = is6;
  })(DocumentLink6 || (DocumentLink6 = {}));
  var SelectionRange5;
  (function(SelectionRange6) {
    function create(range2, parent) {
      return {range: range2, parent};
    }
    SelectionRange6.create = create;
    function is6(value) {
      var candidate = value;
      return candidate !== void 0 && Range34.is(candidate.range) && (candidate.parent === void 0 || SelectionRange6.is(candidate.parent));
    }
    SelectionRange6.is = is6;
  })(SelectionRange5 || (SelectionRange5 = {}));
  var EOL = ["\n", "\r\n", "\r"];
  var TextDocument5;
  (function(TextDocument6) {
    function create(uri, languageId, version2, content) {
      return new FullTextDocument2(uri, languageId, version2, content);
    }
    TextDocument6.create = create;
    function is6(value) {
      var candidate = value;
      return Is4.defined(candidate) && Is4.string(candidate.uri) && (Is4.undefined(candidate.languageId) || Is4.string(candidate.languageId)) && Is4.number(candidate.lineCount) && Is4.func(candidate.getText) && Is4.func(candidate.positionAt) && Is4.func(candidate.offsetAt) ? true : false;
    }
    TextDocument6.is = is6;
    function applyEdits2(document3, edits) {
      var text = document3.getText();
      var sortedEdits = mergeSort2(edits, function(a, b) {
        var diff3 = a.range.start.line - b.range.start.line;
        if (diff3 === 0) {
          return a.range.start.character - b.range.start.character;
        }
        return diff3;
      });
      var lastModifiedOffset = text.length;
      for (var i = sortedEdits.length - 1; i >= 0; i--) {
        var e = sortedEdits[i];
        var startOffset = document3.offsetAt(e.range.start);
        var endOffset = document3.offsetAt(e.range.end);
        if (endOffset <= lastModifiedOffset) {
          text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
        } else {
          throw new Error("Overlapping edit");
        }
        lastModifiedOffset = startOffset;
      }
      return text;
    }
    TextDocument6.applyEdits = applyEdits2;
    function mergeSort2(data, compare) {
      if (data.length <= 1) {
        return data;
      }
      var p = data.length / 2 | 0;
      var left = data.slice(0, p);
      var right = data.slice(p);
      mergeSort2(left, compare);
      mergeSort2(right, compare);
      var leftIdx = 0;
      var rightIdx = 0;
      var i = 0;
      while (leftIdx < left.length && rightIdx < right.length) {
        var ret2 = compare(left[leftIdx], right[rightIdx]);
        if (ret2 <= 0) {
          data[i++] = left[leftIdx++];
        } else {
          data[i++] = right[rightIdx++];
        }
      }
      while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
      }
      while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
      }
      return data;
    }
  })(TextDocument5 || (TextDocument5 = {}));
  var FullTextDocument2 = function() {
    function FullTextDocument3(uri, languageId, version2, content) {
      this._uri = uri;
      this._languageId = languageId;
      this._version = version2;
      this._content = content;
      this._lineOffsets = void 0;
    }
    Object.defineProperty(FullTextDocument3.prototype, "uri", {
      get: function() {
        return this._uri;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FullTextDocument3.prototype, "languageId", {
      get: function() {
        return this._languageId;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FullTextDocument3.prototype, "version", {
      get: function() {
        return this._version;
      },
      enumerable: true,
      configurable: true
    });
    FullTextDocument3.prototype.getText = function(range2) {
      if (range2) {
        var start = this.offsetAt(range2.start);
        var end = this.offsetAt(range2.end);
        return this._content.substring(start, end);
      }
      return this._content;
    };
    FullTextDocument3.prototype.update = function(event, version2) {
      this._content = event.text;
      this._version = version2;
      this._lineOffsets = void 0;
    };
    FullTextDocument3.prototype.getLineOffsets = function() {
      if (this._lineOffsets === void 0) {
        var lineOffsets = [];
        var text = this._content;
        var isLineStart = true;
        for (var i = 0; i < text.length; i++) {
          if (isLineStart) {
            lineOffsets.push(i);
            isLineStart = false;
          }
          var ch = text.charAt(i);
          isLineStart = ch === "\r" || ch === "\n";
          if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
            i++;
          }
        }
        if (isLineStart && text.length > 0) {
          lineOffsets.push(text.length);
        }
        this._lineOffsets = lineOffsets;
      }
      return this._lineOffsets;
    };
    FullTextDocument3.prototype.positionAt = function(offset) {
      offset = Math.max(Math.min(offset, this._content.length), 0);
      var lineOffsets = this.getLineOffsets();
      var low = 0, high = lineOffsets.length;
      if (high === 0) {
        return Position35.create(0, offset);
      }
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
          high = mid;
        } else {
          low = mid + 1;
        }
      }
      var line = low - 1;
      return Position35.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument3.prototype.offsetAt = function(position15) {
      var lineOffsets = this.getLineOffsets();
      if (position15.line >= lineOffsets.length) {
        return this._content.length;
      } else if (position15.line < 0) {
        return 0;
      }
      var lineOffset = lineOffsets[position15.line];
      var nextLineOffset = position15.line + 1 < lineOffsets.length ? lineOffsets[position15.line + 1] : this._content.length;
      return Math.max(Math.min(lineOffset + position15.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
      get: function() {
        return this.getLineOffsets().length;
      },
      enumerable: true,
      configurable: true
    });
    return FullTextDocument3;
  }();
  var Is4;
  (function(Is5) {
    var toString = Object.prototype.toString;
    function defined(value) {
      return typeof value !== "undefined";
    }
    Is5.defined = defined;
    function undefined2(value) {
      return typeof value === "undefined";
    }
    Is5.undefined = undefined2;
    function boolean2(value) {
      return value === true || value === false;
    }
    Is5.boolean = boolean2;
    function string23(value) {
      return toString.call(value) === "[object String]";
    }
    Is5.string = string23;
    function number2(value) {
      return toString.call(value) === "[object Number]";
    }
    Is5.number = number2;
    function func2(value) {
      return toString.call(value) === "[object Function]";
    }
    Is5.func = func2;
    function objectLiteral2(value) {
      return value !== null && typeof value === "object";
    }
    Is5.objectLiteral = objectLiteral2;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    Is5.typedArray = typedArray;
  })(Is4 || (Is4 = {}));
});

// node_modules/vscode-languageserver-protocol/lib/utils/is.js
var require_is2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function boolean2(value) {
    return value === true || value === false;
  }
  exports2.boolean = boolean2;
  function string23(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports2.string = string23;
  function number2(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports2.number = number2;
  function error(value) {
    return value instanceof Error;
  }
  exports2.error = error;
  function func2(value) {
    return typeof value === "function";
  }
  exports2.func = func2;
  function array6(value) {
    return Array.isArray(value);
  }
  exports2.array = array6;
  function stringArray(value) {
    return array6(value) && value.every((elem) => string23(elem));
  }
  exports2.stringArray = stringArray;
  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }
  exports2.typedArray = typedArray;
  function objectLiteral2(value) {
    return value !== null && typeof value === "object";
  }
  exports2.objectLiteral = objectLiteral2;
});

// node_modules/vscode-languageserver-protocol/lib/messages.js
var require_messages2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolRequestType0 = ProtocolRequestType0;
  var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolRequestType = ProtocolRequestType;
  var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolNotificationType = ProtocolNotificationType;
  var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
});

// node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js
var require_protocol_implementation = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var ImplementationRequest3;
  (function(ImplementationRequest4) {
    ImplementationRequest4.method = "textDocument/implementation";
    ImplementationRequest4.type = new messages_1.ProtocolRequestType(ImplementationRequest4.method);
    ImplementationRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
  })(ImplementationRequest3 = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var TypeDefinitionRequest3;
  (function(TypeDefinitionRequest4) {
    TypeDefinitionRequest4.method = "textDocument/typeDefinition";
    TypeDefinitionRequest4.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest4.method);
    TypeDefinitionRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
  })(TypeDefinitionRequest3 = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js
var require_protocol_workspaceFolders = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var WorkspaceFoldersRequest2;
  (function(WorkspaceFoldersRequest3) {
    WorkspaceFoldersRequest3.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
  })(WorkspaceFoldersRequest2 = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
  var DidChangeWorkspaceFoldersNotification2;
  (function(DidChangeWorkspaceFoldersNotification3) {
    DidChangeWorkspaceFoldersNotification3.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
  })(DidChangeWorkspaceFoldersNotification2 = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js
var require_protocol_configuration = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var ConfigurationRequest2;
  (function(ConfigurationRequest3) {
    ConfigurationRequest3.type = new messages_1.ProtocolRequestType("workspace/configuration");
  })(ConfigurationRequest2 = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var DocumentColorRequest3;
  (function(DocumentColorRequest4) {
    DocumentColorRequest4.method = "textDocument/documentColor";
    DocumentColorRequest4.type = new messages_1.ProtocolRequestType(DocumentColorRequest4.method);
    DocumentColorRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentColorRequest3 = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
  var ColorPresentationRequest2;
  (function(ColorPresentationRequest3) {
    ColorPresentationRequest3.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
  })(ColorPresentationRequest2 = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var FoldingRangeKind;
  (function(FoldingRangeKind2) {
    FoldingRangeKind2["Comment"] = "comment";
    FoldingRangeKind2["Imports"] = "imports";
    FoldingRangeKind2["Region"] = "region";
  })(FoldingRangeKind = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
  var FoldingRangeRequest3;
  (function(FoldingRangeRequest4) {
    FoldingRangeRequest4.method = "textDocument/foldingRange";
    FoldingRangeRequest4.type = new messages_1.ProtocolRequestType(FoldingRangeRequest4.method);
    FoldingRangeRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
  })(FoldingRangeRequest3 = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js
var require_protocol_declaration = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var DeclarationRequest3;
  (function(DeclarationRequest4) {
    DeclarationRequest4.method = "textDocument/declaration";
    DeclarationRequest4.type = new messages_1.ProtocolRequestType(DeclarationRequest4.method);
    DeclarationRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DeclarationRequest3 = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var SelectionRangeRequest3;
  (function(SelectionRangeRequest4) {
    SelectionRangeRequest4.method = "textDocument/selectionRange";
    SelectionRangeRequest4.type = new messages_1.ProtocolRequestType(SelectionRangeRequest4.method);
    SelectionRangeRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
  })(SelectionRangeRequest3 = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.progress.js
var require_protocol_progress = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var WorkDoneProgress3;
  (function(WorkDoneProgress4) {
    WorkDoneProgress4.type = new vscode_jsonrpc_1.ProgressType();
  })(WorkDoneProgress3 = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
  var WorkDoneProgressCreateRequest2;
  (function(WorkDoneProgressCreateRequest3) {
    WorkDoneProgressCreateRequest3.type = new messages_1.ProtocolRequestType("window/workDoneProgress/create");
  })(WorkDoneProgressCreateRequest2 = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
  var WorkDoneProgressCancelNotification;
  (function(WorkDoneProgressCancelNotification2) {
    WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType("window/workDoneProgress/cancel");
  })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.js
var require_protocol = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Is4 = require_is2();
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var protocol_implementation_1 = require_protocol_implementation();
  exports2.ImplementationRequest = protocol_implementation_1.ImplementationRequest;
  var protocol_typeDefinition_1 = require_protocol_typeDefinition();
  exports2.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;
  var protocol_workspaceFolders_1 = require_protocol_workspaceFolders();
  exports2.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;
  exports2.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
  var protocol_configuration_1 = require_protocol_configuration();
  exports2.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;
  var protocol_colorProvider_1 = require_protocol_colorProvider();
  exports2.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;
  exports2.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;
  var protocol_foldingRange_1 = require_protocol_foldingRange();
  exports2.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;
  var protocol_declaration_1 = require_protocol_declaration();
  exports2.DeclarationRequest = protocol_declaration_1.DeclarationRequest;
  var protocol_selectionRange_1 = require_protocol_selectionRange();
  exports2.SelectionRangeRequest = protocol_selectionRange_1.SelectionRangeRequest;
  var protocol_progress_1 = require_protocol_progress();
  exports2.WorkDoneProgress = protocol_progress_1.WorkDoneProgress;
  exports2.WorkDoneProgressCreateRequest = protocol_progress_1.WorkDoneProgressCreateRequest;
  exports2.WorkDoneProgressCancelNotification = protocol_progress_1.WorkDoneProgressCancelNotification;
  var DocumentFilter;
  (function(DocumentFilter2) {
    function is6(value) {
      const candidate = value;
      return Is4.string(candidate.language) || Is4.string(candidate.scheme) || Is4.string(candidate.pattern);
    }
    DocumentFilter2.is = is6;
  })(DocumentFilter = exports2.DocumentFilter || (exports2.DocumentFilter = {}));
  var DocumentSelector31;
  (function(DocumentSelector32) {
    function is6(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (let elem of value) {
        if (!Is4.string(elem) && !DocumentFilter.is(elem)) {
          return false;
        }
      }
      return true;
    }
    DocumentSelector32.is = is6;
  })(DocumentSelector31 = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
  var RegistrationRequest2;
  (function(RegistrationRequest3) {
    RegistrationRequest3.type = new messages_1.ProtocolRequestType("client/registerCapability");
  })(RegistrationRequest2 = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
  var UnregistrationRequest2;
  (function(UnregistrationRequest3) {
    UnregistrationRequest3.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
  })(UnregistrationRequest2 = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
  var ResourceOperationKind2;
  (function(ResourceOperationKind3) {
    ResourceOperationKind3.Create = "create";
    ResourceOperationKind3.Rename = "rename";
    ResourceOperationKind3.Delete = "delete";
  })(ResourceOperationKind2 = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
  var FailureHandlingKind2;
  (function(FailureHandlingKind3) {
    FailureHandlingKind3.Abort = "abort";
    FailureHandlingKind3.Transactional = "transactional";
    FailureHandlingKind3.TextOnlyTransactional = "textOnlyTransactional";
    FailureHandlingKind3.Undo = "undo";
  })(FailureHandlingKind2 = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
  var StaticRegistrationOptions2;
  (function(StaticRegistrationOptions3) {
    function hasId(value) {
      const candidate = value;
      return candidate && Is4.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions3.hasId = hasId;
  })(StaticRegistrationOptions2 = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
  var TextDocumentRegistrationOptions2;
  (function(TextDocumentRegistrationOptions3) {
    function is6(value) {
      const candidate = value;
      return candidate && (candidate.documentSelector === null || DocumentSelector31.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions3.is = is6;
  })(TextDocumentRegistrationOptions2 = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
  var WorkDoneProgressOptions2;
  (function(WorkDoneProgressOptions3) {
    function is6(value) {
      const candidate = value;
      return Is4.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is4.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions3.is = is6;
    function hasWorkDoneProgress(value) {
      const candidate = value;
      return candidate && Is4.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions3.hasWorkDoneProgress = hasWorkDoneProgress;
  })(WorkDoneProgressOptions2 = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
  var InitializeRequest2;
  (function(InitializeRequest3) {
    InitializeRequest3.type = new messages_1.ProtocolRequestType("initialize");
  })(InitializeRequest2 = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
  var InitializeError2;
  (function(InitializeError3) {
    InitializeError3.unknownProtocolVersion = 1;
  })(InitializeError2 = exports2.InitializeError || (exports2.InitializeError = {}));
  var InitializedNotification2;
  (function(InitializedNotification3) {
    InitializedNotification3.type = new messages_1.ProtocolNotificationType("initialized");
  })(InitializedNotification2 = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
  var ShutdownRequest2;
  (function(ShutdownRequest3) {
    ShutdownRequest3.type = new messages_1.ProtocolRequestType0("shutdown");
  })(ShutdownRequest2 = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
  var ExitNotification2;
  (function(ExitNotification3) {
    ExitNotification3.type = new messages_1.ProtocolNotificationType0("exit");
  })(ExitNotification2 = exports2.ExitNotification || (exports2.ExitNotification = {}));
  var DidChangeConfigurationNotification2;
  (function(DidChangeConfigurationNotification3) {
    DidChangeConfigurationNotification3.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
  })(DidChangeConfigurationNotification2 = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
  var MessageType2;
  (function(MessageType3) {
    MessageType3.Error = 1;
    MessageType3.Warning = 2;
    MessageType3.Info = 3;
    MessageType3.Log = 4;
  })(MessageType2 = exports2.MessageType || (exports2.MessageType = {}));
  var ShowMessageNotification2;
  (function(ShowMessageNotification3) {
    ShowMessageNotification3.type = new messages_1.ProtocolNotificationType("window/showMessage");
  })(ShowMessageNotification2 = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
  var ShowMessageRequest2;
  (function(ShowMessageRequest3) {
    ShowMessageRequest3.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
  })(ShowMessageRequest2 = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
  var LogMessageNotification2;
  (function(LogMessageNotification3) {
    LogMessageNotification3.type = new messages_1.ProtocolNotificationType("window/logMessage");
  })(LogMessageNotification2 = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
  var TelemetryEventNotification2;
  (function(TelemetryEventNotification3) {
    TelemetryEventNotification3.type = new messages_1.ProtocolNotificationType("telemetry/event");
  })(TelemetryEventNotification2 = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
  var TextDocumentSyncKind2;
  (function(TextDocumentSyncKind3) {
    TextDocumentSyncKind3.None = 0;
    TextDocumentSyncKind3.Full = 1;
    TextDocumentSyncKind3.Incremental = 2;
  })(TextDocumentSyncKind2 = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
  var DidOpenTextDocumentNotification2;
  (function(DidOpenTextDocumentNotification3) {
    DidOpenTextDocumentNotification3.method = "textDocument/didOpen";
    DidOpenTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification3.method);
  })(DidOpenTextDocumentNotification2 = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
  var DidChangeTextDocumentNotification2;
  (function(DidChangeTextDocumentNotification3) {
    DidChangeTextDocumentNotification3.method = "textDocument/didChange";
    DidChangeTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification3.method);
  })(DidChangeTextDocumentNotification2 = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
  var DidCloseTextDocumentNotification2;
  (function(DidCloseTextDocumentNotification3) {
    DidCloseTextDocumentNotification3.method = "textDocument/didClose";
    DidCloseTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification3.method);
  })(DidCloseTextDocumentNotification2 = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
  var DidSaveTextDocumentNotification2;
  (function(DidSaveTextDocumentNotification3) {
    DidSaveTextDocumentNotification3.method = "textDocument/didSave";
    DidSaveTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification3.method);
  })(DidSaveTextDocumentNotification2 = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
  var TextDocumentSaveReason2;
  (function(TextDocumentSaveReason3) {
    TextDocumentSaveReason3.Manual = 1;
    TextDocumentSaveReason3.AfterDelay = 2;
    TextDocumentSaveReason3.FocusOut = 3;
  })(TextDocumentSaveReason2 = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
  var WillSaveTextDocumentNotification2;
  (function(WillSaveTextDocumentNotification3) {
    WillSaveTextDocumentNotification3.method = "textDocument/willSave";
    WillSaveTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification3.method);
  })(WillSaveTextDocumentNotification2 = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
  var WillSaveTextDocumentWaitUntilRequest2;
  (function(WillSaveTextDocumentWaitUntilRequest3) {
    WillSaveTextDocumentWaitUntilRequest3.method = "textDocument/willSaveWaitUntil";
    WillSaveTextDocumentWaitUntilRequest3.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest3.method);
  })(WillSaveTextDocumentWaitUntilRequest2 = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
  var DidChangeWatchedFilesNotification2;
  (function(DidChangeWatchedFilesNotification3) {
    DidChangeWatchedFilesNotification3.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
  })(DidChangeWatchedFilesNotification2 = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
  var FileChangeType2;
  (function(FileChangeType3) {
    FileChangeType3.Created = 1;
    FileChangeType3.Changed = 2;
    FileChangeType3.Deleted = 3;
  })(FileChangeType2 = exports2.FileChangeType || (exports2.FileChangeType = {}));
  var WatchKind2;
  (function(WatchKind3) {
    WatchKind3.Create = 1;
    WatchKind3.Change = 2;
    WatchKind3.Delete = 4;
  })(WatchKind2 = exports2.WatchKind || (exports2.WatchKind = {}));
  var PublishDiagnosticsNotification2;
  (function(PublishDiagnosticsNotification3) {
    PublishDiagnosticsNotification3.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
  })(PublishDiagnosticsNotification2 = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
  var CompletionTriggerKind2;
  (function(CompletionTriggerKind3) {
    CompletionTriggerKind3.Invoked = 1;
    CompletionTriggerKind3.TriggerCharacter = 2;
    CompletionTriggerKind3.TriggerForIncompleteCompletions = 3;
  })(CompletionTriggerKind2 = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
  var CompletionRequest2;
  (function(CompletionRequest3) {
    CompletionRequest3.method = "textDocument/completion";
    CompletionRequest3.type = new messages_1.ProtocolRequestType(CompletionRequest3.method);
    CompletionRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
  })(CompletionRequest2 = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
  var CompletionResolveRequest2;
  (function(CompletionResolveRequest3) {
    CompletionResolveRequest3.method = "completionItem/resolve";
    CompletionResolveRequest3.type = new messages_1.ProtocolRequestType(CompletionResolveRequest3.method);
  })(CompletionResolveRequest2 = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
  var HoverRequest2;
  (function(HoverRequest3) {
    HoverRequest3.method = "textDocument/hover";
    HoverRequest3.type = new messages_1.ProtocolRequestType(HoverRequest3.method);
  })(HoverRequest2 = exports2.HoverRequest || (exports2.HoverRequest = {}));
  var SignatureHelpTriggerKind2;
  (function(SignatureHelpTriggerKind3) {
    SignatureHelpTriggerKind3.Invoked = 1;
    SignatureHelpTriggerKind3.TriggerCharacter = 2;
    SignatureHelpTriggerKind3.ContentChange = 3;
  })(SignatureHelpTriggerKind2 = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
  var SignatureHelpRequest2;
  (function(SignatureHelpRequest3) {
    SignatureHelpRequest3.method = "textDocument/signatureHelp";
    SignatureHelpRequest3.type = new messages_1.ProtocolRequestType(SignatureHelpRequest3.method);
  })(SignatureHelpRequest2 = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
  var DefinitionRequest2;
  (function(DefinitionRequest3) {
    DefinitionRequest3.method = "textDocument/definition";
    DefinitionRequest3.type = new messages_1.ProtocolRequestType(DefinitionRequest3.method);
    DefinitionRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DefinitionRequest2 = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
  var ReferencesRequest2;
  (function(ReferencesRequest3) {
    ReferencesRequest3.method = "textDocument/references";
    ReferencesRequest3.type = new messages_1.ProtocolRequestType(ReferencesRequest3.method);
    ReferencesRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
  })(ReferencesRequest2 = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
  var DocumentHighlightRequest2;
  (function(DocumentHighlightRequest3) {
    DocumentHighlightRequest3.method = "textDocument/documentHighlight";
    DocumentHighlightRequest3.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest3.method);
    DocumentHighlightRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentHighlightRequest2 = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
  var DocumentSymbolRequest2;
  (function(DocumentSymbolRequest3) {
    DocumentSymbolRequest3.method = "textDocument/documentSymbol";
    DocumentSymbolRequest3.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest3.method);
    DocumentSymbolRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentSymbolRequest2 = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
  var CodeActionRequest2;
  (function(CodeActionRequest3) {
    CodeActionRequest3.method = "textDocument/codeAction";
    CodeActionRequest3.type = new messages_1.ProtocolRequestType(CodeActionRequest3.method);
    CodeActionRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
  })(CodeActionRequest2 = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
  var WorkspaceSymbolRequest2;
  (function(WorkspaceSymbolRequest3) {
    WorkspaceSymbolRequest3.method = "workspace/symbol";
    WorkspaceSymbolRequest3.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest3.method);
    WorkspaceSymbolRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
  })(WorkspaceSymbolRequest2 = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
  var CodeLensRequest2;
  (function(CodeLensRequest3) {
    CodeLensRequest3.type = new messages_1.ProtocolRequestType("textDocument/codeLens");
    CodeLensRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
  })(CodeLensRequest2 = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
  var CodeLensResolveRequest2;
  (function(CodeLensResolveRequest3) {
    CodeLensResolveRequest3.type = new messages_1.ProtocolRequestType("codeLens/resolve");
  })(CodeLensResolveRequest2 = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
  var DocumentLinkRequest2;
  (function(DocumentLinkRequest3) {
    DocumentLinkRequest3.method = "textDocument/documentLink";
    DocumentLinkRequest3.type = new messages_1.ProtocolRequestType(DocumentLinkRequest3.method);
    DocumentLinkRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentLinkRequest2 = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
  var DocumentLinkResolveRequest2;
  (function(DocumentLinkResolveRequest3) {
    DocumentLinkResolveRequest3.type = new messages_1.ProtocolRequestType("documentLink/resolve");
  })(DocumentLinkResolveRequest2 = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
  var DocumentFormattingRequest2;
  (function(DocumentFormattingRequest3) {
    DocumentFormattingRequest3.method = "textDocument/formatting";
    DocumentFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest3.method);
  })(DocumentFormattingRequest2 = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
  var DocumentRangeFormattingRequest2;
  (function(DocumentRangeFormattingRequest3) {
    DocumentRangeFormattingRequest3.method = "textDocument/rangeFormatting";
    DocumentRangeFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest3.method);
  })(DocumentRangeFormattingRequest2 = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
  var DocumentOnTypeFormattingRequest2;
  (function(DocumentOnTypeFormattingRequest3) {
    DocumentOnTypeFormattingRequest3.method = "textDocument/onTypeFormatting";
    DocumentOnTypeFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest3.method);
  })(DocumentOnTypeFormattingRequest2 = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
  var RenameRequest2;
  (function(RenameRequest3) {
    RenameRequest3.method = "textDocument/rename";
    RenameRequest3.type = new messages_1.ProtocolRequestType(RenameRequest3.method);
  })(RenameRequest2 = exports2.RenameRequest || (exports2.RenameRequest = {}));
  var PrepareRenameRequest2;
  (function(PrepareRenameRequest3) {
    PrepareRenameRequest3.method = "textDocument/prepareRename";
    PrepareRenameRequest3.type = new messages_1.ProtocolRequestType(PrepareRenameRequest3.method);
  })(PrepareRenameRequest2 = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
  var ExecuteCommandRequest3;
  (function(ExecuteCommandRequest4) {
    ExecuteCommandRequest4.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
  })(ExecuteCommandRequest3 = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
  var ApplyWorkspaceEditRequest2;
  (function(ApplyWorkspaceEditRequest3) {
    ApplyWorkspaceEditRequest3.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
  })(ApplyWorkspaceEditRequest2 = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js
var require_protocol_callHierarchy_proposed = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var CallHierarchyPrepareRequest;
  (function(CallHierarchyPrepareRequest2) {
    CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
    CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
  })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
  var CallHierarchyIncomingCallsRequest;
  (function(CallHierarchyIncomingCallsRequest2) {
    CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
    CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
  })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
  var CallHierarchyOutgoingCallsRequest;
  (function(CallHierarchyOutgoingCallsRequest2) {
    CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
    CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
  })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js
var require_protocol_sematicTokens_proposed = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var SemanticTokenTypes;
  (function(SemanticTokenTypes2) {
    SemanticTokenTypes2["comment"] = "comment";
    SemanticTokenTypes2["keyword"] = "keyword";
    SemanticTokenTypes2["string"] = "string";
    SemanticTokenTypes2["number"] = "number";
    SemanticTokenTypes2["regexp"] = "regexp";
    SemanticTokenTypes2["operator"] = "operator";
    SemanticTokenTypes2["namespace"] = "namespace";
    SemanticTokenTypes2["type"] = "type";
    SemanticTokenTypes2["struct"] = "struct";
    SemanticTokenTypes2["class"] = "class";
    SemanticTokenTypes2["interface"] = "interface";
    SemanticTokenTypes2["enum"] = "enum";
    SemanticTokenTypes2["typeParameter"] = "typeParameter";
    SemanticTokenTypes2["function"] = "function";
    SemanticTokenTypes2["member"] = "member";
    SemanticTokenTypes2["property"] = "property";
    SemanticTokenTypes2["macro"] = "macro";
    SemanticTokenTypes2["variable"] = "variable";
    SemanticTokenTypes2["parameter"] = "parameter";
    SemanticTokenTypes2["label"] = "label";
  })(SemanticTokenTypes = exports2.SemanticTokenTypes || (exports2.SemanticTokenTypes = {}));
  var SemanticTokenModifiers;
  (function(SemanticTokenModifiers2) {
    SemanticTokenModifiers2["documentation"] = "documentation";
    SemanticTokenModifiers2["declaration"] = "declaration";
    SemanticTokenModifiers2["definition"] = "definition";
    SemanticTokenModifiers2["reference"] = "reference";
    SemanticTokenModifiers2["static"] = "static";
    SemanticTokenModifiers2["abstract"] = "abstract";
    SemanticTokenModifiers2["deprecated"] = "deprecated";
    SemanticTokenModifiers2["async"] = "async";
    SemanticTokenModifiers2["volatile"] = "volatile";
    SemanticTokenModifiers2["readonly"] = "readonly";
  })(SemanticTokenModifiers = exports2.SemanticTokenModifiers || (exports2.SemanticTokenModifiers = {}));
  var SemanticTokens;
  (function(SemanticTokens2) {
    function is6(value) {
      const candidate = value;
      return candidate !== void 0 && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
    }
    SemanticTokens2.is = is6;
  })(SemanticTokens = exports2.SemanticTokens || (exports2.SemanticTokens = {}));
  var SemanticTokensRequest;
  (function(SemanticTokensRequest2) {
    SemanticTokensRequest2.method = "textDocument/semanticTokens";
    SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
  })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
  var SemanticTokensEditsRequest;
  (function(SemanticTokensEditsRequest2) {
    SemanticTokensEditsRequest2.method = "textDocument/semanticTokens/edits";
    SemanticTokensEditsRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensEditsRequest2.method);
  })(SemanticTokensEditsRequest = exports2.SemanticTokensEditsRequest || (exports2.SemanticTokensEditsRequest = {}));
  var SemanticTokensRangeRequest;
  (function(SemanticTokensRangeRequest2) {
    SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
    SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
  })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/main.js
var require_main3 = __commonJS((exports2) => {
  "use strict";
  function __export2(m) {
    for (var p in m)
      if (!exports2.hasOwnProperty(p))
        exports2[p] = m[p];
  }
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  exports2.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
  exports2.ResponseError = vscode_jsonrpc_1.ResponseError;
  exports2.CancellationToken = vscode_jsonrpc_1.CancellationToken;
  exports2.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;
  exports2.Disposable = vscode_jsonrpc_1.Disposable;
  exports2.Event = vscode_jsonrpc_1.Event;
  exports2.Emitter = vscode_jsonrpc_1.Emitter;
  exports2.Trace = vscode_jsonrpc_1.Trace;
  exports2.TraceFormat = vscode_jsonrpc_1.TraceFormat;
  exports2.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;
  exports2.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;
  exports2.RequestType = vscode_jsonrpc_1.RequestType;
  exports2.RequestType0 = vscode_jsonrpc_1.RequestType0;
  exports2.NotificationType = vscode_jsonrpc_1.NotificationType;
  exports2.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
  exports2.MessageReader = vscode_jsonrpc_1.MessageReader;
  exports2.MessageWriter = vscode_jsonrpc_1.MessageWriter;
  exports2.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;
  exports2.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
  exports2.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
  exports2.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
  exports2.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
  exports2.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;
  exports2.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;
  exports2.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;
  exports2.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;
  exports2.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;
  exports2.ProgressType = vscode_jsonrpc_1.ProgressType;
  __export2(require_main2());
  __export2(require_protocol());
  var callHierarchy = require_protocol_callHierarchy_proposed();
  var st = require_protocol_sematicTokens_proposed();
  var Proposed2;
  (function(Proposed3) {
    let CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = callHierarchy.CallHierarchyPrepareRequest.method;
      CallHierarchyPrepareRequest2.type = callHierarchy.CallHierarchyPrepareRequest.type;
    })(CallHierarchyPrepareRequest = Proposed3.CallHierarchyPrepareRequest || (Proposed3.CallHierarchyPrepareRequest = {}));
    let CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = callHierarchy.CallHierarchyIncomingCallsRequest.method;
      CallHierarchyIncomingCallsRequest2.type = callHierarchy.CallHierarchyIncomingCallsRequest.type;
    })(CallHierarchyIncomingCallsRequest = Proposed3.CallHierarchyIncomingCallsRequest || (Proposed3.CallHierarchyIncomingCallsRequest = {}));
    let CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = callHierarchy.CallHierarchyOutgoingCallsRequest.method;
      CallHierarchyOutgoingCallsRequest2.type = callHierarchy.CallHierarchyOutgoingCallsRequest.type;
    })(CallHierarchyOutgoingCallsRequest = Proposed3.CallHierarchyOutgoingCallsRequest || (Proposed3.CallHierarchyOutgoingCallsRequest = {}));
    Proposed3.SemanticTokenTypes = st.SemanticTokenTypes;
    Proposed3.SemanticTokenModifiers = st.SemanticTokenModifiers;
    Proposed3.SemanticTokens = st.SemanticTokens;
    let SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = st.SemanticTokensRequest.method;
      SemanticTokensRequest2.type = st.SemanticTokensRequest.type;
    })(SemanticTokensRequest = Proposed3.SemanticTokensRequest || (Proposed3.SemanticTokensRequest = {}));
    let SemanticTokensEditsRequest;
    (function(SemanticTokensEditsRequest2) {
      SemanticTokensEditsRequest2.method = st.SemanticTokensEditsRequest.method;
      SemanticTokensEditsRequest2.type = st.SemanticTokensEditsRequest.type;
    })(SemanticTokensEditsRequest = Proposed3.SemanticTokensEditsRequest || (Proposed3.SemanticTokensEditsRequest = {}));
    let SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = st.SemanticTokensRangeRequest.method;
      SemanticTokensRangeRequest2.type = st.SemanticTokensRangeRequest.type;
    })(SemanticTokensRangeRequest = Proposed3.SemanticTokensRangeRequest || (Proposed3.SemanticTokensRangeRequest = {}));
  })(Proposed2 = exports2.Proposed || (exports2.Proposed = {}));
  function createProtocolConnection2(reader, writer, logger93, strategy) {
    return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger93, strategy);
  }
  exports2.createProtocolConnection = createProtocolConnection2;
});

// node_modules/debounce/index.js
var require_debounce = __commonJS((exports2, module2) => {
  function debounce25(func2, wait2, immediate) {
    var timeout, args, context, timestamp, result;
    if (wait2 == null)
      wait2 = 100;
    function later() {
      var last = Date.now() - timestamp;
      if (last < wait2 && last >= 0) {
        timeout = setTimeout(later, wait2 - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func2.apply(context, args);
          context = args = null;
        }
      }
    }
    ;
    var debounced = function() {
      context = this;
      args = arguments;
      timestamp = Date.now();
      var callNow = immediate && !timeout;
      if (!timeout)
        timeout = setTimeout(later, wait2);
      if (callNow) {
        result = func2.apply(context, args);
        context = args = null;
      }
      return result;
    };
    debounced.clear = function() {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    };
    debounced.flush = function() {
      if (timeout) {
        result = func2.apply(context, args);
        context = args = null;
        clearTimeout(timeout);
        timeout = null;
      }
    };
    return debounced;
  }
  debounce25.debounce = debounce25;
  module2.exports = debounce25;
});

// node_modules/rfc-3986/index.js
var require_rfc_3986 = __commonJS((exports2, module2) => {
  "use strict";
  var internals = {
    rfc3986: {}
  };
  internals.generate = function() {
    var or = "|";
    var digit = "0-9";
    var digitOnly = "[" + digit + "]";
    var alpha = "a-zA-Z";
    var alphaOnly = "[" + alpha + "]";
    internals.rfc3986.cidr = digitOnly + or + "[1-2]" + digitOnly + or + "3[0-2]";
    var hexDigit = digit + "A-Fa-f";
    var hexDigitOnly = "[" + hexDigit + "]";
    var unreserved = alpha + digit + "-\\._~";
    var subDelims = "!\\$&'\\(\\)\\*\\+,;=";
    var pctEncoded = "%" + hexDigit;
    var pchar = unreserved + pctEncoded + subDelims + ":@";
    var pcharOnly = "[" + pchar + "]";
    var zeroPad = "0?";
    var decOctect = "(?:" + zeroPad + zeroPad + digitOnly + or + zeroPad + "[1-9]" + digitOnly + or + "1" + digitOnly + digitOnly + or + "2[0-4]" + digitOnly + or + "25[0-5])";
    internals.rfc3986.IPv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
    var h16 = hexDigitOnly + "{1,4}";
    var ls32 = "(?:" + h16 + ":" + h16 + "|" + internals.rfc3986.IPv4address + ")";
    var IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
    var IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
    var IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
    var IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
    var IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
    var IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
    var IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
    var IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
    var IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
    internals.rfc3986.IPv6address = "(?:" + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ")";
    internals.rfc3986.IPvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
    internals.rfc3986.scheme = alphaOnly + "[" + alpha + digit + "+-\\.]*";
    var userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
    internals.rfc3986.IPLiteral = "\\[(?:" + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ")\\]";
    var regName = "[" + unreserved + pctEncoded + subDelims + "]{0,255}";
    var host = "(?:" + internals.rfc3986.IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ")";
    var port = digitOnly + "*";
    var authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
    var segment = pcharOnly + "*";
    var segmentNz = pcharOnly + "+";
    var pathAbEmpty = "(?:\\/" + segment + ")*";
    var pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
    var pathRootless = segmentNz + pathAbEmpty;
    internals.rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")" + or + pathAbsolute + or + pathRootless + ")";
    internals.rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
    internals.rfc3986.fragment = "[" + pchar + "\\/\\?]*";
    internals.rfc3986.uri = "^(?:" + internals.rfc3986.scheme + ":" + internals.rfc3986.hierPart + ")(?:\\?" + internals.rfc3986.query + ")?(?:#" + internals.rfc3986.fragment + ")?$";
  };
  internals.generate();
  module2.exports = internals.rfc3986;
});

// node_modules/isuri/index.js
var require_isuri = __commonJS((exports2, module2) => {
  "use strict";
  var rfc3986 = require_rfc_3986();
  function escapeRegex(string23) {
    return string23.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
  }
  var internals = {
    Uri: {
      createUriRegex: function(options) {
        options = options || {};
        if (typeof options !== "object" || Array.isArray(options)) {
          throw new Error("options must be an object");
        }
        var customScheme = "";
        if (options.scheme) {
          if (!Array.isArray(options.scheme)) {
            options.scheme = [options.scheme];
          }
          if (options.scheme.length <= 0) {
            throw new Error("scheme must have at least 1 scheme specified");
          }
          for (var i = 0; i < options.scheme.length; ++i) {
            var currentScheme = options.scheme[i];
            if (!(currentScheme instanceof RegExp || typeof currentScheme === "string")) {
              throw new Error("scheme must only contain Regular Expressions or Strings");
            }
            customScheme = customScheme + (customScheme ? "|" : "");
            if (currentScheme instanceof RegExp) {
              customScheme = customScheme + currentScheme.source;
            } else {
              if (!/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(currentScheme)) {
                throw new Error("scheme at position " + i + " must be a valid scheme");
              }
              customScheme = customScheme + escapeRegex(currentScheme);
            }
          }
        }
        var scheme = "(?:" + (customScheme || rfc3986.scheme) + ")";
        return new RegExp("^(?:" + scheme + ":" + rfc3986.hierPart + ")(?:\\?" + rfc3986.query + ")?(?:#" + rfc3986.fragment + ")?$");
      },
      uriRegex: new RegExp(rfc3986.uri)
    }
  };
  internals.Uri.isValid = function(val) {
    return internals.Uri.uriRegex.test(val);
  };
  module2.exports = {
    createUriRegex: internals.Uri.createUriRegex,
    uriRegex: internals.Uri.uriRegex,
    isValid: internals.Uri.isValid
  };
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs55 = require("fs");
  function checkPathExt(path66, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path66.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path66, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path66, options);
  }
  function isexe(path66, options, cb) {
    fs55.stat(path66, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path66, options));
    });
  }
  function sync(path66, options) {
    return checkStat(fs55.statSync(path66), path66, options);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs55 = require("fs");
  function isexe(path66, options, cb) {
    fs55.stat(path66, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path66, options) {
    return checkStat(fs55.statSync(path66), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret2 = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret2;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports2, module2) => {
  var fs55 = require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module2.exports = isexe;
  isexe.sync = sync;
  function isexe(path66, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve3, reject) {
        isexe(path66, options || {}, function(er, is6) {
          if (er) {
            reject(er);
          } else {
            resolve3(is6);
          }
        });
      });
    }
    core(path66, options || {}, function(er, is6) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is6 = false;
        }
      }
      cb(er, is6);
    });
  }
  function sync(path66, options) {
    try {
      return core.sync(path66, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports2, module2) => {
  var isWindows4 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path66 = require("path");
  var COLON = isWindows4 ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows4 && cmd.match(/\\/) ? [""] : [
      ...isWindows4 ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows4 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows4 ? pathExtExe.split(colon) : [""];
    if (isWindows4) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which11 = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve3, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve3(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path66.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve3(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve3, reject) => {
      if (ii === pathExt.length)
        return resolve3(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, {pathExt: pathExtExe}, (er, is6) => {
        if (!er && is6) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve3(p + ext);
        }
        return resolve3(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path66.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is6 = isexe.sync(cur, {pathExt: pathExtExe});
          if (is6) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module2.exports = which11;
  which11.sync = whichSync;
});

// node_modules/marked/src/defaults.js
var require_defaults = __commonJS((exports2, module2) => {
  function getDefaults() {
    return {
      baseUrl: null,
      breaks: false,
      gfm: true,
      headerIds: true,
      headerPrefix: "",
      highlight: null,
      langPrefix: "language-",
      mangle: true,
      pedantic: false,
      renderer: null,
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartLists: false,
      smartypants: false,
      tokenizer: null,
      walkTokens: null,
      xhtml: false
    };
  }
  function changeDefaults(newDefaults) {
    module2.exports.defaults = newDefaults;
  }
  module2.exports = {
    defaults: getDefaults(),
    getDefaults,
    changeDefaults
  };
});

// node_modules/marked/src/helpers.js
var require_helpers = __commonJS((exports2, module2) => {
  var escapeTest = /[&<>"']/;
  var escapeReplace = /[&<>"']/g;
  var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
  var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
  var escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var getEscapeReplacement = (ch) => escapeReplacements[ch];
  function escape(html, encode) {
    if (encode) {
      if (escapeTest.test(html)) {
        return html.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html)) {
        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html;
  }
  var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
  function unescape2(html) {
    return html.replace(unescapeTest, (_, n) => {
      n = n.toLowerCase();
      if (n === "colon")
        return ":";
      if (n.charAt(0) === "#") {
        return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
      }
      return "";
    });
  }
  var caret = /(^|[^\[])\^/g;
  function edit2(regex, opt) {
    regex = regex.source || regex;
    opt = opt || "";
    const obj = {
      replace: (name2, val) => {
        val = val.source || val;
        val = val.replace(caret, "$1");
        regex = regex.replace(name2, val);
        return obj;
      },
      getRegex: () => {
        return new RegExp(regex, opt);
      }
    };
    return obj;
  }
  var nonWordAndColonTest = /[^\w:]/g;
  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
  function cleanUrl(sanitize, base, href) {
    if (sanitize) {
      let prot;
      try {
        prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
      } catch (e) {
        return null;
      }
      if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
        return null;
      }
    }
    if (base && !originIndependentUrl.test(href)) {
      href = resolveUrl(base, href);
    }
    try {
      href = encodeURI(href).replace(/%25/g, "%");
    } catch (e) {
      return null;
    }
    return href;
  }
  var baseUrls = {};
  var justDomain = /^[^:]+:\/*[^/]*$/;
  var protocol = /^([^:]+:)[\s\S]*$/;
  var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
  function resolveUrl(base, href) {
    if (!baseUrls[" " + base]) {
      if (justDomain.test(base)) {
        baseUrls[" " + base] = base + "/";
      } else {
        baseUrls[" " + base] = rtrim(base, "/", true);
      }
    }
    base = baseUrls[" " + base];
    const relativeBase = base.indexOf(":") === -1;
    if (href.substring(0, 2) === "//") {
      if (relativeBase) {
        return href;
      }
      return base.replace(protocol, "$1") + href;
    } else if (href.charAt(0) === "/") {
      if (relativeBase) {
        return href;
      }
      return base.replace(domain, "$1") + href;
    } else {
      return base + href;
    }
  }
  var noopTest = {exec: function noopTest2() {
  }};
  function merge(obj) {
    let i = 1, target, key;
    for (; i < arguments.length; i++) {
      target = arguments[i];
      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }
    return obj;
  }
  function splitCells(tableRow, count) {
    const row = tableRow.replace(/\|/g, (match3, offset, str) => {
      let escaped = false, curr = offset;
      while (--curr >= 0 && str[curr] === "\\")
        escaped = !escaped;
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(/ \|/);
    let i = 0;
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
    for (; i < cells.length; i++) {
      cells[i] = cells[i].trim().replace(/\\\|/g, "|");
    }
    return cells;
  }
  function rtrim(str, c, invert) {
    const l = str.length;
    if (l === 0) {
      return "";
    }
    let suffLen = 0;
    while (suffLen < l) {
      const currChar = str.charAt(l - suffLen - 1);
      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }
    return str.substr(0, l - suffLen);
  }
  function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
      return -1;
    }
    const l = str.length;
    let level = 0, i = 0;
    for (; i < l; i++) {
      if (str[i] === "\\") {
        i++;
      } else if (str[i] === b[0]) {
        level++;
      } else if (str[i] === b[1]) {
        level--;
        if (level < 0) {
          return i;
        }
      }
    }
    return -1;
  }
  function checkSanitizeDeprecation(opt) {
    if (opt && opt.sanitize && !opt.silent) {
      console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
    }
  }
  function repeatString(pattern, count) {
    if (count < 1) {
      return "";
    }
    let result = "";
    while (count > 1) {
      if (count & 1) {
        result += pattern;
      }
      count >>= 1;
      pattern += pattern;
    }
    return result + pattern;
  }
  module2.exports = {
    escape,
    unescape: unescape2,
    edit: edit2,
    cleanUrl,
    resolveUrl,
    noopTest,
    merge,
    splitCells,
    rtrim,
    findClosingBracket,
    checkSanitizeDeprecation,
    repeatString
  };
});

// node_modules/marked/src/Tokenizer.js
var require_Tokenizer = __commonJS((exports2, module2) => {
  var {defaults: defaults2} = require_defaults();
  var {
    rtrim,
    splitCells,
    escape,
    findClosingBracket
  } = require_helpers();
  function outputLink(cap, link, raw) {
    const href = link.href;
    const title = link.title ? escape(link.title) : null;
    const text = cap[1].replace(/\\([\[\]])/g, "$1");
    if (cap[0].charAt(0) !== "!") {
      return {
        type: "link",
        raw,
        href,
        title,
        text
      };
    } else {
      return {
        type: "image",
        raw,
        href,
        title,
        text: escape(text)
      };
    }
  }
  function indentCodeCompensation(raw, text) {
    const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
    if (matchIndentToCode === null) {
      return text;
    }
    const indentToCode = matchIndentToCode[1];
    return text.split("\n").map((node) => {
      const matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) {
        return node;
      }
      const [indentInNode] = matchIndentInNode;
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  module2.exports = class Tokenizer {
    constructor(options) {
      this.options = options || defaults2;
    }
    space(src) {
      const cap = this.rules.block.newline.exec(src);
      if (cap) {
        if (cap[0].length > 1) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
        return {raw: "\n"};
      }
    }
    code(src, tokens) {
      const cap = this.rules.block.code.exec(src);
      if (cap) {
        const lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "paragraph") {
          return {
            raw: cap[0],
            text: cap[0].trimRight()
          };
        }
        const text = cap[0].replace(/^ {4}/gm, "");
        return {
          type: "code",
          raw: cap[0],
          codeBlockStyle: "indented",
          text: !this.options.pedantic ? rtrim(text, "\n") : text
        };
      }
    }
    fences(src) {
      const cap = this.rules.block.fences.exec(src);
      if (cap) {
        const raw = cap[0];
        const text = indentCodeCompensation(raw, cap[3] || "");
        return {
          type: "code",
          raw,
          lang: cap[2] ? cap[2].trim() : cap[2],
          text
        };
      }
    }
    heading(src) {
      const cap = this.rules.block.heading.exec(src);
      if (cap) {
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[1].length,
          text: cap[2]
        };
      }
    }
    nptable(src) {
      const cap = this.rules.block.nptable.exec(src);
      if (cap) {
        const item = {
          type: "table",
          header: splitCells(cap[1].replace(/^ *| *\| *$/g, "")),
          align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
          cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : [],
          raw: cap[0]
        };
        if (item.header.length === item.align.length) {
          let l = item.align.length;
          let i;
          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = "right";
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = "center";
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = "left";
            } else {
              item.align[i] = null;
            }
          }
          l = item.cells.length;
          for (i = 0; i < l; i++) {
            item.cells[i] = splitCells(item.cells[i], item.header.length);
          }
          return item;
        }
      }
    }
    hr(src) {
      const cap = this.rules.block.hr.exec(src);
      if (cap) {
        return {
          type: "hr",
          raw: cap[0]
        };
      }
    }
    blockquote(src) {
      const cap = this.rules.block.blockquote.exec(src);
      if (cap) {
        const text = cap[0].replace(/^ *> ?/gm, "");
        return {
          type: "blockquote",
          raw: cap[0],
          text
        };
      }
    }
    list(src) {
      const cap = this.rules.block.list.exec(src);
      if (cap) {
        let raw = cap[0];
        const bull = cap[2];
        const isordered = bull.length > 1;
        const list2 = {
          type: "list",
          raw,
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : "",
          loose: false,
          items: []
        };
        const itemMatch = cap[0].match(this.rules.block.item);
        let next = false, item, space, bcurr, bnext, addBack, loose, istask, ischecked;
        let l = itemMatch.length;
        bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);
        for (let i = 0; i < l; i++) {
          item = itemMatch[i];
          raw = item;
          if (i !== l - 1) {
            bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);
            if (bnext[1].length > bcurr[0].length || bnext[1].length > 3) {
              itemMatch.splice(i, 2, itemMatch[i] + "\n" + itemMatch[i + 1]);
              i--;
              l--;
              continue;
            } else {
              if (!this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)) {
                addBack = itemMatch.slice(i + 1).join("\n");
                list2.raw = list2.raw.substring(0, list2.raw.length - addBack.length);
                i = l - 1;
              }
            }
            bcurr = bnext;
          }
          space = item.length;
          item = item.replace(/^ *([*+-]|\d+[.)]) ?/, "");
          if (~item.indexOf("\n ")) {
            space -= item.length;
            item = !this.options.pedantic ? item.replace(new RegExp("^ {1," + space + "}", "gm"), "") : item.replace(/^ {1,4}/gm, "");
          }
          loose = next || /\n\n(?!\s*$)/.test(item);
          if (i !== l - 1) {
            next = item.charAt(item.length - 1) === "\n";
            if (!loose)
              loose = next;
          }
          if (loose) {
            list2.loose = true;
          }
          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.test(item);
            ischecked = void 0;
            if (istask) {
              ischecked = item[1] !== " ";
              item = item.replace(/^\[[ xX]\] +/, "");
            }
          }
          list2.items.push({
            type: "list_item",
            raw,
            task: istask,
            checked: ischecked,
            loose,
            text: item
          });
        }
        return list2;
      }
    }
    html(src) {
      const cap = this.rules.block.html.exec(src);
      if (cap) {
        return {
          type: this.options.sanitize ? "paragraph" : "html",
          raw: cap[0],
          pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
        };
      }
    }
    def(src) {
      const cap = this.rules.block.def.exec(src);
      if (cap) {
        if (cap[3])
          cap[3] = cap[3].substring(1, cap[3].length - 1);
        const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
        return {
          tag,
          raw: cap[0],
          href: cap[2],
          title: cap[3]
        };
      }
    }
    table(src) {
      const cap = this.rules.block.table.exec(src);
      if (cap) {
        const item = {
          type: "table",
          header: splitCells(cap[1].replace(/^ *| *\| *$/g, "")),
          align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
          cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : []
        };
        if (item.header.length === item.align.length) {
          item.raw = cap[0];
          let l = item.align.length;
          let i;
          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = "right";
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = "center";
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = "left";
            } else {
              item.align[i] = null;
            }
          }
          l = item.cells.length;
          for (i = 0; i < l; i++) {
            item.cells[i] = splitCells(item.cells[i].replace(/^ *\| *| *\| *$/g, ""), item.header.length);
          }
          return item;
        }
      }
    }
    lheading(src) {
      const cap = this.rules.block.lheading.exec(src);
      if (cap) {
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[2].charAt(0) === "=" ? 1 : 2,
          text: cap[1]
        };
      }
    }
    paragraph(src) {
      const cap = this.rules.block.paragraph.exec(src);
      if (cap) {
        return {
          type: "paragraph",
          raw: cap[0],
          text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1]
        };
      }
    }
    text(src, tokens) {
      const cap = this.rules.block.text.exec(src);
      if (cap) {
        const lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          return {
            raw: cap[0],
            text: cap[0]
          };
        }
        return {
          type: "text",
          raw: cap[0],
          text: cap[0]
        };
      }
    }
    escape(src) {
      const cap = this.rules.inline.escape.exec(src);
      if (cap) {
        return {
          type: "escape",
          raw: cap[0],
          text: escape(cap[1])
        };
      }
    }
    tag(src, inLink, inRawBlock) {
      const cap = this.rules.inline.tag.exec(src);
      if (cap) {
        if (!inLink && /^<a /i.test(cap[0])) {
          inLink = true;
        } else if (inLink && /^<\/a>/i.test(cap[0])) {
          inLink = false;
        }
        if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          inRawBlock = true;
        } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          inRawBlock = false;
        }
        return {
          type: this.options.sanitize ? "text" : "html",
          raw: cap[0],
          inLink,
          inRawBlock,
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
        };
      }
    }
    link(src) {
      const cap = this.rules.inline.link.exec(src);
      if (cap) {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
        let href = cap[2];
        let title = "";
        if (this.options.pedantic) {
          const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
          if (link) {
            href = link[1];
            title = link[3];
          } else {
            title = "";
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : "";
        }
        href = href.trim().replace(/^<([\s\S]*)>$/, "$1");
        const token = outputLink(cap, {
          href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
          title: title ? title.replace(this.rules.inline._escapes, "$1") : title
        }, cap[0]);
        return token;
      }
    }
    reflink(src, links3) {
      let cap;
      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
        link = links3[link.toLowerCase()];
        if (!link || !link.href) {
          const text = cap[0].charAt(0);
          return {
            type: "text",
            raw: text,
            text
          };
        }
        const token = outputLink(cap, link, cap[0]);
        return token;
      }
    }
    strong(src, maskedSrc, prevChar = "") {
      let match3 = this.rules.inline.strong.start.exec(src);
      if (match3 && (!match3[1] || match3[1] && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar)))) {
        maskedSrc = maskedSrc.slice(-1 * src.length);
        const endReg = match3[0] === "**" ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;
        endReg.lastIndex = 0;
        let cap;
        while ((match3 = endReg.exec(maskedSrc)) != null) {
          cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match3.index + 3));
          if (cap) {
            return {
              type: "strong",
              raw: src.slice(0, cap[0].length),
              text: src.slice(2, cap[0].length - 2)
            };
          }
        }
      }
    }
    em(src, maskedSrc, prevChar = "") {
      let match3 = this.rules.inline.em.start.exec(src);
      if (match3 && (!match3[1] || match3[1] && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar)))) {
        maskedSrc = maskedSrc.slice(-1 * src.length);
        const endReg = match3[0] === "*" ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;
        endReg.lastIndex = 0;
        let cap;
        while ((match3 = endReg.exec(maskedSrc)) != null) {
          cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match3.index + 2));
          if (cap) {
            return {
              type: "em",
              raw: src.slice(0, cap[0].length),
              text: src.slice(1, cap[0].length - 1)
            };
          }
        }
      }
    }
    codespan(src) {
      const cap = this.rules.inline.code.exec(src);
      if (cap) {
        let text = cap[2].replace(/\n/g, " ");
        const hasNonSpaceChars = /[^ ]/.test(text);
        const hasSpaceCharsOnBothEnds = text.startsWith(" ") && text.endsWith(" ");
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }
        text = escape(text, true);
        return {
          type: "codespan",
          raw: cap[0],
          text
        };
      }
    }
    br(src) {
      const cap = this.rules.inline.br.exec(src);
      if (cap) {
        return {
          type: "br",
          raw: cap[0]
        };
      }
    }
    del(src) {
      const cap = this.rules.inline.del.exec(src);
      if (cap) {
        return {
          type: "del",
          raw: cap[0],
          text: cap[2]
        };
      }
    }
    autolink(src, mangle) {
      const cap = this.rules.inline.autolink.exec(src);
      if (cap) {
        let text, href;
        if (cap[2] === "@") {
          text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
          href = "mailto:" + text;
        } else {
          text = escape(cap[1]);
          href = text;
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    url(src, mangle) {
      let cap;
      if (cap = this.rules.inline.url.exec(src)) {
        let text, href;
        if (cap[2] === "@") {
          text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
          href = "mailto:" + text;
        } else {
          let prevCapZero;
          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
          } while (prevCapZero !== cap[0]);
          text = escape(cap[0]);
          if (cap[1] === "www.") {
            href = "http://" + text;
          } else {
            href = text;
          }
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    inlineText(src, inRawBlock, smartypants) {
      const cap = this.rules.inline.text.exec(src);
      if (cap) {
        let text;
        if (inRawBlock) {
          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
        } else {
          text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
        }
        return {
          type: "text",
          raw: cap[0],
          text
        };
      }
    }
  };
});

// node_modules/marked/src/rules.js
var require_rules = __commonJS((exports2, module2) => {
  var {
    noopTest,
    edit: edit2,
    merge
  } = require_helpers();
  var block = {
    newline: /^\n+/,
    code: /^( {4}[^\n]+\n*)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
    html: "^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$))",
    def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
    nptable: noopTest,
    table: noopTest,
    lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block.def = edit2(block.def).replace("label", block._label).replace("title", block._title).getRegex();
  block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
  block.item = edit2(block.item, "gm").replace(/bull/g, block.bullet).getRegex();
  block.listItemStart = edit2(/^( *)(bull)/).replace("bull", block.bullet).getRegex();
  block.list = edit2(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
  block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block.html = edit2(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block.paragraph = edit2(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block._tag).getRegex();
  block.blockquote = edit2(block.blockquote).replace("paragraph", block.paragraph).getRegex();
  block.normal = merge({}, block);
  block.gfm = merge({}, block.normal, {
    nptable: "^ *([^|\\n ].*\\|.*)\\n {0,3}([-:]+ *\\|[-| :]*)(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
    table: "^ *\\|(.+)\\n {0,3}\\|?( *[-:]+[-| :]*)(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  });
  block.gfm.nptable = edit2(block.gfm.nptable).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block._tag).getRegex();
  block.gfm.table = edit2(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block._tag).getRegex();
  block.pedantic = merge({}, block.normal, {
    html: edit2(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
    fences: noopTest,
    paragraph: edit2(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
  });
  var inline = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest,
    tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
    nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
    reflinkSearch: "reflink|nolink(?!\\()",
    strong: {
      start: /^(?:(\*\*(?=[*punctuation]))|\*\*)(?![\s])|__/,
      middle: /^\*\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*\*$|^__(?![\s])((?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?)__$/,
      endAst: /[^punctuation\s]\*\*(?!\*)|[punctuation]\*\*(?!\*)(?:(?=[punctuation_\s]|$))/,
      endUnd: /[^\s]__(?!_)(?:(?=[punctuation*\s])|$)/
    },
    em: {
      start: /^(?:(\*(?=[punctuation]))|\*)(?![*\s])|_/,
      middle: /^\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*$|^_(?![_\s])(?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?_$/,
      endAst: /[^punctuation\s]\*(?!\*)|[punctuation]\*(?!\*)(?:(?=[punctuation_\s]|$))/,
      endUnd: /[^\s]_(?!_)(?:(?=[punctuation*\s])|$)/
    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^([\s*punctuation])/
  };
  inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
  inline.punctuation = edit2(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
  inline._blockSkip = "\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>";
  inline._overlapSkip = "__[^_]*?__|\\*\\*\\[^\\*\\]*?\\*\\*";
  inline._comment = edit2(block._comment).replace("(?:-->|$)", "-->").getRegex();
  inline.em.start = edit2(inline.em.start).replace(/punctuation/g, inline._punctuation).getRegex();
  inline.em.middle = edit2(inline.em.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();
  inline.em.endAst = edit2(inline.em.endAst, "g").replace(/punctuation/g, inline._punctuation).getRegex();
  inline.em.endUnd = edit2(inline.em.endUnd, "g").replace(/punctuation/g, inline._punctuation).getRegex();
  inline.strong.start = edit2(inline.strong.start).replace(/punctuation/g, inline._punctuation).getRegex();
  inline.strong.middle = edit2(inline.strong.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();
  inline.strong.endAst = edit2(inline.strong.endAst, "g").replace(/punctuation/g, inline._punctuation).getRegex();
  inline.strong.endUnd = edit2(inline.strong.endUnd, "g").replace(/punctuation/g, inline._punctuation).getRegex();
  inline.blockSkip = edit2(inline._blockSkip, "g").getRegex();
  inline.overlapSkip = edit2(inline._overlapSkip, "g").getRegex();
  inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline.autolink = edit2(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
  inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline.tag = edit2(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
  inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline.link = edit2(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
  inline.reflink = edit2(inline.reflink).replace("label", inline._label).getRegex();
  inline.reflinkSearch = edit2(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
  inline.normal = merge({}, inline);
  inline.pedantic = merge({}, inline.normal, {
    strong: {
      start: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      start: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit2(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
    reflink: edit2(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
  });
  inline.gfm = merge({}, inline.normal, {
    escape: edit2(inline.escape).replace("])", "~|])").getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
  });
  inline.gfm.url = edit2(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
  inline.breaks = merge({}, inline.gfm, {
    br: edit2(inline.br).replace("{2,}", "*").getRegex(),
    text: edit2(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  });
  module2.exports = {
    block,
    inline
  };
});

// node_modules/marked/src/Lexer.js
var require_Lexer = __commonJS((exports2, module2) => {
  var Tokenizer = require_Tokenizer();
  var {defaults: defaults2} = require_defaults();
  var {block, inline} = require_rules();
  var {repeatString} = require_helpers();
  function smartypants(text) {
    return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
  }
  function mangle(text) {
    let out = "", i, ch;
    const l = text.length;
    for (i = 0; i < l; i++) {
      ch = text.charCodeAt(i);
      if (Math.random() > 0.5) {
        ch = "x" + ch.toString(16);
      }
      out += "&#" + ch + ";";
    }
    return out;
  }
  module2.exports = class Lexer {
    constructor(options) {
      this.tokens = [];
      this.tokens.links = Object.create(null);
      this.options = options || defaults2;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      const rules = {
        block: block.normal,
        inline: inline.normal
      };
      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;
        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }
    static get rules() {
      return {
        block,
        inline
      };
    }
    static lex(src, options) {
      const lexer = new Lexer(options);
      return lexer.lex(src);
    }
    static lexInline(src, options) {
      const lexer = new Lexer(options);
      return lexer.inlineTokens(src);
    }
    lex(src) {
      src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
      this.blockTokens(src, this.tokens, true);
      this.inline(this.tokens);
      return this.tokens;
    }
    blockTokens(src, tokens = [], top = true) {
      src = src.replace(/^ +$/gm, "");
      let token, i, l, lastToken;
      while (src) {
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);
          if (token.type) {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.code(src, tokens)) {
          src = src.substring(token.raw.length);
          if (token.type) {
            tokens.push(token);
          } else {
            lastToken = tokens[tokens.length - 1];
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
          }
          continue;
        }
        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.nptable(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          token.tokens = this.blockTokens(token.text, [], top);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          l = token.items.length;
          for (i = 0; i < l; i++) {
            token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
          }
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (top && (token = this.tokenizer.def(src))) {
          src = src.substring(token.raw.length);
          if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }
          continue;
        }
        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (top && (token = this.tokenizer.paragraph(src))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.text(src, tokens)) {
          src = src.substring(token.raw.length);
          if (token.type) {
            tokens.push(token);
          } else {
            lastToken = tokens[tokens.length - 1];
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
          }
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    }
    inline(tokens) {
      let i, j, k, l2, row, token;
      const l = tokens.length;
      for (i = 0; i < l; i++) {
        token = tokens[i];
        switch (token.type) {
          case "paragraph":
          case "text":
          case "heading": {
            token.tokens = [];
            this.inlineTokens(token.text, token.tokens);
            break;
          }
          case "table": {
            token.tokens = {
              header: [],
              cells: []
            };
            l2 = token.header.length;
            for (j = 0; j < l2; j++) {
              token.tokens.header[j] = [];
              this.inlineTokens(token.header[j], token.tokens.header[j]);
            }
            l2 = token.cells.length;
            for (j = 0; j < l2; j++) {
              row = token.cells[j];
              token.tokens.cells[j] = [];
              for (k = 0; k < row.length; k++) {
                token.tokens.cells[j][k] = [];
                this.inlineTokens(row[k], token.tokens.cells[j][k]);
              }
            }
            break;
          }
          case "blockquote": {
            this.inline(token.tokens);
            break;
          }
          case "list": {
            l2 = token.items.length;
            for (j = 0; j < l2; j++) {
              this.inline(token.items[j].tokens);
            }
            break;
          }
          default: {
          }
        }
      }
      return tokens;
    }
    inlineTokens(src, tokens = [], inLink = false, inRawBlock = false) {
      let token;
      let maskedSrc = src;
      let match3;
      let keepPrevChar, prevChar;
      if (this.tokens.links) {
        const links3 = Object.keys(this.tokens.links);
        if (links3.length > 0) {
          while ((match3 = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links3.includes(match3[0].slice(match3[0].lastIndexOf("[") + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match3.index) + "[" + repeatString("a", match3[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      while ((match3 = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match3.index) + "[" + repeatString("a", match3[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      while (src) {
        if (!keepPrevChar) {
          prevChar = "";
        }
        keepPrevChar = false;
        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
          src = src.substring(token.raw.length);
          inLink = token.inLink;
          inRawBlock = token.inRawBlock;
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          if (token.type === "link") {
            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
          }
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          if (token.type === "link") {
            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
          }
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.autolink(src, mangle)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (!inLink && (token = this.tokenizer.url(src, mangle))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
          src = src.substring(token.raw.length);
          prevChar = token.raw.slice(-1);
          keepPrevChar = true;
          tokens.push(token);
          continue;
        }
        if (src) {
          const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    }
  };
});

// node_modules/marked/src/Renderer.js
var require_Renderer = __commonJS((exports2, module2) => {
  var {defaults: defaults2} = require_defaults();
  var {
    cleanUrl,
    escape
  } = require_helpers();
  module2.exports = class Renderer {
    constructor(options) {
      this.options = options || defaults2;
    }
    code(code, infostring, escaped) {
      const lang = (infostring || "").match(/\S*/)[0];
      if (this.options.highlight) {
        const out = this.options.highlight(code, lang);
        if (out != null && out !== code) {
          escaped = true;
          code = out;
        }
      }
      if (!lang) {
        return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    blockquote(quote) {
      return "<blockquote>\n" + quote + "</blockquote>\n";
    }
    html(html) {
      return html;
    }
    heading(text, level, raw, slugger) {
      if (this.options.headerIds) {
        return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
      }
      return "<h" + level + ">" + text + "</h" + level + ">\n";
    }
    hr() {
      return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
    }
    list(body, ordered, start) {
      const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
      return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
    }
    listitem(text) {
      return "<li>" + text + "</li>\n";
    }
    checkbox(checked) {
      return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
    }
    paragraph(text) {
      return "<p>" + text + "</p>\n";
    }
    table(header, body) {
      if (body)
        body = "<tbody>" + body + "</tbody>";
      return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
    }
    tablerow(content) {
      return "<tr>\n" + content + "</tr>\n";
    }
    tablecell(content, flags) {
      const type = flags.header ? "th" : "td";
      const tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
      return tag + content + "</" + type + ">\n";
    }
    strong(text) {
      return "<strong>" + text + "</strong>";
    }
    em(text) {
      return "<em>" + text + "</em>";
    }
    codespan(text) {
      return "<code>" + text + "</code>";
    }
    br() {
      return this.options.xhtml ? "<br/>" : "<br>";
    }
    del(text) {
      return "<del>" + text + "</del>";
    }
    link(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text;
      }
      let out = '<a href="' + escape(href) + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += ">" + text + "</a>";
      return out;
    }
    image(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text;
      }
      let out = '<img src="' + href + '" alt="' + text + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += this.options.xhtml ? "/>" : ">";
      return out;
    }
    text(text) {
      return text;
    }
  };
});

// node_modules/marked/src/TextRenderer.js
var require_TextRenderer = __commonJS((exports2, module2) => {
  module2.exports = class TextRenderer {
    strong(text) {
      return text;
    }
    em(text) {
      return text;
    }
    codespan(text) {
      return text;
    }
    del(text) {
      return text;
    }
    html(text) {
      return text;
    }
    text(text) {
      return text;
    }
    link(href, title, text) {
      return "" + text;
    }
    image(href, title, text) {
      return "" + text;
    }
    br() {
      return "";
    }
  };
});

// node_modules/marked/src/Slugger.js
var require_Slugger = __commonJS((exports2, module2) => {
  module2.exports = class Slugger {
    constructor() {
      this.seen = {};
    }
    serialize(value) {
      return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
    }
    getNextSafeSlug(originalSlug, isDryRun) {
      let slug = originalSlug;
      let occurenceAccumulator = 0;
      if (this.seen.hasOwnProperty(slug)) {
        occurenceAccumulator = this.seen[originalSlug];
        do {
          occurenceAccumulator++;
          slug = originalSlug + "-" + occurenceAccumulator;
        } while (this.seen.hasOwnProperty(slug));
      }
      if (!isDryRun) {
        this.seen[originalSlug] = occurenceAccumulator;
        this.seen[slug] = 0;
      }
      return slug;
    }
    slug(value, options = {}) {
      const slug = this.serialize(value);
      return this.getNextSafeSlug(slug, options.dryrun);
    }
  };
});

// node_modules/marked/src/Parser.js
var require_Parser = __commonJS((exports2, module2) => {
  var Renderer2 = require_Renderer();
  var TextRenderer = require_TextRenderer();
  var Slugger = require_Slugger();
  var {defaults: defaults2} = require_defaults();
  var {
    unescape: unescape2
  } = require_helpers();
  module2.exports = class Parser {
    constructor(options) {
      this.options = options || defaults2;
      this.options.renderer = this.options.renderer || new Renderer2();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer();
      this.slugger = new Slugger();
    }
    static parse(tokens, options) {
      const parser4 = new Parser(options);
      return parser4.parse(tokens);
    }
    static parseInline(tokens, options) {
      const parser4 = new Parser(options);
      return parser4.parseInline(tokens);
    }
    parse(tokens, top = true) {
      let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task2, checkbox;
      const l = tokens.length;
      for (i = 0; i < l; i++) {
        token = tokens[i];
        switch (token.type) {
          case "space": {
            continue;
          }
          case "hr": {
            out += this.renderer.hr();
            continue;
          }
          case "heading": {
            out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape2(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
            continue;
          }
          case "code": {
            out += this.renderer.code(token.text, token.lang, token.escaped);
            continue;
          }
          case "table": {
            header = "";
            cell = "";
            l2 = token.header.length;
            for (j = 0; j < l2; j++) {
              cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {header: true, align: token.align[j]});
            }
            header += this.renderer.tablerow(cell);
            body = "";
            l2 = token.cells.length;
            for (j = 0; j < l2; j++) {
              row = token.tokens.cells[j];
              cell = "";
              l3 = row.length;
              for (k = 0; k < l3; k++) {
                cell += this.renderer.tablecell(this.parseInline(row[k]), {header: false, align: token.align[k]});
              }
              body += this.renderer.tablerow(cell);
            }
            out += this.renderer.table(header, body);
            continue;
          }
          case "blockquote": {
            body = this.parse(token.tokens);
            out += this.renderer.blockquote(body);
            continue;
          }
          case "list": {
            ordered = token.ordered;
            start = token.start;
            loose = token.loose;
            l2 = token.items.length;
            body = "";
            for (j = 0; j < l2; j++) {
              item = token.items[j];
              checked = item.checked;
              task2 = item.task;
              itemBody = "";
              if (item.task) {
                checkbox = this.renderer.checkbox(checked);
                if (loose) {
                  if (item.tokens.length > 0 && item.tokens[0].type === "text") {
                    item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                      item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                    }
                  } else {
                    item.tokens.unshift({
                      type: "text",
                      text: checkbox
                    });
                  }
                } else {
                  itemBody += checkbox;
                }
              }
              itemBody += this.parse(item.tokens, loose);
              body += this.renderer.listitem(itemBody, task2, checked);
            }
            out += this.renderer.list(body, ordered, start);
            continue;
          }
          case "html": {
            out += this.renderer.html(token.text);
            continue;
          }
          case "paragraph": {
            out += this.renderer.paragraph(this.parseInline(token.tokens));
            continue;
          }
          case "text": {
            body = token.tokens ? this.parseInline(token.tokens) : token.text;
            while (i + 1 < l && tokens[i + 1].type === "text") {
              token = tokens[++i];
              body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
            }
            out += top ? this.renderer.paragraph(body) : body;
            continue;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
    parseInline(tokens, renderer2) {
      renderer2 = renderer2 || this.renderer;
      let out = "", i, token;
      const l = tokens.length;
      for (i = 0; i < l; i++) {
        token = tokens[i];
        switch (token.type) {
          case "escape": {
            out += renderer2.text(token.text);
            break;
          }
          case "html": {
            out += renderer2.html(token.text);
            break;
          }
          case "link": {
            out += renderer2.link(token.href, token.title, this.parseInline(token.tokens, renderer2));
            break;
          }
          case "image": {
            out += renderer2.image(token.href, token.title, token.text);
            break;
          }
          case "strong": {
            out += renderer2.strong(this.parseInline(token.tokens, renderer2));
            break;
          }
          case "em": {
            out += renderer2.em(this.parseInline(token.tokens, renderer2));
            break;
          }
          case "codespan": {
            out += renderer2.codespan(token.text);
            break;
          }
          case "br": {
            out += renderer2.br();
            break;
          }
          case "del": {
            out += renderer2.del(this.parseInline(token.tokens, renderer2));
            break;
          }
          case "text": {
            out += renderer2.text(token.text);
            break;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
  };
});

// node_modules/marked/src/marked.js
var require_marked = __commonJS((exports2, module2) => {
  var Lexer = require_Lexer();
  var Parser = require_Parser();
  var Tokenizer = require_Tokenizer();
  var Renderer2 = require_Renderer();
  var TextRenderer = require_TextRenderer();
  var Slugger = require_Slugger();
  var {
    merge,
    checkSanitizeDeprecation,
    escape
  } = require_helpers();
  var {
    getDefaults,
    changeDefaults,
    defaults: defaults2
  } = require_defaults();
  function marked3(src, opt, callback) {
    if (typeof src === "undefined" || src === null) {
      throw new Error("marked(): input parameter is undefined or null");
    }
    if (typeof src !== "string") {
      throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
    }
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    opt = merge({}, marked3.defaults, opt || {});
    checkSanitizeDeprecation(opt);
    if (callback) {
      const highlight = opt.highlight;
      let tokens;
      try {
        tokens = Lexer.lex(src, opt);
      } catch (e) {
        return callback(e);
      }
      const done = function(err) {
        let out;
        if (!err) {
          try {
            out = Parser.parse(tokens, opt);
          } catch (e) {
            err = e;
          }
        }
        opt.highlight = highlight;
        return err ? callback(err) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length)
        return done();
      let pending = 0;
      marked3.walkTokens(tokens, function(token) {
        if (token.type === "code") {
          pending++;
          setTimeout(() => {
            highlight(token.text, token.lang, function(err, code) {
              if (err) {
                return done(err);
              }
              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    try {
      const tokens = Lexer.lex(src, opt);
      if (opt.walkTokens) {
        marked3.walkTokens(tokens, opt.walkTokens);
      }
      return Parser.parse(tokens, opt);
    } catch (e) {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (opt.silent) {
        return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
      }
      throw e;
    }
  }
  marked3.options = marked3.setOptions = function(opt) {
    merge(marked3.defaults, opt);
    changeDefaults(marked3.defaults);
    return marked3;
  };
  marked3.getDefaults = getDefaults;
  marked3.defaults = defaults2;
  marked3.use = function(extension) {
    const opts = merge({}, extension);
    if (extension.renderer) {
      const renderer2 = marked3.defaults.renderer || new Renderer2();
      for (const prop in extension.renderer) {
        const prevRenderer = renderer2[prop];
        renderer2[prop] = (...args) => {
          let ret2 = extension.renderer[prop].apply(renderer2, args);
          if (ret2 === false) {
            ret2 = prevRenderer.apply(renderer2, args);
          }
          return ret2;
        };
      }
      opts.renderer = renderer2;
    }
    if (extension.tokenizer) {
      const tokenizer = marked3.defaults.tokenizer || new Tokenizer();
      for (const prop in extension.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args) => {
          let ret2 = extension.tokenizer[prop].apply(tokenizer, args);
          if (ret2 === false) {
            ret2 = prevTokenizer.apply(tokenizer, args);
          }
          return ret2;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (extension.walkTokens) {
      const walkTokens = marked3.defaults.walkTokens;
      opts.walkTokens = (token) => {
        extension.walkTokens(token);
        if (walkTokens) {
          walkTokens(token);
        }
      };
    }
    marked3.setOptions(opts);
  };
  marked3.walkTokens = function(tokens, callback) {
    for (const token of tokens) {
      callback(token);
      switch (token.type) {
        case "table": {
          for (const cell of token.tokens.header) {
            marked3.walkTokens(cell, callback);
          }
          for (const row of token.tokens.cells) {
            for (const cell of row) {
              marked3.walkTokens(cell, callback);
            }
          }
          break;
        }
        case "list": {
          marked3.walkTokens(token.items, callback);
          break;
        }
        default: {
          if (token.tokens) {
            marked3.walkTokens(token.tokens, callback);
          }
        }
      }
    }
  };
  marked3.parseInline = function(src, opt) {
    if (typeof src === "undefined" || src === null) {
      throw new Error("marked.parseInline(): input parameter is undefined or null");
    }
    if (typeof src !== "string") {
      throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
    }
    opt = merge({}, marked3.defaults, opt || {});
    checkSanitizeDeprecation(opt);
    try {
      const tokens = Lexer.lexInline(src, opt);
      if (opt.walkTokens) {
        marked3.walkTokens(tokens, opt.walkTokens);
      }
      return Parser.parseInline(tokens, opt);
    } catch (e) {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (opt.silent) {
        return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
      }
      throw e;
    }
  };
  marked3.Parser = Parser;
  marked3.parser = Parser.parse;
  marked3.Renderer = Renderer2;
  marked3.TextRenderer = TextRenderer;
  marked3.Lexer = Lexer;
  marked3.lexer = Lexer.lex;
  marked3.Tokenizer = Tokenizer;
  marked3.Slugger = Slugger;
  marked3.parse = marked3;
  module2.exports = marked3;
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS((exports2, module2) => {
  "use strict";
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  module2.exports = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
});

// node_modules/cli-table/node_modules/color-name/index.js
var require_color_name = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/cli-table/node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports2, module2) => {
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (var key in cssKeywords) {
    if (cssKeywords.hasOwnProperty(key)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
  }
  var convert5 = module2.exports = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  for (var model3 in convert5) {
    if (convert5.hasOwnProperty(model3)) {
      if (!("channels" in convert5[model3])) {
        throw new Error("missing channels property: " + model3);
      }
      if (!("labels" in convert5[model3])) {
        throw new Error("missing channel labels property: " + model3);
      }
      if (convert5[model3].labels.length !== convert5[model3].channels) {
        throw new Error("channel and label counts mismatch: " + model3);
      }
      channels3 = convert5[model3].channels;
      labels = convert5[model3].labels;
      delete convert5[model3].channels;
      delete convert5[model3].labels;
      Object.defineProperty(convert5[model3], "channels", {value: channels3});
      Object.defineProperty(convert5[model3], "labels", {value: labels});
    }
  }
  var channels3;
  var labels;
  convert5.rgb.hsl = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;
    var l;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert5.rgb.hsv = function(rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff3 = v - Math.min(r, g, b);
    var diffc = function(c) {
      return (v - c) / 6 / diff3 + 1 / 2;
    };
    if (diff3 === 0) {
      h = s = 0;
    } else {
      s = diff3 / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert5.rgb.hwb = function(rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert5.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert5.rgb.cmyk = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  }
  convert5.rgb.keyword = function(rgb) {
    var reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    var currentClosestDistance = Infinity;
    var currentClosestKeyword;
    for (var keyword in cssKeywords) {
      if (cssKeywords.hasOwnProperty(keyword)) {
        var value = cssKeywords[keyword];
        var distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }
    return currentClosestKeyword;
  };
  convert5.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert5.rgb.xyz = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert5.rgb.lab = function(rgb) {
    var xyz = convert5.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };
  convert5.hsl.rgb = function(hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (var i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert5.hsl.hsv = function(hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert5.hsv.rgb = function(hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert5.hsv.hsl = function(hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert5.hwb.rgb = function(hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);
    var r;
    var g;
    var b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert5.cmyk.rgb = function(cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert5.xyz.rgb = function(xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert5.xyz.lab = function(xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };
  convert5.lab.xyz = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert5.lab.lch = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert5.lch.lab = function(lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert5.rgb.ansi16 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value = 1 in arguments ? arguments[1] : convert5.rgb.hsv(args)[2];
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert5.hsv.ansi16 = function(args) {
    return convert5.rgb.ansi16(convert5.hsv.rgb(args), args[2]);
  };
  convert5.rgb.ansi256 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert5.ansi16.rgb = function(args) {
    var color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert5.ansi256.rgb = function(args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert5.rgb.hex = function(args) {
    var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    var string23 = integer.toString(16).toUpperCase();
    return "000000".substring(string23.length) + string23;
  };
  convert5.hex.rgb = function(args) {
    var match3 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match3) {
      return [0, 0, 0];
    }
    var colorString = match3[0];
    if (match3[0].length === 3) {
      colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join("");
    }
    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 255;
    var g = integer >> 8 & 255;
    var b = integer & 255;
    return [r, g, b];
  };
  convert5.rgb.hcg = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert5.hsl.hcg = function(hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;
    if (l < 0.5) {
      c = 2 * s * l;
    } else {
      c = 2 * s * (1 - l);
    }
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert5.hsv.hcg = function(hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert5.hcg.rgb = function(hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert5.hcg.hsv = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    var f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert5.hcg.hsl = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1 - c) + 0.5 * c;
    var s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert5.hcg.hwb = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert5.hwb.hcg = function(hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert5.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert5.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert5.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert5.gray.hsl = convert5.gray.hsv = function(args) {
    return [0, 0, args[0]];
  };
  convert5.gray.hwb = function(gray2) {
    return [0, 100, gray2[0]];
  };
  convert5.gray.cmyk = function(gray2) {
    return [0, 0, 0, gray2[0]];
  };
  convert5.gray.lab = function(gray2) {
    return [gray2[0], 0, 0];
  };
  convert5.gray.hex = function(gray2) {
    var val = Math.round(gray2[0] / 100 * 255) & 255;
    var integer = (val << 16) + (val << 8) + val;
    var string23 = integer.toString(16).toUpperCase();
    return "000000".substring(string23.length) + string23;
  };
  convert5.rgb.gray = function(rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// node_modules/cli-table/node_modules/color-convert/route.js
var require_route = __commonJS((exports2, module2) => {
  var conversions = require_conversions();
  function buildGraph() {
    var graph = {};
    var models = Object.keys(conversions);
    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);
      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    var path66 = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path66.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path66;
    return fn;
  }
  module2.exports = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// node_modules/cli-table/node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports2, module2) => {
  var conversions = require_conversions();
  var route = require_route();
  var convert5 = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    var wrappedFn = function(args) {
      if (args === void 0 || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    var wrappedFn = function(args) {
      if (args === void 0 || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      var result = fn(args);
      if (typeof result === "object") {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach(function(fromModel) {
    convert5[fromModel] = {};
    Object.defineProperty(convert5[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert5[fromModel], "labels", {value: conversions[fromModel].labels});
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert5[fromModel][toModel] = wrapRounded(fn);
      convert5[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module2.exports = convert5;
});

// node_modules/cli-table/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports2, module2) => {
  "use strict";
  var colorConvert = require_color_convert();
  var wrapAnsi16 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => function() {
    const rgb = fn.apply(colorConvert, arguments);
    return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles3 = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles3.color.grey = styles3.color.gray;
    for (const groupName of Object.keys(styles3)) {
      const group2 = styles3[groupName];
      for (const styleName of Object.keys(group2)) {
        const style2 = group2[styleName];
        styles3[styleName] = {
          open: `[${style2[0]}m`,
          close: `[${style2[1]}m`
        };
        group2[styleName] = styles3[styleName];
        codes.set(style2[0], style2[1]);
      }
      Object.defineProperty(styles3, groupName, {
        value: group2,
        enumerable: false
      });
      Object.defineProperty(styles3, "codes", {
        value: codes,
        enumerable: false
      });
    }
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    styles3.color.close = "[39m";
    styles3.bgColor.close = "[49m";
    styles3.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles3.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles3.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles3.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles3.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles3.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };
    for (let key of Object.keys(colorConvert)) {
      if (typeof colorConvert[key] !== "object") {
        continue;
      }
      const suite = colorConvert[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles3.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles3.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles3.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles3.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles3.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles3.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles3;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// node_modules/cli-table/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/cli-table/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS((exports2, module2) => {
  "use strict";
  var os15 = require("os");
  var hasFlag = require_has_flag2();
  var env2 = process.env;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env2) {
    forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os15.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    if (env2.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/cli-table/node_modules/chalk/templates.js
var require_templates = __commonJS((exports2, module2) => {
  "use strict";
  var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape2(c) {
    if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name2, args) {
    const results = [];
    const chunks = args.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape2(escape) : chr));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
      }
    }
    return results;
  }
  function parseStyle(style2) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style2)) !== null) {
      const name2 = matches[1];
      if (matches[2]) {
        const args = parseArguments(name2, matches[2]);
        results.push([name2].concat(args));
      } else {
        results.push([name2]);
      }
    }
    return results;
  }
  function buildStyle(chalk, styles3) {
    const enabled = {};
    for (const layer of styles3) {
      for (const style2 of layer.styles) {
        enabled[style2[0]] = layer.inverse ? null : style2.slice(1);
      }
    }
    let current = chalk;
    for (const styleName of Object.keys(enabled)) {
      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }
    return current;
  }
  module2.exports = (chalk, tmp) => {
    const styles3 = [];
    const chunks = [];
    let chunk = [];
    tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style2, close, chr) => {
      if (escapeChar) {
        chunk.push(unescape2(escapeChar));
      } else if (style2) {
        const str = chunk.join("");
        chunk = [];
        chunks.push(styles3.length === 0 ? str : buildStyle(chalk, styles3)(str));
        styles3.push({inverse, styles: parseStyle(style2)});
      } else if (close) {
        if (styles3.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk, styles3)(chunk.join("")));
        chunk = [];
        styles3.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(""));
    if (styles3.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles3.length} closing bracket${styles3.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMsg);
    }
    return chunks.join("");
  };
});

// node_modules/cli-table/node_modules/chalk/index.js
var require_chalk = __commonJS((exports2, module2) => {
  "use strict";
  var escapeStringRegexp = require_escape_string_regexp();
  var ansiStyles = require_ansi_styles();
  var stdoutColor = require_supports_color2().stdout;
  var template = require_templates();
  var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
  var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
  var skipModels = new Set(["gray"]);
  var styles3 = Object.create(null);
  function applyOptions(obj, options) {
    options = options || {};
    const scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === void 0 ? scLevel : options.level;
    obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
  }
  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk = {};
      applyOptions(chalk, options);
      chalk.template = function() {
        const args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk.template].concat(args));
      };
      Object.setPrototypeOf(chalk, Chalk.prototype);
      Object.setPrototypeOf(chalk.template, chalk);
      chalk.template.constructor = Chalk;
      return chalk.template;
    }
    applyOptions(this, options);
  }
  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = "[94m";
  }
  for (const key of Object.keys(ansiStyles)) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
    styles3[key] = {
      get() {
        const codes = ansiStyles[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  }
  styles3.visible = {
    get() {
      return build.call(this, this._styles || [], true, "visible");
    }
  };
  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
  for (const model3 of Object.keys(ansiStyles.color.ansi)) {
    if (skipModels.has(model3)) {
      continue;
    }
    styles3[model3] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.color[levelMapping[level]][model3].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.color.close,
            closeRe: ansiStyles.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model3);
        };
      }
    };
  }
  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
  for (const model3 of Object.keys(ansiStyles.bgColor.ansi)) {
    if (skipModels.has(model3)) {
      continue;
    }
    const bgModel = "bg" + model3[0].toUpperCase() + model3.slice(1);
    styles3[bgModel] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.bgColor[levelMapping[level]][model3].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.bgColor.close,
            closeRe: ansiStyles.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model3);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, styles3);
  function build(_styles, _empty2, key) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder._empty = _empty2;
    const self2 = this;
    Object.defineProperty(builder, "level", {
      enumerable: true,
      get() {
        return self2.level;
      },
      set(level) {
        self2.level = level;
      }
    });
    Object.defineProperty(builder, "enabled", {
      enumerable: true,
      get() {
        return self2.enabled;
      },
      set(enabled) {
        self2.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
    builder.__proto__ = proto;
    return builder;
  }
  function applyStyle() {
    const args = arguments;
    const argsLen = args.length;
    let str = String(arguments[0]);
    if (argsLen === 0) {
      return "";
    }
    if (argsLen > 1) {
      for (let a = 1; a < argsLen; a++) {
        str += " " + args[a];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? "" : str;
    }
    const originalDim = ansiStyles.dim.open;
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles.dim.open = "";
    }
    for (const code of this._styles.slice().reverse()) {
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
    }
    ansiStyles.dim.open = originalDim;
    return str;
  }
  function chalkTag(chalk, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(" ");
    }
    const args = [].slice.call(arguments, 2);
    const parts = [strings.raw[0]];
    for (let i = 1; i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
      parts.push(String(strings.raw[i]));
    }
    return template(chalk, parts.join(""));
  }
  Object.defineProperties(Chalk.prototype, styles3);
  module2.exports = Chalk();
  module2.exports.supportsColor = stdoutColor;
  module2.exports.default = module2.exports;
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = ({onlyFirst = false} = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  };
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS((exports2, module2) => {
  "use strict";
  var ansiRegex = require_ansi_regex();
  module2.exports = (string23) => typeof string23 === "string" ? string23.replace(ansiRegex(), "") : string23;
});

// node_modules/string-width/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS((exports2, module2) => {
  "use strict";
  var isFullwidthCodePoint = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
      return true;
    }
    return false;
  };
  module2.exports = isFullwidthCodePoint;
  module2.exports.default = isFullwidthCodePoint;
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// node_modules/string-width/index.js
var require_string_width = __commonJS((exports2, module2) => {
  "use strict";
  var stripAnsi = require_strip_ansi();
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var emojiRegex = require_emoji_regex();
  var stringWidth = (string23) => {
    string23 = string23.replace(emojiRegex(), "  ");
    if (typeof string23 !== "string" || string23.length === 0) {
      return 0;
    }
    string23 = stripAnsi(string23);
    let width = 0;
    for (let i = 0; i < string23.length; i++) {
      const code = string23.codePointAt(i);
      if (code <= 31 || code >= 127 && code <= 159) {
        continue;
      }
      if (code >= 768 && code <= 879) {
        continue;
      }
      if (code > 65535) {
        i++;
      }
      width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
  };
  module2.exports = stringWidth;
  module2.exports.default = stringWidth;
});

// node_modules/cli-table/lib/utils.js
var require_utils = __commonJS((exports2) => {
  var stringWidth = require_string_width();
  exports2.repeat = function(str, times) {
    return Array(times + 1).join(str);
  };
  exports2.pad = function(str, len, pad2, dir) {
    if (len + 1 >= str.length)
      switch (dir) {
        case "left":
          str = Array(len + 1 - str.length).join(pad2) + str;
          break;
        case "both":
          var right = Math.ceil((padlen = len - str.length) / 2);
          var left = padlen - right;
          str = Array(left + 1).join(pad2) + str + Array(right + 1).join(pad2);
          break;
        default:
          str = str + Array(len + 1 - str.length).join(pad2);
      }
    ;
    return str;
  };
  exports2.truncate = function(str, length, chr) {
    chr = chr || "\u2026";
    return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
  };
  function options(defaults2, opts) {
    for (var p in opts) {
      if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
        defaults2[p] = defaults2[p] || {};
        options(defaults2[p], opts[p]);
      } else {
        defaults2[p] = opts[p];
      }
    }
    return defaults2;
  }
  exports2.options = options;
  exports2.strlen = function(str) {
    var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
    var stripped = ("" + (str != null ? str : "")).replace(code, "");
    var split = stripped.split("\n");
    return split.reduce(function(memo, s) {
      var len = stringWidth(s);
      return len > memo ? len : memo;
    }, 0);
  };
});

// node_modules/cli-table/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "cli-table",
    description: "Pretty unicode tables for the CLI",
    version: "0.3.4",
    license: "MIT",
    author: "Guillermo Rauch <guillermo@learnboost.com>",
    contributors: [
      "Sonny Michaud <michaud.sonny@gmail.com> (http://github.com/sonnym)",
      "Gabriel Sambarino <gabriel.sambarino@gmail.com> (http://github.com/chrean)"
    ],
    repository: {
      type: "git",
      url: "https://github.com/Automattic/cli-table.git"
    },
    keywords: [
      "cli",
      "colors",
      "table"
    ],
    dependencies: {
      chalk: "^2.4.1",
      "string-width": "^4.2.0"
    },
    devDependencies: {
      "@babel/core": "^7.12.9",
      "@babel/preset-env": "^7.12.7",
      "@babel/preset-typescript": "^7.12.7",
      "babel-jest": "^26.6.3",
      expect: "^26.6.2",
      expresso: "~0.9",
      jest: "^26.6.3",
      "jest-mock": "^26.6.2",
      "publish-please": "^5.5.2",
      "ts-node": "^9.1.0",
      typescript: "^4.1.2"
    },
    main: "lib",
    files: [
      "lib"
    ],
    scripts: {
      test: "jest",
      "publish-please": "publish-please --access public"
    },
    engines: {
      node: ">= 10.0.0"
    }
  };
});

// node_modules/cli-table/lib/index.js
var require_lib6 = __commonJS((exports2, module2) => {
  var colors2 = require_chalk();
  var utils = require_utils();
  var repeat2 = utils.repeat;
  var truncate = utils.truncate;
  var pad2 = utils.pad;
  function Table2(options) {
    this.options = utils.options({
      chars: {
        top: "\u2500",
        "top-mid": "\u252C",
        "top-left": "\u250C",
        "top-right": "\u2510",
        bottom: "\u2500",
        "bottom-mid": "\u2534",
        "bottom-left": "\u2514",
        "bottom-right": "\u2518",
        left: "\u2502",
        "left-mid": "\u251C",
        mid: "\u2500",
        "mid-mid": "\u253C",
        right: "\u2502",
        "right-mid": "\u2524",
        middle: "\u2502"
      },
      truncate: "\u2026",
      colors: true,
      colWidths: [],
      colAligns: [],
      style: {
        "padding-left": 1,
        "padding-right": 1,
        head: ["red"],
        border: ["white"],
        compact: false
      },
      head: []
    }, options);
  }
  Table2.prototype.__proto__ = Array.prototype;
  Table2.prototype.__defineGetter__("width", function() {
    var str = this.toString().split("\n");
    if (str.length)
      return str[0].length;
    return 0;
  });
  Table2.prototype.render;
  Table2.prototype.toString = function() {
    var ret2 = "", options = this.options, style2 = options.style, head = options.head, chars2 = options.chars, truncater = options.truncate, colWidths = options.colWidths || new Array(this.head.length), totalWidth = 0;
    if (!head.length && !this.length)
      return "";
    if (!colWidths.length) {
      var all_rows = this.slice(0);
      if (head.length) {
        all_rows = all_rows.concat([head]);
      }
      ;
      all_rows.forEach(function(cells) {
        if (Array.isArray(cells) && cells.length) {
          extractColumnWidths(cells);
        } else {
          var header_cell = Object.keys(cells)[0], value_cell = cells[header_cell];
          colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
          if (Array.isArray(value_cell) && value_cell.length) {
            extractColumnWidths(value_cell, 1);
          } else {
            colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
          }
        }
      });
    }
    ;
    totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(function(a, b) {
      return a + b;
    })) + colWidths.length + 1;
    function extractColumnWidths(arr, offset) {
      var offset = offset || 0;
      arr.forEach(function(cell, i) {
        colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
      });
    }
    ;
    function get_width(obj) {
      return typeof obj == "object" && obj && obj.width != void 0 ? obj.width : (typeof obj == "object" && obj !== null ? utils.strlen(obj.text) : utils.strlen(obj)) + (style2["padding-left"] || 0) + (style2["padding-right"] || 0);
    }
    function line(line2, left, right, intersection) {
      var width = 0, line2 = left + repeat2(line2, totalWidth - 2) + right;
      colWidths.forEach(function(w, i) {
        if (i == colWidths.length - 1)
          return;
        width += w + 1;
        line2 = line2.substr(0, width) + intersection + line2.substr(width + 1);
      });
      return applyStyles(options.style.border, line2);
    }
    ;
    function lineTop() {
      var l2 = line(chars2.top, chars2["top-left"] || chars2.top, chars2["top-right"] || chars2.top, chars2["top-mid"]);
      if (l2)
        ret2 += l2 + "\n";
    }
    ;
    function generateRow(items, style3) {
      var cells = [], max_height = 0;
      if (!Array.isArray(items) && typeof items === "object") {
        var key = Object.keys(items)[0], value = items[key], first_cell_head = true;
        if (Array.isArray(value)) {
          items = value;
          items.unshift(key);
        } else {
          items = [key, value];
        }
      }
      items.forEach(function(item, i) {
        var contents = (item == null ? "" : item).toString().split("\n").reduce(function(memo, l2) {
          memo.push(string23(l2, i));
          return memo;
        }, []);
        var height = contents.length;
        if (height > max_height) {
          max_height = height;
        }
        ;
        cells.push({contents, height});
      });
      var lines = new Array(max_height);
      cells.forEach(function(cell, i) {
        cell.contents.forEach(function(line2, j2) {
          if (!lines[j2]) {
            lines[j2] = [];
          }
          ;
          if (style3 || first_cell_head && i === 0 && options.style.head) {
            line2 = applyStyles(options.style.head, line2);
          }
          lines[j2].push(line2);
        });
        for (var j = cell.height, l2 = max_height; j < l2; j++) {
          if (!lines[j]) {
            lines[j] = [];
          }
          ;
          lines[j].push(string23("", i));
        }
      });
      var ret3 = "";
      lines.forEach(function(line2, index) {
        if (ret3.length > 0) {
          ret3 += "\n" + applyStyles(options.style.border, chars2.left);
        }
        ret3 += line2.join(applyStyles(options.style.border, chars2.middle)) + applyStyles(options.style.border, chars2.right);
      });
      return applyStyles(options.style.border, chars2.left) + ret3;
    }
    ;
    function applyStyles(styles3, subject) {
      if (!subject)
        return "";
      if (!options.colors)
        return subject;
      styles3.forEach(function(style3) {
        subject = colors2[style3](subject);
      });
      return subject;
    }
    ;
    function string23(str, index) {
      var str = String(typeof str == "object" && str.text ? str.text : str), length = utils.strlen(str), width = colWidths[index] - (style2["padding-left"] || 0) - (style2["padding-right"] || 0), align = options.colAligns[index] || "left";
      return repeat2(" ", style2["padding-left"] || 0) + (length == width ? str : length < width ? pad2(str, width + (str.length - length), " ", align == "left" ? "right" : align == "middle" ? "both" : "left") : truncater ? truncate(str, width, truncater) : str) + repeat2(" ", style2["padding-right"] || 0);
    }
    ;
    if (head.length) {
      lineTop();
      ret2 += generateRow(head, style2.head) + "\n";
    }
    if (this.length)
      this.forEach(function(cells, i) {
        if (!head.length && i == 0)
          lineTop();
        else {
          if (!style2.compact || i < !!head.length ? 1 : cells.length == 0) {
            var l2 = line(chars2.mid, chars2["left-mid"], chars2["right-mid"], chars2["mid-mid"]);
            if (l2)
              ret2 += l2 + "\n";
          }
        }
        if (Array.isArray(cells) && !cells.length) {
          return;
        } else {
          ret2 += generateRow(cells) + "\n";
        }
        ;
      });
    var l = line(chars2.bottom, chars2["bottom-left"] || chars2.bottom, chars2["bottom-right"] || chars2.bottom, chars2["bottom-mid"]);
    if (l)
      ret2 += l;
    else
      ret2 = ret2.slice(0, -1);
    return ret2;
  };
  module2.exports = Table2;
  module2.exports.version = require_package().version;
});

// node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS((exports2, module2) => {
  "use strict";
  var ANSI_BACKGROUND_OFFSET = 10;
  var wrapAnsi256 = (offset = 0) => (code) => `[${38 + offset};5;${code}m`;
  var wrapAnsi16m = (offset = 0) => (red, green, blue2) => `[${38 + offset};2;${red};${green};${blue2}m`;
  function assembleStyles() {
    const codes = new Map();
    const styles3 = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles3.color.gray = styles3.color.blackBright;
    styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright;
    styles3.color.grey = styles3.color.blackBright;
    styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
    for (const [groupName, group2] of Object.entries(styles3)) {
      for (const [styleName, style2] of Object.entries(group2)) {
        styles3[styleName] = {
          open: `[${style2[0]}m`,
          close: `[${style2[1]}m`
        };
        group2[styleName] = styles3[styleName];
        codes.set(style2[0], style2[1]);
      }
      Object.defineProperty(styles3, groupName, {
        value: group2,
        enumerable: false
      });
    }
    Object.defineProperty(styles3, "codes", {
      value: codes,
      enumerable: false
    });
    styles3.color.close = "[39m";
    styles3.bgColor.close = "[49m";
    styles3.color.ansi256 = wrapAnsi256();
    styles3.color.ansi16m = wrapAnsi16m();
    styles3.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles3.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    styles3.rgbToAnsi256 = (red, green, blue2) => {
      if (red === green && green === blue2) {
        if (red < 8) {
          return 16;
        }
        if (red > 248) {
          return 231;
        }
        return Math.round((red - 8) / 247 * 24) + 232;
      }
      return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue2 / 255 * 5);
    };
    styles3.hexToRgb = (hex) => {
      const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
      if (!matches) {
        return [0, 0, 0];
      }
      let {colorString} = matches.groups;
      if (colorString.length === 3) {
        colorString = colorString.split("").map((character) => character + character).join("");
      }
      const integer = Number.parseInt(colorString, 16);
      return [
        integer >> 16 & 255,
        integer >> 8 & 255,
        integer & 255
      ];
    };
    styles3.hexToAnsi256 = (hex) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex));
    return styles3;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// node_modules/bytes/index.js
var require_bytes = __commonJS((exports2, module2) => {
  /*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   */
  "use strict";
  module2.exports = bytes3;
  module2.exports.format = format4;
  module2.exports.parse = parse4;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes3(value, options) {
    if (typeof value === "string") {
      return parse4(value);
    }
    if (typeof value === "number") {
      return format4(value, options);
    }
    return null;
  }
  function format4(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map[unit.toLowerCase()]) {
      if (mag >= map.pb) {
        unit = "PB";
      } else if (mag >= map.tb) {
        unit = "TB";
      } else if (mag >= map.gb) {
        unit = "GB";
      } else if (mag >= map.mb) {
        unit = "MB";
      } else if (mag >= map.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.replace(formatThousandsRegExp, thousandsSeparator);
    }
    return str + unitSeparator + unit;
  }
  function parse4(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    return Math.floor(map[unit] * floatValue);
  }
});

// node_modules/fast-diff/diff.js
var require_diff2 = __commonJS((exports2, module2) => {
  var DIFF_DELETE = -1;
  var DIFF_INSERT = 1;
  var DIFF_EQUAL = 0;
  function diff_main(text1, text2, cursor_pos, _fix_unicode) {
    if (text1 === text2) {
      if (text1) {
        return [[DIFF_EQUAL, text1]];
      }
      return [];
    }
    if (cursor_pos != null) {
      var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
      if (editdiff) {
        return editdiff;
      }
    }
    var commonlength = diff_commonPrefix(text1, text2);
    var commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);
    commonlength = diff_commonSuffix(text1, text2);
    var commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength);
    text2 = text2.substring(0, text2.length - commonlength);
    var diffs = diff_compute_(text1, text2);
    if (commonprefix) {
      diffs.unshift([DIFF_EQUAL, commonprefix]);
    }
    if (commonsuffix) {
      diffs.push([DIFF_EQUAL, commonsuffix]);
    }
    diff_cleanupMerge(diffs, _fix_unicode);
    return diffs;
  }
  function diff_compute_(text1, text2) {
    var diffs;
    if (!text1) {
      return [[DIFF_INSERT, text2]];
    }
    if (!text2) {
      return [[DIFF_DELETE, text1]];
    }
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    var i = longtext.indexOf(shorttext);
    if (i !== -1) {
      diffs = [
        [DIFF_INSERT, longtext.substring(0, i)],
        [DIFF_EQUAL, shorttext],
        [DIFF_INSERT, longtext.substring(i + shorttext.length)]
      ];
      if (text1.length > text2.length) {
        diffs[0][0] = diffs[2][0] = DIFF_DELETE;
      }
      return diffs;
    }
    if (shorttext.length === 1) {
      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
    }
    var hm = diff_halfMatch_(text1, text2);
    if (hm) {
      var text1_a = hm[0];
      var text1_b = hm[1];
      var text2_a = hm[2];
      var text2_b = hm[3];
      var mid_common = hm[4];
      var diffs_a = diff_main(text1_a, text2_a);
      var diffs_b = diff_main(text1_b, text2_b);
      return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
    }
    return diff_bisect_(text1, text2);
  }
  function diff_bisect_(text1, text2) {
    var text1_length = text1.length;
    var text2_length = text2.length;
    var max_d = Math.ceil((text1_length + text2_length) / 2);
    var v_offset = max_d;
    var v_length = 2 * max_d;
    var v12 = new Array(v_length);
    var v2 = new Array(v_length);
    for (var x = 0; x < v_length; x++) {
      v12[x] = -1;
      v2[x] = -1;
    }
    v12[v_offset + 1] = 0;
    v2[v_offset + 1] = 0;
    var delta = text1_length - text2_length;
    var front = delta % 2 !== 0;
    var k1start = 0;
    var k1end = 0;
    var k2start = 0;
    var k2end = 0;
    for (var d = 0; d < max_d; d++) {
      for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
        var k1_offset = v_offset + k1;
        var x1;
        if (k1 === -d || k1 !== d && v12[k1_offset - 1] < v12[k1_offset + 1]) {
          x1 = v12[k1_offset + 1];
        } else {
          x1 = v12[k1_offset - 1] + 1;
        }
        var y1 = x1 - k1;
        while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
          x1++;
          y1++;
        }
        v12[k1_offset] = x1;
        if (x1 > text1_length) {
          k1end += 2;
        } else if (y1 > text2_length) {
          k1start += 2;
        } else if (front) {
          var k2_offset = v_offset + delta - k1;
          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
            var x2 = text1_length - v2[k2_offset];
            if (x1 >= x2) {
              return diff_bisectSplit_(text1, text2, x1, y1);
            }
          }
        }
      }
      for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
        var k2_offset = v_offset + k2;
        var x2;
        if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
          x2 = v2[k2_offset + 1];
        } else {
          x2 = v2[k2_offset - 1] + 1;
        }
        var y2 = x2 - k2;
        while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
          x2++;
          y2++;
        }
        v2[k2_offset] = x2;
        if (x2 > text1_length) {
          k2end += 2;
        } else if (y2 > text2_length) {
          k2start += 2;
        } else if (!front) {
          var k1_offset = v_offset + delta - k2;
          if (k1_offset >= 0 && k1_offset < v_length && v12[k1_offset] !== -1) {
            var x1 = v12[k1_offset];
            var y1 = v_offset + x1 - k1_offset;
            x2 = text1_length - x2;
            if (x1 >= x2) {
              return diff_bisectSplit_(text1, text2, x1, y1);
            }
          }
        }
      }
    }
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }
  function diff_bisectSplit_(text1, text2, x, y) {
    var text1a = text1.substring(0, x);
    var text2a = text2.substring(0, y);
    var text1b = text1.substring(x);
    var text2b = text2.substring(y);
    var diffs = diff_main(text1a, text2a);
    var diffsb = diff_main(text1b, text2b);
    return diffs.concat(diffsb);
  }
  function diff_commonPrefix(text1, text2) {
    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
      return 0;
    }
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerstart = 0;
    while (pointermin < pointermid) {
      if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
        pointermin = pointermid;
        pointerstart = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
      pointermid--;
    }
    return pointermid;
  }
  function diff_commonSuffix(text1, text2) {
    if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
      return 0;
    }
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerend = 0;
    while (pointermin < pointermid) {
      if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
        pointermin = pointermid;
        pointerend = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
      pointermid--;
    }
    return pointermid;
  }
  function diff_halfMatch_(text1, text2) {
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
      return null;
    }
    function diff_halfMatchI_(longtext2, shorttext2, i) {
      var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
      var j = -1;
      var best_common = "";
      var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
      while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
        var prefixLength = diff_commonPrefix(longtext2.substring(i), shorttext2.substring(j));
        var suffixLength = diff_commonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
        if (best_common.length < suffixLength + prefixLength) {
          best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
          best_longtext_a = longtext2.substring(0, i - suffixLength);
          best_longtext_b = longtext2.substring(i + prefixLength);
          best_shorttext_a = shorttext2.substring(0, j - suffixLength);
          best_shorttext_b = shorttext2.substring(j + prefixLength);
        }
      }
      if (best_common.length * 2 >= longtext2.length) {
        return [
          best_longtext_a,
          best_longtext_b,
          best_shorttext_a,
          best_shorttext_b,
          best_common
        ];
      } else {
        return null;
      }
    }
    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
    var hm;
    if (!hm1 && !hm2) {
      return null;
    } else if (!hm2) {
      hm = hm1;
    } else if (!hm1) {
      hm = hm2;
    } else {
      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
    }
    var text1_a, text1_b, text2_a, text2_b;
    if (text1.length > text2.length) {
      text1_a = hm[0];
      text1_b = hm[1];
      text2_a = hm[2];
      text2_b = hm[3];
    } else {
      text2_a = hm[0];
      text2_b = hm[1];
      text1_a = hm[2];
      text1_b = hm[3];
    }
    var mid_common = hm[4];
    return [text1_a, text1_b, text2_a, text2_b, mid_common];
  }
  function diff_cleanupMerge(diffs, fix_unicode) {
    diffs.push([DIFF_EQUAL, ""]);
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = "";
    var text_insert = "";
    var commonlength;
    while (pointer < diffs.length) {
      if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
        diffs.splice(pointer, 1);
        continue;
      }
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          pointer++;
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          pointer++;
          break;
        case DIFF_EQUAL:
          var previous_equality = pointer - count_insert - count_delete - 1;
          if (fix_unicode) {
            if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
              var stray = diffs[previous_equality][1].slice(-1);
              diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);
              text_delete = stray + text_delete;
              text_insert = stray + text_insert;
              if (!diffs[previous_equality][1]) {
                diffs.splice(previous_equality, 1);
                pointer--;
                var k = previous_equality - 1;
                if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                  count_insert++;
                  text_insert = diffs[k][1] + text_insert;
                  k--;
                }
                if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                  count_delete++;
                  text_delete = diffs[k][1] + text_delete;
                  k--;
                }
                previous_equality = k;
              }
            }
            if (starts_with_pair_end(diffs[pointer][1])) {
              var stray = diffs[pointer][1].charAt(0);
              diffs[pointer][1] = diffs[pointer][1].slice(1);
              text_delete += stray;
              text_insert += stray;
            }
          }
          if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
            diffs.splice(pointer, 1);
            break;
          }
          if (text_delete.length > 0 || text_insert.length > 0) {
            if (text_delete.length > 0 && text_insert.length > 0) {
              commonlength = diff_commonPrefix(text_insert, text_delete);
              if (commonlength !== 0) {
                if (previous_equality >= 0) {
                  diffs[previous_equality][1] += text_insert.substring(0, commonlength);
                } else {
                  diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                  pointer++;
                }
                text_insert = text_insert.substring(commonlength);
                text_delete = text_delete.substring(commonlength);
              }
              commonlength = diff_commonSuffix(text_insert, text_delete);
              if (commonlength !== 0) {
                diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                text_insert = text_insert.substring(0, text_insert.length - commonlength);
                text_delete = text_delete.substring(0, text_delete.length - commonlength);
              }
            }
            var n = count_insert + count_delete;
            if (text_delete.length === 0 && text_insert.length === 0) {
              diffs.splice(pointer - n, n);
              pointer = pointer - n;
            } else if (text_delete.length === 0) {
              diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
              pointer = pointer - n + 1;
            } else if (text_insert.length === 0) {
              diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
              pointer = pointer - n + 1;
            } else {
              diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
              pointer = pointer - n + 2;
            }
          }
          if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
            diffs[pointer - 1][1] += diffs[pointer][1];
            diffs.splice(pointer, 1);
          } else {
            pointer++;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = "";
          text_insert = "";
          break;
      }
    }
    if (diffs[diffs.length - 1][1] === "") {
      diffs.pop();
    }
    var changes = false;
    pointer = 1;
    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
        if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
          diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
          diffs.splice(pointer - 1, 1);
          changes = true;
        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
          diffs[pointer - 1][1] += diffs[pointer + 1][1];
          diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
          diffs.splice(pointer + 1, 1);
          changes = true;
        }
      }
      pointer++;
    }
    if (changes) {
      diff_cleanupMerge(diffs, fix_unicode);
    }
  }
  function is_surrogate_pair_start(charCode2) {
    return charCode2 >= 55296 && charCode2 <= 56319;
  }
  function is_surrogate_pair_end(charCode2) {
    return charCode2 >= 56320 && charCode2 <= 57343;
  }
  function starts_with_pair_end(str) {
    return is_surrogate_pair_end(str.charCodeAt(0));
  }
  function ends_with_pair_start(str) {
    return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
  }
  function remove_empty_tuples(tuples) {
    var ret2 = [];
    for (var i = 0; i < tuples.length; i++) {
      if (tuples[i][1].length > 0) {
        ret2.push(tuples[i]);
      }
    }
    return ret2;
  }
  function make_edit_splice(before, oldMiddle, newMiddle, after) {
    if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
      return null;
    }
    return remove_empty_tuples([
      [DIFF_EQUAL, before],
      [DIFF_DELETE, oldMiddle],
      [DIFF_INSERT, newMiddle],
      [DIFF_EQUAL, after]
    ]);
  }
  function find_cursor_edit_diff(oldText, newText, cursor_pos) {
    var oldRange = typeof cursor_pos === "number" ? {index: cursor_pos, length: 0} : cursor_pos.oldRange;
    var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
    var oldLength = oldText.length;
    var newLength = newText.length;
    if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
      var oldCursor = oldRange.index;
      var oldBefore = oldText.slice(0, oldCursor);
      var oldAfter = oldText.slice(oldCursor);
      var maybeNewCursor = newRange ? newRange.index : null;
      editBefore: {
        var newCursor = oldCursor + newLength - oldLength;
        if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
          break editBefore;
        }
        if (newCursor < 0 || newCursor > newLength) {
          break editBefore;
        }
        var newBefore = newText.slice(0, newCursor);
        var newAfter = newText.slice(newCursor);
        if (newAfter !== oldAfter) {
          break editBefore;
        }
        var prefixLength = Math.min(oldCursor, newCursor);
        var oldPrefix = oldBefore.slice(0, prefixLength);
        var newPrefix = newBefore.slice(0, prefixLength);
        if (oldPrefix !== newPrefix) {
          break editBefore;
        }
        var oldMiddle = oldBefore.slice(prefixLength);
        var newMiddle = newBefore.slice(prefixLength);
        return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
      }
      editAfter: {
        if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
          break editAfter;
        }
        var cursor = oldCursor;
        var newBefore = newText.slice(0, cursor);
        var newAfter = newText.slice(cursor);
        if (newBefore !== oldBefore) {
          break editAfter;
        }
        var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
        var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
        var newSuffix = newAfter.slice(newAfter.length - suffixLength);
        if (oldSuffix !== newSuffix) {
          break editAfter;
        }
        var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
        var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
        return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
      }
    }
    if (oldRange.length > 0 && newRange && newRange.length === 0) {
      replaceRange: {
        var oldPrefix = oldText.slice(0, oldRange.index);
        var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
        var prefixLength = oldPrefix.length;
        var suffixLength = oldSuffix.length;
        if (newLength < prefixLength + suffixLength) {
          break replaceRange;
        }
        var newPrefix = newText.slice(0, prefixLength);
        var newSuffix = newText.slice(newLength - suffixLength);
        if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
          break replaceRange;
        }
        var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
        var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
        return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
      }
    }
    return null;
  }
  function diff3(text1, text2, cursor_pos) {
    return diff_main(text1, text2, cursor_pos, true);
  }
  diff3.INSERT = DIFF_INSERT;
  diff3.DELETE = DIFF_DELETE;
  diff3.EQUAL = DIFF_EQUAL;
  module2.exports = diff3;
});

// node_modules/universalify/index.js
var require_universalify2 = __commonJS((exports2) => {
  "use strict";
  exports2.fromCallback = function(fn) {
    return Object.defineProperty(function(...args) {
      if (typeof args[args.length - 1] === "function")
        fn.apply(this, args);
      else {
        return new Promise((resolve3, reject) => {
          fn.apply(this, args.concat([(err, res) => err ? reject(err) : resolve3(res)]));
        });
      }
    }, "name", {value: fn.name});
  };
  exports2.fromPromise = function(fn) {
    return Object.defineProperty(function(...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== "function")
        return fn.apply(this, args);
      else
        fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
    }, "name", {value: fn.name});
  };
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs2 = __commonJS((exports2) => {
  "use strict";
  var u = require_universalify2().fromCallback;
  var fs55 = require_graceful_fs();
  var api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs55[key] === "function";
  });
  Object.keys(fs55).forEach((key) => {
    if (key === "promises") {
      return;
    }
    exports2[key] = fs55[key];
  });
  api.forEach((method) => {
    exports2[method] = u(fs55[method]);
  });
  exports2.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs55.exists(filename, callback);
    }
    return new Promise((resolve3) => {
      return fs55.exists(filename, resolve3);
    });
  };
  exports2.read = function(fd, buffer4, offset, length, position15, callback) {
    if (typeof callback === "function") {
      return fs55.read(fd, buffer4, offset, length, position15, callback);
    }
    return new Promise((resolve3, reject) => {
      fs55.read(fd, buffer4, offset, length, position15, (err, bytesRead, buffer5) => {
        if (err)
          return reject(err);
        resolve3({bytesRead, buffer: buffer5});
      });
    });
  };
  exports2.write = function(fd, buffer4, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs55.write(fd, buffer4, ...args);
    }
    return new Promise((resolve3, reject) => {
      fs55.write(fd, buffer4, ...args, (err, bytesWritten, buffer5) => {
        if (err)
          return reject(err);
        resolve3({bytesWritten, buffer: buffer5});
      });
    });
  };
  if (typeof fs55.writev === "function") {
    exports2.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs55.writev(fd, buffers, ...args);
      }
      return new Promise((resolve3, reject) => {
        fs55.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve3({bytesWritten, buffers: buffers2});
        });
      });
    };
  }
  if (typeof fs55.realpath.native === "function") {
    exports2.realpath.native = u(fs55.realpath.native);
  }
});

// node_modules/at-least-node/index.js
var require_at_least_node = __commonJS((exports2, module2) => {
  module2.exports = (r) => {
    const n = process.versions.node.split(".").map((x) => parseInt(x, 10));
    r = r.split(".").map((x) => parseInt(x, 10));
    return n[0] > r[0] || n[0] === r[0] && (n[1] > r[1] || n[1] === r[1] && n[2] >= r[2]);
  };
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_fs2();
  var path66 = require("path");
  var atLeastNode = require_at_least_node();
  var useNativeRecursiveOption = atLeastNode("10.12.0");
  var checkPath = (pth) => {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path66.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = "EINVAL";
        throw error;
      }
    }
  };
  var processOptions = (options) => {
    const defaults2 = {mode: 511};
    if (typeof options === "number")
      options = {mode: options};
    return {...defaults2, ...options};
  };
  var permissionError = (pth) => {
    const error = new Error(`operation not permitted, mkdir '${pth}'`);
    error.code = "EPERM";
    error.errno = -4048;
    error.path = pth;
    error.syscall = "mkdir";
    return error;
  };
  module2.exports.makeDir = async (input, options) => {
    checkPath(input);
    options = processOptions(options);
    if (useNativeRecursiveOption) {
      const pth = path66.resolve(input);
      return fs55.mkdir(pth, {
        mode: options.mode,
        recursive: true
      });
    }
    const make = async (pth) => {
      try {
        await fs55.mkdir(pth, options.mode);
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path66.dirname(pth) === pth) {
            throw permissionError(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          await make(path66.dirname(pth));
          return make(pth);
        }
        try {
          const stats = await fs55.stat(pth);
          if (!stats.isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch {
          throw error;
        }
      }
    };
    return make(path66.resolve(input));
  };
  module2.exports.makeDirSync = (input, options) => {
    checkPath(input);
    options = processOptions(options);
    if (useNativeRecursiveOption) {
      const pth = path66.resolve(input);
      return fs55.mkdirSync(pth, {
        mode: options.mode,
        recursive: true
      });
    }
    const make = (pth) => {
      try {
        fs55.mkdirSync(pth, options.mode);
      } catch (error) {
        if (error.code === "EPERM") {
          throw error;
        }
        if (error.code === "ENOENT") {
          if (path66.dirname(pth) === pth) {
            throw permissionError(pth);
          }
          if (error.message.includes("null bytes")) {
            throw error;
          }
          make(path66.dirname(pth));
          return make(pth);
        }
        try {
          if (!fs55.statSync(pth).isDirectory()) {
            throw new Error("The path is not a directory");
          }
        } catch {
          throw error;
        }
      }
    };
    return make(path66.resolve(input));
  };
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs3 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify2().fromPromise;
  var {makeDir: _makeDir, makeDirSync} = require_make_dir();
  var makeDir = u(_makeDir);
  module2.exports = {
    mkdirs: makeDir,
    mkdirsSync: makeDirSync,
    mkdirp: makeDir,
    mkdirpSync: makeDirSync,
    ensureDir: makeDir,
    ensureDirSync: makeDirSync
  };
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes2 = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  function utimesMillis(path66, atime, mtime, callback) {
    fs55.open(path66, "r+", (err, fd) => {
      if (err)
        return callback(err);
      fs55.futimes(fd, atime, mtime, (futimesErr) => {
        fs55.close(fd, (closeErr) => {
          if (callback)
            callback(futimesErr || closeErr);
        });
      });
    });
  }
  function utimesMillisSync(path66, atime, mtime) {
    const fd = fs55.openSync(path66, "r+");
    fs55.futimesSync(fd, atime, mtime);
    return fs55.closeSync(fd);
  }
  module2.exports = {
    utimesMillis,
    utimesMillisSync
  };
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat2 = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_fs2();
  var path66 = require("path");
  var util54 = require("util");
  var atLeastNode = require_at_least_node();
  var nodeSupportsBigInt = atLeastNode("10.5.0");
  var stat = (file) => nodeSupportsBigInt ? fs55.stat(file, {bigint: true}) : fs55.stat(file);
  var statSync = (file) => nodeSupportsBigInt ? fs55.statSync(file, {bigint: true}) : fs55.statSync(file);
  function getStats(src, dest) {
    return Promise.all([
      stat(src),
      stat(dest).catch((err) => {
        if (err.code === "ENOENT")
          return null;
        throw err;
      })
    ]).then(([srcStat, destStat]) => ({srcStat, destStat}));
  }
  function getStatsSync(src, dest) {
    let destStat;
    const srcStat = statSync(src);
    try {
      destStat = statSync(dest);
    } catch (err) {
      if (err.code === "ENOENT")
        return {srcStat, destStat: null};
      throw err;
    }
    return {srcStat, destStat};
  }
  function checkPaths(src, dest, funcName, cb) {
    util54.callbackify(getStats)(src, dest, (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat, destStat} = stats;
      if (destStat && areIdentical(srcStat, destStat)) {
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        return cb(new Error(errMsg(src, dest, funcName)));
      }
      return cb(null, {srcStat, destStat});
    });
  }
  function checkPathsSync(src, dest, funcName) {
    const {srcStat, destStat} = getStatsSync(src, dest);
    if (destStat && areIdentical(srcStat, destStat)) {
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return {srcStat, destStat};
  }
  function checkParentPaths(src, srcStat, dest, funcName, cb) {
    const srcParent = path66.resolve(path66.dirname(src));
    const destParent = path66.resolve(path66.dirname(dest));
    if (destParent === srcParent || destParent === path66.parse(destParent).root)
      return cb();
    const callback = (err, destStat) => {
      if (err) {
        if (err.code === "ENOENT")
          return cb();
        return cb(err);
      }
      if (areIdentical(srcStat, destStat)) {
        return cb(new Error(errMsg(src, dest, funcName)));
      }
      return checkParentPaths(src, srcStat, destParent, funcName, cb);
    };
    if (nodeSupportsBigInt)
      fs55.stat(destParent, {bigint: true}, callback);
    else
      fs55.stat(destParent, callback);
  }
  function checkParentPathsSync(src, srcStat, dest, funcName) {
    const srcParent = path66.resolve(path66.dirname(src));
    const destParent = path66.resolve(path66.dirname(dest));
    if (destParent === srcParent || destParent === path66.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = statSync(destParent);
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
  }
  function areIdentical(srcStat, destStat) {
    if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
      if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {
        return true;
      }
      if (destStat.size === srcStat.size && destStat.mode === srcStat.mode && destStat.nlink === srcStat.nlink && destStat.atimeMs === srcStat.atimeMs && destStat.mtimeMs === srcStat.mtimeMs && destStat.ctimeMs === srcStat.ctimeMs && destStat.birthtimeMs === srcStat.birthtimeMs) {
        return true;
      }
    }
    return false;
  }
  function isSrcSubdir(src, dest) {
    const srcArr = path66.resolve(src).split(path66.sep).filter((i) => i);
    const destArr = path66.resolve(dest).split(path66.sep).filter((i) => i);
    return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
  }
  function errMsg(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
  }
  module2.exports = {
    checkPaths,
    checkPathsSync,
    checkParentPaths,
    checkParentPathsSync,
    isSrcSubdir
  };
});

// node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync3 = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var mkdirsSync = require_mkdirs3().mkdirsSync;
  var utimesMillisSync = require_utimes2().utimesMillisSync;
  var stat = require_stat2();
  function copySync(src, dest, opts) {
    if (typeof opts === "function") {
      opts = {filter: opts};
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
    }
    const {srcStat, destStat} = stat.checkPathsSync(src, dest, "copy");
    stat.checkParentPathsSync(src, srcStat, dest, "copy");
    return handleFilterAndCopy(destStat, src, dest, opts);
  }
  function handleFilterAndCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest))
      return;
    const destParent = path66.dirname(dest);
    if (!fs55.existsSync(destParent))
      mkdirsSync(destParent);
    return startCopy(destStat, src, dest, opts);
  }
  function startCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest))
      return;
    return getStats(destStat, src, dest, opts);
  }
  function getStats(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs55.statSync : fs55.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    else if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
  }
  function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    return mayCopyFile(srcStat, src, dest, opts);
  }
  function mayCopyFile(srcStat, src, dest, opts) {
    if (opts.overwrite) {
      fs55.unlinkSync(dest);
      return copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile(srcStat, src, dest, opts) {
    fs55.copyFileSync(src, dest);
    if (opts.preserveTimestamps)
      handleTimestamps(srcStat.mode, src, dest);
    return setDestMode(dest, srcStat.mode);
  }
  function handleTimestamps(srcMode, src, dest) {
    if (fileIsNotWritable(srcMode))
      makeFileWritable(dest, srcMode);
    return setDestTimestamps(src, dest);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return setDestMode(dest, srcMode | 128);
  }
  function setDestMode(dest, srcMode) {
    return fs55.chmodSync(dest, srcMode);
  }
  function setDestTimestamps(src, dest) {
    const updatedSrcStat = fs55.statSync(src);
    return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return mkDirAndCopy(srcStat.mode, src, dest, opts);
    if (destStat && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    return copyDir(src, dest, opts);
  }
  function mkDirAndCopy(srcMode, src, dest, opts) {
    fs55.mkdirSync(dest);
    copyDir(src, dest, opts);
    return setDestMode(dest, srcMode);
  }
  function copyDir(src, dest, opts) {
    fs55.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
  }
  function copyDirItem(item, src, dest, opts) {
    const srcItem = path66.join(src, item);
    const destItem = path66.join(dest, item);
    const {destStat} = stat.checkPathsSync(srcItem, destItem, "copy");
    return startCopy(destStat, srcItem, destItem, opts);
  }
  function onLink(destStat, src, dest, opts) {
    let resolvedSrc = fs55.readlinkSync(src);
    if (opts.dereference) {
      resolvedSrc = path66.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs55.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs55.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN")
          return fs55.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path66.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (fs55.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink(resolvedSrc, dest);
    }
  }
  function copyLink(resolvedSrc, dest) {
    fs55.unlinkSync(dest);
    return fs55.symlinkSync(resolvedSrc, dest);
  }
  module2.exports = copySync;
});

// node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync4 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    copySync: require_copy_sync3()
  };
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify2().fromPromise;
  var fs55 = require_fs2();
  function pathExists(path66) {
    return fs55.access(path66).then(() => true).catch(() => false);
  }
  module2.exports = {
    pathExists: u(pathExists),
    pathExistsSync: fs55.existsSync
  };
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy3 = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var mkdirs = require_mkdirs3().mkdirs;
  var pathExists = require_path_exists2().pathExists;
  var utimesMillis = require_utimes2().utimesMillis;
  var stat = require_stat2();
  function copy(src, dest, opts, cb) {
    if (typeof opts === "function" && !cb) {
      cb = opts;
      opts = {};
    } else if (typeof opts === "function") {
      opts = {filter: opts};
    }
    cb = cb || function() {
    };
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
    }
    stat.checkPaths(src, dest, "copy", (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat, destStat} = stats;
      stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
        if (err2)
          return cb(err2);
        if (opts.filter)
          return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
        return checkParentDir(destStat, src, dest, opts, cb);
      });
    });
  }
  function checkParentDir(destStat, src, dest, opts, cb) {
    const destParent = path66.dirname(dest);
    pathExists(destParent, (err, dirExists) => {
      if (err)
        return cb(err);
      if (dirExists)
        return startCopy(destStat, src, dest, opts, cb);
      mkdirs(destParent, (err2) => {
        if (err2)
          return cb(err2);
        return startCopy(destStat, src, dest, opts, cb);
      });
    });
  }
  function handleFilter(onInclude, destStat, src, dest, opts, cb) {
    Promise.resolve(opts.filter(src, dest)).then((include) => {
      if (include)
        return onInclude(destStat, src, dest, opts, cb);
      return cb();
    }, (error) => cb(error));
  }
  function startCopy(destStat, src, dest, opts, cb) {
    if (opts.filter)
      return handleFilter(getStats, destStat, src, dest, opts, cb);
    return getStats(destStat, src, dest, opts, cb);
  }
  function getStats(destStat, src, dest, opts, cb) {
    const stat2 = opts.dereference ? fs55.stat : fs55.lstat;
    stat2(src, (err, srcStat) => {
      if (err)
        return cb(err);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts, cb);
    });
  }
  function onFile(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts, cb);
    return mayCopyFile(srcStat, src, dest, opts, cb);
  }
  function mayCopyFile(srcStat, src, dest, opts, cb) {
    if (opts.overwrite) {
      fs55.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return copyFile(srcStat, src, dest, opts, cb);
      });
    } else if (opts.errorOnExist) {
      return cb(new Error(`'${dest}' already exists`));
    } else
      return cb();
  }
  function copyFile(srcStat, src, dest, opts, cb) {
    fs55.copyFile(src, dest, (err) => {
      if (err)
        return cb(err);
      if (opts.preserveTimestamps)
        return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
      return setDestMode(dest, srcStat.mode, cb);
    });
  }
  function handleTimestampsAndMode(srcMode, src, dest, cb) {
    if (fileIsNotWritable(srcMode)) {
      return makeFileWritable(dest, srcMode, (err) => {
        if (err)
          return cb(err);
        return setDestTimestampsAndMode(srcMode, src, dest, cb);
      });
    }
    return setDestTimestampsAndMode(srcMode, src, dest, cb);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode, cb) {
    return setDestMode(dest, srcMode | 128, cb);
  }
  function setDestTimestampsAndMode(srcMode, src, dest, cb) {
    setDestTimestamps(src, dest, (err) => {
      if (err)
        return cb(err);
      return setDestMode(dest, srcMode, cb);
    });
  }
  function setDestMode(dest, srcMode, cb) {
    return fs55.chmod(dest, srcMode, cb);
  }
  function setDestTimestamps(src, dest, cb) {
    fs55.stat(src, (err, updatedSrcStat) => {
      if (err)
        return cb(err);
      return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
    });
  }
  function onDir(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat)
      return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
    if (destStat && !destStat.isDirectory()) {
      return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
    }
    return copyDir(src, dest, opts, cb);
  }
  function mkDirAndCopy(srcMode, src, dest, opts, cb) {
    fs55.mkdir(dest, (err) => {
      if (err)
        return cb(err);
      copyDir(src, dest, opts, (err2) => {
        if (err2)
          return cb(err2);
        return setDestMode(dest, srcMode, cb);
      });
    });
  }
  function copyDir(src, dest, opts, cb) {
    fs55.readdir(src, (err, items) => {
      if (err)
        return cb(err);
      return copyDirItems(items, src, dest, opts, cb);
    });
  }
  function copyDirItems(items, src, dest, opts, cb) {
    const item = items.pop();
    if (!item)
      return cb();
    return copyDirItem(items, item, src, dest, opts, cb);
  }
  function copyDirItem(items, item, src, dest, opts, cb) {
    const srcItem = path66.join(src, item);
    const destItem = path66.join(dest, item);
    stat.checkPaths(srcItem, destItem, "copy", (err, stats) => {
      if (err)
        return cb(err);
      const {destStat} = stats;
      startCopy(destStat, srcItem, destItem, opts, (err2) => {
        if (err2)
          return cb(err2);
        return copyDirItems(items, src, dest, opts, cb);
      });
    });
  }
  function onLink(destStat, src, dest, opts, cb) {
    fs55.readlink(src, (err, resolvedSrc) => {
      if (err)
        return cb(err);
      if (opts.dereference) {
        resolvedSrc = path66.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs55.symlink(resolvedSrc, dest, cb);
      } else {
        fs55.readlink(dest, (err2, resolvedDest) => {
          if (err2) {
            if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
              return fs55.symlink(resolvedSrc, dest, cb);
            return cb(err2);
          }
          if (opts.dereference) {
            resolvedDest = path66.resolve(process.cwd(), resolvedDest);
          }
          if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
            return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
          }
          if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
            return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
          }
          return copyLink(resolvedSrc, dest, cb);
        });
      }
    });
  }
  function copyLink(resolvedSrc, dest, cb) {
    fs55.unlink(dest, (err) => {
      if (err)
        return cb(err);
      return fs55.symlink(resolvedSrc, dest, cb);
    });
  }
  module2.exports = copy;
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy4 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify2().fromCallback;
  module2.exports = {
    copy: u(require_copy3())
  };
});

// node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf2 = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var assert = require("assert");
  var isWindows4 = process.platform === "win32";
  function defaults2(options) {
    const methods2 = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods2.forEach((m) => {
      options[m] = options[m] || fs55[m];
      m = m + "Sync";
      options[m] = options[m] || fs55[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
  }
  function rimraf(p, options, cb) {
    let busyTries = 0;
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    defaults2(options);
    rimraf_(p, options, function CB(er) {
      if (er) {
        if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
          busyTries++;
          const time = busyTries * 100;
          return setTimeout(() => rimraf_(p, options, CB), time);
        }
        if (er.code === "ENOENT")
          er = null;
      }
      cb(er);
    });
  }
  function rimraf_(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT") {
        return cb(null);
      }
      if (er && er.code === "EPERM" && isWindows4) {
        return fixWinEPERM(p, options, er, cb);
      }
      if (st && st.isDirectory()) {
        return rmdir(p, options, er, cb);
      }
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT") {
            return cb(null);
          }
          if (er2.code === "EPERM") {
            return isWindows4 ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          }
          if (er2.code === "EISDIR") {
            return rmdir(p, options, er2, cb);
          }
        }
        return cb(er2);
      });
    });
  }
  function fixWinEPERM(p, options, er, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2) {
        cb(er2.code === "ENOENT" ? null : er);
      } else {
        options.stat(p, (er3, stats) => {
          if (er3) {
            cb(er3.code === "ENOENT" ? null : er);
          } else if (stats.isDirectory()) {
            rmdir(p, options, er, cb);
          } else {
            options.unlink(p, cb);
          }
        });
      }
    });
  }
  function fixWinEPERMSync(p, options, er) {
    let stats;
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    if (stats.isDirectory()) {
      rmdirSync(p, options, er);
    } else {
      options.unlinkSync(p);
    }
  }
  function rmdir(p, options, originalEr, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
        rmkids(p, options, cb);
      } else if (er && er.code === "ENOTDIR") {
        cb(originalEr);
      } else {
        cb(er);
      }
    });
  }
  function rmkids(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er)
        return cb(er);
      let n = files.length;
      let errState;
      if (n === 0)
        return options.rmdir(p, cb);
      files.forEach((f) => {
        rimraf(path66.join(p, f), options, (er2) => {
          if (errState) {
            return;
          }
          if (er2)
            return cb(errState = er2);
          if (--n === 0) {
            options.rmdir(p, cb);
          }
        });
      });
    });
  }
  function rimrafSync(p, options) {
    let st;
    options = options || {};
    defaults2(options);
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    try {
      st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      }
      if (er.code === "EPERM" && isWindows4) {
        fixWinEPERMSync(p, options, er);
      }
    }
    try {
      if (st && st.isDirectory()) {
        rmdirSync(p, options, null);
      } else {
        options.unlinkSync(p);
      }
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      } else if (er.code === "EPERM") {
        return isWindows4 ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
      } else if (er.code !== "EISDIR") {
        throw er;
      }
      rmdirSync(p, options, er);
    }
  }
  function rmdirSync(p, options, originalEr) {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOTDIR") {
        throw originalEr;
      } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
        rmkidsSync(p, options);
      } else if (er.code !== "ENOENT") {
        throw er;
      }
    }
  }
  function rmkidsSync(p, options) {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path66.join(p, f), options));
    if (isWindows4) {
      const startTime = Date.now();
      do {
        try {
          const ret2 = options.rmdirSync(p, options);
          return ret2;
        } catch {
        }
      } while (Date.now() - startTime < 500);
    } else {
      const ret2 = options.rmdirSync(p, options);
      return ret2;
    }
  }
  module2.exports = rimraf;
  rimraf.sync = rimrafSync;
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify2().fromCallback;
  var rimraf = require_rimraf2();
  module2.exports = {
    remove: u(rimraf),
    removeSync: rimraf.sync
  };
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify2().fromCallback;
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var mkdir = require_mkdirs3();
  var remove = require_remove2();
  var emptyDir = u(function emptyDir2(dir, callback) {
    callback = callback || function() {
    };
    fs55.readdir(dir, (err, items) => {
      if (err)
        return mkdir.mkdirs(dir, callback);
      items = items.map((item) => path66.join(dir, item));
      deleteItem();
      function deleteItem() {
        const item = items.pop();
        if (!item)
          return callback();
        remove.remove(item, (err2) => {
          if (err2)
            return callback(err2);
          deleteItem();
        });
      }
    });
  });
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs55.readdirSync(dir);
    } catch {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path66.join(dir, item);
      remove.removeSync(item);
    });
  }
  module2.exports = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file3 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify2().fromCallback;
  var path66 = require("path");
  var fs55 = require_graceful_fs();
  var mkdir = require_mkdirs3();
  function createFile(file, callback) {
    function makeFile() {
      fs55.writeFile(file, "", (err) => {
        if (err)
          return callback(err);
        callback();
      });
    }
    fs55.stat(file, (err, stats) => {
      if (!err && stats.isFile())
        return callback();
      const dir = path66.dirname(file);
      fs55.stat(dir, (err2, stats2) => {
        if (err2) {
          if (err2.code === "ENOENT") {
            return mkdir.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeFile();
            });
          }
          return callback(err2);
        }
        if (stats2.isDirectory())
          makeFile();
        else {
          fs55.readdir(dir, (err3) => {
            if (err3)
              return callback(err3);
          });
        }
      });
    });
  }
  function createFileSync(file) {
    let stats;
    try {
      stats = fs55.statSync(file);
    } catch {
    }
    if (stats && stats.isFile())
      return;
    const dir = path66.dirname(file);
    try {
      if (!fs55.statSync(dir).isDirectory()) {
        fs55.readdirSync(dir);
      }
    } catch (err) {
      if (err && err.code === "ENOENT")
        mkdir.mkdirsSync(dir);
      else
        throw err;
    }
    fs55.writeFileSync(file, "");
  }
  module2.exports = {
    createFile: u(createFile),
    createFileSync
  };
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify2().fromCallback;
  var path66 = require("path");
  var fs55 = require_graceful_fs();
  var mkdir = require_mkdirs3();
  var pathExists = require_path_exists2().pathExists;
  function createLink(srcpath, dstpath, callback) {
    function makeLink(srcpath2, dstpath2) {
      fs55.link(srcpath2, dstpath2, (err) => {
        if (err)
          return callback(err);
        callback(null);
      });
    }
    pathExists(dstpath, (err, destinationExists) => {
      if (err)
        return callback(err);
      if (destinationExists)
        return callback(null);
      fs55.lstat(srcpath, (err2) => {
        if (err2) {
          err2.message = err2.message.replace("lstat", "ensureLink");
          return callback(err2);
        }
        const dir = path66.dirname(dstpath);
        pathExists(dir, (err3, dirExists) => {
          if (err3)
            return callback(err3);
          if (dirExists)
            return makeLink(srcpath, dstpath);
          mkdir.mkdirs(dir, (err4) => {
            if (err4)
              return callback(err4);
            makeLink(srcpath, dstpath);
          });
        });
      });
    });
  }
  function createLinkSync(srcpath, dstpath) {
    const destinationExists = fs55.existsSync(dstpath);
    if (destinationExists)
      return void 0;
    try {
      fs55.lstatSync(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path66.dirname(dstpath);
    const dirExists = fs55.existsSync(dir);
    if (dirExists)
      return fs55.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs55.linkSync(srcpath, dstpath);
  }
  module2.exports = {
    createLink: u(createLink),
    createLinkSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths2 = __commonJS((exports2, module2) => {
  "use strict";
  var path66 = require("path");
  var fs55 = require_graceful_fs();
  var pathExists = require_path_exists2().pathExists;
  function symlinkPaths(srcpath, dstpath, callback) {
    if (path66.isAbsolute(srcpath)) {
      return fs55.lstat(srcpath, (err) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          return callback(err);
        }
        return callback(null, {
          toCwd: srcpath,
          toDst: srcpath
        });
      });
    } else {
      const dstdir = path66.dirname(dstpath);
      const relativeToDst = path66.join(dstdir, srcpath);
      return pathExists(relativeToDst, (err, exists) => {
        if (err)
          return callback(err);
        if (exists) {
          return callback(null, {
            toCwd: relativeToDst,
            toDst: srcpath
          });
        } else {
          return fs55.lstat(srcpath, (err2) => {
            if (err2) {
              err2.message = err2.message.replace("lstat", "ensureSymlink");
              return callback(err2);
            }
            return callback(null, {
              toCwd: srcpath,
              toDst: path66.relative(dstdir, srcpath)
            });
          });
        }
      });
    }
  }
  function symlinkPathsSync(srcpath, dstpath) {
    let exists;
    if (path66.isAbsolute(srcpath)) {
      exists = fs55.existsSync(srcpath);
      if (!exists)
        throw new Error("absolute srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    } else {
      const dstdir = path66.dirname(dstpath);
      const relativeToDst = path66.join(dstdir, srcpath);
      exists = fs55.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      } else {
        exists = fs55.existsSync(srcpath);
        if (!exists)
          throw new Error("relative srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: path66.relative(dstdir, srcpath)
        };
      }
    }
  }
  module2.exports = {
    symlinkPaths,
    symlinkPathsSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type2 = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  function symlinkType(srcpath, type, callback) {
    callback = typeof type === "function" ? type : callback;
    type = typeof type === "function" ? false : type;
    if (type)
      return callback(null, type);
    fs55.lstat(srcpath, (err, stats) => {
      if (err)
        return callback(null, "file");
      type = stats && stats.isDirectory() ? "dir" : "file";
      callback(null, type);
    });
  }
  function symlinkTypeSync(srcpath, type) {
    let stats;
    if (type)
      return type;
    try {
      stats = fs55.lstatSync(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  module2.exports = {
    symlinkType,
    symlinkTypeSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify2().fromCallback;
  var path66 = require("path");
  var fs55 = require_graceful_fs();
  var _mkdirs = require_mkdirs3();
  var mkdirs = _mkdirs.mkdirs;
  var mkdirsSync = _mkdirs.mkdirsSync;
  var _symlinkPaths = require_symlink_paths2();
  var symlinkPaths = _symlinkPaths.symlinkPaths;
  var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
  var _symlinkType = require_symlink_type2();
  var symlinkType = _symlinkType.symlinkType;
  var symlinkTypeSync = _symlinkType.symlinkTypeSync;
  var pathExists = require_path_exists2().pathExists;
  function createSymlink(srcpath, dstpath, type, callback) {
    callback = typeof type === "function" ? type : callback;
    type = typeof type === "function" ? false : type;
    pathExists(dstpath, (err, destinationExists) => {
      if (err)
        return callback(err);
      if (destinationExists)
        return callback(null);
      symlinkPaths(srcpath, dstpath, (err2, relative) => {
        if (err2)
          return callback(err2);
        srcpath = relative.toDst;
        symlinkType(relative.toCwd, type, (err3, type2) => {
          if (err3)
            return callback(err3);
          const dir = path66.dirname(dstpath);
          pathExists(dir, (err4, dirExists) => {
            if (err4)
              return callback(err4);
            if (dirExists)
              return fs55.symlink(srcpath, dstpath, type2, callback);
            mkdirs(dir, (err5) => {
              if (err5)
                return callback(err5);
              fs55.symlink(srcpath, dstpath, type2, callback);
            });
          });
        });
      });
    });
  }
  function createSymlinkSync(srcpath, dstpath, type) {
    const destinationExists = fs55.existsSync(dstpath);
    if (destinationExists)
      return void 0;
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type = symlinkTypeSync(relative.toCwd, type);
    const dir = path66.dirname(dstpath);
    const exists = fs55.existsSync(dir);
    if (exists)
      return fs55.symlinkSync(srcpath, dstpath, type);
    mkdirsSync(dir);
    return fs55.symlinkSync(srcpath, dstpath, type);
  }
  module2.exports = {
    createSymlink: u(createSymlink),
    createSymlinkSync
  };
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure2 = __commonJS((exports2, module2) => {
  "use strict";
  var file = require_file3();
  var link = require_link2();
  var symlink = require_symlink2();
  module2.exports = {
    createFile: file.createFile,
    createFileSync: file.createFileSync,
    ensureFile: file.createFile,
    ensureFileSync: file.createFileSync,
    createLink: link.createLink,
    createLinkSync: link.createLinkSync,
    ensureLink: link.createLink,
    ensureLinkSync: link.createLinkSync,
    createSymlink: symlink.createSymlink,
    createSymlinkSync: symlink.createSymlinkSync,
    ensureSymlink: symlink.createSymlink,
    ensureSymlinkSync: symlink.createSymlinkSync
  };
});

// node_modules/jsonfile/node_modules/universalify/index.js
var require_universalify3 = __commonJS((exports2) => {
  "use strict";
  exports2.fromCallback = function(fn) {
    return Object.defineProperty(function(...args) {
      if (typeof args[args.length - 1] === "function")
        fn.apply(this, args);
      else {
        return new Promise((resolve3, reject) => {
          fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve3(res));
        });
      }
    }, "name", {value: fn.name});
  };
  exports2.fromPromise = function(fn) {
    return Object.defineProperty(function(...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== "function")
        return fn.apply(this, args);
      else
        fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
    }, "name", {value: fn.name});
  };
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS((exports2, module2) => {
  function stringify2(obj, {EOL = "\n", finalEOL = true, replacer = null, spaces} = {}) {
    const EOF = finalEOL ? EOL : "";
    const str = JSON.stringify(obj, replacer, spaces);
    return str.replace(/\n/g, EOL) + EOF;
  }
  function stripBom(content) {
    if (Buffer.isBuffer(content))
      content = content.toString("utf8");
    return content.replace(/^\uFEFF/, "");
  }
  module2.exports = {stringify: stringify2, stripBom};
});

// node_modules/jsonfile/index.js
var require_jsonfile3 = __commonJS((exports2, module2) => {
  var _fs;
  try {
    _fs = require_graceful_fs();
  } catch (_) {
    _fs = require("fs");
  }
  var universalify = require_universalify3();
  var {stringify: stringify2, stripBom} = require_utils2();
  async function _readFile(file, options = {}) {
    if (typeof options === "string") {
      options = {encoding: options};
    }
    const fs55 = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    let data = await universalify.fromCallback(fs55.readFile)(file, options);
    data = stripBom(data);
    let obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
    return obj;
  }
  var readFile2 = universalify.fromPromise(_readFile);
  function readFileSync(file, options = {}) {
    if (typeof options === "string") {
      options = {encoding: options};
    }
    const fs55 = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    try {
      let content = fs55.readFileSync(file, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
  }
  async function _writeFile(file, obj, options = {}) {
    const fs55 = options.fs || _fs;
    const str = stringify2(obj, options);
    await universalify.fromCallback(fs55.writeFile)(file, str, options);
  }
  var writeFile2 = universalify.fromPromise(_writeFile);
  function writeFileSync(file, obj, options = {}) {
    const fs55 = options.fs || _fs;
    const str = stringify2(obj, options);
    return fs55.writeFileSync(file, str, options);
  }
  var jsonfile = {
    readFile: readFile2,
    readFileSync,
    writeFile: writeFile2,
    writeFileSync
  };
  module2.exports = jsonfile;
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile4 = __commonJS((exports2, module2) => {
  "use strict";
  var jsonFile = require_jsonfile3();
  module2.exports = {
    readJson: jsonFile.readFile,
    readJsonSync: jsonFile.readFileSync,
    writeJson: jsonFile.writeFile,
    writeJsonSync: jsonFile.writeFileSync
  };
});

// node_modules/fs-extra/lib/output/index.js
var require_output2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify2().fromCallback;
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var mkdir = require_mkdirs3();
  var pathExists = require_path_exists2().pathExists;
  function outputFile(file, data, encoding, callback) {
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = "utf8";
    }
    const dir = path66.dirname(file);
    pathExists(dir, (err, itDoes) => {
      if (err)
        return callback(err);
      if (itDoes)
        return fs55.writeFile(file, data, encoding, callback);
      mkdir.mkdirs(dir, (err2) => {
        if (err2)
          return callback(err2);
        fs55.writeFile(file, data, encoding, callback);
      });
    });
  }
  function outputFileSync(file, ...args) {
    const dir = path66.dirname(file);
    if (fs55.existsSync(dir)) {
      return fs55.writeFileSync(file, ...args);
    }
    mkdir.mkdirsSync(dir);
    fs55.writeFileSync(file, ...args);
  }
  module2.exports = {
    outputFile: u(outputFile),
    outputFileSync
  };
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json2 = __commonJS((exports2, module2) => {
  "use strict";
  var {stringify: stringify2} = require_utils2();
  var {outputFile} = require_output2();
  async function outputJson(file, data, options = {}) {
    const str = stringify2(data, options);
    await outputFile(file, str, options);
  }
  module2.exports = outputJson;
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync2 = __commonJS((exports2, module2) => {
  "use strict";
  var {stringify: stringify2} = require_utils2();
  var {outputFileSync} = require_output2();
  function outputJsonSync(file, data, options) {
    const str = stringify2(data, options);
    outputFileSync(file, str, options);
  }
  module2.exports = outputJsonSync;
});

// node_modules/fs-extra/lib/json/index.js
var require_json2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify2().fromPromise;
  var jsonFile = require_jsonfile4();
  jsonFile.outputJson = u(require_output_json2());
  jsonFile.outputJsonSync = require_output_json_sync2();
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  module2.exports = jsonFile;
});

// node_modules/fs-extra/lib/move-sync/move-sync.js
var require_move_sync3 = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var copySync = require_copy_sync4().copySync;
  var removeSync = require_remove2().removeSync;
  var mkdirpSync = require_mkdirs3().mkdirpSync;
  var stat = require_stat2();
  function moveSync(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const {srcStat} = stat.checkPathsSync(src, dest, "move");
    stat.checkParentPathsSync(src, srcStat, dest, "move");
    mkdirpSync(path66.dirname(dest));
    return doRename(src, dest, overwrite);
  }
  function doRename(src, dest, overwrite) {
    if (overwrite) {
      removeSync(dest);
      return rename(src, dest, overwrite);
    }
    if (fs55.existsSync(dest))
      throw new Error("dest already exists.");
    return rename(src, dest, overwrite);
  }
  function rename(src, dest, overwrite) {
    try {
      fs55.renameSync(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV")
        throw err;
      return moveAcrossDevice(src, dest, overwrite);
    }
  }
  function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copySync(src, dest, opts);
    return removeSync(src);
  }
  module2.exports = moveSync;
});

// node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync4 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    moveSync: require_move_sync3()
  };
});

// node_modules/fs-extra/lib/move/move.js
var require_move3 = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require_graceful_fs();
  var path66 = require("path");
  var copy = require_copy4().copy;
  var remove = require_remove2().remove;
  var mkdirp = require_mkdirs3().mkdirp;
  var pathExists = require_path_exists2().pathExists;
  var stat = require_stat2();
  function move(src, dest, opts, cb) {
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    const overwrite = opts.overwrite || opts.clobber || false;
    stat.checkPaths(src, dest, "move", (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat} = stats;
      stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
        if (err2)
          return cb(err2);
        mkdirp(path66.dirname(dest), (err3) => {
          if (err3)
            return cb(err3);
          return doRename(src, dest, overwrite, cb);
        });
      });
    });
  }
  function doRename(src, dest, overwrite, cb) {
    if (overwrite) {
      return remove(dest, (err) => {
        if (err)
          return cb(err);
        return rename(src, dest, overwrite, cb);
      });
    }
    pathExists(dest, (err, destExists) => {
      if (err)
        return cb(err);
      if (destExists)
        return cb(new Error("dest already exists."));
      return rename(src, dest, overwrite, cb);
    });
  }
  function rename(src, dest, overwrite, cb) {
    fs55.rename(src, dest, (err) => {
      if (!err)
        return cb();
      if (err.code !== "EXDEV")
        return cb(err);
      return moveAcrossDevice(src, dest, overwrite, cb);
    });
  }
  function moveAcrossDevice(src, dest, overwrite, cb) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copy(src, dest, opts, (err) => {
      if (err)
        return cb(err);
      return remove(src, cb);
    });
  }
  module2.exports = move;
});

// node_modules/fs-extra/lib/move/index.js
var require_move4 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify2().fromCallback;
  module2.exports = {
    move: u(require_move3())
  };
});

// node_modules/fs-extra/lib/index.js
var require_lib7 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    ...require_fs2(),
    ...require_copy_sync4(),
    ...require_copy4(),
    ...require_empty2(),
    ...require_ensure2(),
    ...require_json2(),
    ...require_mkdirs3(),
    ...require_move_sync4(),
    ...require_move4(),
    ...require_output2(),
    ...require_path_exists2(),
    ...require_remove2()
  };
  var fs55 = require("fs");
  if (Object.getOwnPropertyDescriptor(fs55, "promises")) {
    Object.defineProperty(module2.exports, "promises", {
      get() {
        return fs55.promises;
      }
    });
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports2, module2) => {
  module2.exports = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range2(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range2;
  function range2(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports2, module2) => {
  var concatMap = require_concat_map();
  var balanced = require_balanced_match();
  module2.exports = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad2 = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad2) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports2, module2) => {
  module2.exports = minimatch11;
  minimatch11.Minimatch = Minimatch;
  var path66 = {sep: "/"};
  try {
    path66 = require("path");
  } catch (er) {
  }
  var GLOBSTAR = minimatch11.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = require_brace_expansion();
  var plTypes = {
    "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
    "?": {open: "(?:", close: ")?"},
    "+": {open: "(?:", close: ")+"},
    "*": {open: "(?:", close: ")*"},
    "@": {open: "(?:", close: ")"}
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch11.filter = filter;
  function filter(pattern, options) {
    options = options || {};
    return function(p, i, list2) {
      return minimatch11(p, pattern, options);
    };
  }
  function ext(a, b) {
    a = a || {};
    b = b || {};
    var t = {};
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    return t;
  }
  minimatch11.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch11;
    var orig = minimatch11;
    var m = function minimatch12(p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch2(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return Minimatch;
    return minimatch11.defaults(def).Minimatch;
  };
  function minimatch11(p, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    if (pattern.trim() === "")
      return p === "";
    return new Minimatch(pattern, options).match(p);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (path66.sep !== "/") {
      pattern = pattern.split(path66.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    if (this._made)
      return;
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = console.error;
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch11.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    if (typeof pattern === "undefined") {
      throw new TypeError("undefined pattern");
    }
    if (options.nobrace || !pattern.match(/\{.*\}/)) {
      return [pattern];
    }
    return expand(pattern);
  }
  Minimatch.prototype.parse = parse4;
  var SUBPARSE = {};
  function parse4(pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError("pattern is too long");
    }
    var options = this.options;
    if (!options.noglobstar && pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/":
          return false;
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          if (inClass) {
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch11.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch11.match = function(list2, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list2 = list2.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list2.length) {
      list2.push(pattern);
    }
    return list2;
  };
  Minimatch.prototype.match = match3;
  function match3(f, partial) {
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options = this.options;
    if (path66.sep !== "/") {
      f = f.split(path66.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  }
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", {this: this, file, pattern});
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase();
        } else {
          hit = f === p;
        }
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      var emptyFileEnd = fi === fl - 1 && file[fi] === "";
      return emptyFileEnd;
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
});

// node_modules/node-int64/Int64.js
var require_Int64 = __commonJS((exports2, module2) => {
  var VAL32 = 4294967296;
  var _HEX = [];
  for (var i = 0; i < 256; i++) {
    _HEX[i] = (i > 15 ? "" : "0") + i.toString(16);
  }
  var Int64 = module2.exports = function(a1, a2) {
    if (a1 instanceof Buffer) {
      this.buffer = a1;
      this.offset = a2 || 0;
    } else if (Object.prototype.toString.call(a1) == "[object Uint8Array]") {
      this.buffer = new Buffer(a1);
      this.offset = a2 || 0;
    } else {
      this.buffer = this.buffer || new Buffer(8);
      this.offset = 0;
      this.setValue.apply(this, arguments);
    }
  };
  Int64.MAX_INT = Math.pow(2, 53);
  Int64.MIN_INT = -Math.pow(2, 53);
  Int64.prototype = {
    constructor: Int64,
    _2scomp: function() {
      var b = this.buffer, o = this.offset, carry = 1;
      for (var i2 = o + 7; i2 >= o; i2--) {
        var v = (b[i2] ^ 255) + carry;
        b[i2] = v & 255;
        carry = v >> 8;
      }
    },
    setValue: function(hi, lo) {
      var negate = false;
      if (arguments.length == 1) {
        if (typeof hi == "number") {
          negate = hi < 0;
          hi = Math.abs(hi);
          lo = hi % VAL32;
          hi = hi / VAL32;
          if (hi > VAL32)
            throw new RangeError(hi + " is outside Int64 range");
          hi = hi | 0;
        } else if (typeof hi == "string") {
          hi = (hi + "").replace(/^0x/, "");
          lo = hi.substr(-8);
          hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : "";
          hi = parseInt(hi, 16);
          lo = parseInt(lo, 16);
        } else {
          throw new Error(hi + " must be a Number or String");
        }
      }
      var b = this.buffer, o = this.offset;
      for (var i2 = 7; i2 >= 0; i2--) {
        b[o + i2] = lo & 255;
        lo = i2 == 4 ? hi : lo >>> 8;
      }
      if (negate)
        this._2scomp();
    },
    toNumber: function(allowImprecise) {
      var b = this.buffer, o = this.offset;
      var negate = b[o] & 128, x = 0, carry = 1;
      for (var i2 = 7, m = 1; i2 >= 0; i2--, m *= 256) {
        var v = b[o + i2];
        if (negate) {
          v = (v ^ 255) + carry;
          carry = v >> 8;
          v = v & 255;
        }
        x += v * m;
      }
      if (!allowImprecise && x >= Int64.MAX_INT) {
        return negate ? -Infinity : Infinity;
      }
      return negate ? -x : x;
    },
    valueOf: function() {
      return this.toNumber(false);
    },
    toString: function(radix) {
      return this.valueOf().toString(radix || 10);
    },
    toOctetString: function(sep) {
      var out = new Array(8);
      var b = this.buffer, o = this.offset;
      for (var i2 = 0; i2 < 8; i2++) {
        out[i2] = _HEX[b[o + i2]];
      }
      return out.join(sep || "");
    },
    toBuffer: function(rawBuffer) {
      if (rawBuffer && this.offset === 0)
        return this.buffer;
      var out = new Buffer(8);
      this.buffer.copy(out, 0, this.offset, this.offset + 8);
      return out;
    },
    copy: function(targetBuffer, targetOffset) {
      this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
    },
    compare: function(other) {
      if ((this.buffer[this.offset] & 128) != (other.buffer[other.offset] & 128)) {
        return other.buffer[other.offset] - this.buffer[this.offset];
      }
      for (var i2 = 0; i2 < 8; i2++) {
        if (this.buffer[this.offset + i2] !== other.buffer[other.offset + i2]) {
          return this.buffer[this.offset + i2] - other.buffer[other.offset + i2];
        }
      }
      return 0;
    },
    equals: function(other) {
      return this.compare(other) === 0;
    },
    inspect: function() {
      return "[Int64 value:" + this + " octets:" + this.toOctetString(" ") + "]";
    }
  };
});

// node_modules/bser/index.js
var require_bser = __commonJS((exports2) => {
  var EE = require("events").EventEmitter;
  var util54 = require("util");
  var os15 = require("os");
  var assert = require("assert");
  var Int64 = require_Int64();
  var isBigEndian = os15.endianness() == "BE";
  function nextPow2(size) {
    return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));
  }
  function Accumulator(initsize) {
    this.buf = Buffer.alloc(nextPow2(initsize || 8192));
    this.readOffset = 0;
    this.writeOffset = 0;
  }
  exports2.Accumulator = Accumulator;
  Accumulator.prototype.writeAvail = function() {
    return this.buf.length - this.writeOffset;
  };
  Accumulator.prototype.readAvail = function() {
    return this.writeOffset - this.readOffset;
  };
  Accumulator.prototype.reserve = function(size) {
    if (size < this.writeAvail()) {
      return;
    }
    if (this.readOffset > 0) {
      this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);
      this.writeOffset -= this.readOffset;
      this.readOffset = 0;
    }
    if (size < this.writeAvail()) {
      return;
    }
    var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));
    this.buf.copy(buf);
    this.buf = buf;
  };
  Accumulator.prototype.append = function(buf) {
    if (Buffer.isBuffer(buf)) {
      this.reserve(buf.length);
      buf.copy(this.buf, this.writeOffset, 0, buf.length);
      this.writeOffset += buf.length;
    } else {
      var size = Buffer.byteLength(buf);
      this.reserve(size);
      this.buf.write(buf, this.writeOffset);
      this.writeOffset += size;
    }
  };
  Accumulator.prototype.assertReadableSize = function(size) {
    if (this.readAvail() < size) {
      throw new Error("wanted to read " + size + " bytes but only have " + this.readAvail());
    }
  };
  Accumulator.prototype.peekString = function(size) {
    this.assertReadableSize(size);
    return this.buf.toString("utf-8", this.readOffset, this.readOffset + size);
  };
  Accumulator.prototype.readString = function(size) {
    var str = this.peekString(size);
    this.readOffset += size;
    return str;
  };
  Accumulator.prototype.peekInt = function(size) {
    this.assertReadableSize(size);
    switch (size) {
      case 1:
        return this.buf.readInt8(this.readOffset, size);
      case 2:
        return isBigEndian ? this.buf.readInt16BE(this.readOffset, size) : this.buf.readInt16LE(this.readOffset, size);
      case 4:
        return isBigEndian ? this.buf.readInt32BE(this.readOffset, size) : this.buf.readInt32LE(this.readOffset, size);
      case 8:
        var big = this.buf.slice(this.readOffset, this.readOffset + 8);
        if (isBigEndian) {
          return new Int64(big);
        }
        return new Int64(byteswap64(big));
      default:
        throw new Error("invalid integer size " + size);
    }
  };
  Accumulator.prototype.readInt = function(bytes3) {
    var ival = this.peekInt(bytes3);
    if (ival instanceof Int64 && isFinite(ival.valueOf())) {
      ival = ival.valueOf();
    }
    this.readOffset += bytes3;
    return ival;
  };
  Accumulator.prototype.peekDouble = function() {
    this.assertReadableSize(8);
    return isBigEndian ? this.buf.readDoubleBE(this.readOffset) : this.buf.readDoubleLE(this.readOffset);
  };
  Accumulator.prototype.readDouble = function() {
    var dval = this.peekDouble();
    this.readOffset += 8;
    return dval;
  };
  Accumulator.prototype.readAdvance = function(size) {
    if (size > 0) {
      this.assertReadableSize(size);
    } else if (size < 0 && this.readOffset + size < 0) {
      throw new Error("advance with negative offset " + size + " would seek off the start of the buffer");
    }
    this.readOffset += size;
  };
  Accumulator.prototype.writeByte = function(value) {
    this.reserve(1);
    this.buf.writeInt8(value, this.writeOffset);
    ++this.writeOffset;
  };
  Accumulator.prototype.writeInt = function(value, size) {
    this.reserve(size);
    switch (size) {
      case 1:
        this.buf.writeInt8(value, this.writeOffset);
        break;
      case 2:
        if (isBigEndian) {
          this.buf.writeInt16BE(value, this.writeOffset);
        } else {
          this.buf.writeInt16LE(value, this.writeOffset);
        }
        break;
      case 4:
        if (isBigEndian) {
          this.buf.writeInt32BE(value, this.writeOffset);
        } else {
          this.buf.writeInt32LE(value, this.writeOffset);
        }
        break;
      default:
        throw new Error("unsupported integer size " + size);
    }
    this.writeOffset += size;
  };
  Accumulator.prototype.writeDouble = function(value) {
    this.reserve(8);
    if (isBigEndian) {
      this.buf.writeDoubleBE(value, this.writeOffset);
    } else {
      this.buf.writeDoubleLE(value, this.writeOffset);
    }
    this.writeOffset += 8;
  };
  var BSER_ARRAY = 0;
  var BSER_OBJECT = 1;
  var BSER_STRING = 2;
  var BSER_INT8 = 3;
  var BSER_INT16 = 4;
  var BSER_INT32 = 5;
  var BSER_INT64 = 6;
  var BSER_REAL = 7;
  var BSER_TRUE = 8;
  var BSER_FALSE = 9;
  var BSER_NULL = 10;
  var BSER_TEMPLATE = 11;
  var BSER_SKIP = 12;
  var ST_NEED_PDU = 0;
  var ST_FILL_PDU = 1;
  var MAX_INT8 = 127;
  var MAX_INT16 = 32767;
  var MAX_INT32 = 2147483647;
  function BunserBuf() {
    EE.call(this);
    this.buf = new Accumulator();
    this.state = ST_NEED_PDU;
  }
  util54.inherits(BunserBuf, EE);
  exports2.BunserBuf = BunserBuf;
  BunserBuf.prototype.append = function(buf, synchronous) {
    if (synchronous) {
      this.buf.append(buf);
      return this.process(synchronous);
    }
    try {
      this.buf.append(buf);
    } catch (err) {
      this.emit("error", err);
      return;
    }
    this.processLater();
  };
  BunserBuf.prototype.processLater = function() {
    var self2 = this;
    process.nextTick(function() {
      try {
        self2.process(false);
      } catch (err) {
        self2.emit("error", err);
      }
    });
  };
  BunserBuf.prototype.process = function(synchronous) {
    if (this.state == ST_NEED_PDU) {
      if (this.buf.readAvail() < 2) {
        return;
      }
      this.expectCode(0);
      this.expectCode(1);
      this.pduLen = this.decodeInt(true);
      if (this.pduLen === false) {
        this.buf.readAdvance(-2);
        return;
      }
      this.buf.reserve(this.pduLen);
      this.state = ST_FILL_PDU;
    }
    if (this.state == ST_FILL_PDU) {
      if (this.buf.readAvail() < this.pduLen) {
        return;
      }
      var val = this.decodeAny();
      if (synchronous) {
        return val;
      }
      this.emit("value", val);
      this.state = ST_NEED_PDU;
    }
    if (!synchronous && this.buf.readAvail() > 0) {
      this.processLater();
    }
  };
  BunserBuf.prototype.raise = function(reason) {
    throw new Error(reason + ", in Buffer of length " + this.buf.buf.length + " (" + this.buf.readAvail() + " readable) at offset " + this.buf.readOffset + " buffer: " + JSON.stringify(this.buf.buf.slice(this.buf.readOffset, this.buf.readOffset + 32).toJSON()));
  };
  BunserBuf.prototype.expectCode = function(expected) {
    var code = this.buf.readInt(1);
    if (code != expected) {
      this.raise("expected bser opcode " + expected + " but got " + code);
    }
  };
  BunserBuf.prototype.decodeAny = function() {
    var code = this.buf.peekInt(1);
    switch (code) {
      case BSER_INT8:
      case BSER_INT16:
      case BSER_INT32:
      case BSER_INT64:
        return this.decodeInt();
      case BSER_REAL:
        this.buf.readAdvance(1);
        return this.buf.readDouble();
      case BSER_TRUE:
        this.buf.readAdvance(1);
        return true;
      case BSER_FALSE:
        this.buf.readAdvance(1);
        return false;
      case BSER_NULL:
        this.buf.readAdvance(1);
        return null;
      case BSER_STRING:
        return this.decodeString();
      case BSER_ARRAY:
        return this.decodeArray();
      case BSER_OBJECT:
        return this.decodeObject();
      case BSER_TEMPLATE:
        return this.decodeTemplate();
      default:
        this.raise("unhandled bser opcode " + code);
    }
  };
  BunserBuf.prototype.decodeArray = function() {
    this.expectCode(BSER_ARRAY);
    var nitems = this.decodeInt();
    var arr = [];
    for (var i = 0; i < nitems; ++i) {
      arr.push(this.decodeAny());
    }
    return arr;
  };
  BunserBuf.prototype.decodeObject = function() {
    this.expectCode(BSER_OBJECT);
    var nitems = this.decodeInt();
    var res = {};
    for (var i = 0; i < nitems; ++i) {
      var key = this.decodeString();
      var val = this.decodeAny();
      res[key] = val;
    }
    return res;
  };
  BunserBuf.prototype.decodeTemplate = function() {
    this.expectCode(BSER_TEMPLATE);
    var keys = this.decodeArray();
    var nitems = this.decodeInt();
    var arr = [];
    for (var i = 0; i < nitems; ++i) {
      var obj = {};
      for (var keyidx = 0; keyidx < keys.length; ++keyidx) {
        if (this.buf.peekInt(1) == BSER_SKIP) {
          this.buf.readAdvance(1);
          continue;
        }
        var val = this.decodeAny();
        obj[keys[keyidx]] = val;
      }
      arr.push(obj);
    }
    return arr;
  };
  BunserBuf.prototype.decodeString = function() {
    this.expectCode(BSER_STRING);
    var len = this.decodeInt();
    return this.buf.readString(len);
  };
  BunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {
    if (relaxSizeAsserts && this.buf.readAvail() < 1) {
      return false;
    } else {
      this.buf.assertReadableSize(1);
    }
    var code = this.buf.peekInt(1);
    var size = 0;
    switch (code) {
      case BSER_INT8:
        size = 1;
        break;
      case BSER_INT16:
        size = 2;
        break;
      case BSER_INT32:
        size = 4;
        break;
      case BSER_INT64:
        size = 8;
        break;
      default:
        this.raise("invalid bser int encoding " + code);
    }
    if (relaxSizeAsserts && this.buf.readAvail() < 1 + size) {
      return false;
    }
    this.buf.readAdvance(1);
    return this.buf.readInt(size);
  };
  function loadFromBuffer(input) {
    var buf = new BunserBuf();
    var result = buf.append(input, true);
    if (buf.buf.readAvail()) {
      throw Error("excess data found after input buffer, use BunserBuf instead");
    }
    if (typeof result === "undefined") {
      throw Error("no bser found in string and no error raised!?");
    }
    return result;
  }
  exports2.loadFromBuffer = loadFromBuffer;
  function byteswap64(buf) {
    var swap = Buffer.alloc(buf.length);
    for (var i = 0; i < buf.length; i++) {
      swap[i] = buf[buf.length - 1 - i];
    }
    return swap;
  }
  function dump_int64(buf, val) {
    var be = val.toBuffer();
    if (isBigEndian) {
      buf.writeByte(BSER_INT64);
      buf.append(be);
      return;
    }
    var le = byteswap64(be);
    buf.writeByte(BSER_INT64);
    buf.append(le);
  }
  function dump_int(buf, val) {
    var abs = Math.abs(val);
    if (abs <= MAX_INT8) {
      buf.writeByte(BSER_INT8);
      buf.writeInt(val, 1);
    } else if (abs <= MAX_INT16) {
      buf.writeByte(BSER_INT16);
      buf.writeInt(val, 2);
    } else if (abs <= MAX_INT32) {
      buf.writeByte(BSER_INT32);
      buf.writeInt(val, 4);
    } else {
      dump_int64(buf, new Int64(val));
    }
  }
  function dump_any(buf, val) {
    switch (typeof val) {
      case "number":
        if (isFinite(val) && Math.floor(val) === val) {
          dump_int(buf, val);
        } else {
          buf.writeByte(BSER_REAL);
          buf.writeDouble(val);
        }
        return;
      case "string":
        buf.writeByte(BSER_STRING);
        dump_int(buf, Buffer.byteLength(val));
        buf.append(val);
        return;
      case "boolean":
        buf.writeByte(val ? BSER_TRUE : BSER_FALSE);
        return;
      case "object":
        if (val === null) {
          buf.writeByte(BSER_NULL);
          return;
        }
        if (val instanceof Int64) {
          dump_int64(buf, val);
          return;
        }
        if (Array.isArray(val)) {
          buf.writeByte(BSER_ARRAY);
          dump_int(buf, val.length);
          for (var i = 0; i < val.length; ++i) {
            dump_any(buf, val[i]);
          }
          return;
        }
        buf.writeByte(BSER_OBJECT);
        var keys = Object.keys(val);
        var num_keys = keys.length;
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          var v = val[key];
          if (typeof v == "undefined") {
            num_keys--;
          }
        }
        dump_int(buf, num_keys);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          var v = val[key];
          if (typeof v == "undefined") {
            continue;
          }
          dump_any(buf, key);
          try {
            dump_any(buf, v);
          } catch (e) {
            throw new Error(e.message + " (while serializing object property with name `" + key + "')");
          }
        }
        return;
      default:
        throw new Error("cannot serialize type " + typeof val + " to BSER");
    }
  }
  function dumpToBuffer(val) {
    var buf = new Accumulator();
    buf.writeByte(0);
    buf.writeByte(1);
    buf.writeByte(BSER_INT32);
    buf.writeInt(0, 4);
    dump_any(buf, val);
    var off = buf.writeOffset;
    var len = off - 7;
    buf.writeOffset = 3;
    buf.writeInt(len, 4);
    buf.writeOffset = off;
    return buf.buf.slice(0, off);
  }
  exports2.dumpToBuffer = dumpToBuffer;
});

// node_modules/fb-watchman/index.js
var require_fb_watchman = __commonJS((exports2, module2) => {
  "use strict";
  var net5 = require("net");
  var EE = require("events").EventEmitter;
  var util54 = require("util");
  var childProcess = require("child_process");
  var bser = require_bser();
  var unilateralTags = ["subscription", "log"];
  function Client2(options) {
    var self2 = this;
    EE.call(this);
    this.watchmanBinaryPath = "watchman";
    if (options && options.watchmanBinaryPath) {
      this.watchmanBinaryPath = options.watchmanBinaryPath.trim();
    }
    ;
    this.commands = [];
  }
  util54.inherits(Client2, EE);
  module2.exports.Client = Client2;
  Client2.prototype.sendNextCommand = function() {
    if (this.currentCommand) {
      return;
    }
    this.currentCommand = this.commands.shift();
    if (!this.currentCommand) {
      return;
    }
    this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));
  };
  Client2.prototype.cancelCommands = function(why) {
    var error = new Error(why);
    var cmds = this.commands;
    this.commands = [];
    if (this.currentCommand) {
      cmds.unshift(this.currentCommand);
      this.currentCommand = null;
    }
    cmds.forEach(function(cmd) {
      cmd.cb(error);
    });
  };
  Client2.prototype.connect = function() {
    var self2 = this;
    function makeSock(sockname) {
      self2.bunser = new bser.BunserBuf();
      self2.bunser.on("value", function(obj) {
        var unilateral = false;
        for (var i = 0; i < unilateralTags.length; i++) {
          var tag = unilateralTags[i];
          if (tag in obj) {
            unilateral = tag;
          }
        }
        if (unilateral) {
          self2.emit(unilateral, obj);
        } else if (self2.currentCommand) {
          var cmd = self2.currentCommand;
          self2.currentCommand = null;
          if ("error" in obj) {
            var error = new Error(obj.error);
            error.watchmanResponse = obj;
            cmd.cb(error);
          } else {
            cmd.cb(null, obj);
          }
        }
        self2.sendNextCommand();
      });
      self2.bunser.on("error", function(err) {
        self2.emit("error", err);
      });
      self2.socket = net5.createConnection(sockname);
      self2.socket.on("connect", function() {
        self2.connecting = false;
        self2.emit("connect");
        self2.sendNextCommand();
      });
      self2.socket.on("error", function(err) {
        self2.connecting = false;
        self2.emit("error", err);
      });
      self2.socket.on("data", function(buf) {
        if (self2.bunser) {
          self2.bunser.append(buf);
        }
      });
      self2.socket.on("end", function() {
        self2.socket = null;
        self2.bunser = null;
        self2.cancelCommands("The watchman connection was closed");
        self2.emit("end");
      });
    }
    if (process.env.WATCHMAN_SOCK) {
      makeSock(process.env.WATCHMAN_SOCK);
      return;
    }
    var args = ["--no-pretty", "get-sockname"];
    var proc = null;
    var spawnFailed = false;
    function spawnError(error) {
      if (spawnFailed) {
        return;
      }
      spawnFailed = true;
      if (error.errno === "EACCES") {
        error.message = "The Watchman CLI is installed but cannot be spawned because of a permission problem";
      } else if (error.errno === "ENOENT") {
        error.message = "Watchman was not found in PATH.  See https://facebook.github.io/watchman/docs/install.html for installation instructions";
      }
      console.error("Watchman: ", error.message);
      self2.emit("error", error);
    }
    try {
      proc = childProcess.spawn(this.watchmanBinaryPath, args, {
        stdio: ["ignore", "pipe", "pipe"]
      });
    } catch (error) {
      spawnError(error);
      return;
    }
    var stdout = [];
    var stderr = [];
    proc.stdout.on("data", function(data) {
      stdout.push(data);
    });
    proc.stderr.on("data", function(data) {
      data = data.toString("utf8");
      stderr.push(data);
      console.error(data);
    });
    proc.on("error", function(error) {
      spawnError(error);
    });
    proc.on("close", function(code, signal) {
      if (code !== 0) {
        spawnError(new Error(self2.watchmanBinaryPath + " " + args.join(" ") + " returned with exit code=" + code + ", signal=" + signal + ", stderr= " + stderr.join("")));
        return;
      }
      try {
        var obj = JSON.parse(stdout.join(""));
        if ("error" in obj) {
          var error = new Error(obj.error);
          error.watchmanResponse = obj;
          self2.emit("error", error);
          return;
        }
        makeSock(obj.sockname);
      } catch (e) {
        self2.emit("error", e);
      }
    });
  };
  Client2.prototype.command = function(args, done) {
    done = done || function() {
    };
    this.commands.push({cmd: args, cb: done});
    if (!this.socket) {
      if (!this.connecting) {
        this.connecting = true;
        this.connect();
        return;
      }
      return;
    }
    this.sendNextCommand();
  };
  var cap_versions = {
    "cmd-watch-del-all": "3.1.1",
    "cmd-watch-project": "3.1",
    relative_root: "3.3",
    "term-dirname": "3.1",
    "term-idirname": "3.1",
    wildmatch: "3.7"
  };
  function vers_compare(a, b) {
    a = a.split(".");
    b = b.split(".");
    for (var i = 0; i < 3; i++) {
      var d = parseInt(a[i] || "0") - parseInt(b[i] || "0");
      if (d != 0) {
        return d;
      }
    }
    return 0;
  }
  function have_cap(vers, name2) {
    if (name2 in cap_versions) {
      return vers_compare(vers, cap_versions[name2]) >= 0;
    }
    return false;
  }
  Client2.prototype._synthesizeCapabilityCheck = function(resp, optional, required) {
    resp.capabilities = {};
    var version2 = resp.version;
    optional.forEach(function(name2) {
      resp.capabilities[name2] = have_cap(version2, name2);
    });
    required.forEach(function(name2) {
      var have = have_cap(version2, name2);
      resp.capabilities[name2] = have;
      if (!have) {
        resp.error = "client required capability `" + name2 + "` is not supported by this server";
      }
    });
    return resp;
  };
  Client2.prototype.capabilityCheck = function(caps, done) {
    var optional = caps.optional || [];
    var required = caps.required || [];
    var self2 = this;
    this.command(["version", {
      optional,
      required
    }], function(error, resp) {
      if (error) {
        done(error);
        return;
      }
      if (!("capabilities" in resp)) {
        resp = self2._synthesizeCapabilityCheck(resp, optional, required);
        if (resp.error) {
          error = new Error(resp.error);
          error.watchmanResponse = resp;
          done(error);
          return;
        }
      }
      done(null, resp);
    });
  };
  Client2.prototype.end = function() {
    this.cancelCommands("The client was ended");
    if (this.socket) {
      this.socket.end();
      this.socket = null;
    }
    this.bunser = null;
  };
});

// package.json
var require_package2 = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "coc.nvim",
    version: "0.0.80",
    description: "LSP based intellisense engine for neovim & vim8.",
    main: "./lib/index.js",
    engines: {
      node: ">=8.10.0"
    },
    scripts: {
      clean: "rimraf lib build",
      lint: "eslint . --ext .ts --quiet",
      build: "./build.js",
      watch: "node watch.js",
      test: "node --trace-warnings node_modules/jest/bin/jest.js --runInBand --forceExit",
      "test-build": "node --trace-warnings node_modules/jest/bin/jest.js --runInBand --coverage --forceExit",
      prepare: "./build.js"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/neoclide/coc.nvim.git"
    },
    keywords: [
      "complete",
      "neovim"
    ],
    author: "Qiming Zhao <chemzqm@gmail.com>",
    license: "MIT",
    bugs: {
      url: "https://github.com/neoclide/coc.nvim/issues"
    },
    homepage: "https://github.com/neoclide/coc.nvim#readme",
    jest: {
      globals: {
        __TEST__: true
      },
      projects: [
        "<rootDir>"
      ],
      watchman: false,
      clearMocks: true,
      globalSetup: "./jest.js",
      testEnvironment: "node",
      moduleFileExtensions: [
        "ts",
        "tsx",
        "json",
        "js"
      ],
      transform: {
        "^.+\\.tsx?$": "ts-jest"
      },
      testRegex: "src/__tests__/.*\\.(test|spec)\\.ts$",
      coverageDirectory: "./coverage/"
    },
    devDependencies: {
      "@types/cli-table": "^0.3.0",
      "@types/debounce": "^3.0.0",
      "@types/fb-watchman": "^2.0.0",
      "@types/glob": "^7.1.3",
      "@types/jest": "^26.0.18",
      "@types/marked": "^1.2.1",
      "@types/minimatch": "^3.0.3",
      "@types/mkdirp": "^1.0.1",
      "@types/node": "^10.12.0",
      "@types/semver": "^7.3.4",
      "@types/tar": "^4.0.4",
      "@types/uuid": "^8.3.0",
      "@types/which": "^1.3.2",
      "@typescript-eslint/eslint-plugin": "^4.9.1",
      "@typescript-eslint/parser": "^4.9.1",
      colors: "^1.4.0",
      eslint: "^7.15.0",
      "eslint-plugin-jest": "^24.1.3",
      "eslint-plugin-jsdoc": "^30.7.8",
      jest: "26.6.3",
      "ts-jest": "^26.4.4",
      typescript: "^4.1.2",
      esbuild: "^0.8.26",
      "vscode-languageserver": "next"
    },
    dependencies: {
      "@chemzqm/neovim": "^5.2.12",
      "ansi-styles": "^5.0.0",
      bser: "^2.1.1",
      bytes: "^3.1.0",
      "cli-table": "^0.3.4",
      clipboardy: "^2.3.0",
      "content-disposition": "^0.5.3",
      debounce: "^1.2.0",
      "fast-diff": "^1.2.0",
      "fb-watchman": "^2.0.1",
      "follow-redirects": "^1.13.0",
      "fs-extra": "^9.0.1",
      glob: "^7.1.6",
      "http-proxy-agent": "^4.0.1",
      "https-proxy-agent": "^5.0.0",
      isuri: "^2.0.3",
      "jsonc-parser": "^2.3.1",
      log4js: "^6.3.0",
      marked: "^1.2.5",
      minimatch: "^3.0.4",
      "promise.prototype.finally": "^3.1.2",
      rc: "^1.2.8",
      semver: "^7.3.2",
      tar: "^6.0.5",
      tslib: "^2.0.3",
      unzipper: "^0.10.11",
      uuid: "^7.0.3",
      "vscode-jsonrpc": "^5.0.1",
      "vscode-languageserver-protocol": "^3.15.3",
      "vscode-languageserver-textdocument": "^1.0.1",
      "vscode-languageserver-types": "^3.15.1",
      "vscode-uri": "^2.1.2",
      which: "^2.0.2"
    }
  };
});

// node_modules/ini/ini.js
var require_ini = __commonJS((exports2) => {
  exports2.parse = exports2.decode = decode;
  exports2.stringify = exports2.encode = encode;
  exports2.safe = safe;
  exports2.unsafe = unsafe;
  var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
  function encode(obj, opt) {
    var children = [];
    var out = "";
    if (typeof opt === "string") {
      opt = {
        section: opt,
        whitespace: false
      };
    } else {
      opt = opt || {};
      opt.whitespace = opt.whitespace === true;
    }
    var separator = opt.whitespace ? " = " : "=";
    Object.keys(obj).forEach(function(k, _, __) {
      var val = obj[k];
      if (val && Array.isArray(val)) {
        val.forEach(function(item) {
          out += safe(k + "[]") + separator + safe(item) + "\n";
        });
      } else if (val && typeof val === "object") {
        children.push(k);
      } else {
        out += safe(k) + separator + safe(val) + eol;
      }
    });
    if (opt.section && out.length) {
      out = "[" + safe(opt.section) + "]" + eol + out;
    }
    children.forEach(function(k, _, __) {
      var nk = dotSplit(k).join("\\.");
      var section2 = (opt.section ? opt.section + "." : "") + nk;
      var child = encode(obj[k], {
        section: section2,
        whitespace: opt.whitespace
      });
      if (out.length && child.length) {
        out += eol;
      }
      out += child;
    });
    return out;
  }
  function dotSplit(str) {
    return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
      return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
    });
  }
  function decode(str) {
    var out = {};
    var p = out;
    var section2 = null;
    var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
    var lines = str.split(/[\r\n]+/g);
    lines.forEach(function(line, _, __) {
      if (!line || line.match(/^\s*[;#]/))
        return;
      var match3 = line.match(re);
      if (!match3)
        return;
      if (match3[1] !== void 0) {
        section2 = unsafe(match3[1]);
        p = out[section2] = out[section2] || {};
        return;
      }
      var key = unsafe(match3[2]);
      var value = match3[3] ? unsafe(match3[4]) : true;
      switch (value) {
        case "true":
        case "false":
        case "null":
          value = JSON.parse(value);
      }
      if (key.length > 2 && key.slice(-2) === "[]") {
        key = key.substring(0, key.length - 2);
        if (!p[key]) {
          p[key] = [];
        } else if (!Array.isArray(p[key])) {
          p[key] = [p[key]];
        }
      }
      if (Array.isArray(p[key])) {
        p[key].push(value);
      } else {
        p[key] = value;
      }
    });
    Object.keys(out).filter(function(k, _, __) {
      if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k])) {
        return false;
      }
      var parts = dotSplit(k);
      var p2 = out;
      var l = parts.pop();
      var nl = l.replace(/\\\./g, ".");
      parts.forEach(function(part, _2, __2) {
        if (!p2[part] || typeof p2[part] !== "object")
          p2[part] = {};
        p2 = p2[part];
      });
      if (p2 === out && nl === l) {
        return false;
      }
      p2[nl] = out[k];
      return true;
    }).forEach(function(del, _, __) {
      delete out[del];
    });
    return out;
  }
  function isQuoted(val) {
    return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
  }
  function safe(val) {
    return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
  }
  function unsafe(val, doUnesc) {
    val = (val || "").trim();
    if (isQuoted(val)) {
      if (val.charAt(0) === "'") {
        val = val.substr(1, val.length - 2);
      }
      try {
        val = JSON.parse(val);
      } catch (_) {
      }
    } else {
      var esc = false;
      var unesc = "";
      for (var i = 0, l = val.length; i < l; i++) {
        var c = val.charAt(i);
        if (esc) {
          if ("\\;#".indexOf(c) !== -1) {
            unesc += c;
          } else {
            unesc += "\\" + c;
          }
          esc = false;
        } else if (";#".indexOf(c) !== -1) {
          break;
        } else if (c === "\\") {
          esc = true;
        } else {
          unesc += c;
        }
      }
      if (esc) {
        unesc += "\\";
      }
      return unesc.trim();
    }
    return val;
  }
});

// node_modules/rc/node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS((exports2, module2) => {
  "use strict";
  var singleComment = 1;
  var multiComment = 2;
  function stripWithoutWhitespace() {
    return "";
  }
  function stripWithWhitespace(str, start, end) {
    return str.slice(start, end).replace(/\S/g, " ");
  }
  module2.exports = function(str, opts) {
    opts = opts || {};
    var currentChar;
    var nextChar;
    var insideString = false;
    var insideComment = false;
    var offset = 0;
    var ret2 = "";
    var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
    for (var i = 0; i < str.length; i++) {
      currentChar = str[i];
      nextChar = str[i + 1];
      if (!insideComment && currentChar === '"') {
        var escaped = str[i - 1] === "\\" && str[i - 2] !== "\\";
        if (!escaped) {
          insideString = !insideString;
        }
      }
      if (insideString) {
        continue;
      }
      if (!insideComment && currentChar + nextChar === "//") {
        ret2 += str.slice(offset, i);
        offset = i;
        insideComment = singleComment;
        i++;
      } else if (insideComment === singleComment && currentChar + nextChar === "\r\n") {
        i++;
        insideComment = false;
        ret2 += strip(str, offset, i);
        offset = i;
        continue;
      } else if (insideComment === singleComment && currentChar === "\n") {
        insideComment = false;
        ret2 += strip(str, offset, i);
        offset = i;
      } else if (!insideComment && currentChar + nextChar === "/*") {
        ret2 += str.slice(offset, i);
        offset = i;
        insideComment = multiComment;
        i++;
        continue;
      } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
        i++;
        insideComment = false;
        ret2 += strip(str, offset, i + 1);
        offset = i + 1;
        continue;
      }
    }
    return ret2 + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
  };
});

// node_modules/rc/lib/utils.js
var require_utils3 = __commonJS((exports2) => {
  "use strict";
  var fs55 = require("fs");
  var ini = require_ini();
  var path66 = require("path");
  var stripJsonComments = require_strip_json_comments();
  var parse4 = exports2.parse = function(content) {
    if (/^\s*{/.test(content))
      return JSON.parse(stripJsonComments(content));
    return ini.parse(content);
  };
  var file = exports2.file = function() {
    var args = [].slice.call(arguments).filter(function(arg) {
      return arg != null;
    });
    for (var i in args)
      if (typeof args[i] !== "string")
        return;
    var file2 = path66.join.apply(null, args);
    var content;
    try {
      return fs55.readFileSync(file2, "utf-8");
    } catch (err) {
      return;
    }
  };
  var json = exports2.json = function() {
    var content = file.apply(null, arguments);
    return content ? parse4(content) : null;
  };
  var env2 = exports2.env = function(prefix, env3) {
    env3 = env3 || process.env;
    var obj = {};
    var l = prefix.length;
    for (var k in env3) {
      if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
        var keypath = k.substring(l).split("__");
        var _emptyStringIndex;
        while ((_emptyStringIndex = keypath.indexOf("")) > -1) {
          keypath.splice(_emptyStringIndex, 1);
        }
        var cursor = obj;
        keypath.forEach(function _buildSubObj(_subkey, i) {
          if (!_subkey || typeof cursor !== "object")
            return;
          if (i === keypath.length - 1)
            cursor[_subkey] = env3[k];
          if (cursor[_subkey] === void 0)
            cursor[_subkey] = {};
          cursor = cursor[_subkey];
        });
      }
    }
    return obj;
  };
  var find = exports2.find = function() {
    var rel = path66.join.apply(null, [].slice.call(arguments));
    function find2(start, rel2) {
      var file2 = path66.join(start, rel2);
      try {
        fs55.statSync(file2);
        return file2;
      } catch (err) {
        if (path66.dirname(start) !== start)
          return find2(path66.dirname(start), rel2);
      }
    }
    return find2(process.cwd(), rel);
  };
});

// node_modules/deep-extend/lib/deep-extend.js
var require_deep_extend = __commonJS((exports2, module2) => {
  /*!
   * @description Recursive object extending
   * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
   * @license MIT
   *
   * The MIT License (MIT)
   *
   * Copyright (c) 2013-2018 Viacheslav Lotsmanov
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the "Software"), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   * the Software, and to permit persons to whom the Software is furnished to do so,
   * subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
  "use strict";
  function isSpecificValue(val) {
    return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
  }
  function cloneSpecificValue(val) {
    if (val instanceof Buffer) {
      var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
      val.copy(x);
      return x;
    } else if (val instanceof Date) {
      return new Date(val.getTime());
    } else if (val instanceof RegExp) {
      return new RegExp(val);
    } else {
      throw new Error("Unexpected situation");
    }
  }
  function deepCloneArray(arr) {
    var clone = [];
    arr.forEach(function(item, index) {
      if (typeof item === "object" && item !== null) {
        if (Array.isArray(item)) {
          clone[index] = deepCloneArray(item);
        } else if (isSpecificValue(item)) {
          clone[index] = cloneSpecificValue(item);
        } else {
          clone[index] = deepExtend({}, item);
        }
      } else {
        clone[index] = item;
      }
    });
    return clone;
  }
  function safeGetProperty(object15, property) {
    return property === "__proto__" ? void 0 : object15[property];
  }
  var deepExtend = module2.exports = function() {
    if (arguments.length < 1 || typeof arguments[0] !== "object") {
      return false;
    }
    if (arguments.length < 2) {
      return arguments[0];
    }
    var target = arguments[0];
    var args = Array.prototype.slice.call(arguments, 1);
    var val, src, clone;
    args.forEach(function(obj) {
      if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return;
      }
      Object.keys(obj).forEach(function(key) {
        src = safeGetProperty(target, key);
        val = safeGetProperty(obj, key);
        if (val === target) {
          return;
        } else if (typeof val !== "object" || val === null) {
          target[key] = val;
          return;
        } else if (Array.isArray(val)) {
          target[key] = deepCloneArray(val);
          return;
        } else if (isSpecificValue(val)) {
          target[key] = cloneSpecificValue(val);
          return;
        } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
          target[key] = deepExtend({}, val);
          return;
        } else {
          target[key] = deepExtend(src, val);
          return;
        }
      });
    });
    return target;
  };
});

// node_modules/minimist/index.js
var require_minimist = __commonJS((exports2, module2) => {
  module2.exports = function(args, opts) {
    if (!opts)
      opts = {};
    var flags = {bools: {}, strings: {}, unknownFn: null};
    if (typeof opts["unknown"] === "function") {
      flags.unknownFn = opts["unknown"];
    }
    if (typeof opts["boolean"] === "boolean" && opts["boolean"]) {
      flags.allBools = true;
    } else {
      [].concat(opts["boolean"]).filter(Boolean).forEach(function(key2) {
        flags.bools[key2] = true;
      });
    }
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function(key2) {
      aliases[key2] = [].concat(opts.alias[key2]);
      aliases[key2].forEach(function(x) {
        aliases[x] = [key2].concat(aliases[key2].filter(function(y) {
          return x !== y;
        }));
      });
    });
    [].concat(opts.string).filter(Boolean).forEach(function(key2) {
      flags.strings[key2] = true;
      if (aliases[key2]) {
        flags.strings[aliases[key2]] = true;
      }
    });
    var defaults2 = opts["default"] || {};
    var argv = {_: []};
    Object.keys(flags.bools).forEach(function(key2) {
      setArg(key2, defaults2[key2] === void 0 ? false : defaults2[key2]);
    });
    var notFlags = [];
    if (args.indexOf("--") !== -1) {
      notFlags = args.slice(args.indexOf("--") + 1);
      args = args.slice(0, args.indexOf("--"));
    }
    function argDefined(key2, arg2) {
      return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
    }
    function setArg(key2, val, arg2) {
      if (arg2 && flags.unknownFn && !argDefined(key2, arg2)) {
        if (flags.unknownFn(arg2) === false)
          return;
      }
      var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
      setKey(argv, key2.split("."), value2);
      (aliases[key2] || []).forEach(function(x) {
        setKey(argv, x.split("."), value2);
      });
    }
    function setKey(obj, keys, value2) {
      var o = obj;
      for (var i2 = 0; i2 < keys.length - 1; i2++) {
        var key2 = keys[i2];
        if (key2 === "__proto__")
          return;
        if (o[key2] === void 0)
          o[key2] = {};
        if (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype)
          o[key2] = {};
        if (o[key2] === Array.prototype)
          o[key2] = [];
        o = o[key2];
      }
      var key2 = keys[keys.length - 1];
      if (key2 === "__proto__")
        return;
      if (o === Object.prototype || o === Number.prototype || o === String.prototype)
        o = {};
      if (o === Array.prototype)
        o = [];
      if (o[key2] === void 0 || flags.bools[key2] || typeof o[key2] === "boolean") {
        o[key2] = value2;
      } else if (Array.isArray(o[key2])) {
        o[key2].push(value2);
      } else {
        o[key2] = [o[key2], value2];
      }
    }
    function aliasIsBoolean(key2) {
      return aliases[key2].some(function(x) {
        return flags.bools[x];
      });
    }
    for (var i = 0; i < args.length; i++) {
      var arg = args[i];
      if (/^--.+=/.test(arg)) {
        var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
        var key = m[1];
        var value = m[2];
        if (flags.bools[key]) {
          value = value !== "false";
        }
        setArg(key, value, arg);
      } else if (/^--no-.+/.test(arg)) {
        var key = arg.match(/^--no-(.+)/)[1];
        setArg(key, false, arg);
      } else if (/^--.+/.test(arg)) {
        var key = arg.match(/^--(.+)/)[1];
        var next = args[i + 1];
        if (next !== void 0 && !/^-/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
          setArg(key, next, arg);
          i++;
        } else if (/^(true|false)$/.test(next)) {
          setArg(key, next === "true", arg);
          i++;
        } else {
          setArg(key, flags.strings[key] ? "" : true, arg);
        }
      } else if (/^-[^-]+/.test(arg)) {
        var letters = arg.slice(1, -1).split("");
        var broken = false;
        for (var j = 0; j < letters.length; j++) {
          var next = arg.slice(j + 2);
          if (next === "-") {
            setArg(letters[j], next, arg);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
            setArg(letters[j], next.split("=")[1], arg);
            broken = true;
            break;
          }
          if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
            setArg(letters[j], next, arg);
            broken = true;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], arg.slice(j + 2), arg);
            broken = true;
            break;
          } else {
            setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
          }
        }
        var key = arg.slice(-1)[0];
        if (!broken && key !== "-") {
          if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, args[i + 1], arg);
            i++;
          } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
            setArg(key, args[i + 1] === "true", arg);
            i++;
          } else {
            setArg(key, flags.strings[key] ? "" : true, arg);
          }
        }
      } else {
        if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
          argv._.push(flags.strings["_"] || !isNumber(arg) ? arg : Number(arg));
        }
        if (opts.stopEarly) {
          argv._.push.apply(argv._, args.slice(i + 1));
          break;
        }
      }
    }
    Object.keys(defaults2).forEach(function(key2) {
      if (!hasKey(argv, key2.split("."))) {
        setKey(argv, key2.split("."), defaults2[key2]);
        (aliases[key2] || []).forEach(function(x) {
          setKey(argv, x.split("."), defaults2[key2]);
        });
      }
    });
    if (opts["--"]) {
      argv["--"] = new Array();
      notFlags.forEach(function(key2) {
        argv["--"].push(key2);
      });
    } else {
      notFlags.forEach(function(key2) {
        argv._.push(key2);
      });
    }
    return argv;
  };
  function hasKey(obj, keys) {
    var o = obj;
    keys.slice(0, -1).forEach(function(key2) {
      o = o[key2] || {};
    });
    var key = keys[keys.length - 1];
    return key in o;
  }
  function isNumber(x) {
    if (typeof x === "number")
      return true;
    if (/^0x[0-9a-f]+$/i.test(x))
      return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
  }
});

// node_modules/rc/index.js
var require_rc = __commonJS((exports2, module2) => {
  var cc = require_utils3();
  var join2 = require("path").join;
  var deepExtend = require_deep_extend();
  var etc = "/etc";
  var win = process.platform === "win32";
  var home = win ? process.env.USERPROFILE : process.env.HOME;
  module2.exports = function(name2, defaults2, argv, parse4) {
    if (typeof name2 !== "string")
      throw new Error("rc(name): name *must* be string");
    if (!argv)
      argv = require_minimist()(process.argv.slice(2));
    defaults2 = (typeof defaults2 === "string" ? cc.json(defaults2) : defaults2) || {};
    parse4 = parse4 || cc.parse;
    var env2 = cc.env(name2 + "_");
    var configs = [defaults2];
    var configFiles = [];
    function addConfigFile(file) {
      if (configFiles.indexOf(file) >= 0)
        return;
      var fileConfig = cc.file(file);
      if (fileConfig) {
        configs.push(parse4(fileConfig));
        configFiles.push(file);
      }
    }
    if (!win)
      [
        join2(etc, name2, "config"),
        join2(etc, name2 + "rc")
      ].forEach(addConfigFile);
    if (home)
      [
        join2(home, ".config", name2, "config"),
        join2(home, ".config", name2),
        join2(home, "." + name2, "config"),
        join2(home, "." + name2 + "rc")
      ].forEach(addConfigFile);
    addConfigFile(cc.find("." + name2 + "rc"));
    if (env2.config)
      addConfigFile(env2.config);
    if (argv.config)
      addConfigFile(argv.config);
    return deepExtend.apply(null, configs.concat([
      env2,
      argv,
      configFiles.length ? {configs: configFiles, config: configFiles[configFiles.length - 1]} : void 0
    ]));
  };
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS((exports2, module2) => {
  var debug;
  try {
    debug = require_src()("follow-redirects");
  } catch (error) {
    debug = function() {
    };
  }
  module2.exports = debug;
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS((exports2, module2) => {
  var url2 = require("url");
  var URL = url2.URL;
  var http3 = require("http");
  var https3 = require("https");
  var Writable = require("stream").Writable;
  var assert = require("assert");
  var debug = require_debug2();
  var eventHandlers = Object.create(null);
  ["abort", "aborted", "connect", "error", "socket", "timeout"].forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "");
  var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
  var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
  var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      self2._processResponse(response);
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.write = function(data, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError();
    }
    if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = null;
    }
    if (data.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data.length;
      this._requestBodyBuffers.push({data, encoding});
      this._currentRequest.write(data, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError());
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data, encoding, callback) {
    if (typeof data === "function") {
      callback = data;
      data = encoding = null;
    } else if (typeof encoding === "function") {
      callback = encoding;
      encoding = null;
    }
    if (!data) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name2, value) {
    this._options.headers[name2] = value;
    this._currentRequest.setHeader(name2, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name2) {
    delete this._options.headers[name2];
    this._currentRequest.removeHeader(name2);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    if (callback) {
      this.once("timeout", callback);
    }
    if (this.socket) {
      startTimer(this, msecs);
    } else {
      var self2 = this;
      this._currentRequest.once("socket", function() {
        startTimer(self2, msecs);
      });
    }
    this.once("response", clearTimer);
    this.once("error", clearTimer);
    return this;
  };
  function startTimer(request2, msecs) {
    clearTimeout(request2._timeout);
    request2._timeout = setTimeout(function() {
      request2.emit("timeout");
    }, msecs);
  }
  function clearTimer() {
    clearTimeout(this._timeout);
  }
  [
    "abort",
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      this.emit("error", new TypeError("Unsupported protocol " + protocol));
      return;
    }
    if (this._options.agents) {
      var scheme = protocol.substr(0, protocol.length - 1);
      this._options.agent = this._options.agents[scheme];
    }
    var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    this._currentUrl = url2.format(this._options);
    request2._redirectable = this;
    for (var event in eventHandlers) {
      if (event) {
        request2.on(event, eventHandlers[event]);
      }
    }
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error) {
        if (request2 === self2._currentRequest) {
          if (error) {
            self2.emit("error", error);
          } else if (i < buffers.length) {
            var buffer4 = buffers[i++];
            if (!request2.finished) {
              request2.write(buffer4.data, buffer4.encoding, writeNext);
            }
          } else if (self2._ended) {
            request2.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location5 = response.headers.location;
    if (location5 && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
      this._currentRequest.removeAllListeners();
      this._currentRequest.on("error", noop);
      this._currentRequest.abort();
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) || url2.parse(this._currentUrl).hostname;
      var redirectUrl = url2.resolve(this._currentUrl, location5);
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url2.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.hostname !== previousHostName) {
        removeMatchingHeaders(/^authorization$/i, this._options.headers);
      }
      if (typeof this._options.beforeRedirect === "function") {
        var responseDetails = {headers: response.headers};
        try {
          this._options.beforeRedirect.call(null, this._options, responseDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        var error = new RedirectionError("Redirected request failed: " + cause.message);
        error.cause = cause;
        this.emit("error", error);
      }
    } else {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
    }
  };
  function wrap(protocols) {
    var exports3 = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
      wrappedProtocol.request = function(input, options, callback) {
        if (typeof input === "string") {
          var urlStr = input;
          try {
            input = urlToOptions(new URL(urlStr));
          } catch (err) {
            input = url2.parse(urlStr);
          }
        } else if (URL && input instanceof URL) {
          input = urlToOptions(input);
        } else {
          callback = options;
          options = input;
          input = {protocol};
        }
        if (typeof options === "function") {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports3.maxRedirects,
          maxBodyLength: exports3.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        assert.equal(options.protocol, protocol, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      };
      wrappedProtocol.get = function(input, options, callback) {
        var request2 = wrappedProtocol.request(input, options, callback);
        request2.end();
        return request2;
      };
    });
    return exports3;
  }
  function noop() {
  }
  function urlToOptions(urlObject) {
    var options = {
      protocol: urlObject.protocol,
      hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
      hash: urlObject.hash,
      search: urlObject.search,
      pathname: urlObject.pathname,
      path: urlObject.pathname + urlObject.search,
      href: urlObject.href
    };
    if (urlObject.port !== "") {
      options.port = Number(urlObject.port);
    }
    return options;
  }
  function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for (var header in headers) {
      if (regex.test(header)) {
        lastValue = headers[header];
        delete headers[header];
      }
    }
    return lastValue;
  }
  function createErrorType(code, defaultMessage) {
    function CustomError(message) {
      Error.captureStackTrace(this, this.constructor);
      this.message = message || defaultMessage;
    }
    CustomError.prototype = new Error();
    CustomError.prototype.constructor = CustomError;
    CustomError.prototype.name = "Error [" + code + "]";
    CustomError.prototype.code = code;
    return CustomError;
  }
  module2.exports = wrap({http: http3, https: https3});
  module2.exports.wrap = wrap;
});

// node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS((exports2, module2) => {
  "use strict";
  var argmap = new Map([
    ["C", "cwd"],
    ["f", "file"],
    ["z", "gzip"],
    ["P", "preservePaths"],
    ["U", "unlink"],
    ["strip-components", "strip"],
    ["stripComponents", "strip"],
    ["keep-newer", "newer"],
    ["keepNewer", "newer"],
    ["keep-newer-files", "newer"],
    ["keepNewerFiles", "newer"],
    ["k", "keep"],
    ["keep-existing", "keep"],
    ["keepExisting", "keep"],
    ["m", "noMtime"],
    ["no-mtime", "noMtime"],
    ["p", "preserveOwner"],
    ["L", "follow"],
    ["h", "follow"]
  ]);
  var parse4 = module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
    argmap.has(k) ? argmap.get(k) : k,
    opt[k]
  ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {};
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list2) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist();
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list2 && typeof list2.forEach === "function") {
      list2.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return void 0;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return void 0;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.head; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret2 = new Yallist();
    if (to < from || to < 0) {
      return ret2;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret2.push(walker.value);
    }
    return ret2;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret2 = new Yallist();
    if (to < from || to < 0) {
      return ret2;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret2.push(walker.value);
    }
    return ret2;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret2 = [];
    for (var i = 0; walker && i < deleteCount; i++) {
      ret2.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0; i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret2;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  }
  function push(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  }
  function Node(value, prev, next, list2) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list2);
    }
    this.list = list2;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// node_modules/minipass/index.js
var require_minipass = __commonJS((exports2, module2) => {
  "use strict";
  var EE = require("events");
  var Stream = require("stream");
  var Yallist = require_yallist();
  var SD = require("string_decoder").StringDecoder;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
  var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
  var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
  module2.exports = class Minipass extends Stream {
    constructor(options) {
      super();
      this[FLOWING] = false;
      this[PAUSED] = false;
      this.pipes = new Yallist();
      this.buffer = new Yallist();
      this[OBJECTMODE] = options && options.objectMode || false;
      if (this[OBJECTMODE])
        this[ENCODING] = null;
      else
        this[ENCODING] = options && options.encoding || null;
      if (this[ENCODING] === "buffer")
        this[ENCODING] = null;
      this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
      this[EOF] = false;
      this[EMITTED_END] = false;
      this[EMITTING_END] = false;
      this[CLOSED] = false;
      this.writable = true;
      this.readable = true;
      this[BUFFERLENGTH] = 0;
      this[DESTROYED] = false;
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(enc) {
      if (this[OBJECTMODE])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
        throw new Error("cannot change encoding");
      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this.buffer.length)
          this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
      }
      this[ENCODING] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(\u0950) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!\u0950;
    }
    write(chunk, encoding, cb) {
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), {code: "ERR_STREAM_DESTROYED"}));
        return true;
      }
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk))
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        else if (isArrayBuffer(chunk))
          chunk = Buffer.from(chunk);
        else if (typeof chunk !== "string")
          this.objectMode = true;
      }
      if (!this.objectMode && !chunk.length) {
        const ret2 = this.flowing;
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          cb();
        return ret2;
      }
      if (typeof chunk === "string" && !this[OBJECTMODE] && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk);
      try {
        return this.flowing ? (this.emit("data", chunk), this.flowing) : (this[BUFFERPUSH](chunk), false);
      } finally {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          cb();
      }
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      try {
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
          return null;
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = new Yallist([
              Array.from(this.buffer).join("")
            ]);
          else
            this.buffer = new Yallist([
              Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])
            ]);
        }
        return this[READ](n || null, this.buffer.head.value);
      } finally {
        this[MAYBE_EMIT_END]();
      }
    }
    [READ](n, chunk) {
      if (n === chunk.length || n === null)
        this[BUFFERSHIFT]();
      else {
        this.buffer.head.value = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit("data", chunk);
      if (!this.buffer.length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this.flowing || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this.buffer.length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      return this.buffer.push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this.buffer.length) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this.buffer.head.value.length;
      }
      return this.buffer.shift();
    }
    [FLUSH]() {
      do {
      } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
      if (!this.buffer.length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      return chunk ? (this.emit("data", chunk), this.flowing) : false;
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === process.stdout || dest === process.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      const p = {dest, opts, ondrain: (_) => this[RESUME]()};
      this.pipes.push(p);
      dest.on("drain", p.ondrain);
      this[RESUME]();
      if (ended && p.opts.end)
        p.dest.end();
      return dest;
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      try {
        return super.on(ev, fn);
      } finally {
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        }
      }
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, data) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
        return;
      else if (ev === "data") {
        if (!data)
          return;
        if (this.pipes.length)
          this.pipes.forEach((p) => p.dest.write(data) === false && this.pause());
      } else if (ev === "end") {
        if (this[EMITTED_END] === true)
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[DECODER]) {
          data = this[DECODER].end();
          if (data) {
            this.pipes.forEach((p) => p.dest.write(data));
            super.emit("data", data);
          }
        }
        this.pipes.forEach((p) => {
          p.dest.removeListener("drain", p.ondrain);
          if (p.opts.end)
            p.dest.end();
        });
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return;
      }
      const args = new Array(arguments.length);
      args[0] = ev;
      args[1] = data;
      if (arguments.length > 2) {
        for (let i = 2; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
      }
      try {
        return super.emit.apply(this, args);
      } finally {
        if (!isEndish(ev))
          this[MAYBE_EMIT_END]();
        else
          this.removeAllListeners(ev);
      }
    }
    collect() {
      const buf = [];
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      return p.then(() => buf);
    }
    concat() {
      return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
    }
    promise() {
      return new Promise((resolve3, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("end", () => resolve3());
        this.on("error", (er) => reject(er));
      });
    }
    [ASYNCITERATOR]() {
      const next = () => {
        const res = this.read();
        if (res !== null)
          return Promise.resolve({done: false, value: res});
        if (this[EOF])
          return Promise.resolve({done: true});
        let resolve3 = null;
        let reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata);
          this.removeListener("end", onend);
          reject(er);
        };
        const ondata = (value) => {
          this.removeListener("error", onerr);
          this.removeListener("end", onend);
          this.pause();
          resolve3({value, done: !!this[EOF]});
        };
        const onend = () => {
          this.removeListener("error", onerr);
          this.removeListener("data", ondata);
          resolve3({done: true});
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve3 = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {next};
    }
    [ITERATOR]() {
      const next = () => {
        const value = this.read();
        const done = value === null;
        return {value, done};
      };
      return {next};
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this.buffer = new Yallist();
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === "function" && !this[CLOSED])
        this.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
    }
  };
});

// node_modules/minizlib/constants.js
var require_constants2 = __commonJS((exports2, module2) => {
  var realZlibConstants = require("zlib").constants || {ZLIB_VERNUM: 4736};
  module2.exports = Object.freeze(Object.assign(Object.create(null), {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
  }, realZlibConstants));
});

// node_modules/minizlib/index.js
var require_minizlib = __commonJS((exports2) => {
  "use strict";
  var assert = require("assert");
  var Buffer2 = require("buffer").Buffer;
  var realZlib = require("zlib");
  var constants = exports2.constants = require_constants2();
  var Minipass = require_minipass();
  var OriginalBufferConcat = Buffer2.concat;
  var _superWrite = Symbol("_superWrite");
  var ZlibError = class extends Error {
    constructor(err) {
      super("zlib: " + err.message);
      this.code = err.code;
      this.errno = err.errno;
      if (!this.code)
        this.code = "ZLIB_ERROR";
      this.message = "zlib: " + err.message;
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return "ZlibError";
    }
  };
  var _opts = Symbol("opts");
  var _flushFlag = Symbol("flushFlag");
  var _finishFlushFlag = Symbol("finishFlushFlag");
  var _fullFlushFlag = Symbol("fullFlushFlag");
  var _handle = Symbol("handle");
  var _onError = Symbol("onError");
  var _sawError = Symbol("sawError");
  var _level = Symbol("level");
  var _strategy = Symbol("strategy");
  var _ended = Symbol("ended");
  var _defaultFullFlush = Symbol("_defaultFullFlush");
  var ZlibBase = class extends Minipass {
    constructor(opts, mode) {
      if (!opts || typeof opts !== "object")
        throw new TypeError("invalid options for ZlibBase constructor");
      super(opts);
      this[_sawError] = false;
      this[_ended] = false;
      this[_opts] = opts;
      this[_flushFlag] = opts.flush;
      this[_finishFlushFlag] = opts.finishFlush;
      try {
        this[_handle] = new realZlib[mode](opts);
      } catch (er) {
        throw new ZlibError(er);
      }
      this[_onError] = (err) => {
        if (this[_sawError])
          return;
        this[_sawError] = true;
        this.close();
        this.emit("error", err);
      };
      this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
      this.once("end", () => this.close);
    }
    close() {
      if (this[_handle]) {
        this[_handle].close();
        this[_handle] = null;
        this.emit("close");
      }
    }
    reset() {
      if (!this[_sawError]) {
        assert(this[_handle], "zlib binding closed");
        return this[_handle].reset();
      }
    }
    flush(flushFlag) {
      if (this.ended)
        return;
      if (typeof flushFlag !== "number")
        flushFlag = this[_fullFlushFlag];
      this.write(Object.assign(Buffer2.alloc(0), {[_flushFlag]: flushFlag}));
    }
    end(chunk, encoding, cb) {
      if (chunk)
        this.write(chunk, encoding);
      this.flush(this[_finishFlushFlag]);
      this[_ended] = true;
      return super.end(null, null, cb);
    }
    get ended() {
      return this[_ended];
    }
    write(chunk, encoding, cb) {
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (typeof chunk === "string")
        chunk = Buffer2.from(chunk, encoding);
      if (this[_sawError])
        return;
      assert(this[_handle], "zlib binding closed");
      const nativeHandle = this[_handle]._handle;
      const originalNativeClose = nativeHandle.close;
      nativeHandle.close = () => {
      };
      const originalClose = this[_handle].close;
      this[_handle].close = () => {
      };
      Buffer2.concat = (args) => args;
      let result;
      try {
        const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
        result = this[_handle]._processChunk(chunk, flushFlag);
        Buffer2.concat = OriginalBufferConcat;
      } catch (err) {
        Buffer2.concat = OriginalBufferConcat;
        this[_onError](new ZlibError(err));
      } finally {
        if (this[_handle]) {
          this[_handle]._handle = nativeHandle;
          nativeHandle.close = originalNativeClose;
          this[_handle].close = originalClose;
          this[_handle].removeAllListeners("error");
        }
      }
      if (this[_handle])
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
      let writeReturn;
      if (result) {
        if (Array.isArray(result) && result.length > 0) {
          writeReturn = this[_superWrite](Buffer2.from(result[0]));
          for (let i = 1; i < result.length; i++) {
            writeReturn = this[_superWrite](result[i]);
          }
        } else {
          writeReturn = this[_superWrite](Buffer2.from(result));
        }
      }
      if (cb)
        cb();
      return writeReturn;
    }
    [_superWrite](data) {
      return super.write(data);
    }
  };
  var Zlib = class extends ZlibBase {
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants.Z_NO_FLUSH;
      opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
      super(opts, mode);
      this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
      this[_level] = opts.level;
      this[_strategy] = opts.strategy;
    }
    params(level, strategy) {
      if (this[_sawError])
        return;
      if (!this[_handle])
        throw new Error("cannot switch params when binding is closed");
      if (!this[_handle].params)
        throw new Error("not supported in this implementation");
      if (this[_level] !== level || this[_strategy] !== strategy) {
        this.flush(constants.Z_SYNC_FLUSH);
        assert(this[_handle], "zlib binding closed");
        const origFlush = this[_handle].flush;
        this[_handle].flush = (flushFlag, cb) => {
          this.flush(flushFlag);
          cb();
        };
        try {
          this[_handle].params(level, strategy);
        } finally {
          this[_handle].flush = origFlush;
        }
        if (this[_handle]) {
          this[_level] = level;
          this[_strategy] = strategy;
        }
      }
    }
  };
  var Deflate = class extends Zlib {
    constructor(opts) {
      super(opts, "Deflate");
    }
  };
  var Inflate = class extends Zlib {
    constructor(opts) {
      super(opts, "Inflate");
    }
  };
  var _portable = Symbol("_portable");
  var Gzip = class extends Zlib {
    constructor(opts) {
      super(opts, "Gzip");
      this[_portable] = opts && !!opts.portable;
    }
    [_superWrite](data) {
      if (!this[_portable])
        return super[_superWrite](data);
      this[_portable] = false;
      data[9] = 255;
      return super[_superWrite](data);
    }
  };
  var Gunzip = class extends Zlib {
    constructor(opts) {
      super(opts, "Gunzip");
    }
  };
  var DeflateRaw = class extends Zlib {
    constructor(opts) {
      super(opts, "DeflateRaw");
    }
  };
  var InflateRaw = class extends Zlib {
    constructor(opts) {
      super(opts, "InflateRaw");
    }
  };
  var Unzip = class extends Zlib {
    constructor(opts) {
      super(opts, "Unzip");
    }
  };
  var Brotli = class extends ZlibBase {
    constructor(opts, mode) {
      opts = opts || {};
      opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
      opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
      super(opts, mode);
      this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
    }
  };
  var BrotliCompress = class extends Brotli {
    constructor(opts) {
      super(opts, "BrotliCompress");
    }
  };
  var BrotliDecompress = class extends Brotli {
    constructor(opts) {
      super(opts, "BrotliDecompress");
    }
  };
  exports2.Deflate = Deflate;
  exports2.Inflate = Inflate;
  exports2.Gzip = Gzip;
  exports2.Gunzip = Gunzip;
  exports2.DeflateRaw = DeflateRaw;
  exports2.InflateRaw = InflateRaw;
  exports2.Unzip = Unzip;
  if (typeof realZlib.BrotliCompress === "function") {
    exports2.BrotliCompress = BrotliCompress;
    exports2.BrotliDecompress = BrotliDecompress;
  } else {
    exports2.BrotliCompress = exports2.BrotliDecompress = class {
      constructor() {
        throw new Error("Brotli is not supported in this version of Node.js");
      }
    };
  }
});

// node_modules/tar/lib/types.js
var require_types2 = __commonJS((exports2) => {
  "use strict";
  exports2.name = new Map([
    ["0", "File"],
    ["", "OldFile"],
    ["1", "Link"],
    ["2", "SymbolicLink"],
    ["3", "CharacterDevice"],
    ["4", "BlockDevice"],
    ["5", "Directory"],
    ["6", "FIFO"],
    ["7", "ContiguousFile"],
    ["g", "GlobalExtendedHeader"],
    ["x", "ExtendedHeader"],
    ["A", "SolarisACL"],
    ["D", "GNUDumpDir"],
    ["I", "Inode"],
    ["K", "NextFileHasLongLinkpath"],
    ["L", "NextFileHasLongPath"],
    ["M", "ContinuationFile"],
    ["N", "OldGnuLongPath"],
    ["S", "SparseFile"],
    ["V", "TapeVolumeHeader"],
    ["X", "OldExtendedHeader"]
  ]);
  exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
});

// node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS((exports2, module2) => {
  "use strict";
  var types11 = require_types2();
  var MiniPass = require_minipass();
  var SLURP = Symbol("slurp");
  module2.exports = class ReadEntry extends MiniPass {
    constructor(header, ex, gex) {
      super();
      this.pause();
      this.extended = ex;
      this.globalExtended = gex;
      this.header = header;
      this.startBlockSize = 512 * Math.ceil(header.size / 512);
      this.blockRemain = this.startBlockSize;
      this.remain = header.size;
      this.type = header.type;
      this.meta = false;
      this.ignore = false;
      switch (this.type) {
        case "File":
        case "OldFile":
        case "Link":
        case "SymbolicLink":
        case "CharacterDevice":
        case "BlockDevice":
        case "Directory":
        case "FIFO":
        case "ContiguousFile":
        case "GNUDumpDir":
          break;
        case "NextFileHasLongLinkpath":
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
        case "GlobalExtendedHeader":
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this.meta = true;
          break;
        default:
          this.ignore = true;
      }
      this.path = header.path;
      this.mode = header.mode;
      if (this.mode)
        this.mode = this.mode & 4095;
      this.uid = header.uid;
      this.gid = header.gid;
      this.uname = header.uname;
      this.gname = header.gname;
      this.size = header.size;
      this.mtime = header.mtime;
      this.atime = header.atime;
      this.ctime = header.ctime;
      this.linkpath = header.linkpath;
      this.uname = header.uname;
      this.gname = header.gname;
      if (ex)
        this[SLURP](ex);
      if (gex)
        this[SLURP](gex, true);
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain)
        throw new Error("writing more to entry than is appropriate");
      const r = this.remain;
      const br = this.blockRemain;
      this.remain = Math.max(0, r - writeLen);
      this.blockRemain = Math.max(0, br - writeLen);
      if (this.ignore)
        return true;
      if (r >= writeLen)
        return super.write(data);
      return super.write(data.slice(0, r));
    }
    [SLURP](ex, global2) {
      for (let k in ex) {
        if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
          this[k] = ex[k];
      }
    }
  };
});

// node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS((exports2) => {
  "use strict";
  var encode = exports2.encode = (num, buf) => {
    if (!Number.isSafeInteger(num))
      throw Error("cannot encode number outside of javascript safe integer range");
    else if (num < 0)
      encodeNegative(num, buf);
    else
      encodePositive(num, buf);
    return buf;
  };
  var encodePositive = (num, buf) => {
    buf[0] = 128;
    for (var i = buf.length; i > 1; i--) {
      buf[i - 1] = num & 255;
      num = Math.floor(num / 256);
    }
  };
  var encodeNegative = (num, buf) => {
    buf[0] = 255;
    var flipped = false;
    num = num * -1;
    for (var i = buf.length; i > 1; i--) {
      var byte = num & 255;
      num = Math.floor(num / 256);
      if (flipped)
        buf[i - 1] = onesComp(byte);
      else if (byte === 0)
        buf[i - 1] = 0;
      else {
        flipped = true;
        buf[i - 1] = twosComp(byte);
      }
    }
  };
  var parse4 = exports2.parse = (buf) => {
    var post = buf[buf.length - 1];
    var pre = buf[0];
    var value;
    if (pre === 128)
      value = pos(buf.slice(1, buf.length));
    else if (pre === 255)
      value = twos(buf);
    else
      throw Error("invalid base256 encoding");
    if (!Number.isSafeInteger(value))
      throw Error("parsed number outside of javascript safe integer range");
    return value;
  };
  var twos = (buf) => {
    var len = buf.length;
    var sum = 0;
    var flipped = false;
    for (var i = len - 1; i > -1; i--) {
      var byte = buf[i];
      var f;
      if (flipped)
        f = onesComp(byte);
      else if (byte === 0)
        f = byte;
      else {
        flipped = true;
        f = twosComp(byte);
      }
      if (f !== 0)
        sum -= f * Math.pow(256, len - i - 1);
    }
    return sum;
  };
  var pos = (buf) => {
    var len = buf.length;
    var sum = 0;
    for (var i = len - 1; i > -1; i--) {
      var byte = buf[i];
      if (byte !== 0)
        sum += byte * Math.pow(256, len - i - 1);
    }
    return sum;
  };
  var onesComp = (byte) => (255 ^ byte) & 255;
  var twosComp = (byte) => (255 ^ byte) + 1 & 255;
});

// node_modules/tar/lib/header.js
var require_header = __commonJS((exports2, module2) => {
  "use strict";
  var types11 = require_types2();
  var pathModule = require("path").posix;
  var large = require_large_numbers();
  var SLURP = Symbol("slurp");
  var TYPE = Symbol("type");
  var Header = class {
    constructor(data, off, ex, gex) {
      this.cksumValid = false;
      this.needPax = false;
      this.nullBlock = false;
      this.block = null;
      this.path = null;
      this.mode = null;
      this.uid = null;
      this.gid = null;
      this.size = null;
      this.mtime = null;
      this.cksum = null;
      this[TYPE] = "0";
      this.linkpath = null;
      this.uname = null;
      this.gname = null;
      this.devmaj = 0;
      this.devmin = 0;
      this.atime = null;
      this.ctime = null;
      if (Buffer.isBuffer(data))
        this.decode(data, off || 0, ex, gex);
      else if (data)
        this.set(data);
    }
    decode(buf, off, ex, gex) {
      if (!off)
        off = 0;
      if (!buf || !(buf.length >= off + 512))
        throw new Error("need 512 bytes for header");
      this.path = decString(buf, off, 100);
      this.mode = decNumber(buf, off + 100, 8);
      this.uid = decNumber(buf, off + 108, 8);
      this.gid = decNumber(buf, off + 116, 8);
      this.size = decNumber(buf, off + 124, 12);
      this.mtime = decDate(buf, off + 136, 12);
      this.cksum = decNumber(buf, off + 148, 12);
      this[SLURP](ex);
      this[SLURP](gex, true);
      this[TYPE] = decString(buf, off + 156, 1);
      if (this[TYPE] === "")
        this[TYPE] = "0";
      if (this[TYPE] === "0" && this.path.substr(-1) === "/")
        this[TYPE] = "5";
      if (this[TYPE] === "5")
        this.size = 0;
      this.linkpath = decString(buf, off + 157, 100);
      if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
        this.uname = decString(buf, off + 265, 32);
        this.gname = decString(buf, off + 297, 32);
        this.devmaj = decNumber(buf, off + 329, 8);
        this.devmin = decNumber(buf, off + 337, 8);
        if (buf[off + 475] !== 0) {
          const prefix = decString(buf, off + 345, 155);
          this.path = prefix + "/" + this.path;
        } else {
          const prefix = decString(buf, off + 345, 130);
          if (prefix)
            this.path = prefix + "/" + this.path;
          this.atime = decDate(buf, off + 476, 12);
          this.ctime = decDate(buf, off + 488, 12);
        }
      }
      let sum = 8 * 32;
      for (let i = off; i < off + 148; i++) {
        sum += buf[i];
      }
      for (let i = off + 156; i < off + 512; i++) {
        sum += buf[i];
      }
      this.cksumValid = sum === this.cksum;
      if (this.cksum === null && sum === 8 * 32)
        this.nullBlock = true;
    }
    [SLURP](ex, global2) {
      for (let k in ex) {
        if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
          this[k] = ex[k];
      }
    }
    encode(buf, off) {
      if (!buf) {
        buf = this.block = Buffer.alloc(512);
        off = 0;
      }
      if (!off)
        off = 0;
      if (!(buf.length >= off + 512))
        throw new Error("need 512 bytes for header");
      const prefixSize = this.ctime || this.atime ? 130 : 155;
      const split = splitPrefix(this.path || "", prefixSize);
      const path66 = split[0];
      const prefix = split[1];
      this.needPax = split[2];
      this.needPax = encString(buf, off, 100, path66) || this.needPax;
      this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
      this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
      this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
      this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
      this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
      buf[off + 156] = this[TYPE].charCodeAt(0);
      this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
      buf.write("ustar\x0000", off + 257, 8);
      this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
      this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
      this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
      this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
      this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
      if (buf[off + 475] !== 0)
        this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
      else {
        this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
        this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
        this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
      }
      let sum = 8 * 32;
      for (let i = off; i < off + 148; i++) {
        sum += buf[i];
      }
      for (let i = off + 156; i < off + 512; i++) {
        sum += buf[i];
      }
      this.cksum = sum;
      encNumber(buf, off + 148, 8, this.cksum);
      this.cksumValid = true;
      return this.needPax;
    }
    set(data) {
      for (let i in data) {
        if (data[i] !== null && data[i] !== void 0)
          this[i] = data[i];
      }
    }
    get type() {
      return types11.name.get(this[TYPE]) || this[TYPE];
    }
    get typeKey() {
      return this[TYPE];
    }
    set type(type) {
      if (types11.code.has(type))
        this[TYPE] = types11.code.get(type);
      else
        this[TYPE] = type;
    }
  };
  var splitPrefix = (p, prefixSize) => {
    const pathSize = 100;
    let pp = p;
    let prefix = "";
    let ret2;
    const root = pathModule.parse(p).root || ".";
    if (Buffer.byteLength(pp) < pathSize)
      ret2 = [pp, prefix, false];
    else {
      prefix = pathModule.dirname(pp);
      pp = pathModule.basename(pp);
      do {
        if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize)
          ret2 = [pp, prefix, false];
        else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize)
          ret2 = [pp.substr(0, pathSize - 1), prefix, true];
        else {
          pp = pathModule.join(pathModule.basename(prefix), pp);
          prefix = pathModule.dirname(prefix);
        }
      } while (prefix !== root && !ret2);
      if (!ret2)
        ret2 = [p.substr(0, pathSize - 1), "", true];
    }
    return ret2;
  };
  var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
  var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
  var numToDate = (num) => num === null ? null : new Date(num * 1e3);
  var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
  var nanNull = (value) => isNaN(value) ? null : value;
  var decSmallNumber = (buf, off, size) => nanNull(parseInt(buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8));
  var MAXNUM = {
    12: 8589934591,
    8: 2097151
  };
  var encNumber = (buf, off, size, number2) => number2 === null ? false : number2 > MAXNUM[size] || number2 < 0 ? (large.encode(number2, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number2), false);
  var encSmallNumber = (buf, off, size, number2) => buf.write(octalString(number2, size), off, size, "ascii");
  var octalString = (number2, size) => padOctal(Math.floor(number2).toString(8), size);
  var padOctal = (string23, size) => (string23.length === size - 1 ? string23 : new Array(size - string23.length - 1).join("0") + string23 + " ") + "\0";
  var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
  var NULLS = new Array(156).join("\0");
  var encString = (buf, off, size, string23) => string23 === null ? false : (buf.write(string23 + NULLS, off, size, "utf8"), string23.length !== Buffer.byteLength(string23) || string23.length > size);
  module2.exports = Header;
});

// node_modules/tar/lib/pax.js
var require_pax = __commonJS((exports2, module2) => {
  "use strict";
  var Header = require_header();
  var path66 = require("path");
  var Pax = class {
    constructor(obj, global2) {
      this.atime = obj.atime || null;
      this.charset = obj.charset || null;
      this.comment = obj.comment || null;
      this.ctime = obj.ctime || null;
      this.gid = obj.gid || null;
      this.gname = obj.gname || null;
      this.linkpath = obj.linkpath || null;
      this.mtime = obj.mtime || null;
      this.path = obj.path || null;
      this.size = obj.size || null;
      this.uid = obj.uid || null;
      this.uname = obj.uname || null;
      this.dev = obj.dev || null;
      this.ino = obj.ino || null;
      this.nlink = obj.nlink || null;
      this.global = global2 || false;
    }
    encode() {
      const body = this.encodeBody();
      if (body === "")
        return null;
      const bodyLen = Buffer.byteLength(body);
      const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
      const buf = Buffer.allocUnsafe(bufLen);
      for (let i = 0; i < 512; i++) {
        buf[i] = 0;
      }
      new Header({
        path: ("PaxHeader/" + path66.basename(this.path)).slice(0, 99),
        mode: this.mode || 420,
        uid: this.uid || null,
        gid: this.gid || null,
        size: bodyLen,
        mtime: this.mtime || null,
        type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
        linkpath: "",
        uname: this.uname || "",
        gname: this.gname || "",
        devmaj: 0,
        devmin: 0,
        atime: this.atime || null,
        ctime: this.ctime || null
      }).encode(buf);
      buf.write(body, 512, bodyLen, "utf8");
      for (let i = bodyLen + 512; i < buf.length; i++) {
        buf[i] = 0;
      }
      return buf;
    }
    encodeBody() {
      return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
    }
    encodeField(field) {
      if (this[field] === null || this[field] === void 0)
        return "";
      const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
      const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
      const byteLen = Buffer.byteLength(s);
      let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
      if (byteLen + digits >= Math.pow(10, digits))
        digits += 1;
      const len = digits + byteLen;
      return len + s;
    }
  };
  Pax.parse = (string23, ex, g) => new Pax(merge(parseKV(string23), ex), g);
  var merge = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
  var parseKV = (string23) => string23.replace(/\n$/, "").split("\n").reduce(parseKVLine, Object.create(null));
  var parseKVLine = (set, line) => {
    const n = parseInt(line, 10);
    if (n !== Buffer.byteLength(line) + 1)
      return set;
    line = line.substr((n + " ").length);
    const kv = line.split("=");
    const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
    if (!k)
      return set;
    const v = kv.join("=");
    set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
    return set;
  };
  module2.exports = Pax;
});

// node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (Base) => class extends Base {
    warn(code, message, data = {}) {
      if (this.file)
        data.file = this.file;
      if (this.cwd)
        data.cwd = this.cwd;
      data.code = message instanceof Error && message.code || code;
      data.tarCode = code;
      if (!this.strict && data.recoverable !== false) {
        if (message instanceof Error) {
          data = Object.assign(message, data);
          message = message.message;
        }
        this.emit("warn", data.tarCode, message, data);
      } else if (message instanceof Error) {
        this.emit("error", Object.assign(message, data));
      } else
        this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
    }
  };
});

// node_modules/tar/lib/winchars.js
var require_winchars = __commonJS((exports2, module2) => {
  "use strict";
  var raw = [
    "|",
    "<",
    ">",
    "?",
    ":"
  ];
  var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
  var toWin = new Map(raw.map((char, i) => [char, win[i]]));
  var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
  module2.exports = {
    encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
    decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
  };
});

// node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (mode, isDir, portable) => {
    mode &= 4095;
    if (portable) {
      mode = (mode | 384) & ~18;
    }
    if (isDir) {
      if (mode & 256)
        mode |= 64;
      if (mode & 32)
        mode |= 8;
      if (mode & 4)
        mode |= 1;
    }
    return mode;
  };
});

// node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS((exports2, module2) => {
  "use strict";
  var MiniPass = require_minipass();
  var Pax = require_pax();
  var Header = require_header();
  var ReadEntry = require_read_entry();
  var fs55 = require("fs");
  var path66 = require("path");
  var types11 = require_types2();
  var maxReadSize = 16 * 1024 * 1024;
  var PROCESS = Symbol("process");
  var FILE = Symbol("file");
  var DIRECTORY = Symbol("directory");
  var SYMLINK = Symbol("symlink");
  var HARDLINK = Symbol("hardlink");
  var HEADER = Symbol("header");
  var READ = Symbol("read");
  var LSTAT = Symbol("lstat");
  var ONLSTAT = Symbol("onlstat");
  var ONREAD = Symbol("onread");
  var ONREADLINK = Symbol("onreadlink");
  var OPENFILE = Symbol("openfile");
  var ONOPENFILE = Symbol("onopenfile");
  var CLOSE = Symbol("close");
  var MODE = Symbol("mode");
  var warner = require_warn_mixin();
  var winchars = require_winchars();
  var modeFix = require_mode_fix();
  var WriteEntry = warner(class WriteEntry extends MiniPass {
    constructor(p, opt) {
      opt = opt || {};
      super(opt);
      if (typeof p !== "string")
        throw new TypeError("path is required");
      this.path = p;
      this.portable = !!opt.portable;
      this.myuid = process.getuid && process.getuid();
      this.myuser = process.env.USER || "";
      this.maxReadSize = opt.maxReadSize || maxReadSize;
      this.linkCache = opt.linkCache || new Map();
      this.statCache = opt.statCache || new Map();
      this.preservePaths = !!opt.preservePaths;
      this.cwd = opt.cwd || process.cwd();
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;
      this.mtime = opt.mtime || null;
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      let pathWarn = false;
      if (!this.preservePaths && path66.win32.isAbsolute(p)) {
        const parsed = path66.win32.parse(p);
        this.path = p.substr(parsed.root.length);
        pathWarn = parsed.root;
      }
      this.win32 = !!opt.win32 || process.platform === "win32";
      if (this.win32) {
        this.path = winchars.decode(this.path.replace(/\\/g, "/"));
        p = p.replace(/\\/g, "/");
      }
      this.absolute = opt.absolute || path66.resolve(this.cwd, p);
      if (this.path === "")
        this.path = "./";
      if (pathWarn) {
        this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
          entry: this,
          path: pathWarn + this.path
        });
      }
      if (this.statCache.has(this.absolute))
        this[ONLSTAT](this.statCache.get(this.absolute));
      else
        this[LSTAT]();
    }
    [LSTAT]() {
      fs55.lstat(this.absolute, (er, stat) => {
        if (er)
          return this.emit("error", er);
        this[ONLSTAT](stat);
      });
    }
    [ONLSTAT](stat) {
      this.statCache.set(this.absolute, stat);
      this.stat = stat;
      if (!stat.isFile())
        stat.size = 0;
      this.type = getType(stat);
      this.emit("stat", stat);
      this[PROCESS]();
    }
    [PROCESS]() {
      switch (this.type) {
        case "File":
          return this[FILE]();
        case "Directory":
          return this[DIRECTORY]();
        case "SymbolicLink":
          return this[SYMLINK]();
        default:
          return this.end();
      }
    }
    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }
    [HEADER]() {
      if (this.type === "Directory" && this.portable)
        this.noMtime = true;
      this.header = new Header({
        path: this.path,
        linkpath: this.linkpath,
        mode: this[MODE](this.stat.mode),
        uid: this.portable ? null : this.stat.uid,
        gid: this.portable ? null : this.stat.gid,
        size: this.stat.size,
        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
        type: this.type,
        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
        atime: this.portable ? null : this.stat.atime,
        ctime: this.portable ? null : this.stat.ctime
      });
      if (this.header.encode() && !this.noPax)
        this.write(new Pax({
          atime: this.portable ? null : this.header.atime,
          ctime: this.portable ? null : this.header.ctime,
          gid: this.portable ? null : this.header.gid,
          mtime: this.noMtime ? null : this.mtime || this.header.mtime,
          path: this.path,
          linkpath: this.linkpath,
          size: this.header.size,
          uid: this.portable ? null : this.header.uid,
          uname: this.portable ? null : this.header.uname,
          dev: this.portable ? null : this.stat.dev,
          ino: this.portable ? null : this.stat.ino,
          nlink: this.portable ? null : this.stat.nlink
        }).encode());
      this.write(this.header.block);
    }
    [DIRECTORY]() {
      if (this.path.substr(-1) !== "/")
        this.path += "/";
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
    [SYMLINK]() {
      fs55.readlink(this.absolute, (er, linkpath) => {
        if (er)
          return this.emit("error", er);
        this[ONREADLINK](linkpath);
      });
    }
    [ONREADLINK](linkpath) {
      this.linkpath = linkpath.replace(/\\/g, "/");
      this[HEADER]();
      this.end();
    }
    [HARDLINK](linkpath) {
      this.type = "Link";
      this.linkpath = path66.relative(this.cwd, linkpath).replace(/\\/g, "/");
      this.stat.size = 0;
      this[HEADER]();
      this.end();
    }
    [FILE]() {
      if (this.stat.nlink > 1) {
        const linkKey = this.stat.dev + ":" + this.stat.ino;
        if (this.linkCache.has(linkKey)) {
          const linkpath = this.linkCache.get(linkKey);
          if (linkpath.indexOf(this.cwd) === 0)
            return this[HARDLINK](linkpath);
        }
        this.linkCache.set(linkKey, this.absolute);
      }
      this[HEADER]();
      if (this.stat.size === 0)
        return this.end();
      this[OPENFILE]();
    }
    [OPENFILE]() {
      fs55.open(this.absolute, "r", (er, fd) => {
        if (er)
          return this.emit("error", er);
        this[ONOPENFILE](fd);
      });
    }
    [ONOPENFILE](fd) {
      const blockLen = 512 * Math.ceil(this.stat.size / 512);
      const bufLen = Math.min(blockLen, this.maxReadSize);
      const buf = Buffer.allocUnsafe(bufLen);
      this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen);
    }
    [READ](fd, buf, offset, length, pos, remain, blockRemain) {
      fs55.read(fd, buf, offset, length, pos, (er, bytesRead) => {
        if (er) {
          return this[CLOSE](fd, () => this.emit("error", er));
        }
        this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);
      });
    }
    [CLOSE](fd, cb) {
      fs55.close(fd, cb);
    }
    [ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {
      if (bytesRead <= 0 && remain > 0) {
        const er = new Error("encountered unexpected EOF");
        er.path = this.absolute;
        er.syscall = "read";
        er.code = "EOF";
        return this[CLOSE](fd, () => this.emit("error", er));
      }
      if (bytesRead > remain) {
        const er = new Error("did not encounter expected EOF");
        er.path = this.absolute;
        er.syscall = "read";
        er.code = "EOF";
        return this[CLOSE](fd, () => this.emit("error", er));
      }
      if (bytesRead === remain) {
        for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {
          buf[i + offset] = 0;
          bytesRead++;
          remain++;
        }
      }
      const writeBuf = offset === 0 && bytesRead === buf.length ? buf : buf.slice(offset, offset + bytesRead);
      remain -= bytesRead;
      blockRemain -= bytesRead;
      pos += bytesRead;
      offset += bytesRead;
      this.write(writeBuf);
      if (!remain) {
        if (blockRemain)
          this.write(Buffer.alloc(blockRemain));
        return this[CLOSE](fd, (er) => er ? this.emit("error", er) : this.end());
      }
      if (offset >= length) {
        buf = Buffer.allocUnsafe(length);
        offset = 0;
      }
      length = buf.length - offset;
      this[READ](fd, buf, offset, length, pos, remain, blockRemain);
    }
  });
  var WriteEntrySync = class extends WriteEntry {
    constructor(path67, opt) {
      super(path67, opt);
    }
    [LSTAT]() {
      this[ONLSTAT](fs55.lstatSync(this.absolute));
    }
    [SYMLINK]() {
      this[ONREADLINK](fs55.readlinkSync(this.absolute));
    }
    [OPENFILE]() {
      this[ONOPENFILE](fs55.openSync(this.absolute, "r"));
    }
    [READ](fd, buf, offset, length, pos, remain, blockRemain) {
      let threw = true;
      try {
        const bytesRead = fs55.readSync(fd, buf, offset, length, pos);
        this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);
        threw = false;
      } finally {
        if (threw)
          try {
            this[CLOSE](fd, () => {
            });
          } catch (er) {
          }
      }
    }
    [CLOSE](fd, cb) {
      fs55.closeSync(fd);
      cb();
    }
  };
  var WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
    constructor(readEntry, opt) {
      opt = opt || {};
      super(opt);
      this.preservePaths = !!opt.preservePaths;
      this.portable = !!opt.portable;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.noMtime = !!opt.noMtime;
      this.readEntry = readEntry;
      this.type = readEntry.type;
      if (this.type === "Directory" && this.portable)
        this.noMtime = true;
      this.path = readEntry.path;
      this.mode = this[MODE](readEntry.mode);
      this.uid = this.portable ? null : readEntry.uid;
      this.gid = this.portable ? null : readEntry.gid;
      this.uname = this.portable ? null : readEntry.uname;
      this.gname = this.portable ? null : readEntry.gname;
      this.size = readEntry.size;
      this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
      this.atime = this.portable ? null : readEntry.atime;
      this.ctime = this.portable ? null : readEntry.ctime;
      this.linkpath = readEntry.linkpath;
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      let pathWarn = false;
      if (path66.isAbsolute(this.path) && !this.preservePaths) {
        const parsed = path66.parse(this.path);
        pathWarn = parsed.root;
        this.path = this.path.substr(parsed.root.length);
      }
      this.remain = readEntry.size;
      this.blockRemain = readEntry.startBlockSize;
      this.header = new Header({
        path: this.path,
        linkpath: this.linkpath,
        mode: this.mode,
        uid: this.portable ? null : this.uid,
        gid: this.portable ? null : this.gid,
        size: this.size,
        mtime: this.noMtime ? null : this.mtime,
        type: this.type,
        uname: this.portable ? null : this.uname,
        atime: this.portable ? null : this.atime,
        ctime: this.portable ? null : this.ctime
      });
      if (pathWarn) {
        this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
          entry: this,
          path: pathWarn + this.path
        });
      }
      if (this.header.encode() && !this.noPax)
        super.write(new Pax({
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime,
          gid: this.portable ? null : this.gid,
          mtime: this.noMtime ? null : this.mtime,
          path: this.path,
          linkpath: this.linkpath,
          size: this.size,
          uid: this.portable ? null : this.uid,
          uname: this.portable ? null : this.uname,
          dev: this.portable ? null : this.readEntry.dev,
          ino: this.portable ? null : this.readEntry.ino,
          nlink: this.portable ? null : this.readEntry.nlink
        }).encode());
      super.write(this.header.block);
      readEntry.pipe(this);
    }
    [MODE](mode) {
      return modeFix(mode, this.type === "Directory", this.portable);
    }
    write(data) {
      const writeLen = data.length;
      if (writeLen > this.blockRemain)
        throw new Error("writing more to entry than is appropriate");
      this.blockRemain -= writeLen;
      return super.write(data);
    }
    end() {
      if (this.blockRemain)
        this.write(Buffer.alloc(this.blockRemain));
      return super.end();
    }
  });
  WriteEntry.Sync = WriteEntrySync;
  WriteEntry.Tar = WriteEntryTar;
  var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
  module2.exports = WriteEntry;
});

// node_modules/tar/lib/pack.js
var require_pack = __commonJS((exports2, module2) => {
  "use strict";
  var PackJob = class {
    constructor(path67, absolute) {
      this.path = path67 || "./";
      this.absolute = absolute;
      this.entry = null;
      this.stat = null;
      this.readdir = null;
      this.pending = false;
      this.ignore = false;
      this.piped = false;
    }
  };
  var MiniPass = require_minipass();
  var zlib3 = require_minizlib();
  var ReadEntry = require_read_entry();
  var WriteEntry = require_write_entry();
  var WriteEntrySync = WriteEntry.Sync;
  var WriteEntryTar = WriteEntry.Tar;
  var Yallist = require_yallist();
  var EOF = Buffer.alloc(1024);
  var ONSTAT = Symbol("onStat");
  var ENDED = Symbol("ended");
  var QUEUE = Symbol("queue");
  var CURRENT = Symbol("current");
  var PROCESS = Symbol("process");
  var PROCESSING = Symbol("processing");
  var PROCESSJOB = Symbol("processJob");
  var JOBS = Symbol("jobs");
  var JOBDONE = Symbol("jobDone");
  var ADDFSENTRY = Symbol("addFSEntry");
  var ADDTARENTRY = Symbol("addTarEntry");
  var STAT = Symbol("stat");
  var READDIR = Symbol("readdir");
  var ONREADDIR = Symbol("onreaddir");
  var PIPE = Symbol("pipe");
  var ENTRY = Symbol("entry");
  var ENTRYOPT = Symbol("entryOpt");
  var WRITEENTRYCLASS = Symbol("writeEntryClass");
  var WRITE = Symbol("write");
  var ONDRAIN = Symbol("ondrain");
  var fs55 = require("fs");
  var path66 = require("path");
  var warner = require_warn_mixin();
  var Pack = warner(class Pack extends MiniPass {
    constructor(opt) {
      super(opt);
      opt = opt || Object.create(null);
      this.opt = opt;
      this.file = opt.file || "";
      this.cwd = opt.cwd || process.cwd();
      this.maxReadSize = opt.maxReadSize;
      this.preservePaths = !!opt.preservePaths;
      this.strict = !!opt.strict;
      this.noPax = !!opt.noPax;
      this.prefix = (opt.prefix || "").replace(/(\\|\/)+$/, "");
      this.linkCache = opt.linkCache || new Map();
      this.statCache = opt.statCache || new Map();
      this.readdirCache = opt.readdirCache || new Map();
      this[WRITEENTRYCLASS] = WriteEntry;
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      this.portable = !!opt.portable;
      this.zip = null;
      if (opt.gzip) {
        if (typeof opt.gzip !== "object")
          opt.gzip = {};
        if (this.portable)
          opt.gzip.portable = true;
        this.zip = new zlib3.Gzip(opt.gzip);
        this.zip.on("data", (chunk) => super.write(chunk));
        this.zip.on("end", (_) => super.end());
        this.zip.on("drain", (_) => this[ONDRAIN]());
        this.on("resume", (_) => this.zip.resume());
      } else
        this.on("drain", this[ONDRAIN]);
      this.noDirRecurse = !!opt.noDirRecurse;
      this.follow = !!opt.follow;
      this.noMtime = !!opt.noMtime;
      this.mtime = opt.mtime || null;
      this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
      this[QUEUE] = new Yallist();
      this[JOBS] = 0;
      this.jobs = +opt.jobs || 4;
      this[PROCESSING] = false;
      this[ENDED] = false;
    }
    [WRITE](chunk) {
      return super.write(chunk);
    }
    add(path67) {
      this.write(path67);
      return this;
    }
    end(path67) {
      if (path67)
        this.write(path67);
      this[ENDED] = true;
      this[PROCESS]();
      return this;
    }
    write(path67) {
      if (this[ENDED])
        throw new Error("write after end");
      if (path67 instanceof ReadEntry)
        this[ADDTARENTRY](path67);
      else
        this[ADDFSENTRY](path67);
      return this.flowing;
    }
    [ADDTARENTRY](p) {
      const absolute = path66.resolve(this.cwd, p.path);
      if (this.prefix)
        p.path = this.prefix + "/" + p.path.replace(/^\.(\/+|$)/, "");
      if (!this.filter(p.path, p))
        p.resume();
      else {
        const job = new PackJob(p.path, absolute, false);
        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
        job.entry.on("end", (_) => this[JOBDONE](job));
        this[JOBS] += 1;
        this[QUEUE].push(job);
      }
      this[PROCESS]();
    }
    [ADDFSENTRY](p) {
      const absolute = path66.resolve(this.cwd, p);
      if (this.prefix)
        p = this.prefix + "/" + p.replace(/^\.(\/+|$)/, "");
      this[QUEUE].push(new PackJob(p, absolute));
      this[PROCESS]();
    }
    [STAT](job) {
      job.pending = true;
      this[JOBS] += 1;
      const stat = this.follow ? "stat" : "lstat";
      fs55[stat](job.absolute, (er, stat2) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er)
          this.emit("error", er);
        else
          this[ONSTAT](job, stat2);
      });
    }
    [ONSTAT](job, stat) {
      this.statCache.set(job.absolute, stat);
      job.stat = stat;
      if (!this.filter(job.path, stat))
        job.ignore = true;
      this[PROCESS]();
    }
    [READDIR](job) {
      job.pending = true;
      this[JOBS] += 1;
      fs55.readdir(job.absolute, (er, entries) => {
        job.pending = false;
        this[JOBS] -= 1;
        if (er)
          return this.emit("error", er);
        this[ONREADDIR](job, entries);
      });
    }
    [ONREADDIR](job, entries) {
      this.readdirCache.set(job.absolute, entries);
      job.readdir = entries;
      this[PROCESS]();
    }
    [PROCESS]() {
      if (this[PROCESSING])
        return;
      this[PROCESSING] = true;
      for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
        this[PROCESSJOB](w.value);
        if (w.value.ignore) {
          const p = w.next;
          this[QUEUE].removeNode(w);
          w.next = p;
        }
      }
      this[PROCESSING] = false;
      if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
        if (this.zip)
          this.zip.end(EOF);
        else {
          super.write(EOF);
          super.end();
        }
      }
    }
    get [CURRENT]() {
      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
    }
    [JOBDONE](job) {
      this[QUEUE].shift();
      this[JOBS] -= 1;
      this[PROCESS]();
    }
    [PROCESSJOB](job) {
      if (job.pending)
        return;
      if (job.entry) {
        if (job === this[CURRENT] && !job.piped)
          this[PIPE](job);
        return;
      }
      if (!job.stat) {
        if (this.statCache.has(job.absolute))
          this[ONSTAT](job, this.statCache.get(job.absolute));
        else
          this[STAT](job);
      }
      if (!job.stat)
        return;
      if (job.ignore)
        return;
      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
        if (this.readdirCache.has(job.absolute))
          this[ONREADDIR](job, this.readdirCache.get(job.absolute));
        else
          this[READDIR](job);
        if (!job.readdir)
          return;
      }
      job.entry = this[ENTRY](job);
      if (!job.entry) {
        job.ignore = true;
        return;
      }
      if (job === this[CURRENT] && !job.piped)
        this[PIPE](job);
    }
    [ENTRYOPT](job) {
      return {
        onwarn: (code, msg, data) => this.warn(code, msg, data),
        noPax: this.noPax,
        cwd: this.cwd,
        absolute: job.absolute,
        preservePaths: this.preservePaths,
        maxReadSize: this.maxReadSize,
        strict: this.strict,
        portable: this.portable,
        linkCache: this.linkCache,
        statCache: this.statCache,
        noMtime: this.noMtime,
        mtime: this.mtime
      };
    }
    [ENTRY](job) {
      this[JOBS] += 1;
      try {
        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
      } catch (er) {
        this.emit("error", er);
      }
    }
    [ONDRAIN]() {
      if (this[CURRENT] && this[CURRENT].entry)
        this[CURRENT].entry.resume();
    }
    [PIPE](job) {
      job.piped = true;
      if (job.readdir)
        job.readdir.forEach((entry) => {
          const p = this.prefix ? job.path.slice(this.prefix.length + 1) || "./" : job.path;
          const base = p === "./" ? "" : p.replace(/\/*$/, "/");
          this[ADDFSENTRY](base + entry);
        });
      const source3 = job.entry;
      const zip = this.zip;
      if (zip)
        source3.on("data", (chunk) => {
          if (!zip.write(chunk))
            source3.pause();
        });
      else
        source3.on("data", (chunk) => {
          if (!super.write(chunk))
            source3.pause();
        });
    }
    pause() {
      if (this.zip)
        this.zip.pause();
      return super.pause();
    }
  });
  var PackSync = class extends Pack {
    constructor(opt) {
      super(opt);
      this[WRITEENTRYCLASS] = WriteEntrySync;
    }
    pause() {
    }
    resume() {
    }
    [STAT](job) {
      const stat = this.follow ? "statSync" : "lstatSync";
      this[ONSTAT](job, fs55[stat](job.absolute));
    }
    [READDIR](job, stat) {
      this[ONREADDIR](job, fs55.readdirSync(job.absolute));
    }
    [PIPE](job) {
      const source3 = job.entry;
      const zip = this.zip;
      if (job.readdir)
        job.readdir.forEach((entry) => {
          const p = this.prefix ? job.path.slice(this.prefix.length + 1) || "./" : job.path;
          const base = p === "./" ? "" : p.replace(/\/*$/, "/");
          this[ADDFSENTRY](base + entry);
        });
      if (zip)
        source3.on("data", (chunk) => {
          zip.write(chunk);
        });
      else
        source3.on("data", (chunk) => {
          super[WRITE](chunk);
        });
    }
  };
  Pack.Sync = PackSync;
  module2.exports = Pack;
});

// node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS((exports2) => {
  "use strict";
  var MiniPass = require_minipass();
  var EE = require("events").EventEmitter;
  var fs55 = require("fs");
  var writev = fs55.writev;
  if (!writev) {
    const binding = process.binding("fs");
    const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
    writev = (fd, iovec, pos, cb) => {
      const done = (er, bw) => cb(er, bw, iovec);
      const req = new FSReqWrap();
      req.oncomplete = done;
      binding.writeBuffers(fd, iovec, pos, req);
    };
  }
  var _autoClose = Symbol("_autoClose");
  var _close = Symbol("_close");
  var _ended = Symbol("_ended");
  var _fd = Symbol("_fd");
  var _finished = Symbol("_finished");
  var _flags = Symbol("_flags");
  var _flush = Symbol("_flush");
  var _handleChunk = Symbol("_handleChunk");
  var _makeBuf = Symbol("_makeBuf");
  var _mode = Symbol("_mode");
  var _needDrain = Symbol("_needDrain");
  var _onerror = Symbol("_onerror");
  var _onopen = Symbol("_onopen");
  var _onread = Symbol("_onread");
  var _onwrite = Symbol("_onwrite");
  var _open = Symbol("_open");
  var _path = Symbol("_path");
  var _pos = Symbol("_pos");
  var _queue = Symbol("_queue");
  var _read = Symbol("_read");
  var _readSize = Symbol("_readSize");
  var _reading = Symbol("_reading");
  var _remain = Symbol("_remain");
  var _size = Symbol("_size");
  var _write = Symbol("_write");
  var _writing = Symbol("_writing");
  var _defaultFlag = Symbol("_defaultFlag");
  var _errored = Symbol("_errored");
  var ReadStream = class extends MiniPass {
    constructor(path66, opt) {
      opt = opt || {};
      super(opt);
      this.readable = true;
      this.writable = false;
      if (typeof path66 !== "string")
        throw new TypeError("path must be a string");
      this[_errored] = false;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
      this[_path] = path66;
      this[_readSize] = opt.readSize || 16 * 1024 * 1024;
      this[_reading] = false;
      this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
      this[_remain] = this[_size];
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      if (typeof this[_fd] === "number")
        this[_read]();
      else
        this[_open]();
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    write() {
      throw new TypeError("this is a readable stream");
    }
    end() {
      throw new TypeError("this is a readable stream");
    }
    [_open]() {
      fs55.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (er)
        this[_onerror](er);
      else {
        this[_fd] = fd;
        this.emit("open", fd);
        this[_read]();
      }
    }
    [_makeBuf]() {
      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
    [_read]() {
      if (!this[_reading]) {
        this[_reading] = true;
        const buf = this[_makeBuf]();
        if (buf.length === 0)
          return process.nextTick(() => this[_onread](null, 0, buf));
        fs55.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
      }
    }
    [_onread](er, br, buf) {
      this[_reading] = false;
      if (er)
        this[_onerror](er);
      else if (this[_handleChunk](br, buf))
        this[_read]();
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs55.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
    [_onerror](er) {
      this[_reading] = true;
      this[_close]();
      this.emit("error", er);
    }
    [_handleChunk](br, buf) {
      let ret2 = false;
      this[_remain] -= br;
      if (br > 0)
        ret2 = super.write(br < buf.length ? buf.slice(0, br) : buf);
      if (br === 0 || this[_remain] <= 0) {
        ret2 = false;
        this[_close]();
        super.end();
      }
      return ret2;
    }
    emit(ev, data) {
      switch (ev) {
        case "prefinish":
        case "finish":
          break;
        case "drain":
          if (typeof this[_fd] === "number")
            this[_read]();
          break;
        case "error":
          if (this[_errored])
            return;
          this[_errored] = true;
          return super.emit(ev, data);
        default:
          return super.emit(ev, data);
      }
    }
  };
  var ReadStreamSync = class extends ReadStream {
    [_open]() {
      let threw = true;
      try {
        this[_onopen](null, fs55.openSync(this[_path], "r"));
        threw = false;
      } finally {
        if (threw)
          this[_close]();
      }
    }
    [_read]() {
      let threw = true;
      try {
        if (!this[_reading]) {
          this[_reading] = true;
          do {
            const buf = this[_makeBuf]();
            const br = buf.length === 0 ? 0 : fs55.readSync(this[_fd], buf, 0, buf.length, null);
            if (!this[_handleChunk](br, buf))
              break;
          } while (true);
          this[_reading] = false;
        }
        threw = false;
      } finally {
        if (threw)
          this[_close]();
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs55.closeSync(fd);
        this.emit("close");
      }
    }
  };
  var WriteStream = class extends EE {
    constructor(path66, opt) {
      opt = opt || {};
      super(opt);
      this.readable = false;
      this.writable = true;
      this[_errored] = false;
      this[_writing] = false;
      this[_ended] = false;
      this[_needDrain] = false;
      this[_queue] = [];
      this[_path] = path66;
      this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
      this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
      this[_pos] = typeof opt.start === "number" ? opt.start : null;
      this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
      const defaultFlag = this[_pos] !== null ? "r+" : "w";
      this[_defaultFlag] = opt.flags === void 0;
      this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
      if (this[_fd] === null)
        this[_open]();
    }
    emit(ev, data) {
      if (ev === "error") {
        if (this[_errored])
          return;
        this[_errored] = true;
      }
      return super.emit(ev, data);
    }
    get fd() {
      return this[_fd];
    }
    get path() {
      return this[_path];
    }
    [_onerror](er) {
      this[_close]();
      this[_writing] = true;
      this.emit("error", er);
    }
    [_open]() {
      fs55.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
      if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
        this[_flags] = "w";
        this[_open]();
      } else if (er)
        this[_onerror](er);
      else {
        this[_fd] = fd;
        this.emit("open", fd);
        this[_flush]();
      }
    }
    end(buf, enc) {
      if (buf)
        this.write(buf, enc);
      this[_ended] = true;
      if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
        this[_onwrite](null, 0);
      return this;
    }
    write(buf, enc) {
      if (typeof buf === "string")
        buf = Buffer.from(buf, enc);
      if (this[_ended]) {
        this.emit("error", new Error("write() after end()"));
        return false;
      }
      if (this[_fd] === null || this[_writing] || this[_queue].length) {
        this[_queue].push(buf);
        this[_needDrain] = true;
        return false;
      }
      this[_writing] = true;
      this[_write](buf);
      return true;
    }
    [_write](buf) {
      fs55.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
    [_onwrite](er, bw) {
      if (er)
        this[_onerror](er);
      else {
        if (this[_pos] !== null)
          this[_pos] += bw;
        if (this[_queue].length)
          this[_flush]();
        else {
          this[_writing] = false;
          if (this[_ended] && !this[_finished]) {
            this[_finished] = true;
            this[_close]();
            this.emit("finish");
          } else if (this[_needDrain]) {
            this[_needDrain] = false;
            this.emit("drain");
          }
        }
      }
    }
    [_flush]() {
      if (this[_queue].length === 0) {
        if (this[_ended])
          this[_onwrite](null, 0);
      } else if (this[_queue].length === 1)
        this[_write](this[_queue].pop());
      else {
        const iovec = this[_queue];
        this[_queue] = [];
        writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs55.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
      }
    }
  };
  var WriteStreamSync = class extends WriteStream {
    [_open]() {
      let fd;
      if (this[_defaultFlag] && this[_flags] === "r+") {
        try {
          fd = fs55.openSync(this[_path], this[_flags], this[_mode]);
        } catch (er) {
          if (er.code === "ENOENT") {
            this[_flags] = "w";
            return this[_open]();
          } else
            throw er;
        }
      } else
        fd = fs55.openSync(this[_path], this[_flags], this[_mode]);
      this[_onopen](null, fd);
    }
    [_close]() {
      if (this[_autoClose] && typeof this[_fd] === "number") {
        const fd = this[_fd];
        this[_fd] = null;
        fs55.closeSync(fd);
        this.emit("close");
      }
    }
    [_write](buf) {
      let threw = true;
      try {
        this[_onwrite](null, fs55.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
        threw = false;
      } finally {
        if (threw)
          try {
            this[_close]();
          } catch (_) {
          }
      }
    }
  };
  exports2.ReadStream = ReadStream;
  exports2.ReadStreamSync = ReadStreamSync;
  exports2.WriteStream = WriteStream;
  exports2.WriteStreamSync = WriteStreamSync;
});

// node_modules/tar/lib/parse.js
var require_parse2 = __commonJS((exports2, module2) => {
  "use strict";
  var warner = require_warn_mixin();
  var path66 = require("path");
  var Header = require_header();
  var EE = require("events");
  var Yallist = require_yallist();
  var maxMetaEntrySize = 1024 * 1024;
  var Entry = require_read_entry();
  var Pax = require_pax();
  var zlib3 = require_minizlib();
  var gzipHeader = Buffer.from([31, 139]);
  var STATE = Symbol("state");
  var WRITEENTRY = Symbol("writeEntry");
  var READENTRY = Symbol("readEntry");
  var NEXTENTRY = Symbol("nextEntry");
  var PROCESSENTRY = Symbol("processEntry");
  var EX = Symbol("extendedHeader");
  var GEX = Symbol("globalExtendedHeader");
  var META = Symbol("meta");
  var EMITMETA = Symbol("emitMeta");
  var BUFFER = Symbol("buffer");
  var QUEUE = Symbol("queue");
  var ENDED = Symbol("ended");
  var EMITTEDEND = Symbol("emittedEnd");
  var EMIT = Symbol("emit");
  var UNZIP = Symbol("unzip");
  var CONSUMECHUNK = Symbol("consumeChunk");
  var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
  var CONSUMEBODY = Symbol("consumeBody");
  var CONSUMEMETA = Symbol("consumeMeta");
  var CONSUMEHEADER = Symbol("consumeHeader");
  var CONSUMING = Symbol("consuming");
  var BUFFERCONCAT = Symbol("bufferConcat");
  var MAYBEEND = Symbol("maybeEnd");
  var WRITING = Symbol("writing");
  var ABORTED = Symbol("aborted");
  var DONE = Symbol("onDone");
  var SAW_VALID_ENTRY = Symbol("sawValidEntry");
  var SAW_NULL_BLOCK = Symbol("sawNullBlock");
  var SAW_EOF = Symbol("sawEOF");
  var noop = (_) => true;
  module2.exports = warner(class Parser extends EE {
    constructor(opt) {
      opt = opt || {};
      super(opt);
      this.file = opt.file || "";
      this[SAW_VALID_ENTRY] = null;
      this.on(DONE, (_) => {
        if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
          this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
        }
      });
      if (opt.ondone)
        this.on(DONE, opt.ondone);
      else
        this.on(DONE, (_) => {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
          this.emit("close");
        });
      this.strict = !!opt.strict;
      this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
      this.filter = typeof opt.filter === "function" ? opt.filter : noop;
      this.writable = true;
      this.readable = false;
      this[QUEUE] = new Yallist();
      this[BUFFER] = null;
      this[READENTRY] = null;
      this[WRITEENTRY] = null;
      this[STATE] = "begin";
      this[META] = "";
      this[EX] = null;
      this[GEX] = null;
      this[ENDED] = false;
      this[UNZIP] = null;
      this[ABORTED] = false;
      this[SAW_NULL_BLOCK] = false;
      this[SAW_EOF] = false;
      if (typeof opt.onwarn === "function")
        this.on("warn", opt.onwarn);
      if (typeof opt.onentry === "function")
        this.on("entry", opt.onentry);
    }
    [CONSUMEHEADER](chunk, position15) {
      if (this[SAW_VALID_ENTRY] === null)
        this[SAW_VALID_ENTRY] = false;
      let header;
      try {
        header = new Header(chunk, position15, this[EX], this[GEX]);
      } catch (er) {
        return this.warn("TAR_ENTRY_INVALID", er);
      }
      if (header.nullBlock) {
        if (this[SAW_NULL_BLOCK]) {
          this[SAW_EOF] = true;
          if (this[STATE] === "begin")
            this[STATE] = "header";
          this[EMIT]("eof");
        } else {
          this[SAW_NULL_BLOCK] = true;
          this[EMIT]("nullBlock");
        }
      } else {
        this[SAW_NULL_BLOCK] = false;
        if (!header.cksumValid)
          this.warn("TAR_ENTRY_INVALID", "checksum failure", {header});
        else if (!header.path)
          this.warn("TAR_ENTRY_INVALID", "path is required", {header});
        else {
          const type = header.type;
          if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
            this.warn("TAR_ENTRY_INVALID", "linkpath required", {header});
          else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
            this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", {header});
          else {
            const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
            if (!this[SAW_VALID_ENTRY]) {
              if (entry.remain) {
                const onend = () => {
                  if (!entry.invalid)
                    this[SAW_VALID_ENTRY] = true;
                };
                entry.on("end", onend);
              } else {
                this[SAW_VALID_ENTRY] = true;
              }
            }
            if (entry.meta) {
              if (entry.size > this.maxMetaEntrySize) {
                entry.ignore = true;
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = "ignore";
                entry.resume();
              } else if (entry.size > 0) {
                this[META] = "";
                entry.on("data", (c) => this[META] += c);
                this[STATE] = "meta";
              }
            } else {
              this[EX] = null;
              entry.ignore = entry.ignore || !this.filter(entry.path, entry);
              if (entry.ignore) {
                this[EMIT]("ignoredEntry", entry);
                this[STATE] = entry.remain ? "ignore" : "header";
                entry.resume();
              } else {
                if (entry.remain)
                  this[STATE] = "body";
                else {
                  this[STATE] = "header";
                  entry.end();
                }
                if (!this[READENTRY]) {
                  this[QUEUE].push(entry);
                  this[NEXTENTRY]();
                } else
                  this[QUEUE].push(entry);
              }
            }
          }
        }
      }
    }
    [PROCESSENTRY](entry) {
      let go = true;
      if (!entry) {
        this[READENTRY] = null;
        go = false;
      } else if (Array.isArray(entry))
        this.emit.apply(this, entry);
      else {
        this[READENTRY] = entry;
        this.emit("entry", entry);
        if (!entry.emittedEnd) {
          entry.on("end", (_) => this[NEXTENTRY]());
          go = false;
        }
      }
      return go;
    }
    [NEXTENTRY]() {
      do {
      } while (this[PROCESSENTRY](this[QUEUE].shift()));
      if (!this[QUEUE].length) {
        const re = this[READENTRY];
        const drainNow = !re || re.flowing || re.size === re.remain;
        if (drainNow) {
          if (!this[WRITING])
            this.emit("drain");
        } else
          re.once("drain", (_) => this.emit("drain"));
      }
    }
    [CONSUMEBODY](chunk, position15) {
      const entry = this[WRITEENTRY];
      const br = entry.blockRemain;
      const c = br >= chunk.length && position15 === 0 ? chunk : chunk.slice(position15, position15 + br);
      entry.write(c);
      if (!entry.blockRemain) {
        this[STATE] = "header";
        this[WRITEENTRY] = null;
        entry.end();
      }
      return c.length;
    }
    [CONSUMEMETA](chunk, position15) {
      const entry = this[WRITEENTRY];
      const ret2 = this[CONSUMEBODY](chunk, position15);
      if (!this[WRITEENTRY])
        this[EMITMETA](entry);
      return ret2;
    }
    [EMIT](ev, data, extra) {
      if (!this[QUEUE].length && !this[READENTRY])
        this.emit(ev, data, extra);
      else
        this[QUEUE].push([ev, data, extra]);
    }
    [EMITMETA](entry) {
      this[EMIT]("meta", this[META]);
      switch (entry.type) {
        case "ExtendedHeader":
        case "OldExtendedHeader":
          this[EX] = Pax.parse(this[META], this[EX], false);
          break;
        case "GlobalExtendedHeader":
          this[GEX] = Pax.parse(this[META], this[GEX], true);
          break;
        case "NextFileHasLongPath":
        case "OldGnuLongPath":
          this[EX] = this[EX] || Object.create(null);
          this[EX].path = this[META].replace(/\0.*/, "");
          break;
        case "NextFileHasLongLinkpath":
          this[EX] = this[EX] || Object.create(null);
          this[EX].linkpath = this[META].replace(/\0.*/, "");
          break;
        default:
          throw new Error("unknown meta: " + entry.type);
      }
    }
    abort(error) {
      this[ABORTED] = true;
      this.emit("abort", error);
      this.warn("TAR_ABORT", error, {recoverable: false});
    }
    write(chunk) {
      if (this[ABORTED])
        return;
      if (this[UNZIP] === null && chunk) {
        if (this[BUFFER]) {
          chunk = Buffer.concat([this[BUFFER], chunk]);
          this[BUFFER] = null;
        }
        if (chunk.length < gzipHeader.length) {
          this[BUFFER] = chunk;
          return true;
        }
        for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
          if (chunk[i] !== gzipHeader[i])
            this[UNZIP] = false;
        }
        if (this[UNZIP] === null) {
          const ended = this[ENDED];
          this[ENDED] = false;
          this[UNZIP] = new zlib3.Unzip();
          this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
          this[UNZIP].on("error", (er) => this.abort(er));
          this[UNZIP].on("end", (_) => {
            this[ENDED] = true;
            this[CONSUMECHUNK]();
          });
          this[WRITING] = true;
          const ret3 = this[UNZIP][ended ? "end" : "write"](chunk);
          this[WRITING] = false;
          return ret3;
        }
      }
      this[WRITING] = true;
      if (this[UNZIP])
        this[UNZIP].write(chunk);
      else
        this[CONSUMECHUNK](chunk);
      this[WRITING] = false;
      const ret2 = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
      if (!ret2 && !this[QUEUE].length)
        this[READENTRY].once("drain", (_) => this.emit("drain"));
      return ret2;
    }
    [BUFFERCONCAT](c) {
      if (c && !this[ABORTED])
        this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
    }
    [MAYBEEND]() {
      if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
        this[EMITTEDEND] = true;
        const entry = this[WRITEENTRY];
        if (entry && entry.blockRemain) {
          const have = this[BUFFER] ? this[BUFFER].length : 0;
          this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, {entry});
          if (this[BUFFER])
            entry.write(this[BUFFER]);
          entry.end();
        }
        this[EMIT](DONE);
      }
    }
    [CONSUMECHUNK](chunk) {
      if (this[CONSUMING])
        this[BUFFERCONCAT](chunk);
      else if (!chunk && !this[BUFFER])
        this[MAYBEEND]();
      else {
        this[CONSUMING] = true;
        if (this[BUFFER]) {
          this[BUFFERCONCAT](chunk);
          const c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](c);
        } else {
          this[CONSUMECHUNKSUB](chunk);
        }
        while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
          const c = this[BUFFER];
          this[BUFFER] = null;
          this[CONSUMECHUNKSUB](c);
        }
        this[CONSUMING] = false;
      }
      if (!this[BUFFER] || this[ENDED])
        this[MAYBEEND]();
    }
    [CONSUMECHUNKSUB](chunk) {
      let position15 = 0;
      let length = chunk.length;
      while (position15 + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
        switch (this[STATE]) {
          case "begin":
          case "header":
            this[CONSUMEHEADER](chunk, position15);
            position15 += 512;
            break;
          case "ignore":
          case "body":
            position15 += this[CONSUMEBODY](chunk, position15);
            break;
          case "meta":
            position15 += this[CONSUMEMETA](chunk, position15);
            break;
          default:
            throw new Error("invalid state: " + this[STATE]);
        }
      }
      if (position15 < length) {
        if (this[BUFFER])
          this[BUFFER] = Buffer.concat([chunk.slice(position15), this[BUFFER]]);
        else
          this[BUFFER] = chunk.slice(position15);
      }
    }
    end(chunk) {
      if (!this[ABORTED]) {
        if (this[UNZIP])
          this[UNZIP].end(chunk);
        else {
          this[ENDED] = true;
          this.write(chunk);
        }
      }
    }
  });
});

// node_modules/tar/lib/list.js
var require_list = __commonJS((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Parser = require_parse2();
  var fs55 = require("fs");
  var fsm = require_fs_minipass();
  var path66 = require("path");
  var t = module2.exports = (opt_, files, cb) => {
    if (typeof opt_ === "function")
      cb = opt_, files = null, opt_ = {};
    else if (Array.isArray(opt_))
      files = opt_, opt_ = {};
    if (typeof files === "function")
      cb = files, files = null;
    if (!files)
      files = [];
    else
      files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb === "function")
      throw new TypeError("callback only supported with file option");
    if (files.length)
      filesFilter(opt, files);
    if (!opt.noResume)
      onentryFunction(opt);
    return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list2(opt);
  };
  var onentryFunction = (opt) => {
    const onentry = opt.onentry;
    opt.onentry = onentry ? (e) => {
      onentry(e);
      e.resume();
    } : (e) => e.resume();
  };
  var filesFilter = (opt, files) => {
    const map = new Map(files.map((f) => [f.replace(/\/+$/, ""), true]));
    const filter = opt.filter;
    const mapHas = (file, r) => {
      const root = r || path66.parse(file).root || ".";
      const ret2 = file === root ? false : map.has(file) ? map.get(file) : mapHas(path66.dirname(file), root);
      map.set(file, ret2);
      return ret2;
    };
    opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, "")) : (file) => mapHas(file.replace(/\/+$/, ""));
  };
  var listFileSync = (opt) => {
    const p = list2(opt);
    const file = opt.file;
    let threw = true;
    let fd;
    try {
      const stat = fs55.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      if (stat.size < readSize) {
        p.end(fs55.readFileSync(file));
      } else {
        let pos = 0;
        const buf = Buffer.allocUnsafe(readSize);
        fd = fs55.openSync(file, "r");
        while (pos < stat.size) {
          let bytesRead = fs55.readSync(fd, buf, 0, readSize, pos);
          pos += bytesRead;
          p.write(buf.slice(0, bytesRead));
        }
        p.end();
      }
      threw = false;
    } finally {
      if (threw && fd)
        try {
          fs55.closeSync(fd);
        } catch (er) {
        }
    }
  };
  var listFile = (opt, cb) => {
    const parse4 = new Parser(opt);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const file = opt.file;
    const p = new Promise((resolve3, reject) => {
      parse4.on("error", reject);
      parse4.on("end", resolve3);
      fs55.stat(file, (er, stat) => {
        if (er)
          reject(er);
        else {
          const stream = new fsm.ReadStream(file, {
            readSize,
            size: stat.size
          });
          stream.on("error", reject);
          stream.pipe(parse4);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  };
  var list2 = (opt) => new Parser(opt);
});

// node_modules/tar/lib/create.js
var require_create = __commonJS((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Pack = require_pack();
  var fs55 = require("fs");
  var fsm = require_fs_minipass();
  var t = require_list();
  var path66 = require("path");
  var c = module2.exports = (opt_, files, cb) => {
    if (typeof files === "function")
      cb = files;
    if (Array.isArray(opt_))
      files = opt_, opt_ = {};
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb === "function")
      throw new TypeError("callback only supported with file option");
    return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
  };
  var createFileSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    const stream = new fsm.WriteStreamSync(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream);
    addFilesSync(p, files);
  };
  var createFile = (opt, files, cb) => {
    const p = new Pack(opt);
    const stream = new fsm.WriteStream(opt.file, {
      mode: opt.mode || 438
    });
    p.pipe(stream);
    const promise = new Promise((res, rej) => {
      stream.on("error", rej);
      stream.on("close", res);
      p.on("error", rej);
    });
    addFilesAsync(p, files);
    return cb ? promise.then(cb, cb) : promise;
  };
  var addFilesSync = (p, files) => {
    files.forEach((file) => {
      if (file.charAt(0) === "@")
        t({
          file: path66.resolve(p.cwd, file.substr(1)),
          sync: true,
          noResume: true,
          onentry: (entry) => p.add(entry)
        });
      else
        p.add(file);
    });
    p.end();
  };
  var addFilesAsync = (p, files) => {
    while (files.length) {
      const file = files.shift();
      if (file.charAt(0) === "@")
        return t({
          file: path66.resolve(p.cwd, file.substr(1)),
          noResume: true,
          onentry: (entry) => p.add(entry)
        }).then((_) => addFilesAsync(p, files));
      else
        p.add(file);
    }
    p.end();
  };
  var createSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    addFilesSync(p, files);
    return p;
  };
  var create = (opt, files) => {
    const p = new Pack(opt);
    addFilesAsync(p, files);
    return p;
  };
});

// node_modules/tar/lib/replace.js
var require_replace = __commonJS((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Pack = require_pack();
  var Parse = require_parse2();
  var fs55 = require("fs");
  var fsm = require_fs_minipass();
  var t = require_list();
  var path66 = require("path");
  var Header = require_header();
  var r = module2.exports = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file)
      throw new TypeError("file is required");
    if (opt.gzip)
      throw new TypeError("cannot append to compressed archives");
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    files = Array.from(files);
    return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
  };
  var replaceSync = (opt, files) => {
    const p = new Pack.Sync(opt);
    let threw = true;
    let fd;
    let position15;
    try {
      try {
        fd = fs55.openSync(opt.file, "r+");
      } catch (er) {
        if (er.code === "ENOENT")
          fd = fs55.openSync(opt.file, "w+");
        else
          throw er;
      }
      const st = fs55.fstatSync(fd);
      const headBuf = Buffer.alloc(512);
      POSITION:
        for (position15 = 0; position15 < st.size; position15 += 512) {
          for (let bufPos = 0, bytes3 = 0; bufPos < 512; bufPos += bytes3) {
            bytes3 = fs55.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position15 + bufPos);
            if (position15 === 0 && headBuf[0] === 31 && headBuf[1] === 139)
              throw new Error("cannot append to compressed archives");
            if (!bytes3)
              break POSITION;
          }
          let h = new Header(headBuf);
          if (!h.cksumValid)
            break;
          let entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position15 + entryBlockSize + 512 > st.size)
            break;
          position15 += entryBlockSize;
          if (opt.mtimeCache)
            opt.mtimeCache.set(h.path, h.mtime);
        }
      threw = false;
      streamSync(opt, p, position15, fd, files);
    } finally {
      if (threw)
        try {
          fs55.closeSync(fd);
        } catch (er) {
        }
    }
  };
  var streamSync = (opt, p, position15, fd, files) => {
    const stream = new fsm.WriteStreamSync(opt.file, {
      fd,
      start: position15
    });
    p.pipe(stream);
    addFilesSync(p, files);
  };
  var replace = (opt, files, cb) => {
    files = Array.from(files);
    const p = new Pack(opt);
    const getPos = (fd, size, cb_) => {
      const cb2 = (er, pos) => {
        if (er)
          fs55.close(fd, (_) => cb_(er));
        else
          cb_(null, pos);
      };
      let position15 = 0;
      if (size === 0)
        return cb2(null, 0);
      let bufPos = 0;
      const headBuf = Buffer.alloc(512);
      const onread = (er, bytes3) => {
        if (er)
          return cb2(er);
        bufPos += bytes3;
        if (bufPos < 512 && bytes3)
          return fs55.read(fd, headBuf, bufPos, headBuf.length - bufPos, position15 + bufPos, onread);
        if (position15 === 0 && headBuf[0] === 31 && headBuf[1] === 139)
          return cb2(new Error("cannot append to compressed archives"));
        if (bufPos < 512)
          return cb2(null, position15);
        const h = new Header(headBuf);
        if (!h.cksumValid)
          return cb2(null, position15);
        const entryBlockSize = 512 * Math.ceil(h.size / 512);
        if (position15 + entryBlockSize + 512 > size)
          return cb2(null, position15);
        position15 += entryBlockSize + 512;
        if (position15 >= size)
          return cb2(null, position15);
        if (opt.mtimeCache)
          opt.mtimeCache.set(h.path, h.mtime);
        bufPos = 0;
        fs55.read(fd, headBuf, 0, 512, position15, onread);
      };
      fs55.read(fd, headBuf, 0, 512, position15, onread);
    };
    const promise = new Promise((resolve3, reject) => {
      p.on("error", reject);
      let flag = "r+";
      const onopen = (er, fd) => {
        if (er && er.code === "ENOENT" && flag === "r+") {
          flag = "w+";
          return fs55.open(opt.file, flag, onopen);
        }
        if (er)
          return reject(er);
        fs55.fstat(fd, (er2, st) => {
          if (er2)
            return reject(er2);
          getPos(fd, st.size, (er3, position15) => {
            if (er3)
              return reject(er3);
            const stream = new fsm.WriteStream(opt.file, {
              fd,
              start: position15
            });
            p.pipe(stream);
            stream.on("error", reject);
            stream.on("close", resolve3);
            addFilesAsync(p, files);
          });
        });
      };
      fs55.open(opt.file, flag, onopen);
    });
    return cb ? promise.then(cb, cb) : promise;
  };
  var addFilesSync = (p, files) => {
    files.forEach((file) => {
      if (file.charAt(0) === "@")
        t({
          file: path66.resolve(p.cwd, file.substr(1)),
          sync: true,
          noResume: true,
          onentry: (entry) => p.add(entry)
        });
      else
        p.add(file);
    });
    p.end();
  };
  var addFilesAsync = (p, files) => {
    while (files.length) {
      const file = files.shift();
      if (file.charAt(0) === "@")
        return t({
          file: path66.resolve(p.cwd, file.substr(1)),
          noResume: true,
          onentry: (entry) => p.add(entry)
        }).then((_) => addFilesAsync(p, files));
      else
        p.add(file);
    }
    p.end();
  };
});

// node_modules/tar/lib/update.js
var require_update = __commonJS((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var r = require_replace();
  var u = module2.exports = (opt_, files, cb) => {
    const opt = hlo(opt_);
    if (!opt.file)
      throw new TypeError("file is required");
    if (opt.gzip)
      throw new TypeError("cannot append to compressed archives");
    if (!files || !Array.isArray(files) || !files.length)
      throw new TypeError("no files or directories specified");
    files = Array.from(files);
    mtimeFilter(opt);
    return r(opt, files, cb);
  };
  var mtimeFilter = (opt) => {
    const filter = opt.filter;
    if (!opt.mtimeCache)
      opt.mtimeCache = new Map();
    opt.filter = filter ? (path66, stat) => filter(path66, stat) && !(opt.mtimeCache.get(path66) > stat.mtime) : (path66, stat) => !(opt.mtimeCache.get(path66) > stat.mtime);
  };
});

// node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS((exports2, module2) => {
  var {promisify} = require("util");
  var fs55 = require("fs");
  var optsArg = (opts) => {
    if (!opts)
      opts = {mode: 511, fs: fs55};
    else if (typeof opts === "object")
      opts = {mode: 511, fs: fs55, ...opts};
    else if (typeof opts === "number")
      opts = {mode: opts, fs: fs55};
    else if (typeof opts === "string")
      opts = {mode: parseInt(opts, 8), fs: fs55};
    else
      throw new TypeError("invalid options argument");
    opts.mkdir = opts.mkdir || opts.fs.mkdir || fs55.mkdir;
    opts.mkdirAsync = promisify(opts.mkdir);
    opts.stat = opts.stat || opts.fs.stat || fs55.stat;
    opts.statAsync = promisify(opts.stat);
    opts.statSync = opts.statSync || opts.fs.statSync || fs55.statSync;
    opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs55.mkdirSync;
    return opts;
  };
  module2.exports = optsArg;
});

// node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS((exports2, module2) => {
  var platform3 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
  var {resolve: resolve3, parse: parse4} = require("path");
  var pathArg = (path66) => {
    if (/\0/.test(path66)) {
      throw Object.assign(new TypeError("path must be a string without null bytes"), {
        path: path66,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path66 = resolve3(path66);
    if (platform3 === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const {root} = parse4(path66);
      if (badWinChars.test(path66.substr(root.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path66,
          code: "EINVAL"
        });
      }
    }
    return path66;
  };
  module2.exports = pathArg;
});

// node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS((exports2, module2) => {
  var {dirname: dirname4} = require("path");
  var findMade = (opts, parent, path66 = void 0) => {
    if (path66 === parent)
      return Promise.resolve();
    return opts.statAsync(parent).then((st) => st.isDirectory() ? path66 : void 0, (er) => er.code === "ENOENT" ? findMade(opts, dirname4(parent), parent) : void 0);
  };
  var findMadeSync = (opts, parent, path66 = void 0) => {
    if (path66 === parent)
      return void 0;
    try {
      return opts.statSync(parent).isDirectory() ? path66 : void 0;
    } catch (er) {
      return er.code === "ENOENT" ? findMadeSync(opts, dirname4(parent), parent) : void 0;
    }
  };
  module2.exports = {findMade, findMadeSync};
});

// node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS((exports2, module2) => {
  var {dirname: dirname4} = require("path");
  var mkdirpManual = (path66, opts, made) => {
    opts.recursive = false;
    const parent = dirname4(path66);
    if (parent === path66) {
      return opts.mkdirAsync(path66, opts).catch((er) => {
        if (er.code !== "EISDIR")
          throw er;
      });
    }
    return opts.mkdirAsync(path66, opts).then(() => made || path66, (er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path66, opts, made2));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      return opts.statAsync(path66).then((st) => {
        if (st.isDirectory())
          return made;
        else
          throw er;
      }, () => {
        throw er;
      });
    });
  };
  var mkdirpManualSync = (path66, opts, made) => {
    const parent = dirname4(path66);
    opts.recursive = false;
    if (parent === path66) {
      try {
        return opts.mkdirSync(path66, opts);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        else
          return;
      }
    }
    try {
      opts.mkdirSync(path66, opts);
      return made || path66;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path66, opts, mkdirpManualSync(parent, opts, made));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      try {
        if (!opts.statSync(path66).isDirectory())
          throw er;
      } catch (_) {
        throw er;
      }
    }
  };
  module2.exports = {mkdirpManual, mkdirpManualSync};
});

// node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS((exports2, module2) => {
  var {dirname: dirname4} = require("path");
  var {findMade, findMadeSync} = require_find_made();
  var {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
  var mkdirpNative = (path66, opts) => {
    opts.recursive = true;
    const parent = dirname4(path66);
    if (parent === path66)
      return opts.mkdirAsync(path66, opts);
    return findMade(opts, path66).then((made) => opts.mkdirAsync(path66, opts).then(() => made).catch((er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(path66, opts);
      else
        throw er;
    }));
  };
  var mkdirpNativeSync = (path66, opts) => {
    opts.recursive = true;
    const parent = dirname4(path66);
    if (parent === path66)
      return opts.mkdirSync(path66, opts);
    const made = findMadeSync(opts, path66);
    try {
      opts.mkdirSync(path66, opts);
      return made;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path66, opts);
      else
        throw er;
    }
  };
  module2.exports = {mkdirpNative, mkdirpNativeSync};
});

// node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS((exports2, module2) => {
  var fs55 = require("fs");
  var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
  var versArr = version2.replace(/^v/, "").split(".");
  var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
  var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs55.mkdir;
  var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs55.mkdirSync;
  module2.exports = {useNative, useNativeSync};
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS((exports2, module2) => {
  var optsArg = require_opts_arg();
  var pathArg = require_path_arg();
  var {mkdirpNative, mkdirpNativeSync} = require_mkdirp_native();
  var {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
  var {useNative, useNativeSync} = require_use_native();
  var mkdirp = (path66, opts) => {
    path66 = pathArg(path66);
    opts = optsArg(opts);
    return useNative(opts) ? mkdirpNative(path66, opts) : mkdirpManual(path66, opts);
  };
  var mkdirpSync = (path66, opts) => {
    path66 = pathArg(path66);
    opts = optsArg(opts);
    return useNativeSync(opts) ? mkdirpNativeSync(path66, opts) : mkdirpManualSync(path66, opts);
  };
  mkdirp.sync = mkdirpSync;
  mkdirp.native = (path66, opts) => mkdirpNative(pathArg(path66), optsArg(opts));
  mkdirp.manual = (path66, opts) => mkdirpManual(pathArg(path66), optsArg(opts));
  mkdirp.nativeSync = (path66, opts) => mkdirpNativeSync(pathArg(path66), optsArg(opts));
  mkdirp.manualSync = (path66, opts) => mkdirpManualSync(pathArg(path66), optsArg(opts));
  module2.exports = mkdirp;
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require("fs");
  var path66 = require("path");
  var LCHOWN = fs55.lchown ? "lchown" : "chown";
  var LCHOWNSYNC = fs55.lchownSync ? "lchownSync" : "chownSync";
  var needEISDIRHandled = fs55.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
  var lchownSync = (path67, uid, gid) => {
    try {
      return fs55[LCHOWNSYNC](path67, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  };
  var chownSync = (path67, uid, gid) => {
    try {
      return fs55.chownSync(path67, uid, gid);
    } catch (er) {
      if (er.code !== "ENOENT")
        throw er;
    }
  };
  var handleEISDIR = needEISDIRHandled ? (path67, uid, gid, cb) => (er) => {
    if (!er || er.code !== "EISDIR")
      cb(er);
    else
      fs55.chown(path67, uid, gid, cb);
  } : (_, __, ___, cb) => cb;
  var handleEISDirSync = needEISDIRHandled ? (path67, uid, gid) => {
    try {
      return lchownSync(path67, uid, gid);
    } catch (er) {
      if (er.code !== "EISDIR")
        throw er;
      chownSync(path67, uid, gid);
    }
  } : (path67, uid, gid) => lchownSync(path67, uid, gid);
  var nodeVersion = process.version;
  var readdir = (path67, options, cb) => fs55.readdir(path67, options, cb);
  var readdirSync = (path67, options) => fs55.readdirSync(path67, options);
  if (/^v4\./.test(nodeVersion))
    readdir = (path67, options, cb) => fs55.readdir(path67, cb);
  var chown = (cpath, uid, gid, cb) => {
    fs55[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
      cb(er && er.code !== "ENOENT" ? er : null);
    }));
  };
  var chownrKid = (p, child, uid, gid, cb) => {
    if (typeof child === "string")
      return fs55.lstat(path66.resolve(p, child), (er, stats) => {
        if (er)
          return cb(er.code !== "ENOENT" ? er : null);
        stats.name = child;
        chownrKid(p, stats, uid, gid, cb);
      });
    if (child.isDirectory()) {
      chownr(path66.resolve(p, child.name), uid, gid, (er) => {
        if (er)
          return cb(er);
        const cpath = path66.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      });
    } else {
      const cpath = path66.resolve(p, child.name);
      chown(cpath, uid, gid, cb);
    }
  };
  var chownr = (p, uid, gid, cb) => {
    readdir(p, {withFileTypes: true}, (er, children) => {
      if (er) {
        if (er.code === "ENOENT")
          return cb();
        else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
          return cb(er);
      }
      if (er || !children.length)
        return chown(p, uid, gid, cb);
      let len = children.length;
      let errState = null;
      const then = (er2) => {
        if (errState)
          return;
        if (er2)
          return cb(errState = er2);
        if (--len === 0)
          return chown(p, uid, gid, cb);
      };
      children.forEach((child) => chownrKid(p, child, uid, gid, then));
    });
  };
  var chownrKidSync = (p, child, uid, gid) => {
    if (typeof child === "string") {
      try {
        const stats = fs55.lstatSync(path66.resolve(p, child));
        stats.name = child;
        child = stats;
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else
          throw er;
      }
    }
    if (child.isDirectory())
      chownrSync(path66.resolve(p, child.name), uid, gid);
    handleEISDirSync(path66.resolve(p, child.name), uid, gid);
  };
  var chownrSync = (p, uid, gid) => {
    let children;
    try {
      children = readdirSync(p, {withFileTypes: true});
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
        return handleEISDirSync(p, uid, gid);
      else
        throw er;
    }
    if (children && children.length)
      children.forEach((child) => chownrKidSync(p, child, uid, gid));
    return handleEISDirSync(p, uid, gid);
  };
  module2.exports = chownr;
  chownr.sync = chownrSync;
});

// node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS((exports2, module2) => {
  "use strict";
  var mkdirp = require_mkdirp();
  var fs55 = require("fs");
  var path66 = require("path");
  var chownr = require_chownr();
  var SymlinkError = class extends Error {
    constructor(symlink, path67) {
      super("Cannot extract through symbolic link");
      this.path = path67;
      this.symlink = symlink;
    }
    get name() {
      return "SylinkError";
    }
  };
  var CwdError = class extends Error {
    constructor(path67, code) {
      super(code + ": Cannot cd into '" + path67 + "'");
      this.path = path67;
      this.code = code;
    }
    get name() {
      return "CwdError";
    }
  };
  var mkdir = module2.exports = (dir, opt, cb) => {
    const umask = opt.umask;
    const mode = opt.mode | 448;
    const needChmod = (mode & umask) !== 0;
    const uid = opt.uid;
    const gid = opt.gid;
    const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
    const preserve = opt.preserve;
    const unlink = opt.unlink;
    const cache = opt.cache;
    const cwd = opt.cwd;
    const done = (er, created) => {
      if (er)
        cb(er);
      else {
        cache.set(dir, true);
        if (created && doChown)
          chownr(created, uid, gid, (er2) => done(er2));
        else if (needChmod)
          fs55.chmod(dir, mode, cb);
        else
          cb();
      }
    };
    if (cache && cache.get(dir) === true)
      return done();
    if (dir === cwd)
      return fs55.stat(dir, (er, st) => {
        if (er || !st.isDirectory())
          er = new CwdError(dir, er && er.code || "ENOTDIR");
        done(er);
      });
    if (preserve)
      return mkdirp(dir, {mode}).then((made) => done(null, made), done);
    const sub = path66.relative(cwd, dir);
    const parts = sub.split(/\/|\\/);
    mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);
  };
  var mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
    if (!parts.length)
      return cb(null, created);
    const p = parts.shift();
    const part = base + "/" + p;
    if (cache.get(part))
      return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
    fs55.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
  };
  var onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {
    if (er) {
      if (er.path && path66.dirname(er.path) === cwd && (er.code === "ENOTDIR" || er.code === "ENOENT"))
        return cb(new CwdError(cwd, er.code));
      fs55.lstat(part, (statEr, st) => {
        if (statEr)
          cb(statEr);
        else if (st.isDirectory())
          mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
        else if (unlink)
          fs55.unlink(part, (er2) => {
            if (er2)
              return cb(er2);
            fs55.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
          });
        else if (st.isSymbolicLink())
          return cb(new SymlinkError(part, part + "/" + parts.join("/")));
        else
          cb(er);
      });
    } else {
      created = created || part;
      mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
    }
  };
  var mkdirSync = module2.exports.sync = (dir, opt) => {
    const umask = opt.umask;
    const mode = opt.mode | 448;
    const needChmod = (mode & umask) !== 0;
    const uid = opt.uid;
    const gid = opt.gid;
    const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
    const preserve = opt.preserve;
    const unlink = opt.unlink;
    const cache = opt.cache;
    const cwd = opt.cwd;
    const done = (created2) => {
      cache.set(dir, true);
      if (created2 && doChown)
        chownr.sync(created2, uid, gid);
      if (needChmod)
        fs55.chmodSync(dir, mode);
    };
    if (cache && cache.get(dir) === true)
      return done();
    if (dir === cwd) {
      let ok = false;
      let code = "ENOTDIR";
      try {
        ok = fs55.statSync(dir).isDirectory();
      } catch (er) {
        code = er.code;
      } finally {
        if (!ok)
          throw new CwdError(dir, code);
      }
      done();
      return;
    }
    if (preserve)
      return done(mkdirp.sync(dir, mode));
    const sub = path66.relative(cwd, dir);
    const parts = sub.split(/\/|\\/);
    let created = null;
    for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift()) {
      if (cache.get(part))
        continue;
      try {
        fs55.mkdirSync(part, mode);
        created = created || part;
        cache.set(part, true);
      } catch (er) {
        if (er.path && path66.dirname(er.path) === cwd && (er.code === "ENOTDIR" || er.code === "ENOENT"))
          return new CwdError(cwd, er.code);
        const st = fs55.lstatSync(part);
        if (st.isDirectory()) {
          cache.set(part, true);
          continue;
        } else if (unlink) {
          fs55.unlinkSync(part);
          fs55.mkdirSync(part, mode);
          created = created || part;
          cache.set(part, true);
          continue;
        } else if (st.isSymbolicLink())
          return new SymlinkError(part, part + "/" + parts.join("/"));
      }
    }
    return done(created);
  };
});

// node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS((exports2, module2) => {
  var assert = require("assert");
  module2.exports = () => {
    const queues = new Map();
    const reservations = new Map();
    const {join: join2} = require("path");
    const getDirs = (path66) => join2(path66).split(/[\\\/]/).slice(0, -1).reduce((set, path67) => set.length ? set.concat(join2(set[set.length - 1], path67)) : [path67], []);
    const running = new Set();
    const getQueues = (fn) => {
      const res = reservations.get(fn);
      if (!res)
        throw new Error("function does not have any path reservations");
      return {
        paths: res.paths.map((path66) => queues.get(path66)),
        dirs: [...res.dirs].map((path66) => queues.get(path66))
      };
    };
    const check = (fn) => {
      const {paths, dirs} = getQueues(fn);
      return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
    };
    const run = (fn) => {
      if (running.has(fn) || !check(fn))
        return false;
      running.add(fn);
      fn(() => clear(fn));
      return true;
    };
    const clear = (fn) => {
      if (!running.has(fn))
        return false;
      const {paths, dirs} = reservations.get(fn);
      const next = new Set();
      paths.forEach((path66) => {
        const q = queues.get(path66);
        assert.equal(q[0], fn);
        if (q.length === 1)
          queues.delete(path66);
        else {
          q.shift();
          if (typeof q[0] === "function")
            next.add(q[0]);
          else
            q[0].forEach((fn2) => next.add(fn2));
        }
      });
      dirs.forEach((dir) => {
        const q = queues.get(dir);
        assert(q[0] instanceof Set);
        if (q[0].size === 1 && q.length === 1) {
          queues.delete(dir);
        } else if (q[0].size === 1) {
          q.shift();
          next.add(q[0]);
        } else
          q[0].delete(fn);
      });
      running.delete(fn);
      next.forEach((fn2) => run(fn2));
      return true;
    };
    const reserve = (paths, fn) => {
      const dirs = new Set(paths.map((path66) => getDirs(path66)).reduce((a, b) => a.concat(b)));
      reservations.set(fn, {dirs, paths});
      paths.forEach((path66) => {
        const q = queues.get(path66);
        if (!q)
          queues.set(path66, [fn]);
        else
          q.push(fn);
      });
      dirs.forEach((dir) => {
        const q = queues.get(dir);
        if (!q)
          queues.set(dir, [new Set([fn])]);
        else if (q[q.length - 1] instanceof Set)
          q[q.length - 1].add(fn);
        else
          q.push(new Set([fn]));
      });
      return run(fn);
    };
    return {check, reserve};
  };
});

// node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS((exports2, module2) => {
  var platform3 = process.env.__FAKE_PLATFORM__ || process.platform;
  var isWindows4 = platform3 === "win32";
  var fs55 = global.__FAKE_TESTING_FS__ || require("fs");
  var {O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0} = fs55.constants;
  var fMapEnabled = isWindows4 && !!UV_FS_O_FILEMAP;
  var fMapLimit = 512 * 1024;
  var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
  module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
});

// node_modules/tar/lib/unpack.js
var require_unpack = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var EE = require("events").EventEmitter;
  var Parser = require_parse2();
  var fs55 = require("fs");
  var fsm = require_fs_minipass();
  var path66 = require("path");
  var mkdir = require_mkdir();
  var mkdirSync = mkdir.sync;
  var wc = require_winchars();
  var pathReservations = require_path_reservations();
  var ONENTRY = Symbol("onEntry");
  var CHECKFS = Symbol("checkFs");
  var CHECKFS2 = Symbol("checkFs2");
  var ISREUSABLE = Symbol("isReusable");
  var MAKEFS = Symbol("makeFs");
  var FILE = Symbol("file");
  var DIRECTORY = Symbol("directory");
  var LINK = Symbol("link");
  var SYMLINK = Symbol("symlink");
  var HARDLINK = Symbol("hardlink");
  var UNSUPPORTED = Symbol("unsupported");
  var UNKNOWN = Symbol("unknown");
  var CHECKPATH = Symbol("checkPath");
  var MKDIR = Symbol("mkdir");
  var ONERROR = Symbol("onError");
  var PENDING = Symbol("pending");
  var PEND = Symbol("pend");
  var UNPEND = Symbol("unpend");
  var ENDED = Symbol("ended");
  var MAYBECLOSE = Symbol("maybeClose");
  var SKIP = Symbol("skip");
  var DOCHOWN = Symbol("doChown");
  var UID = Symbol("uid");
  var GID = Symbol("gid");
  var crypto3 = require("crypto");
  var getFlag = require_get_write_flag();
  var neverCalled = () => {
    throw new Error("sync function called cb somehow?!?");
  };
  var unlinkFile = (path67, cb) => {
    if (process.platform !== "win32")
      return fs55.unlink(path67, cb);
    const name2 = path67 + ".DELETE." + crypto3.randomBytes(16).toString("hex");
    fs55.rename(path67, name2, (er) => {
      if (er)
        return cb(er);
      fs55.unlink(name2, cb);
    });
  };
  var unlinkFileSync = (path67) => {
    if (process.platform !== "win32")
      return fs55.unlinkSync(path67);
    const name2 = path67 + ".DELETE." + crypto3.randomBytes(16).toString("hex");
    fs55.renameSync(path67, name2);
    fs55.unlinkSync(name2);
  };
  var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
  var Unpack = class extends Parser {
    constructor(opt) {
      if (!opt)
        opt = {};
      opt.ondone = (_) => {
        this[ENDED] = true;
        this[MAYBECLOSE]();
      };
      super(opt);
      this.reservations = pathReservations();
      this.transform = typeof opt.transform === "function" ? opt.transform : null;
      this.writable = true;
      this.readable = false;
      this[PENDING] = 0;
      this[ENDED] = false;
      this.dirCache = opt.dirCache || new Map();
      if (typeof opt.uid === "number" || typeof opt.gid === "number") {
        if (typeof opt.uid !== "number" || typeof opt.gid !== "number")
          throw new TypeError("cannot set owner without number uid and gid");
        if (opt.preserveOwner)
          throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
        this.uid = opt.uid;
        this.gid = opt.gid;
        this.setOwner = true;
      } else {
        this.uid = null;
        this.gid = null;
        this.setOwner = false;
      }
      if (opt.preserveOwner === void 0 && typeof opt.uid !== "number")
        this.preserveOwner = process.getuid && process.getuid() === 0;
      else
        this.preserveOwner = !!opt.preserveOwner;
      this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
      this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
      this.forceChown = opt.forceChown === true;
      this.win32 = !!opt.win32 || process.platform === "win32";
      this.newer = !!opt.newer;
      this.keep = !!opt.keep;
      this.noMtime = !!opt.noMtime;
      this.preservePaths = !!opt.preservePaths;
      this.unlink = !!opt.unlink;
      this.cwd = path66.resolve(opt.cwd || process.cwd());
      this.strip = +opt.strip || 0;
      this.processUmask = process.umask();
      this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
      this.dmode = opt.dmode || 511 & ~this.umask;
      this.fmode = opt.fmode || 438 & ~this.umask;
      this.on("entry", (entry) => this[ONENTRY](entry));
    }
    warn(code, msg, data = {}) {
      if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT")
        data.recoverable = false;
      return super.warn(code, msg, data);
    }
    [MAYBECLOSE]() {
      if (this[ENDED] && this[PENDING] === 0) {
        this.emit("prefinish");
        this.emit("finish");
        this.emit("end");
        this.emit("close");
      }
    }
    [CHECKPATH](entry) {
      if (this.strip) {
        const parts = entry.path.split(/\/|\\/);
        if (parts.length < this.strip)
          return false;
        entry.path = parts.slice(this.strip).join("/");
        if (entry.type === "Link") {
          const linkparts = entry.linkpath.split(/\/|\\/);
          if (linkparts.length >= this.strip)
            entry.linkpath = linkparts.slice(this.strip).join("/");
        }
      }
      if (!this.preservePaths) {
        const p = entry.path;
        if (p.match(/(^|\/|\\)\.\.(\\|\/|$)/)) {
          this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
            entry,
            path: p
          });
          return false;
        }
        if (path66.win32.isAbsolute(p)) {
          const parsed = path66.win32.parse(p);
          entry.path = p.substr(parsed.root.length);
          const r = parsed.root;
          this.warn("TAR_ENTRY_INFO", `stripping ${r} from absolute path`, {
            entry,
            path: p
          });
        }
      }
      if (this.win32) {
        const parsed = path66.win32.parse(entry.path);
        entry.path = parsed.root === "" ? wc.encode(entry.path) : parsed.root + wc.encode(entry.path.substr(parsed.root.length));
      }
      if (path66.isAbsolute(entry.path))
        entry.absolute = entry.path;
      else
        entry.absolute = path66.resolve(this.cwd, entry.path);
      return true;
    }
    [ONENTRY](entry) {
      if (!this[CHECKPATH](entry))
        return entry.resume();
      assert.equal(typeof entry.absolute, "string");
      switch (entry.type) {
        case "Directory":
        case "GNUDumpDir":
          if (entry.mode)
            entry.mode = entry.mode | 448;
        case "File":
        case "OldFile":
        case "ContiguousFile":
        case "Link":
        case "SymbolicLink":
          return this[CHECKFS](entry);
        case "CharacterDevice":
        case "BlockDevice":
        case "FIFO":
          return this[UNSUPPORTED](entry);
      }
    }
    [ONERROR](er, entry) {
      if (er.name === "CwdError")
        this.emit("error", er);
      else {
        this.warn("TAR_ENTRY_ERROR", er, {entry});
        this[UNPEND]();
        entry.resume();
      }
    }
    [MKDIR](dir, mode, cb) {
      mkdir(dir, {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode
      }, cb);
    }
    [DOCHOWN](entry) {
      return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
    }
    [UID](entry) {
      return uint32(this.uid, entry.uid, this.processUid);
    }
    [GID](entry) {
      return uint32(this.gid, entry.gid, this.processGid);
    }
    [FILE](entry, fullyDone) {
      const mode = entry.mode & 4095 || this.fmode;
      const stream = new fsm.WriteStream(entry.absolute, {
        flags: getFlag(entry.size),
        mode,
        autoClose: false
      });
      stream.on("error", (er) => this[ONERROR](er, entry));
      let actions = 1;
      const done = (er) => {
        if (er)
          return this[ONERROR](er, entry);
        if (--actions === 0) {
          fs55.close(stream.fd, (er2) => {
            fullyDone();
            er2 ? this[ONERROR](er2, entry) : this[UNPEND]();
          });
        }
      };
      stream.on("finish", (_) => {
        const abs = entry.absolute;
        const fd = stream.fd;
        if (entry.mtime && !this.noMtime) {
          actions++;
          const atime = entry.atime || new Date();
          const mtime = entry.mtime;
          fs55.futimes(fd, atime, mtime, (er) => er ? fs55.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
        }
        if (this[DOCHOWN](entry)) {
          actions++;
          const uid = this[UID](entry);
          const gid = this[GID](entry);
          fs55.fchown(fd, uid, gid, (er) => er ? fs55.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
        }
        done();
      });
      const tx = this.transform ? this.transform(entry) || entry : entry;
      if (tx !== entry) {
        tx.on("error", (er) => this[ONERROR](er, entry));
        entry.pipe(tx);
      }
      tx.pipe(stream);
    }
    [DIRECTORY](entry, fullyDone) {
      const mode = entry.mode & 4095 || this.dmode;
      this[MKDIR](entry.absolute, mode, (er) => {
        if (er) {
          fullyDone();
          return this[ONERROR](er, entry);
        }
        let actions = 1;
        const done = (_) => {
          if (--actions === 0) {
            fullyDone();
            this[UNPEND]();
            entry.resume();
          }
        };
        if (entry.mtime && !this.noMtime) {
          actions++;
          fs55.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
        }
        if (this[DOCHOWN](entry)) {
          actions++;
          fs55.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
        }
        done();
      });
    }
    [UNSUPPORTED](entry) {
      entry.unsupported = true;
      this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, {entry});
      entry.resume();
    }
    [SYMLINK](entry, done) {
      this[LINK](entry, entry.linkpath, "symlink", done);
    }
    [HARDLINK](entry, done) {
      this[LINK](entry, path66.resolve(this.cwd, entry.linkpath), "link", done);
    }
    [PEND]() {
      this[PENDING]++;
    }
    [UNPEND]() {
      this[PENDING]--;
      this[MAYBECLOSE]();
    }
    [SKIP](entry) {
      this[UNPEND]();
      entry.resume();
    }
    [ISREUSABLE](entry, st) {
      return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && process.platform !== "win32";
    }
    [CHECKFS](entry) {
      this[PEND]();
      const paths = [entry.path];
      if (entry.linkpath)
        paths.push(entry.linkpath);
      this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
    }
    [CHECKFS2](entry, done) {
      this[MKDIR](path66.dirname(entry.absolute), this.dmode, (er) => {
        if (er) {
          done();
          return this[ONERROR](er, entry);
        }
        fs55.lstat(entry.absolute, (er2, st) => {
          if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
            this[SKIP](entry);
            done();
          } else if (er2 || this[ISREUSABLE](entry, st)) {
            this[MAKEFS](null, entry, done);
          } else if (st.isDirectory()) {
            if (entry.type === "Directory") {
              if (!entry.mode || (st.mode & 4095) === entry.mode)
                this[MAKEFS](null, entry, done);
              else
                fs55.chmod(entry.absolute, entry.mode, (er3) => this[MAKEFS](er3, entry, done));
            } else
              fs55.rmdir(entry.absolute, (er3) => this[MAKEFS](er3, entry, done));
          } else
            unlinkFile(entry.absolute, (er3) => this[MAKEFS](er3, entry, done));
        });
      });
    }
    [MAKEFS](er, entry, done) {
      if (er)
        return this[ONERROR](er, entry);
      switch (entry.type) {
        case "File":
        case "OldFile":
        case "ContiguousFile":
          return this[FILE](entry, done);
        case "Link":
          return this[HARDLINK](entry, done);
        case "SymbolicLink":
          return this[SYMLINK](entry, done);
        case "Directory":
        case "GNUDumpDir":
          return this[DIRECTORY](entry, done);
      }
    }
    [LINK](entry, linkpath, link, done) {
      fs55[link](linkpath, entry.absolute, (er) => {
        if (er)
          return this[ONERROR](er, entry);
        done();
        this[UNPEND]();
        entry.resume();
      });
    }
  };
  var UnpackSync = class extends Unpack {
    constructor(opt) {
      super(opt);
    }
    [CHECKFS](entry) {
      const er = this[MKDIR](path66.dirname(entry.absolute), this.dmode, neverCalled);
      if (er)
        return this[ONERROR](er, entry);
      try {
        const st = fs55.lstatSync(entry.absolute);
        if (this.keep || this.newer && st.mtime > entry.mtime)
          return this[SKIP](entry);
        else if (this[ISREUSABLE](entry, st))
          return this[MAKEFS](null, entry, neverCalled);
        else {
          try {
            if (st.isDirectory()) {
              if (entry.type === "Directory") {
                if (entry.mode && (st.mode & 4095) !== entry.mode)
                  fs55.chmodSync(entry.absolute, entry.mode);
              } else
                fs55.rmdirSync(entry.absolute);
            } else
              unlinkFileSync(entry.absolute);
            return this[MAKEFS](null, entry, neverCalled);
          } catch (er2) {
            return this[ONERROR](er2, entry);
          }
        }
      } catch (er2) {
        return this[MAKEFS](null, entry, neverCalled);
      }
    }
    [FILE](entry, _) {
      const mode = entry.mode & 4095 || this.fmode;
      const oner = (er) => {
        let closeError;
        try {
          fs55.closeSync(fd);
        } catch (e) {
          closeError = e;
        }
        if (er || closeError)
          this[ONERROR](er || closeError, entry);
      };
      let stream;
      let fd;
      try {
        fd = fs55.openSync(entry.absolute, getFlag(entry.size), mode);
      } catch (er) {
        return oner(er);
      }
      const tx = this.transform ? this.transform(entry) || entry : entry;
      if (tx !== entry) {
        tx.on("error", (er) => this[ONERROR](er, entry));
        entry.pipe(tx);
      }
      tx.on("data", (chunk) => {
        try {
          fs55.writeSync(fd, chunk, 0, chunk.length);
        } catch (er) {
          oner(er);
        }
      });
      tx.on("end", (_2) => {
        let er = null;
        if (entry.mtime && !this.noMtime) {
          const atime = entry.atime || new Date();
          const mtime = entry.mtime;
          try {
            fs55.futimesSync(fd, atime, mtime);
          } catch (futimeser) {
            try {
              fs55.utimesSync(entry.absolute, atime, mtime);
            } catch (utimeser) {
              er = futimeser;
            }
          }
        }
        if (this[DOCHOWN](entry)) {
          const uid = this[UID](entry);
          const gid = this[GID](entry);
          try {
            fs55.fchownSync(fd, uid, gid);
          } catch (fchowner) {
            try {
              fs55.chownSync(entry.absolute, uid, gid);
            } catch (chowner) {
              er = er || fchowner;
            }
          }
        }
        oner(er);
      });
    }
    [DIRECTORY](entry, _) {
      const mode = entry.mode & 4095 || this.dmode;
      const er = this[MKDIR](entry.absolute, mode);
      if (er)
        return this[ONERROR](er, entry);
      if (entry.mtime && !this.noMtime) {
        try {
          fs55.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
        } catch (er2) {
        }
      }
      if (this[DOCHOWN](entry)) {
        try {
          fs55.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
        } catch (er2) {
        }
      }
      entry.resume();
    }
    [MKDIR](dir, mode) {
      try {
        return mkdir.sync(dir, {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode
        });
      } catch (er) {
        return er;
      }
    }
    [LINK](entry, linkpath, link, _) {
      try {
        fs55[link + "Sync"](linkpath, entry.absolute);
        entry.resume();
      } catch (er) {
        return this[ONERROR](er, entry);
      }
    }
  };
  Unpack.Sync = UnpackSync;
  module2.exports = Unpack;
});

// node_modules/tar/lib/extract.js
var require_extract = __commonJS((exports2, module2) => {
  "use strict";
  var hlo = require_high_level_opt();
  var Unpack = require_unpack();
  var fs55 = require("fs");
  var fsm = require_fs_minipass();
  var path66 = require("path");
  var x = module2.exports = (opt_, files, cb) => {
    if (typeof opt_ === "function")
      cb = opt_, files = null, opt_ = {};
    else if (Array.isArray(opt_))
      files = opt_, opt_ = {};
    if (typeof files === "function")
      cb = files, files = null;
    if (!files)
      files = [];
    else
      files = Array.from(files);
    const opt = hlo(opt_);
    if (opt.sync && typeof cb === "function")
      throw new TypeError("callback not supported for sync tar functions");
    if (!opt.file && typeof cb === "function")
      throw new TypeError("callback only supported with file option");
    if (files.length)
      filesFilter(opt, files);
    return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
  };
  var filesFilter = (opt, files) => {
    const map = new Map(files.map((f) => [f.replace(/\/+$/, ""), true]));
    const filter = opt.filter;
    const mapHas = (file, r) => {
      const root = r || path66.parse(file).root || ".";
      const ret2 = file === root ? false : map.has(file) ? map.get(file) : mapHas(path66.dirname(file), root);
      map.set(file, ret2);
      return ret2;
    };
    opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, "")) : (file) => mapHas(file.replace(/\/+$/, ""));
  };
  var extractFileSync = (opt) => {
    const u = new Unpack.Sync(opt);
    const file = opt.file;
    let threw = true;
    let fd;
    const stat = fs55.statSync(file);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const stream = new fsm.ReadStreamSync(file, {
      readSize,
      size: stat.size
    });
    stream.pipe(u);
  };
  var extractFile = (opt, cb) => {
    const u = new Unpack(opt);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    const file = opt.file;
    const p = new Promise((resolve3, reject) => {
      u.on("error", reject);
      u.on("close", resolve3);
      fs55.stat(file, (er, stat) => {
        if (er)
          reject(er);
        else {
          const stream = new fsm.ReadStream(file, {
            readSize,
            size: stat.size
          });
          stream.on("error", reject);
          stream.pipe(u);
        }
      });
    });
    return cb ? p.then(cb, cb) : p;
  };
  var extractSync = (opt) => {
    return new Unpack.Sync(opt);
  };
  var extract = (opt) => {
    return new Unpack(opt);
  };
});

// node_modules/tar/index.js
var require_tar = __commonJS((exports2) => {
  "use strict";
  exports2.c = exports2.create = require_create();
  exports2.r = exports2.replace = require_replace();
  exports2.t = exports2.list = require_list();
  exports2.u = exports2.update = require_update();
  exports2.x = exports2.extract = require_extract();
  exports2.Pack = require_pack();
  exports2.Unpack = require_unpack();
  exports2.Parse = require_parse2();
  exports2.ReadEntry = require_read_entry();
  exports2.WriteEntry = require_write_entry();
  exports2.Header = require_header();
  exports2.Pax = require_pax();
  exports2.types = require_types2();
});

// node_modules/listenercount/index.js
var require_listenercount = __commonJS((exports2, module2) => {
  "use strict";
  var listenerCount = require("events").listenerCount;
  listenerCount = listenerCount || function(ee, event) {
    var listeners = ee && ee._events && ee._events[event];
    if (Array.isArray(listeners)) {
      return listeners.length;
    } else if (typeof listeners === "function") {
      return 1;
    } else {
      return 0;
    }
  };
  module2.exports = listenerCount;
});

// node_modules/buffer-indexof-polyfill/init-buffer.js
var require_init_buffer = __commonJS((exports2, module2) => {
  module2.exports = function initBuffer(val) {
    var nodeVersion = process && process.version ? process.version : "v5.0.0";
    var major = nodeVersion.split(".")[0].replace("v", "");
    return major < 6 ? new Buffer(val) : Buffer.from(val);
  };
});

// node_modules/buffer-indexof-polyfill/index.js
var require_buffer_indexof_polyfill = __commonJS(() => {
  "use strict";
  var initBuffer = require_init_buffer();
  if (!Buffer.prototype.indexOf) {
    Buffer.prototype.indexOf = function(value, offset) {
      offset = offset || 0;
      if (typeof value === "string" || value instanceof String) {
        value = initBuffer(value);
      } else if (typeof value === "number" || value instanceof Number) {
        value = initBuffer([value]);
      }
      var len = value.length;
      for (var i = offset; i <= this.length - len; i++) {
        var mismatch = false;
        for (var j = 0; j < len; j++) {
          if (this[i + j] != value[j]) {
            mismatch = true;
            break;
          }
        }
        if (!mismatch) {
          return i;
        }
      }
      return -1;
    };
  }
  function bufferLastIndexOf(value, offset) {
    if (typeof value === "string" || value instanceof String) {
      value = initBuffer(value);
    } else if (typeof value === "number" || value instanceof Number) {
      value = initBuffer([value]);
    }
    var len = value.length;
    offset = offset || this.length - len;
    for (var i = offset; i >= 0; i--) {
      var mismatch = false;
      for (var j = 0; j < len; j++) {
        if (this[i + j] != value[j]) {
          mismatch = true;
          break;
        }
      }
      if (!mismatch) {
        return i;
      }
    }
    return -1;
  }
  if (Buffer.prototype.lastIndexOf) {
    if (initBuffer("ABC").lastIndexOf("ABC") === -1)
      Buffer.prototype.lastIndexOf = bufferLastIndexOf;
  } else {
    Buffer.prototype.lastIndexOf = bufferLastIndexOf;
  }
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS((exports2) => {
  (function(global2, undefined2) {
    "use strict";
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i + 1];
      }
      var task2 = {callback, args};
      tasksByHandle[nextHandle] = task2;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task2) {
      var callback = task2.callback;
      var args = task2.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined2, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task2 = tasksByHandle[handle];
        if (task2) {
          currentlyRunningATask = true;
          try {
            run(task2);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel();
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof global === "undefined" ? exports2 : global : self);
});

// node_modules/traverse/index.js
var require_traverse = __commonJS((exports2, module2) => {
  module2.exports = Traverse;
  function Traverse(obj) {
    if (!(this instanceof Traverse))
      return new Traverse(obj);
    this.value = obj;
  }
  Traverse.prototype.get = function(ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i++) {
      var key = ps[i];
      if (!Object.hasOwnProperty.call(node, key)) {
        node = void 0;
        break;
      }
      node = node[key];
    }
    return node;
  };
  Traverse.prototype.set = function(ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i++) {
      var key = ps[i];
      if (!Object.hasOwnProperty.call(node, key))
        node[key] = {};
      node = node[key];
    }
    node[ps[i]] = value;
    return value;
  };
  Traverse.prototype.map = function(cb) {
    return walk2(this.value, cb, true);
  };
  Traverse.prototype.forEach = function(cb) {
    this.value = walk2(this.value, cb, false);
    return this.value;
  };
  Traverse.prototype.reduce = function(cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function(x) {
      if (!this.isRoot || !skip) {
        acc = cb.call(this, acc, x);
      }
    });
    return acc;
  };
  Traverse.prototype.deepEqual = function(obj) {
    if (arguments.length !== 1) {
      throw new Error("deepEqual requires exactly one object to compare against");
    }
    var equal = true;
    var node = obj;
    this.forEach(function(y) {
      var notEqual = function() {
        equal = false;
        return void 0;
      }.bind(this);
      if (!this.isRoot) {
        if (typeof node !== "object")
          return notEqual();
        node = node[this.key];
      }
      var x = node;
      this.post(function() {
        node = x;
      });
      var toS = function(o) {
        return Object.prototype.toString.call(o);
      };
      if (this.circular) {
        if (Traverse(obj).get(this.circular.path) !== x)
          notEqual();
      } else if (typeof x !== typeof y) {
        notEqual();
      } else if (x === null || y === null || x === void 0 || y === void 0) {
        if (x !== y)
          notEqual();
      } else if (x.__proto__ !== y.__proto__) {
        notEqual();
      } else if (x === y) {
      } else if (typeof x === "function") {
        if (x instanceof RegExp) {
          if (x.toString() != y.toString())
            notEqual();
        } else if (x !== y)
          notEqual();
      } else if (typeof x === "object") {
        if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
          if (toS(x) !== toS(y)) {
            notEqual();
          }
        } else if (x instanceof Date || y instanceof Date) {
          if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
            notEqual();
          }
        } else {
          var kx = Object.keys(x);
          var ky = Object.keys(y);
          if (kx.length !== ky.length)
            return notEqual();
          for (var i = 0; i < kx.length; i++) {
            var k = kx[i];
            if (!Object.hasOwnProperty.call(y, k)) {
              notEqual();
            }
          }
        }
      }
    });
    return equal;
  };
  Traverse.prototype.paths = function() {
    var acc = [];
    this.forEach(function(x) {
      acc.push(this.path);
    });
    return acc;
  };
  Traverse.prototype.nodes = function() {
    var acc = [];
    this.forEach(function(x) {
      acc.push(this.node);
    });
    return acc;
  };
  Traverse.prototype.clone = function() {
    var parents = [], nodes = [];
    return function clone(src) {
      for (var i = 0; i < parents.length; i++) {
        if (parents[i] === src) {
          return nodes[i];
        }
      }
      if (typeof src === "object" && src !== null) {
        var dst = copy(src);
        parents.push(src);
        nodes.push(dst);
        Object.keys(src).forEach(function(key) {
          dst[key] = clone(src[key]);
        });
        parents.pop();
        nodes.pop();
        return dst;
      } else {
        return src;
      }
    }(this.value);
  };
  function walk2(root, cb, immutable) {
    var path66 = [];
    var parents = [];
    var alive = true;
    return function walker(node_) {
      var node = immutable ? copy(node_) : node_;
      var modifiers = {};
      var state = {
        node,
        node_,
        path: [].concat(path66),
        parent: parents.slice(-1)[0],
        key: path66.slice(-1)[0],
        isRoot: path66.length === 0,
        level: path66.length,
        circular: null,
        update: function(x) {
          if (!state.isRoot) {
            state.parent.node[state.key] = x;
          }
          state.node = x;
        },
        delete: function() {
          delete state.parent.node[state.key];
        },
        remove: function() {
          if (Array.isArray(state.parent.node)) {
            state.parent.node.splice(state.key, 1);
          } else {
            delete state.parent.node[state.key];
          }
        },
        before: function(f) {
          modifiers.before = f;
        },
        after: function(f) {
          modifiers.after = f;
        },
        pre: function(f) {
          modifiers.pre = f;
        },
        post: function(f) {
          modifiers.post = f;
        },
        stop: function() {
          alive = false;
        }
      };
      if (!alive)
        return state;
      if (typeof node === "object" && node !== null) {
        state.isLeaf = Object.keys(node).length == 0;
        for (var i = 0; i < parents.length; i++) {
          if (parents[i].node_ === node_) {
            state.circular = parents[i];
            break;
          }
        }
      } else {
        state.isLeaf = true;
      }
      state.notLeaf = !state.isLeaf;
      state.notRoot = !state.isRoot;
      var ret2 = cb.call(state, state.node);
      if (ret2 !== void 0 && state.update)
        state.update(ret2);
      if (modifiers.before)
        modifiers.before.call(state, state.node);
      if (typeof state.node == "object" && state.node !== null && !state.circular) {
        parents.push(state);
        var keys = Object.keys(state.node);
        keys.forEach(function(key, i2) {
          path66.push(key);
          if (modifiers.pre)
            modifiers.pre.call(state, state.node[key], key);
          var child = walker(state.node[key]);
          if (immutable && Object.hasOwnProperty.call(state.node, key)) {
            state.node[key] = child.node;
          }
          child.isLast = i2 == keys.length - 1;
          child.isFirst = i2 == 0;
          if (modifiers.post)
            modifiers.post.call(state, child);
          path66.pop();
        });
        parents.pop();
      }
      if (modifiers.after)
        modifiers.after.call(state, state.node);
      return state;
    }(root).node;
  }
  Object.keys(Traverse.prototype).forEach(function(key) {
    Traverse[key] = function(obj) {
      var args = [].slice.call(arguments, 1);
      var t = Traverse(obj);
      return t[key].apply(t, args);
    };
  });
  function copy(src) {
    if (typeof src === "object" && src !== null) {
      var dst;
      if (Array.isArray(src)) {
        dst = [];
      } else if (src instanceof Date) {
        dst = new Date(src);
      } else if (src instanceof Boolean) {
        dst = new Boolean(src);
      } else if (src instanceof Number) {
        dst = new Number(src);
      } else if (src instanceof String) {
        dst = new String(src);
      } else {
        dst = Object.create(Object.getPrototypeOf(src));
      }
      Object.keys(src).forEach(function(key) {
        dst[key] = src[key];
      });
      return dst;
    } else
      return src;
  }
});

// node_modules/chainsaw/index.js
var require_chainsaw = __commonJS((exports2, module2) => {
  var Traverse = require_traverse();
  var EventEmitter8 = require("events").EventEmitter;
  module2.exports = Chainsaw;
  function Chainsaw(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== void 0)
      saw.handlers = r;
    saw.record();
    return saw.chain();
  }
  Chainsaw.light = function ChainsawLight(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== void 0)
      saw.handlers = r;
    return saw.chain();
  };
  Chainsaw.saw = function(builder, handlers) {
    var saw = new EventEmitter8();
    saw.handlers = handlers;
    saw.actions = [];
    saw.chain = function() {
      var ch = Traverse(saw.handlers).map(function(node) {
        if (this.isRoot)
          return node;
        var ps = this.path;
        if (typeof node === "function") {
          this.update(function() {
            saw.actions.push({
              path: ps,
              args: [].slice.call(arguments)
            });
            return ch;
          });
        }
      });
      process.nextTick(function() {
        saw.emit("begin");
        saw.next();
      });
      return ch;
    };
    saw.pop = function() {
      return saw.actions.shift();
    };
    saw.next = function() {
      var action = saw.pop();
      if (!action) {
        saw.emit("end");
      } else if (!action.trap) {
        var node = saw.handlers;
        action.path.forEach(function(key) {
          node = node[key];
        });
        node.apply(saw.handlers, action.args);
      }
    };
    saw.nest = function(cb) {
      var args = [].slice.call(arguments, 1);
      var autonext = true;
      if (typeof cb === "boolean") {
        var autonext = cb;
        cb = args.shift();
      }
      var s = Chainsaw.saw(builder, {});
      var r = builder.call(s.handlers, s);
      if (r !== void 0)
        s.handlers = r;
      if (typeof saw.step !== "undefined") {
        s.record();
      }
      cb.apply(s.chain(), args);
      if (autonext !== false)
        s.on("end", saw.next);
    };
    saw.record = function() {
      upgradeChainsaw(saw);
    };
    ["trap", "down", "jump"].forEach(function(method) {
      saw[method] = function() {
        throw new Error("To use the trap, down and jump features, please call record() first to start recording actions.");
      };
    });
    return saw;
  };
  function upgradeChainsaw(saw) {
    saw.step = 0;
    saw.pop = function() {
      return saw.actions[saw.step++];
    };
    saw.trap = function(name2, cb) {
      var ps = Array.isArray(name2) ? name2 : [name2];
      saw.actions.push({
        path: ps,
        step: saw.step,
        cb,
        trap: true
      });
    };
    saw.down = function(name2) {
      var ps = (Array.isArray(name2) ? name2 : [name2]).join("/");
      var i = saw.actions.slice(saw.step).map(function(x) {
        if (x.trap && x.step <= saw.step)
          return false;
        return x.path.join("/") == ps;
      }).indexOf(true);
      if (i >= 0)
        saw.step += i;
      else
        saw.step = saw.actions.length;
      var act = saw.actions[saw.step - 1];
      if (act && act.trap) {
        saw.step = act.step;
        act.cb();
      } else
        saw.next();
    };
    saw.jump = function(step) {
      saw.step = step;
      saw.next();
    };
  }
});

// node_modules/buffers/index.js
var require_buffers = __commonJS((exports2, module2) => {
  module2.exports = Buffers;
  function Buffers(bufs) {
    if (!(this instanceof Buffers))
      return new Buffers(bufs);
    this.buffers = bufs || [];
    this.length = this.buffers.reduce(function(size, buf) {
      return size + buf.length;
    }, 0);
  }
  Buffers.prototype.push = function() {
    for (var i = 0; i < arguments.length; i++) {
      if (!Buffer.isBuffer(arguments[i])) {
        throw new TypeError("Tried to push a non-buffer");
      }
    }
    for (var i = 0; i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.push(buf);
      this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.unshift = function() {
    for (var i = 0; i < arguments.length; i++) {
      if (!Buffer.isBuffer(arguments[i])) {
        throw new TypeError("Tried to unshift a non-buffer");
      }
    }
    for (var i = 0; i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.unshift(buf);
      this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.copy = function(dst, dStart, start, end) {
    return this.slice(start, end).copy(dst, dStart, 0, end - start);
  };
  Buffers.prototype.splice = function(i, howMany) {
    var buffers = this.buffers;
    var index = i >= 0 ? i : this.length - i;
    var reps = [].slice.call(arguments, 2);
    if (howMany === void 0) {
      howMany = this.length - index;
    } else if (howMany > this.length - index) {
      howMany = this.length - index;
    }
    for (var i = 0; i < reps.length; i++) {
      this.length += reps[i].length;
    }
    var removed = new Buffers();
    var bytes3 = 0;
    var startBytes = 0;
    for (var ii = 0; ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {
      startBytes += buffers[ii].length;
    }
    if (index - startBytes > 0) {
      var start = index - startBytes;
      if (start + howMany < buffers[ii].length) {
        removed.push(buffers[ii].slice(start, start + howMany));
        var orig = buffers[ii];
        var buf0 = new Buffer(start);
        for (var i = 0; i < start; i++) {
          buf0[i] = orig[i];
        }
        var buf1 = new Buffer(orig.length - start - howMany);
        for (var i = start + howMany; i < orig.length; i++) {
          buf1[i - howMany - start] = orig[i];
        }
        if (reps.length > 0) {
          var reps_ = reps.slice();
          reps_.unshift(buf0);
          reps_.push(buf1);
          buffers.splice.apply(buffers, [ii, 1].concat(reps_));
          ii += reps_.length;
          reps = [];
        } else {
          buffers.splice(ii, 1, buf0, buf1);
          ii += 2;
        }
      } else {
        removed.push(buffers[ii].slice(start));
        buffers[ii] = buffers[ii].slice(0, start);
        ii++;
      }
    }
    if (reps.length > 0) {
      buffers.splice.apply(buffers, [ii, 0].concat(reps));
      ii += reps.length;
    }
    while (removed.length < howMany) {
      var buf = buffers[ii];
      var len = buf.length;
      var take = Math.min(len, howMany - removed.length);
      if (take === len) {
        removed.push(buf);
        buffers.splice(ii, 1);
      } else {
        removed.push(buf.slice(0, take));
        buffers[ii] = buffers[ii].slice(take);
      }
    }
    this.length -= removed.length;
    return removed;
  };
  Buffers.prototype.slice = function(i, j) {
    var buffers = this.buffers;
    if (j === void 0)
      j = this.length;
    if (i === void 0)
      i = 0;
    if (j > this.length)
      j = this.length;
    var startBytes = 0;
    for (var si = 0; si < buffers.length && startBytes + buffers[si].length <= i; si++) {
      startBytes += buffers[si].length;
    }
    var target = new Buffer(j - i);
    var ti = 0;
    for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
      var len = buffers[ii].length;
      var start = ti === 0 ? i - startBytes : 0;
      var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
      buffers[ii].copy(target, ti, start, end);
      ti += end - start;
    }
    return target;
  };
  Buffers.prototype.pos = function(i) {
    if (i < 0 || i >= this.length)
      throw new Error("oob");
    var l = i, bi = 0, bu = null;
    for (; ; ) {
      bu = this.buffers[bi];
      if (l < bu.length) {
        return {buf: bi, offset: l};
      } else {
        l -= bu.length;
      }
      bi++;
    }
  };
  Buffers.prototype.get = function get(i) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].get(pos.offset);
  };
  Buffers.prototype.set = function set(i, b) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].set(pos.offset, b);
  };
  Buffers.prototype.indexOf = function(needle, offset) {
    if (typeof needle === "string") {
      needle = new Buffer(needle);
    } else if (needle instanceof Buffer) {
    } else {
      throw new Error("Invalid type for a search string");
    }
    if (!needle.length) {
      return 0;
    }
    if (!this.length) {
      return -1;
    }
    var i = 0, j = 0, match3 = 0, mstart, pos = 0;
    if (offset) {
      var p = this.pos(offset);
      i = p.buf;
      j = p.offset;
      pos = offset;
    }
    for (; ; ) {
      while (j >= this.buffers[i].length) {
        j = 0;
        i++;
        if (i >= this.buffers.length) {
          return -1;
        }
      }
      var char = this.buffers[i][j];
      if (char == needle[match3]) {
        if (match3 == 0) {
          mstart = {
            i,
            j,
            pos
          };
        }
        match3++;
        if (match3 == needle.length) {
          return mstart.pos;
        }
      } else if (match3 != 0) {
        i = mstart.i;
        j = mstart.j;
        pos = mstart.pos;
        match3 = 0;
      }
      j++;
      pos++;
    }
  };
  Buffers.prototype.toBuffer = function() {
    return this.slice();
  };
  Buffers.prototype.toString = function(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
});

// node_modules/binary/lib/vars.js
var require_vars = __commonJS((exports2, module2) => {
  module2.exports = function(store) {
    function getset(name2, value) {
      var node = vars.store;
      var keys = name2.split(".");
      keys.slice(0, -1).forEach(function(k) {
        if (node[k] === void 0)
          node[k] = {};
        node = node[k];
      });
      var key = keys[keys.length - 1];
      if (arguments.length == 1) {
        return node[key];
      } else {
        return node[key] = value;
      }
    }
    var vars = {
      get: function(name2) {
        return getset(name2);
      },
      set: function(name2, value) {
        return getset(name2, value);
      },
      store: store || {}
    };
    return vars;
  };
});

// node_modules/binary/index.js
var require_binary = __commonJS((exports2, module2) => {
  var Chainsaw = require_chainsaw();
  var EventEmitter8 = require("events").EventEmitter;
  var Buffers = require_buffers();
  var Vars = require_vars();
  var Stream = require("stream").Stream;
  exports2 = module2.exports = function(bufOrEm, eventName) {
    if (Buffer.isBuffer(bufOrEm)) {
      return exports2.parse(bufOrEm);
    }
    var s = exports2.stream();
    if (bufOrEm && bufOrEm.pipe) {
      bufOrEm.pipe(s);
    } else if (bufOrEm) {
      bufOrEm.on(eventName || "data", function(buf) {
        s.write(buf);
      });
      bufOrEm.on("end", function() {
        s.end();
      });
    }
    return s;
  };
  exports2.stream = function(input) {
    if (input)
      return exports2.apply(null, arguments);
    var pending = null;
    function getBytes(bytes3, cb, skip) {
      pending = {
        bytes: bytes3,
        skip,
        cb: function(buf) {
          pending = null;
          cb(buf);
        }
      };
      dispatch();
    }
    var offset = null;
    function dispatch() {
      if (!pending) {
        if (caughtEnd)
          done = true;
        return;
      }
      if (typeof pending === "function") {
        pending();
      } else {
        var bytes3 = offset + pending.bytes;
        if (buffers.length >= bytes3) {
          var buf;
          if (offset == null) {
            buf = buffers.splice(0, bytes3);
            if (!pending.skip) {
              buf = buf.slice();
            }
          } else {
            if (!pending.skip) {
              buf = buffers.slice(offset, bytes3);
            }
            offset = bytes3;
          }
          if (pending.skip) {
            pending.cb();
          } else {
            pending.cb(buf);
          }
        }
      }
    }
    function builder(saw) {
      function next() {
        if (!done)
          saw.next();
      }
      var self2 = words(function(bytes3, cb) {
        return function(name2) {
          getBytes(bytes3, function(buf) {
            vars.set(name2, cb(buf));
            next();
          });
        };
      });
      self2.tap = function(cb) {
        saw.nest(cb, vars.store);
      };
      self2.into = function(key, cb) {
        if (!vars.get(key))
          vars.set(key, {});
        var parent = vars;
        vars = Vars(parent.get(key));
        saw.nest(function() {
          cb.apply(this, arguments);
          this.tap(function() {
            vars = parent;
          });
        }, vars.store);
      };
      self2.flush = function() {
        vars.store = {};
        next();
      };
      self2.loop = function(cb) {
        var end = false;
        saw.nest(false, function loop() {
          this.vars = vars.store;
          cb.call(this, function() {
            end = true;
            next();
          }, vars.store);
          this.tap(function() {
            if (end)
              saw.next();
            else
              loop.call(this);
          }.bind(this));
        }, vars.store);
      };
      self2.buffer = function(name2, bytes3) {
        if (typeof bytes3 === "string") {
          bytes3 = vars.get(bytes3);
        }
        getBytes(bytes3, function(buf) {
          vars.set(name2, buf);
          next();
        });
      };
      self2.skip = function(bytes3) {
        if (typeof bytes3 === "string") {
          bytes3 = vars.get(bytes3);
        }
        getBytes(bytes3, function() {
          next();
        });
      };
      self2.scan = function find(name2, search2) {
        if (typeof search2 === "string") {
          search2 = new Buffer(search2);
        } else if (!Buffer.isBuffer(search2)) {
          throw new Error("search must be a Buffer or a string");
        }
        var taken = 0;
        pending = function() {
          var pos = buffers.indexOf(search2, offset + taken);
          var i = pos - offset - taken;
          if (pos !== -1) {
            pending = null;
            if (offset != null) {
              vars.set(name2, buffers.slice(offset, offset + taken + i));
              offset += taken + i + search2.length;
            } else {
              vars.set(name2, buffers.slice(0, taken + i));
              buffers.splice(0, taken + i + search2.length);
            }
            next();
            dispatch();
          } else {
            i = Math.max(buffers.length - search2.length - offset - taken, 0);
          }
          taken += i;
        };
        dispatch();
      };
      self2.peek = function(cb) {
        offset = 0;
        saw.nest(function() {
          cb.call(this, vars.store);
          this.tap(function() {
            offset = null;
          });
        });
      };
      return self2;
    }
    ;
    var stream = Chainsaw.light(builder);
    stream.writable = true;
    var buffers = Buffers();
    stream.write = function(buf) {
      buffers.push(buf);
      dispatch();
    };
    var vars = Vars();
    var done = false, caughtEnd = false;
    stream.end = function() {
      caughtEnd = true;
    };
    stream.pipe = Stream.prototype.pipe;
    Object.getOwnPropertyNames(EventEmitter8.prototype).forEach(function(name2) {
      stream[name2] = EventEmitter8.prototype[name2];
    });
    return stream;
  };
  exports2.parse = function parse4(buffer4) {
    var self2 = words(function(bytes3, cb) {
      return function(name2) {
        if (offset + bytes3 <= buffer4.length) {
          var buf = buffer4.slice(offset, offset + bytes3);
          offset += bytes3;
          vars.set(name2, cb(buf));
        } else {
          vars.set(name2, null);
        }
        return self2;
      };
    });
    var offset = 0;
    var vars = Vars();
    self2.vars = vars.store;
    self2.tap = function(cb) {
      cb.call(self2, vars.store);
      return self2;
    };
    self2.into = function(key, cb) {
      if (!vars.get(key)) {
        vars.set(key, {});
      }
      var parent = vars;
      vars = Vars(parent.get(key));
      cb.call(self2, vars.store);
      vars = parent;
      return self2;
    };
    self2.loop = function(cb) {
      var end = false;
      var ender = function() {
        end = true;
      };
      while (end === false) {
        cb.call(self2, ender, vars.store);
      }
      return self2;
    };
    self2.buffer = function(name2, size) {
      if (typeof size === "string") {
        size = vars.get(size);
      }
      var buf = buffer4.slice(offset, Math.min(buffer4.length, offset + size));
      offset += size;
      vars.set(name2, buf);
      return self2;
    };
    self2.skip = function(bytes3) {
      if (typeof bytes3 === "string") {
        bytes3 = vars.get(bytes3);
      }
      offset += bytes3;
      return self2;
    };
    self2.scan = function(name2, search2) {
      if (typeof search2 === "string") {
        search2 = new Buffer(search2);
      } else if (!Buffer.isBuffer(search2)) {
        throw new Error("search must be a Buffer or a string");
      }
      vars.set(name2, null);
      for (var i = 0; i + offset <= buffer4.length - search2.length + 1; i++) {
        for (var j = 0; j < search2.length && buffer4[offset + i + j] === search2[j]; j++)
          ;
        if (j === search2.length)
          break;
      }
      vars.set(name2, buffer4.slice(offset, offset + i));
      offset += i + search2.length;
      return self2;
    };
    self2.peek = function(cb) {
      var was = offset;
      cb.call(self2, vars.store);
      offset = was;
      return self2;
    };
    self2.flush = function() {
      vars.store = {};
      return self2;
    };
    self2.eof = function() {
      return offset >= buffer4.length;
    };
    return self2;
  };
  function decodeLEu(bytes3) {
    var acc = 0;
    for (var i = 0; i < bytes3.length; i++) {
      acc += Math.pow(256, i) * bytes3[i];
    }
    return acc;
  }
  function decodeBEu(bytes3) {
    var acc = 0;
    for (var i = 0; i < bytes3.length; i++) {
      acc += Math.pow(256, bytes3.length - i - 1) * bytes3[i];
    }
    return acc;
  }
  function decodeBEs(bytes3) {
    var val = decodeBEu(bytes3);
    if ((bytes3[0] & 128) == 128) {
      val -= Math.pow(256, bytes3.length);
    }
    return val;
  }
  function decodeLEs(bytes3) {
    var val = decodeLEu(bytes3);
    if ((bytes3[bytes3.length - 1] & 128) == 128) {
      val -= Math.pow(256, bytes3.length);
    }
    return val;
  }
  function words(decode) {
    var self2 = {};
    [1, 2, 4, 8].forEach(function(bytes3) {
      var bits = bytes3 * 8;
      self2["word" + bits + "le"] = self2["word" + bits + "lu"] = decode(bytes3, decodeLEu);
      self2["word" + bits + "ls"] = decode(bytes3, decodeLEs);
      self2["word" + bits + "be"] = self2["word" + bits + "bu"] = decode(bytes3, decodeBEu);
      self2["word" + bits + "bs"] = decode(bytes3, decodeBEs);
    });
    self2.word8 = self2.word8u = self2.word8be;
    self2.word8s = self2.word8bs;
    return self2;
  }
});

// node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS((exports2, module2) => {
  var isES5 = function() {
    "use strict";
    return this === void 0;
  }();
  if (isES5) {
    module2.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5,
      propertyIsWritable: function(obj, prop) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        return !!(!descriptor || descriptor.writable || descriptor.set);
      }
    };
  } else {
    has = {}.hasOwnProperty;
    str = {}.toString;
    proto = {}.constructor.prototype;
    ObjectKeys = function(o) {
      var ret2 = [];
      for (var key in o) {
        if (has.call(o, key)) {
          ret2.push(key);
        }
      }
      return ret2;
    };
    ObjectGetDescriptor = function(o, key) {
      return {value: o[key]};
    };
    ObjectDefineProperty = function(o, key, desc) {
      o[key] = desc.value;
      return o;
    };
    ObjectFreeze = function(obj) {
      return obj;
    };
    ObjectGetPrototypeOf = function(obj) {
      try {
        return Object(obj).constructor.prototype;
      } catch (e) {
        return proto;
      }
    };
    ArrayIsArray = function(obj) {
      try {
        return str.call(obj) === "[object Array]";
      } catch (e) {
        return false;
      }
    };
    module2.exports = {
      isArray: ArrayIsArray,
      keys: ObjectKeys,
      names: ObjectKeys,
      defineProperty: ObjectDefineProperty,
      getDescriptor: ObjectGetDescriptor,
      freeze: ObjectFreeze,
      getPrototypeOf: ObjectGetPrototypeOf,
      isES5,
      propertyIsWritable: function() {
        return true;
      }
    };
  }
  var has;
  var str;
  var proto;
  var ObjectKeys;
  var ObjectGetDescriptor;
  var ObjectDefineProperty;
  var ObjectFreeze;
  var ObjectGetPrototypeOf;
  var ArrayIsArray;
});

// node_modules/bluebird/js/release/util.js
var require_util = __commonJS((exports, module) => {
  "use strict";
  var es5 = require_es5();
  var canEvaluate = typeof navigator == "undefined";
  var errorObj = {e: {}};
  var tryCatchTarget;
  var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports !== void 0 ? exports : null;
  function tryCatcher() {
    try {
      var target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e) {
      errorObj.e = e;
      return errorObj;
    }
  }
  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }
  var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
      this.constructor = Child;
      this.constructor$ = Parent;
      for (var propertyName in Parent.prototype) {
        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
          this[propertyName + "$"] = Parent.prototype[propertyName];
        }
      }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
  };
  function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
  }
  function isObject(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
  }
  function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError))
      return maybeError;
    return new Error(safeToString(maybeError));
  }
  function withAppended(target, appendee) {
    var len = target.length;
    var ret2 = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
      ret2[i] = target[i];
    }
    ret2[i] = appendee;
    return ret2;
  }
  function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
      var desc = Object.getOwnPropertyDescriptor(obj, key);
      if (desc != null) {
        return desc.get == null && desc.set == null ? desc.value : defaultValue;
      }
    } else {
      return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
    }
  }
  function notEnumerableProp(obj, name2, value) {
    if (isPrimitive(obj))
      return obj;
    var descriptor = {
      value,
      configurable: true,
      enumerable: false,
      writable: true
    };
    es5.defineProperty(obj, name2, descriptor);
    return obj;
  }
  function thrower(r) {
    throw r;
  }
  var inheritedDataKeys = function() {
    var excludedPrototypes = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ];
    var isExcludedProto = function(val) {
      for (var i = 0; i < excludedPrototypes.length; ++i) {
        if (excludedPrototypes[i] === val) {
          return true;
        }
      }
      return false;
    };
    if (es5.isES5) {
      var getKeys2 = Object.getOwnPropertyNames;
      return function(obj) {
        var ret2 = [];
        var visitedKeys = Object.create(null);
        while (obj != null && !isExcludedProto(obj)) {
          var keys;
          try {
            keys = getKeys2(obj);
          } catch (e) {
            return ret2;
          }
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (visitedKeys[key])
              continue;
            visitedKeys[key] = true;
            var desc = Object.getOwnPropertyDescriptor(obj, key);
            if (desc != null && desc.get == null && desc.set == null) {
              ret2.push(key);
            }
          }
          obj = es5.getPrototypeOf(obj);
        }
        return ret2;
      };
    } else {
      var hasProp = {}.hasOwnProperty;
      return function(obj) {
        if (isExcludedProto(obj))
          return [];
        var ret2 = [];
        enumeration:
          for (var key in obj) {
            if (hasProp.call(obj, key)) {
              ret2.push(key);
            } else {
              for (var i = 0; i < excludedPrototypes.length; ++i) {
                if (hasProp.call(excludedPrototypes[i], key)) {
                  continue enumeration;
                }
              }
              ret2.push(key);
            }
          }
        return ret2;
      };
    }
  }();
  var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
  function isClass(fn) {
    try {
      if (typeof fn === "function") {
        var keys = es5.names(fn.prototype);
        var hasMethods = es5.isES5 && keys.length > 1;
        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
          return true;
        }
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function toFastProperties(obj) {
    function FakeConstructor() {
    }
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--)
      new FakeConstructor();
    return obj;
    eval(obj);
  }
  var rident = /^[a-z$_][a-z$_0-9]*$/i;
  function isIdentifier(str) {
    return rident.test(str);
  }
  function filledRange(count, prefix, suffix) {
    var ret2 = new Array(count);
    for (var i = 0; i < count; ++i) {
      ret2[i] = prefix + i + suffix;
    }
    return ret2;
  }
  function safeToString(obj) {
    try {
      return obj + "";
    } catch (e) {
      return "[no string representation]";
    }
  }
  function isError(obj) {
    return obj !== null && typeof obj === "object" && typeof obj.message === "string" && typeof obj.name === "string";
  }
  function markAsOriginatingFromRejection(e) {
    try {
      notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {
    }
  }
  function originatesFromRejection(e) {
    if (e == null)
      return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
  }
  function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
  }
  var ensureErrorObject = function() {
    if (!("stack" in new Error())) {
      return function(value) {
        if (canAttachTrace(value))
          return value;
        try {
          throw new Error(safeToString(value));
        } catch (err) {
          return err;
        }
      };
    } else {
      return function(value) {
        if (canAttachTrace(value))
          return value;
        return new Error(safeToString(value));
      };
    }
  }();
  function classString(obj) {
    return {}.toString.call(obj);
  }
  function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      if (filter(key)) {
        try {
          es5.defineProperty(to, key, es5.getDescriptor(from, key));
        } catch (ignore) {
        }
      }
    }
  }
  var asArray = function(v) {
    if (es5.isArray(v)) {
      return v;
    }
    return null;
  };
  if (typeof Symbol !== "undefined" && Symbol.iterator) {
    ArrayFrom = typeof Array.from === "function" ? function(v) {
      return Array.from(v);
    } : function(v) {
      var ret2 = [];
      var it = v[Symbol.iterator]();
      var itResult;
      while (!(itResult = it.next()).done) {
        ret2.push(itResult.value);
      }
      return ret2;
    };
    asArray = function(v) {
      if (es5.isArray(v)) {
        return v;
      } else if (v != null && typeof v[Symbol.iterator] === "function") {
        return ArrayFrom(v);
      }
      return null;
    };
  }
  var ArrayFrom;
  var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
  var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
  function env(key) {
    return hasEnvVariables ? process.env[key] : void 0;
  }
  function getNativePromise() {
    if (typeof Promise === "function") {
      try {
        var promise = new Promise(function() {
        });
        if ({}.toString.call(promise) === "[object Promise]") {
          return Promise;
        }
      } catch (e) {
      }
    }
  }
  function domainBind(self2, cb) {
    return self2.bind(cb);
  }
  var ret = {
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es5.isArray,
    asArray,
    notEnumerableProp,
    isPrimitive,
    isObject,
    isError,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
    isNode,
    hasEnvVariables,
    env,
    global: globalObject,
    getNativePromise,
    domainBind
  };
  ret.isRecentNode = ret.isNode && function() {
    var version2 = process.versions.node.split(".").map(Number);
    return version2[0] === 0 && version2[1] > 10 || version2[0] > 0;
  }();
  if (ret.isNode)
    ret.toFastProperties(process);
  try {
    throw new Error();
  } catch (e) {
    ret.lastLineError = e;
  }
  module.exports = ret;
});

// node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS((exports2, module2) => {
  "use strict";
  var util54 = require_util();
  var schedule;
  var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
  };
  var NativePromise = util54.getNativePromise();
  if (util54.isNode && typeof MutationObserver === "undefined") {
    GlobalSetImmediate = global.setImmediate;
    ProcessNextTick = process.nextTick;
    schedule = util54.isRecentNode ? function(fn) {
      GlobalSetImmediate.call(global, fn);
    } : function(fn) {
      ProcessNextTick.call(process, fn);
    };
  } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    nativePromise = NativePromise.resolve();
    schedule = function(fn) {
      nativePromise.then(fn);
    };
  } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
    schedule = function() {
      var div = document.createElement("div");
      var opts = {attributes: true};
      var toggleScheduled = false;
      var div2 = document.createElement("div");
      var o2 = new MutationObserver(function() {
        div.classList.toggle("foo");
        toggleScheduled = false;
      });
      o2.observe(div2, opts);
      var scheduleToggle = function() {
        if (toggleScheduled)
          return;
        toggleScheduled = true;
        div2.classList.toggle("foo");
      };
      return function schedule2(fn) {
        var o = new MutationObserver(function() {
          o.disconnect();
          fn();
        });
        o.observe(div, opts);
        scheduleToggle();
      };
    }();
  } else if (typeof setImmediate !== "undefined") {
    schedule = function(fn) {
      setImmediate(fn);
    };
  } else if (typeof setTimeout !== "undefined") {
    schedule = function(fn) {
      setTimeout(fn, 0);
    };
  } else {
    schedule = noAsyncScheduler;
  }
  var GlobalSetImmediate;
  var ProcessNextTick;
  var nativePromise;
  module2.exports = schedule;
});

// node_modules/bluebird/js/release/queue.js
var require_queue = __commonJS((exports2, module2) => {
  "use strict";
  function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
      dst[j + dstIndex] = src[j + srcIndex];
      src[j + srcIndex] = void 0;
    }
  }
  function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
  }
  Queue.prototype._willBeOverCapacity = function(size) {
    return this._capacity < size;
  };
  Queue.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
  };
  Queue.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
      this._pushOne(fn);
      this._pushOne(receiver);
      this._pushOne(arg);
      return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
  };
  Queue.prototype.shift = function() {
    var front = this._front, ret2 = this[front];
    this[front] = void 0;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret2;
  };
  Queue.prototype.length = function() {
    return this._length;
  };
  Queue.prototype._checkCapacity = function(size) {
    if (this._capacity < size) {
      this._resizeTo(this._capacity << 1);
    }
  };
  Queue.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
  };
  module2.exports = Queue;
});

// node_modules/bluebird/js/release/async.js
var require_async = __commonJS((exports2, module2) => {
  "use strict";
  var firstLineError;
  try {
    throw new Error();
  } catch (e) {
    firstLineError = e;
  }
  var schedule = require_schedule();
  var Queue = require_queue();
  var util54 = require_util();
  function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self2 = this;
    this.drainQueues = function() {
      self2._drainQueues();
    };
    this._schedule = schedule;
  }
  Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
  };
  Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  };
  Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
  };
  Async.prototype.disableTrampolineIfNecessary = function() {
    if (util54.hasDevTools) {
      this._trampolineEnabled = false;
    }
  };
  Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  };
  Async.prototype.fatalError = function(e, isNode2) {
    if (isNode2) {
      process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
      process.exit(2);
    } else {
      this.throwLater(e);
    }
  };
  Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
      arg = fn;
      fn = function() {
        throw arg;
      };
    }
    if (typeof setTimeout !== "undefined") {
      setTimeout(function() {
        fn(arg);
      }, 0);
    } else
      try {
        this._schedule(function() {
          fn(arg);
        });
      } catch (e) {
        throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
      }
  };
  function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
  }
  if (!util54.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
  } else {
    Async.prototype.invokeLater = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvokeLater.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          setTimeout(function() {
            fn.call(receiver, arg);
          }, 100);
        });
      }
    };
    Async.prototype.invoke = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvoke.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          fn.call(receiver, arg);
        });
      }
    };
    Async.prototype.settlePromises = function(promise) {
      if (this._trampolineEnabled) {
        AsyncSettlePromises.call(this, promise);
      } else {
        this._schedule(function() {
          promise._settlePromises();
        });
      }
    };
  }
  Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
      var fn = queue.shift();
      if (typeof fn !== "function") {
        fn._settlePromises();
        continue;
      }
      var receiver = queue.shift();
      var arg = queue.shift();
      fn.call(receiver, arg);
    }
  };
  Async.prototype._drainQueues = function() {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
  };
  Async.prototype._queueTick = function() {
    if (!this._isTickUsed) {
      this._isTickUsed = true;
      this._schedule(this.drainQueues);
    }
  };
  Async.prototype._reset = function() {
    this._isTickUsed = false;
  };
  module2.exports = Async;
  module2.exports.firstLineError = firstLineError;
});

// node_modules/bluebird/js/release/errors.js
var require_errors = __commonJS((exports2, module2) => {
  "use strict";
  var es52 = require_es5();
  var Objectfreeze = es52.freeze;
  var util54 = require_util();
  var inherits2 = util54.inherits;
  var notEnumerableProp2 = util54.notEnumerableProp;
  function subError(nameProperty, defaultMessage) {
    function SubError(message) {
      if (!(this instanceof SubError))
        return new SubError(message);
      notEnumerableProp2(this, "message", typeof message === "string" ? message : defaultMessage);
      notEnumerableProp2(this, "name", nameProperty);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        Error.call(this);
      }
    }
    inherits2(SubError, Error);
    return SubError;
  }
  var _TypeError;
  var _RangeError;
  var Warning = subError("Warning", "warning");
  var CancellationError = subError("CancellationError", "cancellation error");
  var TimeoutError = subError("TimeoutError", "timeout error");
  var AggregateError = subError("AggregateError", "aggregate error");
  try {
    _TypeError = TypeError;
    _RangeError = RangeError;
  } catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
  }
  var methods2 = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
  for (var i = 0; i < methods2.length; ++i) {
    if (typeof Array.prototype[methods2[i]] === "function") {
      AggregateError.prototype[methods2[i]] = Array.prototype[methods2[i]];
    }
  }
  es52.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
  });
  AggregateError.prototype["isOperational"] = true;
  var level = 0;
  AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret2 = "\n" + indent + "AggregateError of:\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i2 = 0; i2 < this.length; ++i2) {
      var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
      var lines = str.split("\n");
      for (var j = 0; j < lines.length; ++j) {
        lines[j] = indent + lines[j];
      }
      str = lines.join("\n");
      ret2 += str + "\n";
    }
    level--;
    return ret2;
  };
  function OperationalError(message) {
    if (!(this instanceof OperationalError))
      return new OperationalError(message);
    notEnumerableProp2(this, "name", "OperationalError");
    notEnumerableProp2(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;
    if (message instanceof Error) {
      notEnumerableProp2(this, "message", message.message);
      notEnumerableProp2(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  inherits2(OperationalError, Error);
  var errorTypes = Error["__BluebirdErrorTypes__"];
  if (!errorTypes) {
    errorTypes = Objectfreeze({
      CancellationError,
      TimeoutError,
      OperationalError,
      RejectionError: OperationalError,
      AggregateError
    });
    es52.defineProperty(Error, "__BluebirdErrorTypes__", {
      value: errorTypes,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  module2.exports = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
  };
});

// node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, INTERNAL) {
    var util54 = require_util();
    var errorObj2 = util54.errorObj;
    var isObject2 = util54.isObject;
    function tryConvertToPromise(obj, context) {
      if (isObject2(obj)) {
        if (obj instanceof Promise2)
          return obj;
        var then = getThen(obj);
        if (then === errorObj2) {
          if (context)
            context._pushContext();
          var ret2 = Promise2.reject(then.e);
          if (context)
            context._popContext();
          return ret2;
        } else if (typeof then === "function") {
          if (isAnyBluebirdPromise(obj)) {
            var ret2 = new Promise2(INTERNAL);
            obj._then(ret2._fulfill, ret2._reject, void 0, ret2, null);
            return ret2;
          }
          return doThenable(obj, then, context);
        }
      }
      return obj;
    }
    function doGetThen(obj) {
      return obj.then;
    }
    function getThen(obj) {
      try {
        return doGetThen(obj);
      } catch (e) {
        errorObj2.e = e;
        return errorObj2;
      }
    }
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
      try {
        return hasProp.call(obj, "_promise0");
      } catch (e) {
        return false;
      }
    }
    function doThenable(x, then, context) {
      var promise = new Promise2(INTERNAL);
      var ret2 = promise;
      if (context)
        context._pushContext();
      promise._captureStackTrace();
      if (context)
        context._popContext();
      var synchronous = true;
      var result = util54.tryCatch(then).call(x, resolve3, reject);
      synchronous = false;
      if (promise && result === errorObj2) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
      }
      function resolve3(value) {
        if (!promise)
          return;
        promise._resolveCallback(value);
        promise = null;
      }
      function reject(reason) {
        if (!promise)
          return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
      }
      return ret2;
    }
    return tryConvertToPromise;
  };
});

// node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util54 = require_util();
    var isArray = util54.isArray;
    function toResolutionValue(val) {
      switch (val) {
        case -2:
          return [];
        case -3:
          return {};
      }
    }
    function PromiseArray(values) {
      var promise = this._promise = new Promise2(INTERNAL);
      if (values instanceof Promise2) {
        promise._propagateFrom(values, 3);
      }
      promise._setOnCancel(this);
      this._values = values;
      this._length = 0;
      this._totalResolved = 0;
      this._init(void 0, -2);
    }
    util54.inherits(PromiseArray, Proxyable);
    PromiseArray.prototype.length = function() {
      return this._length;
    };
    PromiseArray.prototype.promise = function() {
      return this._promise;
    };
    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
      var values = tryConvertToPromise(this._values, this._promise);
      if (values instanceof Promise2) {
        values = values._target();
        var bitField = values._bitField;
        ;
        this._values = values;
        if ((bitField & 50397184) === 0) {
          this._promise._setAsyncGuaranteed();
          return values._then(init, this._reject, void 0, this, resolveValueIfEmpty);
        } else if ((bitField & 33554432) !== 0) {
          values = values._value();
        } else if ((bitField & 16777216) !== 0) {
          return this._reject(values._reason());
        } else {
          return this._cancel();
        }
      }
      values = util54.asArray(values);
      if (values === null) {
        var err = apiRejection("expecting an array or an iterable object but got " + util54.classString(values)).reason();
        this._promise._rejectCallback(err, false);
        return;
      }
      if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
          this._resolveEmptyArray();
        } else {
          this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
      }
      this._iterate(values);
    };
    PromiseArray.prototype._iterate = function(values) {
      var len = this.getActualLength(values.length);
      this._length = len;
      this._values = this.shouldCopyValues() ? new Array(len) : this._values;
      var result = this._promise;
      var isResolved = false;
      var bitField = null;
      for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          bitField = maybePromise._bitField;
        } else {
          bitField = null;
        }
        if (isResolved) {
          if (bitField !== null) {
            maybePromise.suppressUnhandledRejections();
          }
        } else if (bitField !== null) {
          if ((bitField & 50397184) === 0) {
            maybePromise._proxy(this, i);
            this._values[i] = maybePromise;
          } else if ((bitField & 33554432) !== 0) {
            isResolved = this._promiseFulfilled(maybePromise._value(), i);
          } else if ((bitField & 16777216) !== 0) {
            isResolved = this._promiseRejected(maybePromise._reason(), i);
          } else {
            isResolved = this._promiseCancelled(i);
          }
        } else {
          isResolved = this._promiseFulfilled(maybePromise, i);
        }
      }
      if (!isResolved)
        result._setAsyncGuaranteed();
    };
    PromiseArray.prototype._isResolved = function() {
      return this._values === null;
    };
    PromiseArray.prototype._resolve = function(value) {
      this._values = null;
      this._promise._fulfill(value);
    };
    PromiseArray.prototype._cancel = function() {
      if (this._isResolved() || !this._promise._isCancellable())
        return;
      this._values = null;
      this._promise._cancel();
    };
    PromiseArray.prototype._reject = function(reason) {
      this._values = null;
      this._promise._rejectCallback(reason, false);
    };
    PromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    PromiseArray.prototype._promiseCancelled = function() {
      this._cancel();
      return true;
    };
    PromiseArray.prototype._promiseRejected = function(reason) {
      this._totalResolved++;
      this._reject(reason);
      return true;
    };
    PromiseArray.prototype._resultCancelled = function() {
      if (this._isResolved())
        return;
      var values = this._values;
      this._cancel();
      if (values instanceof Promise2) {
        values.cancel();
      } else {
        for (var i = 0; i < values.length; ++i) {
          if (values[i] instanceof Promise2) {
            values[i].cancel();
          }
        }
      }
    };
    PromiseArray.prototype.shouldCopyValues = function() {
      return true;
    };
    PromiseArray.prototype.getActualLength = function(len) {
      return len;
    };
    return PromiseArray;
  };
});

// node_modules/bluebird/js/release/context.js
var require_context = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2) {
    var longStackTraces = false;
    var contextStack = [];
    Promise2.prototype._promiseCreated = function() {
    };
    Promise2.prototype._pushContext = function() {
    };
    Promise2.prototype._popContext = function() {
      return null;
    };
    Promise2._peekContext = Promise2.prototype._peekContext = function() {
    };
    function Context() {
      this._trace = new Context.CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function() {
      if (this._trace !== void 0) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
      }
    };
    Context.prototype._popContext = function() {
      if (this._trace !== void 0) {
        var trace = contextStack.pop();
        var ret2 = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret2;
      }
      return null;
    };
    function createContext2() {
      if (longStackTraces)
        return new Context();
    }
    function peekContext() {
      var lastIndex = contextStack.length - 1;
      if (lastIndex >= 0) {
        return contextStack[lastIndex];
      }
      return void 0;
    }
    Context.CapturedTrace = null;
    Context.create = createContext2;
    Context.deactivateLongStackTraces = function() {
    };
    Context.activateLongStackTraces = function() {
      var Promise_pushContext = Promise2.prototype._pushContext;
      var Promise_popContext = Promise2.prototype._popContext;
      var Promise_PeekContext = Promise2._peekContext;
      var Promise_peekContext = Promise2.prototype._peekContext;
      var Promise_promiseCreated = Promise2.prototype._promiseCreated;
      Context.deactivateLongStackTraces = function() {
        Promise2.prototype._pushContext = Promise_pushContext;
        Promise2.prototype._popContext = Promise_popContext;
        Promise2._peekContext = Promise_PeekContext;
        Promise2.prototype._peekContext = Promise_peekContext;
        Promise2.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
      };
      longStackTraces = true;
      Promise2.prototype._pushContext = Context.prototype._pushContext;
      Promise2.prototype._popContext = Context.prototype._popContext;
      Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
      Promise2.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null)
          ctx._promiseCreated = this;
      };
    };
    return Context;
  };
});

// node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, Context) {
    var getDomain = Promise2._getDomain;
    var async2 = Promise2._async;
    var Warning = require_errors().Warning;
    var util54 = require_util();
    var canAttachTrace2 = util54.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util54.env("BLUEBIRD_DEBUG") != 0 && (util54.env("BLUEBIRD_DEBUG") || util54.env("NODE_ENV") === "development"));
    var warnings = !!(util54.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util54.env("BLUEBIRD_WARNINGS")));
    var longStackTraces = !!(util54.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util54.env("BLUEBIRD_LONG_STACK_TRACES")));
    var wForgottenReturn = util54.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util54.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    Promise2.prototype.suppressUnhandledRejections = function() {
      var target = this._target();
      target._bitField = target._bitField & ~1048576 | 524288;
    };
    Promise2.prototype._ensurePossibleRejectionHandled = function() {
      if ((this._bitField & 524288) !== 0)
        return;
      this._setRejectionIsUnhandled();
      async2.invokeLater(this._notifyUnhandledRejection, this, void 0);
    };
    Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
      fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, void 0, this);
    };
    Promise2.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    };
    Promise2.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    };
    Promise2.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
      }
    };
    Promise2.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    };
    Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & ~262144;
    };
    Promise2.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    };
    Promise2.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    };
    Promise2.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & ~1048576;
      if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
      }
    };
    Promise2.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    };
    Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
      return warn(message, shouldUseOwnTrace, promise || this);
    };
    Promise2.onPossiblyUnhandledRejection = function(fn) {
      var domain = getDomain();
      possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util54.domainBind(domain, fn) : void 0;
    };
    Promise2.onUnhandledRejectionHandled = function(fn) {
      var domain = getDomain();
      unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util54.domainBind(domain, fn) : void 0;
    };
    var disableLongStackTraces = function() {
    };
    Promise2.longStackTraces = function() {
      if (async2.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
      }
      if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
          if (async2.haveItemsQueued() && !config.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
          }
          Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
          Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
          Context.deactivateLongStackTraces();
          async2.enableTrampoline();
          config.longStackTraces = false;
        };
        Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async2.disableTrampolineIfNecessary();
      }
    };
    Promise2.hasLongStackTraces = function() {
      return config.longStackTraces && longStackTracesIsSupported();
    };
    var fireDomEvent = function() {
      try {
        if (typeof CustomEvent === "function") {
          var event = new CustomEvent("CustomEvent");
          util54.global.dispatchEvent(event);
          return function(name2, event2) {
            var domEvent = new CustomEvent(name2.toLowerCase(), {
              detail: event2,
              cancelable: true
            });
            return !util54.global.dispatchEvent(domEvent);
          };
        } else if (typeof Event === "function") {
          var event = new Event("CustomEvent");
          util54.global.dispatchEvent(event);
          return function(name2, event2) {
            var domEvent = new Event(name2.toLowerCase(), {
              cancelable: true
            });
            domEvent.detail = event2;
            return !util54.global.dispatchEvent(domEvent);
          };
        } else {
          var event = document.createEvent("CustomEvent");
          event.initCustomEvent("testingtheevent", false, true, {});
          util54.global.dispatchEvent(event);
          return function(name2, event2) {
            var domEvent = document.createEvent("CustomEvent");
            domEvent.initCustomEvent(name2.toLowerCase(), false, true, event2);
            return !util54.global.dispatchEvent(domEvent);
          };
        }
      } catch (e) {
      }
      return function() {
        return false;
      };
    }();
    var fireGlobalEvent = function() {
      if (util54.isNode) {
        return function() {
          return process.emit.apply(process, arguments);
        };
      } else {
        if (!util54.global) {
          return function() {
            return false;
          };
        }
        return function(name2) {
          var methodName = "on" + name2.toLowerCase();
          var method = util54.global[methodName];
          if (!method)
            return false;
          method.apply(util54.global, [].slice.call(arguments, 1));
          return true;
        };
      }
    }();
    function generatePromiseLifecycleEventObject(name2, promise) {
      return {promise};
    }
    var eventToObjectGenerator = {
      promiseCreated: generatePromiseLifecycleEventObject,
      promiseFulfilled: generatePromiseLifecycleEventObject,
      promiseRejected: generatePromiseLifecycleEventObject,
      promiseResolved: generatePromiseLifecycleEventObject,
      promiseCancelled: generatePromiseLifecycleEventObject,
      promiseChained: function(name2, promise, child) {
        return {promise, child};
      },
      warning: function(name2, warning) {
        return {warning};
      },
      unhandledRejection: function(name2, reason, promise) {
        return {reason, promise};
      },
      rejectionHandled: generatePromiseLifecycleEventObject
    };
    var activeFireEvent = function(name2) {
      var globalEventFired = false;
      try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
      } catch (e) {
        async2.throwLater(e);
        globalEventFired = true;
      }
      var domEventFired = false;
      try {
        domEventFired = fireDomEvent(name2, eventToObjectGenerator[name2].apply(null, arguments));
      } catch (e) {
        async2.throwLater(e);
        domEventFired = true;
      }
      return domEventFired || globalEventFired;
    };
    Promise2.config = function(opts) {
      opts = Object(opts);
      if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
          Promise2.longStackTraces();
        } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
          disableLongStackTraces();
        }
      }
      if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;
        if (util54.isObject(warningsOption)) {
          if ("wForgottenReturn" in warningsOption) {
            wForgottenReturn = !!warningsOption.wForgottenReturn;
          }
        }
      }
      if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async2.haveItemsQueued()) {
          throw new Error("cannot enable cancellation after promises are in use");
        }
        Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
        Promise2.prototype._propagateFrom = cancellationPropagateFrom;
        Promise2.prototype._onCancel = cancellationOnCancel;
        Promise2.prototype._setOnCancel = cancellationSetOnCancel;
        Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
        Promise2.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
      }
      if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
          config.monitoring = true;
          Promise2.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
          config.monitoring = false;
          Promise2.prototype._fireEvent = defaultFireEvent;
        }
      }
      return Promise2;
    };
    function defaultFireEvent() {
      return false;
    }
    Promise2.prototype._fireEvent = defaultFireEvent;
    Promise2.prototype._execute = function(executor, resolve3, reject) {
      try {
        executor(resolve3, reject);
      } catch (e) {
        return e;
      }
    };
    Promise2.prototype._onCancel = function() {
    };
    Promise2.prototype._setOnCancel = function(handler2) {
      ;
    };
    Promise2.prototype._attachCancellationCallback = function(onCancel) {
      ;
    };
    Promise2.prototype._captureStackTrace = function() {
    };
    Promise2.prototype._attachExtraTrace = function() {
    };
    Promise2.prototype._clearCancellationData = function() {
    };
    Promise2.prototype._propagateFrom = function(parent, flags) {
      ;
      ;
    };
    function cancellationExecute(executor, resolve3, reject) {
      var promise = this;
      try {
        executor(resolve3, reject, function(onCancel) {
          if (typeof onCancel !== "function") {
            throw new TypeError("onCancel must be a function, got: " + util54.toString(onCancel));
          }
          promise._attachCancellationCallback(onCancel);
        });
      } catch (e) {
        return e;
      }
    }
    function cancellationAttachCancellationCallback(onCancel) {
      if (!this._isCancellable())
        return this;
      var previousOnCancel = this._onCancel();
      if (previousOnCancel !== void 0) {
        if (util54.isArray(previousOnCancel)) {
          previousOnCancel.push(onCancel);
        } else {
          this._setOnCancel([previousOnCancel, onCancel]);
        }
      } else {
        this._setOnCancel(onCancel);
      }
    }
    function cancellationOnCancel() {
      return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
      this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
      this._cancellationParent = void 0;
      this._onCancelField = void 0;
    }
    function cancellationPropagateFrom(parent, flags) {
      if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === void 0) {
          branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
      }
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    function bindingPropagateFrom(parent, flags) {
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    var propagateFromFunction = bindingPropagateFrom;
    function boundValueFunction() {
      var ret2 = this._boundTo;
      if (ret2 !== void 0) {
        if (ret2 instanceof Promise2) {
          if (ret2.isFulfilled()) {
            return ret2.value();
          } else {
            return void 0;
          }
        }
      }
      return ret2;
    }
    function longStackTracesCaptureStackTrace() {
      this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error, ignoreSelf) {
      if (canAttachTrace2(error)) {
        var trace = this._trace;
        if (trace !== void 0) {
          if (ignoreSelf)
            trace = trace._parent;
        }
        if (trace !== void 0) {
          trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
          var parsed = parseStackAndMessage(error);
          util54.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
          util54.notEnumerableProp(error, "__stackCleaned__", true);
        }
      }
    }
    function checkForgottenReturns(returnValue, promiseCreated, name2, promise, parent) {
      if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
        if (parent !== void 0 && parent._returnedNonUndefined())
          return;
        if ((promise._bitField & 65535) === 0)
          return;
        if (name2)
          name2 = name2 + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
          var traceLines = promiseCreated._trace.stack.split("\n");
          var stack = cleanStack(traceLines);
          for (var i = stack.length - 1; i >= 0; --i) {
            var line = stack[i];
            if (!nodeFramePattern.test(line)) {
              var lineMatches = line.match(parseLinePattern);
              if (lineMatches) {
                handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
              }
              break;
            }
          }
          if (stack.length > 0) {
            var firstUserLine = stack[0];
            for (var i = 0; i < traceLines.length; ++i) {
              if (traceLines[i] === firstUserLine) {
                if (i > 0) {
                  creatorLine = "\n" + traceLines[i - 1];
                }
                break;
              }
            }
          }
        }
        var msg = "a promise was created in a " + name2 + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
        promise._warn(msg, true, promiseCreated);
      }
    }
    function deprecated(name2, replacement) {
      var message = name2 + " is deprecated and will be removed in a future version.";
      if (replacement)
        message += " Use " + replacement + " instead.";
      return warn(message);
    }
    function warn(message, shouldUseOwnTrace, promise) {
      if (!config.warnings)
        return;
      var warning = new Warning(message);
      var ctx;
      if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
      } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
        ctx.attachExtraTrace(warning);
      } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
      }
      if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
      }
    }
    function reconstructStack(message, stacks) {
      for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
      }
      if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
      }
      return message + "\n" + stacks.join("\n");
    }
    function removeDuplicateOrEmptyJumps(stacks) {
      for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
          stacks.splice(i, 1);
          i--;
        }
      }
    }
    function removeCommonRoots(stacks) {
      var current = stacks[0];
      for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;
        for (var j = prev.length - 1; j >= 0; --j) {
          if (prev[j] === currentLastLine) {
            commonRootMeetPoint = j;
            break;
          }
        }
        for (var j = commonRootMeetPoint; j >= 0; --j) {
          var line = prev[j];
          if (current[currentLastIndex] === line) {
            current.pop();
            currentLastIndex--;
          } else {
            break;
          }
        }
        current = prev;
      }
    }
    function cleanStack(stack) {
      var ret2 = [];
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = line === "    (No stack trace)" || stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
          if (indentStackFrames && line.charAt(0) !== " ") {
            line = "    " + line;
          }
          ret2.push(line);
        }
      }
      return ret2;
    }
    function stackFramesAsArray(error) {
      var stack = error.stack.replace(/\s+$/g, "").split("\n");
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if (line === "    (No stack trace)" || stackFramePattern.test(line)) {
          break;
        }
      }
      if (i > 0 && error.name != "SyntaxError") {
        stack = stack.slice(i);
      }
      return stack;
    }
    function parseStackAndMessage(error) {
      var stack = error.stack;
      var message = error.toString();
      stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
      return {
        message,
        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
      };
    }
    function formatAndLogError(error, title, isSoft) {
      if (typeof console !== "undefined") {
        var message;
        if (util54.isObject(error)) {
          var stack = error.stack;
          message = title + formatStack(stack, error);
        } else {
          message = title + String(error);
        }
        if (typeof printWarning === "function") {
          printWarning(message, isSoft);
        } else if (typeof console.log === "function" || typeof console.log === "object") {
          console.log(message);
        }
      }
    }
    function fireRejectionEvent(name2, localHandler, reason, promise) {
      var localEventFired = false;
      try {
        if (typeof localHandler === "function") {
          localEventFired = true;
          if (name2 === "rejectionHandled") {
            localHandler(promise);
          } else {
            localHandler(reason, promise);
          }
        }
      } catch (e) {
        async2.throwLater(e);
      }
      if (name2 === "unhandledRejection") {
        if (!activeFireEvent(name2, reason, promise) && !localEventFired) {
          formatAndLogError(reason, "Unhandled rejection ");
        }
      } else {
        activeFireEvent(name2, promise);
      }
    }
    function formatNonError(obj) {
      var str;
      if (typeof obj === "function") {
        str = "[function " + (obj.name || "anonymous") + "]";
      } else {
        str = obj && typeof obj.toString === "function" ? obj.toString() : util54.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
          try {
            var newStr = JSON.stringify(obj);
            str = newStr;
          } catch (e) {
          }
        }
        if (str.length === 0) {
          str = "(empty array)";
        }
      }
      return "(<" + snip(str) + ">, no stack trace)";
    }
    function snip(str) {
      var maxChars = 41;
      if (str.length < maxChars) {
        return str;
      }
      return str.substr(0, maxChars - 3) + "...";
    }
    function longStackTracesIsSupported() {
      return typeof captureStackTrace === "function";
    }
    var shouldIgnore = function() {
      return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
      var matches = line.match(parseLineInfoRegex);
      if (matches) {
        return {
          fileName: matches[1],
          line: parseInt(matches[2], 10)
        };
      }
    }
    function setBounds(firstLineError, lastLineError) {
      if (!longStackTracesIsSupported())
        return;
      var firstStackLines = firstLineError.stack.split("\n");
      var lastStackLines = lastLineError.stack.split("\n");
      var firstIndex = -1;
      var lastIndex = -1;
      var firstFileName;
      var lastFileName;
      for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
          firstFileName = result.fileName;
          firstIndex = result.line;
          break;
        }
      }
      for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
          lastFileName = result.fileName;
          lastIndex = result.line;
          break;
        }
      }
      if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
      }
      shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line))
          return true;
        var info = parseLineInfo(line);
        if (info) {
          if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
            return true;
          }
        }
        return false;
      };
    }
    function CapturedTrace(parent) {
      this._parent = parent;
      this._promisesCreated = 0;
      var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
      captureStackTrace(this, CapturedTrace);
      if (length > 32)
        this.uncycle();
    }
    util54.inherits(CapturedTrace, Error);
    Context.CapturedTrace = CapturedTrace;
    CapturedTrace.prototype.uncycle = function() {
      var length = this._length;
      if (length < 2)
        return;
      var nodes = [];
      var stackToIndex = {};
      for (var i = 0, node = this; node !== void 0; ++i) {
        nodes.push(node);
        node = node._parent;
      }
      length = this._length = i;
      for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === void 0) {
          stackToIndex[stack] = i;
        }
      }
      for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== void 0 && index !== i) {
          if (index > 0) {
            nodes[index - 1]._parent = void 0;
            nodes[index - 1]._length = 1;
          }
          nodes[i]._parent = void 0;
          nodes[i]._length = 1;
          var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
          if (index < length - 1) {
            cycleEdgeNode._parent = nodes[index + 1];
            cycleEdgeNode._parent.uncycle();
            cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
          } else {
            cycleEdgeNode._parent = void 0;
            cycleEdgeNode._length = 1;
          }
          var currentChildLength = cycleEdgeNode._length + 1;
          for (var j = i - 2; j >= 0; --j) {
            nodes[j]._length = currentChildLength;
            currentChildLength++;
          }
          return;
        }
      }
    };
    CapturedTrace.prototype.attachExtraTrace = function(error) {
      if (error.__stackCleaned__)
        return;
      this.uncycle();
      var parsed = parseStackAndMessage(error);
      var message = parsed.message;
      var stacks = [parsed.stack];
      var trace = this;
      while (trace !== void 0) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
      }
      removeCommonRoots(stacks);
      removeDuplicateOrEmptyJumps(stacks);
      util54.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
      util54.notEnumerableProp(error, "__stackCleaned__", true);
    };
    var captureStackTrace = function stackDetection() {
      var v8stackFramePattern = /^\s*at\s*/;
      var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string")
          return stack;
        if (error.name !== void 0 && error.message !== void 0) {
          return error.toString();
        }
        return formatNonError(error);
      };
      if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace2 = Error.captureStackTrace;
        shouldIgnore = function(line) {
          return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
          Error.stackTraceLimit += 6;
          captureStackTrace2(receiver, ignoreUntil);
          Error.stackTraceLimit -= 6;
        };
      }
      var err = new Error();
      if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace3(o) {
          o.stack = new Error().stack;
        };
      }
      var hasStackAfterThrow;
      try {
        throw new Error();
      } catch (e) {
        hasStackAfterThrow = "stack" in e;
      }
      if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace3(o) {
          Error.stackTraceLimit += 6;
          try {
            throw new Error();
          } catch (e) {
            o.stack = e.stack;
          }
          Error.stackTraceLimit -= 6;
        };
      }
      formatStack = function(stack, error) {
        if (typeof stack === "string")
          return stack;
        if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
          return error.toString();
        }
        return formatNonError(error);
      };
      return null;
    }([]);
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
      printWarning = function(message) {
        console.warn(message);
      };
      if (util54.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
          var color = isSoft ? "[33m" : "[31m";
          console.warn(color + message + "[0m\n");
        };
      } else if (!util54.isNode && typeof new Error().stack === "string") {
        printWarning = function(message, isSoft) {
          console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
        };
      }
    }
    var config = {
      warnings,
      longStackTraces: false,
      cancellation: false,
      monitoring: false
    };
    if (longStackTraces)
      Promise2.longStackTraces();
    return {
      longStackTraces: function() {
        return config.longStackTraces;
      },
      warnings: function() {
        return config.warnings;
      },
      cancellation: function() {
        return config.cancellation;
      },
      monitoring: function() {
        return config.monitoring;
      },
      propagateFromFunction: function() {
        return propagateFromFunction;
      },
      boundValueFunction: function() {
        return boundValueFunction;
      },
      checkForgottenReturns,
      setBounds,
      warn,
      deprecated,
      CapturedTrace,
      fireDomEvent,
      fireGlobalEvent
    };
  };
});

// node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, tryConvertToPromise) {
    var util54 = require_util();
    var CancellationError = Promise2.CancellationError;
    var errorObj2 = util54.errorObj;
    function PassThroughHandlerContext(promise, type, handler2) {
      this.promise = promise;
      this.type = type;
      this.handler = handler2;
      this.called = false;
      this.cancelPromise = null;
    }
    PassThroughHandlerContext.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function FinallyHandlerCancelReaction(finallyHandler2) {
      this.finallyHandler = finallyHandler2;
    }
    FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
      checkCancel(this.finallyHandler);
    };
    function checkCancel(ctx, reason) {
      if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
          ctx.cancelPromise._reject(reason);
        } else {
          ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
      }
      return false;
    }
    function succeed() {
      return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
      if (checkCancel(this, reason))
        return;
      errorObj2.e = reason;
      return errorObj2;
    }
    function finallyHandler(reasonOrValue) {
      var promise = this.promise;
      var handler2 = this.handler;
      if (!this.called) {
        this.called = true;
        var ret2 = this.isFinallyHandler() ? handler2.call(promise._boundValue()) : handler2.call(promise._boundValue(), reasonOrValue);
        if (ret2 !== void 0) {
          promise._setReturnedNonUndefined();
          var maybePromise = tryConvertToPromise(ret2, promise);
          if (maybePromise instanceof Promise2) {
            if (this.cancelPromise != null) {
              if (maybePromise._isCancelled()) {
                var reason = new CancellationError("late cancellation observer");
                promise._attachExtraTrace(reason);
                errorObj2.e = reason;
                return errorObj2;
              } else if (maybePromise.isPending()) {
                maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
              }
            }
            return maybePromise._then(succeed, fail, void 0, this, void 0);
          }
        }
      }
      if (promise.isRejected()) {
        checkCancel(this);
        errorObj2.e = reasonOrValue;
        return errorObj2;
      } else {
        checkCancel(this);
        return reasonOrValue;
      }
    }
    Promise2.prototype._passThrough = function(handler2, type, success, fail2) {
      if (typeof handler2 !== "function")
        return this.then();
      return this._then(success, fail2, void 0, new PassThroughHandlerContext(this, type, handler2), void 0);
    };
    Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler2) {
      return this._passThrough(handler2, 0, finallyHandler, finallyHandler);
    };
    Promise2.prototype.tap = function(handler2) {
      return this._passThrough(handler2, 1, finallyHandler);
    };
    return PassThroughHandlerContext;
  };
});

// node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(NEXT_FILTER) {
    var util54 = require_util();
    var getKeys2 = require_es5().keys;
    var tryCatch2 = util54.tryCatch;
    var errorObj2 = util54.errorObj;
    function catchFilter(instances, cb, promise) {
      return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop:
          for (var i = 0; i < instances.length; ++i) {
            var item = instances[i];
            if (item === Error || item != null && item.prototype instanceof Error) {
              if (e instanceof item) {
                return tryCatch2(cb).call(boundTo, e);
              }
            } else if (typeof item === "function") {
              var matchesPredicate = tryCatch2(item).call(boundTo, e);
              if (matchesPredicate === errorObj2) {
                return matchesPredicate;
              } else if (matchesPredicate) {
                return tryCatch2(cb).call(boundTo, e);
              }
            } else if (util54.isObject(e)) {
              var keys = getKeys2(item);
              for (var j = 0; j < keys.length; ++j) {
                var key = keys[j];
                if (item[key] != e[key]) {
                  continue predicateLoop;
                }
              }
              return tryCatch2(cb).call(boundTo, e);
            }
          }
        return NEXT_FILTER;
      };
    }
    return catchFilter;
  };
});

// node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS((exports2, module2) => {
  "use strict";
  var util54 = require_util();
  var maybeWrapAsError2 = util54.maybeWrapAsError;
  var errors = require_errors();
  var OperationalError = errors.OperationalError;
  var es52 = require_es5();
  function isUntypedError(obj) {
    return obj instanceof Error && es52.getPrototypeOf(obj) === Error.prototype;
  }
  var rErrorKey = /^(?:name|message|stack|cause)$/;
  function wrapAsOperationalError(obj) {
    var ret2;
    if (isUntypedError(obj)) {
      ret2 = new OperationalError(obj);
      ret2.name = obj.name;
      ret2.message = obj.message;
      ret2.stack = obj.stack;
      var keys = es52.keys(obj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!rErrorKey.test(key)) {
          ret2[key] = obj[key];
        }
      }
      return ret2;
    }
    util54.markAsOriginatingFromRejection(obj);
    return obj;
  }
  function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
      if (promise === null)
        return;
      if (err) {
        var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
        promise._attachExtraTrace(wrapped);
        promise._reject(wrapped);
      } else if (!multiArgs) {
        promise._fulfill(value);
      } else {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        ;
        promise._fulfill(args);
      }
      promise = null;
    };
  }
  module2.exports = nodebackForPromise;
});

// node_modules/bluebird/js/release/method.js
var require_method = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util54 = require_util();
    var tryCatch2 = util54.tryCatch;
    Promise2.method = function(fn) {
      if (typeof fn !== "function") {
        throw new Promise2.TypeError("expecting a function but got " + util54.classString(fn));
      }
      return function() {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._pushContext();
        var value = tryCatch2(fn).apply(this, arguments);
        var promiseCreated = ret2._popContext();
        debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret2);
        ret2._resolveFromSyncValue(value);
        return ret2;
      };
    };
    Promise2.attempt = Promise2["try"] = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util54.classString(fn));
      }
      var ret2 = new Promise2(INTERNAL);
      ret2._captureStackTrace();
      ret2._pushContext();
      var value;
      if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util54.isArray(arg) ? tryCatch2(fn).apply(ctx, arg) : tryCatch2(fn).call(ctx, arg);
      } else {
        value = tryCatch2(fn)();
      }
      var promiseCreated = ret2._popContext();
      debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret2);
      ret2._resolveFromSyncValue(value);
      return ret2;
    };
    Promise2.prototype._resolveFromSyncValue = function(value) {
      if (value === util54.errorObj) {
        this._rejectCallback(value.e, false);
      } else {
        this._resolveCallback(value, true);
      }
    };
  };
});

// node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = false;
    var rejectThis = function(_, e) {
      this._reject(e);
    };
    var targetRejected = function(e, context) {
      context.promiseRejectionQueued = true;
      context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    var bindingResolved = function(thisArg, context) {
      if ((this._bitField & 50397184) === 0) {
        this._resolveCallback(context.target);
      }
    };
    var bindingRejected = function(e, context) {
      if (!context.promiseRejectionQueued)
        this._reject(e);
    };
    Promise2.prototype.bind = function(thisArg) {
      if (!calledBind) {
        calledBind = true;
        Promise2.prototype._propagateFrom = debug.propagateFromFunction();
        Promise2.prototype._boundValue = debug.boundValueFunction();
      }
      var maybePromise = tryConvertToPromise(thisArg);
      var ret2 = new Promise2(INTERNAL);
      ret2._propagateFrom(this, 1);
      var target = this._target();
      ret2._setBoundTo(maybePromise);
      if (maybePromise instanceof Promise2) {
        var context = {
          promiseRejectionQueued: false,
          promise: ret2,
          target,
          bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, void 0, ret2, context);
        maybePromise._then(bindingResolved, bindingRejected, void 0, ret2, context);
        ret2._setOnCancel(maybePromise);
      } else {
        ret2._resolveCallback(target);
      }
      return ret2;
    };
    Promise2.prototype._setBoundTo = function(obj) {
      if (obj !== void 0) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
      } else {
        this._bitField = this._bitField & ~2097152;
      }
    };
    Promise2.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    };
    Promise2.bind = function(thisArg, value) {
      return Promise2.resolve(value).bind(thisArg);
    };
  };
});

// node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, PromiseArray, apiRejection, debug) {
    var util54 = require_util();
    var tryCatch2 = util54.tryCatch;
    var errorObj2 = util54.errorObj;
    var async2 = Promise2._async;
    Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
      if (!debug.cancellation())
        return this._warn("cancellation is disabled");
      var promise = this;
      var child = promise;
      while (promise._isCancellable()) {
        if (!promise._cancelBy(child)) {
          if (child._isFollowing()) {
            child._followee().cancel();
          } else {
            child._cancelBranched();
          }
          break;
        }
        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
          if (promise._isFollowing()) {
            promise._followee().cancel();
          } else {
            promise._cancelBranched();
          }
          break;
        } else {
          if (promise._isFollowing())
            promise._followee().cancel();
          promise._setWillBeCancelled();
          child = promise;
          promise = parent;
        }
      }
    };
    Promise2.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    };
    Promise2.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
    };
    Promise2.prototype._cancelBy = function(canceller) {
      if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
      } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
          this._invokeOnCancel();
          return true;
        }
      }
      return false;
    };
    Promise2.prototype._cancelBranched = function() {
      if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
      }
    };
    Promise2.prototype._cancel = function() {
      if (!this._isCancellable())
        return;
      this._setCancelled();
      async2.invoke(this._cancelPromises, this, void 0);
    };
    Promise2.prototype._cancelPromises = function() {
      if (this._length() > 0)
        this._settlePromises();
    };
    Promise2.prototype._unsetOnCancel = function() {
      this._onCancelField = void 0;
    };
    Promise2.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    };
    Promise2.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    };
    Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
      if (util54.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
          this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
      } else if (onCancelCallback !== void 0) {
        if (typeof onCancelCallback === "function") {
          if (!internalOnly) {
            var e = tryCatch2(onCancelCallback).call(this._boundValue());
            if (e === errorObj2) {
              this._attachExtraTrace(e.e);
              async2.throwLater(e.e);
            }
          }
        } else {
          onCancelCallback._resultCancelled(this);
        }
      }
    };
    Promise2.prototype._invokeOnCancel = function() {
      var onCancelCallback = this._onCancel();
      this._unsetOnCancel();
      async2.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };
    Promise2.prototype._invokeInternalOnCancel = function() {
      if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
      }
    };
    Promise2.prototype._resultCancelled = function() {
      this.cancel();
    };
  };
});

// node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2) {
    function returner() {
      return this.value;
    }
    function thrower2() {
      throw this.reason;
    }
    Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
      if (value instanceof Promise2)
        value.suppressUnhandledRejections();
      return this._then(returner, void 0, void 0, {value}, void 0);
    };
    Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
      return this._then(thrower2, void 0, void 0, {reason}, void 0);
    };
    Promise2.prototype.catchThrow = function(reason) {
      if (arguments.length <= 1) {
        return this._then(void 0, thrower2, void 0, {reason}, void 0);
      } else {
        var _reason = arguments[1];
        var handler2 = function() {
          throw _reason;
        };
        return this.caught(reason, handler2);
      }
    };
    Promise2.prototype.catchReturn = function(value) {
      if (arguments.length <= 1) {
        if (value instanceof Promise2)
          value.suppressUnhandledRejections();
        return this._then(void 0, returner, void 0, {value}, void 0);
      } else {
        var _value = arguments[1];
        if (_value instanceof Promise2)
          _value.suppressUnhandledRejections();
        var handler2 = function() {
          return _value;
        };
        return this.caught(value, handler2);
      }
    };
  };
});

// node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2) {
    function PromiseInspection(promise) {
      if (promise !== void 0) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
      } else {
        this._bitField = 0;
        this._settledValueField = void 0;
      }
    }
    PromiseInspection.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
      if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
      if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    };
    var isRejected = PromiseInspection.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    };
    var isPending = PromiseInspection.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    };
    var isResolved = PromiseInspection.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    PromiseInspection.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    };
    Promise2.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    };
    Promise2.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    };
    Promise2.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    };
    Promise2.prototype.isPending = function() {
      return isPending.call(this._target());
    };
    Promise2.prototype.isRejected = function() {
      return isRejected.call(this._target());
    };
    Promise2.prototype.isFulfilled = function() {
      return isFulfilled.call(this._target());
    };
    Promise2.prototype.isResolved = function() {
      return isResolved.call(this._target());
    };
    Promise2.prototype.value = function() {
      return value.call(this._target());
    };
    Promise2.prototype.reason = function() {
      var target = this._target();
      target._unsetRejectionIsUnhandled();
      return reason.call(target);
    };
    Promise2.prototype._value = function() {
      return this._settledValue();
    };
    Promise2.prototype._reason = function() {
      this._unsetRejectionIsUnhandled();
      return this._settledValue();
    };
    Promise2.PromiseInspection = PromiseInspection;
  };
});

// node_modules/bluebird/js/release/join.js
var require_join = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async2, getDomain) {
    var util54 = require_util();
    var canEvaluate2 = util54.canEvaluate;
    var tryCatch2 = util54.tryCatch;
    var errorObj2 = util54.errorObj;
    var reject;
    if (true) {
      if (canEvaluate2) {
        var thenCallback = function(i2) {
          return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
        };
        var promiseSetter = function(i2) {
          return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i2));
        };
        var generateHolderClass = function(total) {
          var props = new Array(total);
          for (var i2 = 0; i2 < props.length; ++i2) {
            props[i2] = "this.p" + (i2 + 1);
          }
          var assignment = props.join(" = ") + " = null;";
          var cancellationCode = "var promise;\n" + props.map(function(prop) {
            return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
          }).join("\n");
          var passedArguments = props.join(", ");
          var name2 = "Holder$" + total;
          var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
          code = code.replace(/\[TheName\]/g, name2).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
          return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async2);
        };
        var holderClasses = [];
        var thenCallbacks = [];
        var promiseSetters = [];
        for (var i = 0; i < 8; ++i) {
          holderClasses.push(generateHolderClass(i + 1));
          thenCallbacks.push(thenCallback(i + 1));
          promiseSetters.push(promiseSetter(i + 1));
        }
        reject = function(reason) {
          this._reject(reason);
        };
      }
    }
    Promise2.join = function() {
      var last = arguments.length - 1;
      var fn;
      if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (true) {
          if (last <= 8 && canEvaluate2) {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            var HolderClass = holderClasses[last - 1];
            var holder = new HolderClass(fn);
            var callbacks = thenCallbacks;
            for (var i2 = 0; i2 < last; ++i2) {
              var maybePromise = tryConvertToPromise(arguments[i2], ret2);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                ;
                if ((bitField & 50397184) === 0) {
                  maybePromise._then(callbacks[i2], reject, void 0, ret2, holder);
                  promiseSetters[i2](maybePromise, holder);
                  holder.asyncNeeded = false;
                } else if ((bitField & 33554432) !== 0) {
                  callbacks[i2].call(ret2, maybePromise._value(), holder);
                } else if ((bitField & 16777216) !== 0) {
                  ret2._reject(maybePromise._reason());
                } else {
                  ret2._cancel();
                }
              } else {
                callbacks[i2].call(ret2, maybePromise, holder);
              }
            }
            if (!ret2._isFateSealed()) {
              if (holder.asyncNeeded) {
                var domain = getDomain();
                if (domain !== null) {
                  holder.fn = util54.domainBind(domain, holder.fn);
                }
              }
              ret2._setAsyncGuaranteed();
              ret2._setOnCancel(holder);
            }
            return ret2;
          }
        }
      }
      var $_len = arguments.length;
      var args = new Array($_len);
      for (var $_i = 0; $_i < $_len; ++$_i) {
        args[$_i] = arguments[$_i];
      }
      ;
      if (fn)
        args.pop();
      var ret2 = new PromiseArray(args).promise();
      return fn !== void 0 ? ret2.spread(fn) : ret2;
    };
  };
});

// node_modules/bluebird/js/release/map.js
var require_map = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise2._getDomain;
    var util54 = require_util();
    var tryCatch2 = util54.tryCatch;
    var errorObj2 = util54.errorObj;
    var async2 = Promise2._async;
    function MappingPromiseArray(promises, fn, limit, _filter) {
      this.constructor$(promises);
      this._promise._captureStackTrace();
      var domain = getDomain();
      this._callback = domain === null ? fn : util54.domainBind(domain, fn);
      this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
      this._limit = limit;
      this._inFlight = 0;
      this._queue = [];
      async2.invoke(this._asyncInit, this, void 0);
    }
    util54.inherits(MappingPromiseArray, PromiseArray);
    MappingPromiseArray.prototype._asyncInit = function() {
      this._init$(void 0, -2);
    };
    MappingPromiseArray.prototype._init = function() {
    };
    MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var values = this._values;
      var length = this.length();
      var preservedValues = this._preservedValues;
      var limit = this._limit;
      if (index < 0) {
        index = index * -1 - 1;
        values[index] = value;
        if (limit >= 1) {
          this._inFlight--;
          this._drainQueue();
          if (this._isResolved())
            return true;
        }
      } else {
        if (limit >= 1 && this._inFlight >= limit) {
          values[index] = value;
          this._queue.push(index);
          return false;
        }
        if (preservedValues !== null)
          preservedValues[index] = value;
        var promise = this._promise;
        var callback = this._callback;
        var receiver = promise._boundValue();
        promise._pushContext();
        var ret2 = tryCatch2(callback).call(receiver, value, index, length);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret2, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
        if (ret2 === errorObj2) {
          this._reject(ret2.e);
          return true;
        }
        var maybePromise = tryConvertToPromise(ret2, this._promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          ;
          if ((bitField & 50397184) === 0) {
            if (limit >= 1)
              this._inFlight++;
            values[index] = maybePromise;
            maybePromise._proxy(this, (index + 1) * -1);
            return false;
          } else if ((bitField & 33554432) !== 0) {
            ret2 = maybePromise._value();
          } else if ((bitField & 16777216) !== 0) {
            this._reject(maybePromise._reason());
            return true;
          } else {
            this._cancel();
            return true;
          }
        }
        values[index] = ret2;
      }
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= length) {
        if (preservedValues !== null) {
          this._filter(values, preservedValues);
        } else {
          this._resolve(values);
        }
        return true;
      }
      return false;
    };
    MappingPromiseArray.prototype._drainQueue = function() {
      var queue = this._queue;
      var limit = this._limit;
      var values = this._values;
      while (queue.length > 0 && this._inFlight < limit) {
        if (this._isResolved())
          return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
      }
    };
    MappingPromiseArray.prototype._filter = function(booleans, values) {
      var len = values.length;
      var ret2 = new Array(len);
      var j = 0;
      for (var i = 0; i < len; ++i) {
        if (booleans[i])
          ret2[j++] = values[i];
      }
      ret2.length = j;
      this._resolve(ret2);
    };
    MappingPromiseArray.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function map(promises, fn, options, _filter) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util54.classString(fn));
      }
      var limit = 0;
      if (options !== void 0) {
        if (typeof options === "object" && options !== null) {
          if (typeof options.concurrency !== "number") {
            return Promise2.reject(new TypeError("'concurrency' must be a number but it is " + util54.classString(options.concurrency)));
          }
          limit = options.concurrency;
        } else {
          return Promise2.reject(new TypeError("options argument must be an object but it is " + util54.classString(options)));
        }
      }
      limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
      return new MappingPromiseArray(promises, fn, limit, _filter).promise();
    }
    Promise2.prototype.map = function(fn, options) {
      return map(this, fn, options, null);
    };
    Promise2.map = function(promises, fn, options, _filter) {
      return map(promises, fn, options, _filter);
    };
  };
});

// node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS((exports2, module2) => {
  "use strict";
  var cr = Object.create;
  if (cr) {
    callerCache = cr(null);
    getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
  }
  var callerCache;
  var getterCache;
  module2.exports = function(Promise2) {
    var util54 = require_util();
    var canEvaluate2 = util54.canEvaluate;
    var isIdentifier2 = util54.isIdentifier;
    var getMethodCaller;
    var getGetter;
    if (true) {
      var makeMethodCaller = function(methodName) {
        return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
      };
      var makeGetter = function(propertyName) {
        return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
      };
      var getCompiled = function(name2, compiler, cache) {
        var ret2 = cache[name2];
        if (typeof ret2 !== "function") {
          if (!isIdentifier2(name2)) {
            return null;
          }
          ret2 = compiler(name2);
          cache[name2] = ret2;
          cache[" size"]++;
          if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i)
              delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
          }
        }
        return ret2;
      };
      getMethodCaller = function(name2) {
        return getCompiled(name2, makeMethodCaller, callerCache);
      };
      getGetter = function(name2) {
        return getCompiled(name2, makeGetter, getterCache);
      };
    }
    function ensureMethod(obj, methodName) {
      var fn;
      if (obj != null)
        fn = obj[methodName];
      if (typeof fn !== "function") {
        var message = "Object " + util54.classString(obj) + " has no method '" + util54.toString(methodName) + "'";
        throw new Promise2.TypeError(message);
      }
      return fn;
    }
    function caller(obj) {
      var methodName = this.pop();
      var fn = ensureMethod(obj, methodName);
      return fn.apply(obj, this);
    }
    Promise2.prototype.call = function(methodName) {
      var $_len = arguments.length;
      var args = new Array(Math.max($_len - 1, 0));
      for (var $_i = 1; $_i < $_len; ++$_i) {
        args[$_i - 1] = arguments[$_i];
      }
      ;
      if (true) {
        if (canEvaluate2) {
          var maybeCaller = getMethodCaller(methodName);
          if (maybeCaller !== null) {
            return this._then(maybeCaller, void 0, void 0, args, void 0);
          }
        }
      }
      args.push(methodName);
      return this._then(caller, void 0, void 0, args, void 0);
    };
    function namedGetter(obj) {
      return obj[this];
    }
    function indexedGetter(obj) {
      var index = +this;
      if (index < 0)
        index = Math.max(0, index + obj.length);
      return obj[index];
    }
    Promise2.prototype.get = function(propertyName) {
      var isIndex = typeof propertyName === "number";
      var getter;
      if (!isIndex) {
        if (canEvaluate2) {
          var maybeGetter = getGetter(propertyName);
          getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
          getter = namedGetter;
        }
      } else {
        getter = indexedGetter;
      }
      return this._then(getter, void 0, void 0, propertyName, void 0);
    };
  };
});

// node_modules/bluebird/js/release/using.js
var require_using = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext2, INTERNAL, debug) {
    var util54 = require_util();
    var TypeError2 = require_errors().TypeError;
    var inherits2 = require_util().inherits;
    var errorObj2 = util54.errorObj;
    var tryCatch2 = util54.tryCatch;
    var NULL = {};
    function thrower2(e) {
      setTimeout(function() {
        throw e;
      }, 0);
    }
    function castPreservingDisposable(thenable) {
      var maybePromise = tryConvertToPromise(thenable);
      if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
        maybePromise._setDisposable(thenable._getDisposer());
      }
      return maybePromise;
    }
    function dispose(resources, inspection) {
      var i = 0;
      var len = resources.length;
      var ret2 = new Promise2(INTERNAL);
      function iterator() {
        if (i >= len)
          return ret2._fulfill();
        var maybePromise = castPreservingDisposable(resources[i++]);
        if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
          try {
            maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
          } catch (e) {
            return thrower2(e);
          }
          if (maybePromise instanceof Promise2) {
            return maybePromise._then(iterator, thrower2, null, null, null);
          }
        }
        iterator();
      }
      iterator();
      return ret2;
    }
    function Disposer(data, promise, context) {
      this._data = data;
      this._promise = promise;
      this._context = context;
    }
    Disposer.prototype.data = function() {
      return this._data;
    };
    Disposer.prototype.promise = function() {
      return this._promise;
    };
    Disposer.prototype.resource = function() {
      if (this.promise().isFulfilled()) {
        return this.promise().value();
      }
      return NULL;
    };
    Disposer.prototype.tryDispose = function(inspection) {
      var resource = this.resource();
      var context = this._context;
      if (context !== void 0)
        context._pushContext();
      var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
      if (context !== void 0)
        context._popContext();
      this._promise._unsetDisposable();
      this._data = null;
      return ret2;
    };
    Disposer.isDisposer = function(d) {
      return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };
    function FunctionDisposer(fn, promise, context) {
      this.constructor$(fn, promise, context);
    }
    inherits2(FunctionDisposer, Disposer);
    FunctionDisposer.prototype.doDispose = function(resource, inspection) {
      var fn = this.data();
      return fn.call(resource, resource, inspection);
    };
    function maybeUnwrapDisposer(value) {
      if (Disposer.isDisposer(value)) {
        this.resources[this.index]._setDisposable(value);
        return value.promise();
      }
      return value;
    }
    function ResourceList(length) {
      this.length = length;
      this.promise = null;
      this[length - 1] = null;
    }
    ResourceList.prototype._resultCancelled = function() {
      var len = this.length;
      for (var i = 0; i < len; ++i) {
        var item = this[i];
        if (item instanceof Promise2) {
          item.cancel();
        }
      }
    };
    Promise2.using = function() {
      var len = arguments.length;
      if (len < 2)
        return apiRejection("you must pass at least 2 arguments to Promise.using");
      var fn = arguments[len - 1];
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util54.classString(fn));
      }
      var input;
      var spreadArgs = true;
      if (len === 2 && Array.isArray(arguments[0])) {
        input = arguments[0];
        len = input.length;
        spreadArgs = false;
      } else {
        input = arguments;
        len--;
      }
      var resources = new ResourceList(len);
      for (var i = 0; i < len; ++i) {
        var resource = input[i];
        if (Disposer.isDisposer(resource)) {
          var disposer = resource;
          resource = resource.promise();
          resource._setDisposable(disposer);
        } else {
          var maybePromise = tryConvertToPromise(resource);
          if (maybePromise instanceof Promise2) {
            resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
              resources,
              index: i
            }, void 0);
          }
        }
        resources[i] = resource;
      }
      var reflectedResources = new Array(resources.length);
      for (var i = 0; i < reflectedResources.length; ++i) {
        reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
      }
      var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
        for (var i2 = 0; i2 < inspections.length; ++i2) {
          var inspection = inspections[i2];
          if (inspection.isRejected()) {
            errorObj2.e = inspection.error();
            return errorObj2;
          } else if (!inspection.isFulfilled()) {
            resultPromise.cancel();
            return;
          }
          inspections[i2] = inspection.value();
        }
        promise._pushContext();
        fn = tryCatch2(fn);
        var ret2 = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret2, promiseCreated, "Promise.using", promise);
        return ret2;
      });
      var promise = resultPromise.lastly(function() {
        var inspection = new Promise2.PromiseInspection(resultPromise);
        return dispose(resources, inspection);
      });
      resources.promise = promise;
      promise._setOnCancel(resources);
      return promise;
    };
    Promise2.prototype._setDisposable = function(disposer) {
      this._bitField = this._bitField | 131072;
      this._disposer = disposer;
    };
    Promise2.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    };
    Promise2.prototype._getDisposer = function() {
      return this._disposer;
    };
    Promise2.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & ~131072;
      this._disposer = void 0;
    };
    Promise2.prototype.disposer = function(fn) {
      if (typeof fn === "function") {
        return new FunctionDisposer(fn, this, createContext2());
      }
      throw new TypeError2();
    };
  };
});

// node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, INTERNAL, debug) {
    var util54 = require_util();
    var TimeoutError = Promise2.TimeoutError;
    function HandleWrapper(handle) {
      this.handle = handle;
    }
    HandleWrapper.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var afterValue = function(value) {
      return delay(+this).thenReturn(value);
    };
    var delay = Promise2.delay = function(ms, value) {
      var ret2;
      var handle;
      if (value !== void 0) {
        ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
        if (debug.cancellation() && value instanceof Promise2) {
          ret2._setOnCancel(value);
        }
      } else {
        ret2 = new Promise2(INTERNAL);
        handle = setTimeout(function() {
          ret2._fulfill();
        }, +ms);
        if (debug.cancellation()) {
          ret2._setOnCancel(new HandleWrapper(handle));
        }
        ret2._captureStackTrace();
      }
      ret2._setAsyncGuaranteed();
      return ret2;
    };
    Promise2.prototype.delay = function(ms) {
      return delay(ms, this);
    };
    var afterTimeout = function(promise, message, parent) {
      var err;
      if (typeof message !== "string") {
        if (message instanceof Error) {
          err = message;
        } else {
          err = new TimeoutError("operation timed out");
        }
      } else {
        err = new TimeoutError(message);
      }
      util54.markAsOriginatingFromRejection(err);
      promise._attachExtraTrace(err);
      promise._reject(err);
      if (parent != null) {
        parent.cancel();
      }
    };
    function successClear(value) {
      clearTimeout(this.handle);
      return value;
    }
    function failureClear(reason) {
      clearTimeout(this.handle);
      throw reason;
    }
    Promise2.prototype.timeout = function(ms, message) {
      ms = +ms;
      var ret2, parent;
      var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret2.isPending()) {
          afterTimeout(ret2, message, parent);
        }
      }, ms));
      if (debug.cancellation()) {
        parent = this.then();
        ret2 = parent._then(successClear, failureClear, void 0, handleWrapper, void 0);
        ret2._setOnCancel(handleWrapper);
      } else {
        ret2 = this._then(successClear, failureClear, void 0, handleWrapper, void 0);
      }
      return ret2;
    };
  };
});

// node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var errors = require_errors();
    var TypeError2 = errors.TypeError;
    var util54 = require_util();
    var errorObj2 = util54.errorObj;
    var tryCatch2 = util54.tryCatch;
    var yieldHandlers = [];
    function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
      for (var i = 0; i < yieldHandlers2.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch2(yieldHandlers2[i])(value);
        traceParent._popContext();
        if (result === errorObj2) {
          traceParent._pushContext();
          var ret2 = Promise2.reject(errorObj2.e);
          traceParent._popContext();
          return ret2;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise2)
          return maybePromise;
      }
      return null;
    }
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
      if (debug.cancellation()) {
        var internal = new Promise2(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
        this._promise = internal.lastly(function() {
          return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
      } else {
        var promise = this._promise = new Promise2(INTERNAL);
        promise._captureStackTrace();
      }
      this._stack = stack;
      this._generatorFunction = generatorFunction;
      this._receiver = receiver;
      this._generator = void 0;
      this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
      this._yieldedPromise = null;
      this._cancellationPhase = false;
    }
    util54.inherits(PromiseSpawn, Proxyable);
    PromiseSpawn.prototype._isResolved = function() {
      return this._promise === null;
    };
    PromiseSpawn.prototype._cleanup = function() {
      this._promise = this._generator = null;
      if (debug.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
      }
    };
    PromiseSpawn.prototype._promiseCancelled = function() {
      if (this._isResolved())
        return;
      var implementsReturn = typeof this._generator["return"] !== "undefined";
      var result;
      if (!implementsReturn) {
        var reason = new Promise2.CancellationError("generator .return() sentinel");
        Promise2.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
      } else {
        this._promise._pushContext();
        result = tryCatch2(this._generator["return"]).call(this._generator, void 0);
        this._promise._popContext();
      }
      this._cancellationPhase = true;
      this._yieldedPromise = null;
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseFulfilled = function(value) {
      this._yieldedPromise = null;
      this._promise._pushContext();
      var result = tryCatch2(this._generator.next).call(this._generator, value);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseRejected = function(reason) {
      this._yieldedPromise = null;
      this._promise._attachExtraTrace(reason);
      this._promise._pushContext();
      var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof Promise2) {
        var promise = this._yieldedPromise;
        this._yieldedPromise = null;
        promise.cancel();
      }
    };
    PromiseSpawn.prototype.promise = function() {
      return this._promise;
    };
    PromiseSpawn.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver);
      this._receiver = this._generatorFunction = void 0;
      this._promiseFulfilled(void 0);
    };
    PromiseSpawn.prototype._continue = function(result) {
      var promise = this._promise;
      if (result === errorObj2) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise.cancel();
        } else {
          return promise._rejectCallback(result.e, false);
        }
      }
      var value = result.value;
      if (result.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise.cancel();
        } else {
          return promise._resolveCallback(value);
        }
      } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise2)) {
          maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
          if (maybePromise === null) {
            this._promiseRejected(new TypeError2("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
            return;
          }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        ;
        if ((bitField & 50397184) === 0) {
          this._yieldedPromise = maybePromise;
          maybePromise._proxy(this, null);
        } else if ((bitField & 33554432) !== 0) {
          Promise2._async.invoke(this._promiseFulfilled, this, maybePromise._value());
        } else if ((bitField & 16777216) !== 0) {
          Promise2._async.invoke(this._promiseRejected, this, maybePromise._reason());
        } else {
          this._promiseCancelled();
        }
      }
    };
    Promise2.coroutine = function(generatorFunction, options) {
      if (typeof generatorFunction !== "function") {
        throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var yieldHandler = Object(options).yieldHandler;
      var PromiseSpawn$ = PromiseSpawn;
      var stack = new Error().stack;
      return function() {
        var generator = generatorFunction.apply(this, arguments);
        var spawn4 = new PromiseSpawn$(void 0, void 0, yieldHandler, stack);
        var ret2 = spawn4.promise();
        spawn4._generator = generator;
        spawn4._promiseFulfilled(void 0);
        return ret2;
      };
    };
    Promise2.coroutine.addYieldHandler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util54.classString(fn));
      }
      yieldHandlers.push(fn);
    };
    Promise2.spawn = function(generatorFunction) {
      debug.deprecated("Promise.spawn()", "Promise.coroutine()");
      if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var spawn4 = new PromiseSpawn(generatorFunction, this);
      var ret2 = spawn4.promise();
      spawn4._run(Promise2.spawn);
      return ret2;
    };
  };
});

// node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2) {
    var util54 = require_util();
    var async2 = Promise2._async;
    var tryCatch2 = util54.tryCatch;
    var errorObj2 = util54.errorObj;
    function spreadAdapter(val, nodeback) {
      var promise = this;
      if (!util54.isArray(val))
        return successAdapter.call(promise, val, nodeback);
      var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
      if (ret2 === errorObj2) {
        async2.throwLater(ret2.e);
      }
    }
    function successAdapter(val, nodeback) {
      var promise = this;
      var receiver = promise._boundValue();
      var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
      if (ret2 === errorObj2) {
        async2.throwLater(ret2.e);
      }
    }
    function errorAdapter(reason, nodeback) {
      var promise = this;
      if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
      }
      var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
      if (ret2 === errorObj2) {
        async2.throwLater(ret2.e);
      }
    }
    Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
      if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== void 0 && Object(options).spread) {
          adapter = spreadAdapter;
        }
        this._then(adapter, errorAdapter, void 0, this, nodeback);
      }
      return this;
    };
  };
});

// node_modules/bluebird/js/release/promisify.js
var require_promisify = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, INTERNAL) {
    var THIS = {};
    var util54 = require_util();
    var nodebackForPromise = require_nodeback();
    var withAppended2 = util54.withAppended;
    var maybeWrapAsError2 = util54.maybeWrapAsError;
    var canEvaluate2 = util54.canEvaluate;
    var TypeError2 = require_errors().TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = {__isPromisified__: true};
    var noCopyProps = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    var defaultFilter = function(name2) {
      return util54.isIdentifier(name2) && name2.charAt(0) !== "_" && name2 !== "constructor";
    };
    function propsFilter(key) {
      return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
      try {
        return fn.__isPromisified__ === true;
      } catch (e) {
        return false;
      }
    }
    function hasPromisified(obj, key, suffix) {
      var val = util54.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
      return val ? isPromisified(val) : false;
    }
    function checkValid(ret2, suffix, suffixRegexp) {
      for (var i = 0; i < ret2.length; i += 2) {
        var key = ret2[i];
        if (suffixRegexp.test(key)) {
          var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
          for (var j = 0; j < ret2.length; j += 2) {
            if (ret2[j] === keyWithoutAsyncSuffix) {
              throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
            }
          }
        }
      }
    }
    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
      var keys = util54.inheritedDataKeys(obj);
      var ret2 = [];
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
        if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
          ret2.push(key, value);
        }
      }
      checkValid(ret2, suffix, suffixRegexp);
      return ret2;
    }
    var escapeIdentRegex = function(str) {
      return str.replace(/([$])/, "\\$");
    };
    var makeNodePromisifiedEval;
    if (true) {
      var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret2 = [likelyArgumentCount];
        var min = Math.max(0, likelyArgumentCount - 1 - 3);
        for (var i = likelyArgumentCount - 1; i >= min; --i) {
          ret2.push(i);
        }
        for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
          ret2.push(i);
        }
        return ret2;
      };
      var argumentSequence = function(argumentCount) {
        return util54.filledRange(argumentCount, "_arg", "");
      };
      var parameterDeclaration = function(parameterCount2) {
        return util54.filledRange(Math.max(parameterCount2, 3), "_arg", "");
      };
      var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
          return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
      };
      makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
        function generateCallForArgumentCount(count) {
          var args = argumentSequence(count).join(", ");
          var comma = count > 0 ? ", " : "";
          var ret2;
          if (shouldProxyThis) {
            ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
          } else {
            ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
          }
          return ret2.replace("{{args}}", args).replace(", ", comma);
        }
        function generateArgumentSwitchCase() {
          var ret2 = "";
          for (var i = 0; i < argumentOrder.length; ++i) {
            ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
          }
          ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
          return ret2;
        }
        var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
        var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
        body = body.replace("Parameters", parameterDeclaration(newParameterCount));
        return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise2, fn, receiver, withAppended2, maybeWrapAsError2, nodebackForPromise, util54.tryCatch, util54.errorObj, util54.notEnumerableProp, INTERNAL);
      };
    }
    function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
      var defaultThis = function() {
        return this;
      }();
      var method = callback;
      if (typeof method === "string") {
        callback = fn;
      }
      function promisified() {
        var _receiver = receiver;
        if (receiver === THIS)
          _receiver = this;
        var promise = new Promise2(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
        var fn2 = nodebackForPromise(promise, multiArgs);
        try {
          cb.apply(_receiver, withAppended2(arguments, fn2));
        } catch (e) {
          promise._rejectCallback(maybeWrapAsError2(e), true, true);
        }
        if (!promise._isFateSealed())
          promise._setAsyncGuaranteed();
        return promise;
      }
      util54.notEnumerableProp(promisified, "__isPromisified__", true);
      return promisified;
    }
    var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
    function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
      var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
      var methods2 = promisifiableMethods(obj, suffix, suffixRegexp, filter);
      for (var i = 0, len = methods2.length; i < len; i += 2) {
        var key = methods2[i];
        var fn = methods2[i + 1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
          obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
          var promisified = promisifier(fn, function() {
            return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
          });
          util54.notEnumerableProp(promisified, "__isPromisified__", true);
          obj[promisifiedKey] = promisified;
        }
      }
      util54.toFastProperties(obj);
      return obj;
    }
    function promisify(callback, receiver, multiArgs) {
      return makeNodePromisified(callback, receiver, void 0, callback, null, multiArgs);
    }
    Promise2.promisify = function(fn, options) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util54.classString(fn));
      }
      if (isPromisified(fn)) {
        return fn;
      }
      options = Object(options);
      var receiver = options.context === void 0 ? THIS : options.context;
      var multiArgs = !!options.multiArgs;
      var ret2 = promisify(fn, receiver, multiArgs);
      util54.copyDescriptors(fn, ret2, propsFilter);
      return ret2;
    };
    Promise2.promisifyAll = function(target, options) {
      if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      options = Object(options);
      var multiArgs = !!options.multiArgs;
      var suffix = options.suffix;
      if (typeof suffix !== "string")
        suffix = defaultSuffix;
      var filter = options.filter;
      if (typeof filter !== "function")
        filter = defaultFilter;
      var promisifier = options.promisifier;
      if (typeof promisifier !== "function")
        promisifier = makeNodePromisified;
      if (!util54.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
      }
      var keys = util54.inheritedDataKeys(target);
      for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" && util54.isClass(value)) {
          promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
          promisifyAll(value, suffix, filter, promisifier, multiArgs);
        }
      }
      return promisifyAll(target, suffix, filter, promisifier, multiArgs);
    };
  };
});

// node_modules/bluebird/js/release/props.js
var require_props = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
    var util54 = require_util();
    var isObject2 = util54.isObject;
    var es52 = require_es5();
    var Es6Map;
    if (typeof Map === "function")
      Es6Map = Map;
    var mapToEntries = function() {
      var index = 0;
      var size = 0;
      function extractEntry(value, key) {
        this[index] = value;
        this[index + size] = key;
        index++;
      }
      return function mapToEntries2(map) {
        size = map.size;
        index = 0;
        var ret2 = new Array(map.size * 2);
        map.forEach(extractEntry, ret2);
        return ret2;
      };
    }();
    var entriesToMap = function(entries) {
      var ret2 = new Es6Map();
      var length = entries.length / 2 | 0;
      for (var i = 0; i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret2.set(key, value);
      }
      return ret2;
    };
    function PropertiesPromiseArray(obj) {
      var isMap = false;
      var entries;
      if (Es6Map !== void 0 && obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap = true;
      } else {
        var keys = es52.keys(obj);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
          var key = keys[i];
          entries[i] = obj[key];
          entries[i + len] = key;
        }
      }
      this.constructor$(entries);
      this._isMap = isMap;
      this._init$(void 0, -3);
    }
    util54.inherits(PropertiesPromiseArray, PromiseArray);
    PropertiesPromiseArray.prototype._init = function() {
    };
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
          val = entriesToMap(this._values);
        } else {
          val = {};
          var keyOffset = this.length();
          for (var i = 0, len = this.length(); i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
          }
        }
        this._resolve(val);
        return true;
      }
      return false;
    };
    PropertiesPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    PropertiesPromiseArray.prototype.getActualLength = function(len) {
      return len >> 1;
    };
    function props(promises) {
      var ret2;
      var castValue = tryConvertToPromise(promises);
      if (!isObject2(castValue)) {
        return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
      } else if (castValue instanceof Promise2) {
        ret2 = castValue._then(Promise2.props, void 0, void 0, void 0, void 0);
      } else {
        ret2 = new PropertiesPromiseArray(castValue).promise();
      }
      if (castValue instanceof Promise2) {
        ret2._propagateFrom(castValue, 2);
      }
      return ret2;
    }
    Promise2.prototype.props = function() {
      return props(this);
    };
    Promise2.props = function(promises) {
      return props(promises);
    };
  };
});

// node_modules/bluebird/js/release/race.js
var require_race = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
    var util54 = require_util();
    var raceLater = function(promise) {
      return promise.then(function(array6) {
        return race(array6, promise);
      });
    };
    function race(promises, parent) {
      var maybePromise = tryConvertToPromise(promises);
      if (maybePromise instanceof Promise2) {
        return raceLater(maybePromise);
      } else {
        promises = util54.asArray(promises);
        if (promises === null)
          return apiRejection("expecting an array or an iterable object but got " + util54.classString(promises));
      }
      var ret2 = new Promise2(INTERNAL);
      if (parent !== void 0) {
        ret2._propagateFrom(parent, 3);
      }
      var fulfill = ret2._fulfill;
      var reject = ret2._reject;
      for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];
        if (val === void 0 && !(i in promises)) {
          continue;
        }
        Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
      }
      return ret2;
    }
    Promise2.race = function(promises) {
      return race(promises, void 0);
    };
    Promise2.prototype.race = function() {
      return race(this, void 0);
    };
  };
});

// node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise2._getDomain;
    var util54 = require_util();
    var tryCatch2 = util54.tryCatch;
    function ReductionPromiseArray(promises, fn, initialValue, _each) {
      this.constructor$(promises);
      var domain = getDomain();
      this._fn = domain === null ? fn : util54.domainBind(domain, fn);
      if (initialValue !== void 0) {
        initialValue = Promise2.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
      }
      this._initialValue = initialValue;
      this._currentCancellable = null;
      if (_each === INTERNAL) {
        this._eachValues = Array(this._length);
      } else if (_each === 0) {
        this._eachValues = null;
      } else {
        this._eachValues = void 0;
      }
      this._promise._captureStackTrace();
      this._init$(void 0, -5);
    }
    util54.inherits(ReductionPromiseArray, PromiseArray);
    ReductionPromiseArray.prototype._gotAccum = function(accum) {
      if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
        this._eachValues.push(accum);
      }
    };
    ReductionPromiseArray.prototype._eachComplete = function(value) {
      if (this._eachValues !== null) {
        this._eachValues.push(value);
      }
      return this._eachValues;
    };
    ReductionPromiseArray.prototype._init = function() {
    };
    ReductionPromiseArray.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
    };
    ReductionPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    ReductionPromiseArray.prototype._resolve = function(value) {
      this._promise._resolveCallback(value);
      this._values = null;
    };
    ReductionPromiseArray.prototype._resultCancelled = function(sender) {
      if (sender === this._initialValue)
        return this._cancel();
      if (this._isResolved())
        return;
      this._resultCancelled$();
      if (this._currentCancellable instanceof Promise2) {
        this._currentCancellable.cancel();
      }
      if (this._initialValue instanceof Promise2) {
        this._initialValue.cancel();
      }
    };
    ReductionPromiseArray.prototype._iterate = function(values) {
      this._values = values;
      var value;
      var i;
      var length = values.length;
      if (this._initialValue !== void 0) {
        value = this._initialValue;
        i = 0;
      } else {
        value = Promise2.resolve(values[0]);
        i = 1;
      }
      this._currentCancellable = value;
      if (!value.isRejected()) {
        for (; i < length; ++i) {
          var ctx = {
            accum: null,
            value: values[i],
            index: i,
            length,
            array: this
          };
          value = value._then(gotAccum, void 0, void 0, ctx, void 0);
        }
      }
      if (this._eachValues !== void 0) {
        value = value._then(this._eachComplete, void 0, void 0, this, void 0);
      }
      value._then(completed, completed, void 0, value, this);
    };
    Promise2.prototype.reduce = function(fn, initialValue) {
      return reduce(this, fn, initialValue, null);
    };
    Promise2.reduce = function(promises, fn, initialValue, _each) {
      return reduce(promises, fn, initialValue, _each);
    };
    function completed(valueOrReason, array6) {
      if (this.isFulfilled()) {
        array6._resolve(valueOrReason);
      } else {
        array6._reject(valueOrReason);
      }
    }
    function reduce(promises, fn, initialValue, _each) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util54.classString(fn));
      }
      var array6 = new ReductionPromiseArray(promises, fn, initialValue, _each);
      return array6.promise();
    }
    function gotAccum(accum) {
      this.accum = accum;
      this.array._gotAccum(accum);
      var value = tryConvertToPromise(this.value, this.array._promise);
      if (value instanceof Promise2) {
        this.array._currentCancellable = value;
        return value._then(gotValue, void 0, void 0, this, void 0);
      } else {
        return gotValue.call(this, value);
      }
    }
    function gotValue(value) {
      var array6 = this.array;
      var promise = array6._promise;
      var fn = tryCatch2(array6._fn);
      promise._pushContext();
      var ret2;
      if (array6._eachValues !== void 0) {
        ret2 = fn.call(promise._boundValue(), value, this.index, this.length);
      } else {
        ret2 = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
      }
      if (ret2 instanceof Promise2) {
        array6._currentCancellable = ret2;
      }
      var promiseCreated = promise._popContext();
      debug.checkForgottenReturns(ret2, promiseCreated, array6._eachValues !== void 0 ? "Promise.each" : "Promise.reduce", promise);
      return ret2;
    }
  };
});

// node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, PromiseArray, debug) {
    var PromiseInspection = Promise2.PromiseInspection;
    var util54 = require_util();
    function SettledPromiseArray(values) {
      this.constructor$(values);
    }
    util54.inherits(SettledPromiseArray, PromiseArray);
    SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
      this._values[index] = inspection;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var ret2 = new PromiseInspection();
      ret2._bitField = 33554432;
      ret2._settledValueField = value;
      return this._promiseResolved(index, ret2);
    };
    SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
      var ret2 = new PromiseInspection();
      ret2._bitField = 16777216;
      ret2._settledValueField = reason;
      return this._promiseResolved(index, ret2);
    };
    Promise2.settle = function(promises) {
      debug.deprecated(".settle()", ".reflect()");
      return new SettledPromiseArray(promises).promise();
    };
    Promise2.prototype.settle = function() {
      return Promise2.settle(this);
    };
  };
});

// node_modules/bluebird/js/release/some.js
var require_some = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, PromiseArray, apiRejection) {
    var util54 = require_util();
    var RangeError2 = require_errors().RangeError;
    var AggregateError = require_errors().AggregateError;
    var isArray = util54.isArray;
    var CANCELLATION = {};
    function SomePromiseArray(values) {
      this.constructor$(values);
      this._howMany = 0;
      this._unwrap = false;
      this._initialized = false;
    }
    util54.inherits(SomePromiseArray, PromiseArray);
    SomePromiseArray.prototype._init = function() {
      if (!this._initialized) {
        return;
      }
      if (this._howMany === 0) {
        this._resolve([]);
        return;
      }
      this._init$(void 0, -5);
      var isArrayResolved = isArray(this._values);
      if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
      }
    };
    SomePromiseArray.prototype.init = function() {
      this._initialized = true;
      this._init();
    };
    SomePromiseArray.prototype.setUnwrap = function() {
      this._unwrap = true;
    };
    SomePromiseArray.prototype.howMany = function() {
      return this._howMany;
    };
    SomePromiseArray.prototype.setHowMany = function(count) {
      this._howMany = count;
    };
    SomePromiseArray.prototype._promiseFulfilled = function(value) {
      this._addFulfilled(value);
      if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
          this._resolve(this._values[0]);
        } else {
          this._resolve(this._values);
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._promiseRejected = function(reason) {
      this._addRejected(reason);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._promiseCancelled = function() {
      if (this._values instanceof Promise2 || this._values == null) {
        return this._cancel();
      }
      this._addRejected(CANCELLATION);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i < this._values.length; ++i) {
          if (this._values[i] !== CANCELLATION) {
            e.push(this._values[i]);
          }
        }
        if (e.length > 0) {
          this._reject(e);
        } else {
          this._cancel();
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._fulfilled = function() {
      return this._totalResolved;
    };
    SomePromiseArray.prototype._rejected = function() {
      return this._values.length - this.length();
    };
    SomePromiseArray.prototype._addRejected = function(reason) {
      this._values.push(reason);
    };
    SomePromiseArray.prototype._addFulfilled = function(value) {
      this._values[this._totalResolved++] = value;
    };
    SomePromiseArray.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    };
    SomePromiseArray.prototype._getRangeError = function(count) {
      var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
      return new RangeError2(message);
    };
    SomePromiseArray.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function some(promises, howMany) {
      if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
      }
      var ret2 = new SomePromiseArray(promises);
      var promise = ret2.promise();
      ret2.setHowMany(howMany);
      ret2.init();
      return promise;
    }
    Promise2.some = function(promises, howMany) {
      return some(promises, howMany);
    };
    Promise2.prototype.some = function(howMany) {
      return some(this, howMany);
    };
    Promise2._SomePromiseArray = SomePromiseArray;
  };
});

// node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, INTERNAL) {
    var PromiseMap = Promise2.map;
    Promise2.prototype.filter = function(fn, options) {
      return PromiseMap(this, fn, options, INTERNAL);
    };
    Promise2.filter = function(promises, fn, options) {
      return PromiseMap(promises, fn, options, INTERNAL);
    };
  };
});

// node_modules/bluebird/js/release/each.js
var require_each = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2, INTERNAL) {
    var PromiseReduce = Promise2.reduce;
    var PromiseAll = Promise2.all;
    function promiseAllThis() {
      return PromiseAll(this);
    }
    function PromiseMapSeries(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    }
    Promise2.prototype.each = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
    };
    Promise2.prototype.mapSeries = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };
    Promise2.each = function(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
    };
    Promise2.mapSeries = PromiseMapSeries;
  };
});

// node_modules/bluebird/js/release/any.js
var require_any = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Promise2) {
    var SomePromiseArray = Promise2._SomePromiseArray;
    function any(promises) {
      var ret2 = new SomePromiseArray(promises);
      var promise = ret2.promise();
      ret2.setHowMany(1);
      ret2.setUnwrap();
      ret2.init();
      return promise;
    }
    Promise2.any = function(promises) {
      return any(promises);
    };
    Promise2.prototype.any = function() {
      return any(this);
    };
  };
});

// node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function() {
    var makeSelfResolutionError = function() {
      return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
    };
    var reflectHandler = function() {
      return new Promise2.PromiseInspection(this._target());
    };
    var apiRejection = function(msg) {
      return Promise2.reject(new TypeError2(msg));
    };
    function Proxyable() {
    }
    var UNDEFINED_BINDING = {};
    var util54 = require_util();
    var getDomain;
    if (util54.isNode) {
      getDomain = function() {
        var ret2 = process.domain;
        if (ret2 === void 0)
          ret2 = null;
        return ret2;
      };
    } else {
      getDomain = function() {
        return null;
      };
    }
    util54.notEnumerableProp(Promise2, "_getDomain", getDomain);
    var es52 = require_es5();
    var Async = require_async();
    var async2 = new Async();
    es52.defineProperty(Promise2, "_async", {value: async2});
    var errors = require_errors();
    var TypeError2 = Promise2.TypeError = errors.TypeError;
    Promise2.RangeError = errors.RangeError;
    var CancellationError = Promise2.CancellationError = errors.CancellationError;
    Promise2.TimeoutError = errors.TimeoutError;
    Promise2.OperationalError = errors.OperationalError;
    Promise2.RejectionError = errors.OperationalError;
    Promise2.AggregateError = errors.AggregateError;
    var INTERNAL = function() {
    };
    var APPLY = {};
    var NEXT_FILTER = {};
    var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
    var PromiseArray = require_promise_array()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
    var Context = require_context()(Promise2);
    var createContext2 = Context.create;
    var debug = require_debuggability()(Promise2, Context);
    var CapturedTrace = debug.CapturedTrace;
    var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise);
    var catchFilter = require_catch_filter()(NEXT_FILTER);
    var nodebackForPromise = require_nodeback();
    var errorObj2 = util54.errorObj;
    var tryCatch2 = util54.tryCatch;
    function check(self2, executor) {
      if (typeof executor !== "function") {
        throw new TypeError2("expecting a function but got " + util54.classString(executor));
      }
      if (self2.constructor !== Promise2) {
        throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
      }
    }
    function Promise2(executor) {
      this._bitField = 0;
      this._fulfillmentHandler0 = void 0;
      this._rejectionHandler0 = void 0;
      this._promise0 = void 0;
      this._receiver0 = void 0;
      if (executor !== INTERNAL) {
        check(this, executor);
        this._resolveFromExecutor(executor);
      }
      this._promiseCreated();
      this._fireEvent("promiseCreated", this);
    }
    Promise2.prototype.toString = function() {
      return "[object Promise]";
    };
    Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
      var len = arguments.length;
      if (len > 1) {
        var catchInstances = new Array(len - 1), j = 0, i;
        for (i = 0; i < len - 1; ++i) {
          var item = arguments[i];
          if (util54.isObject(item)) {
            catchInstances[j++] = item;
          } else {
            return apiRejection("expecting an object but got A catch statement predicate " + util54.classString(item));
          }
        }
        catchInstances.length = j;
        fn = arguments[i];
        return this.then(void 0, catchFilter(catchInstances, fn, this));
      }
      return this.then(void 0, fn);
    };
    Promise2.prototype.reflect = function() {
      return this._then(reflectHandler, reflectHandler, void 0, this, void 0);
    };
    Promise2.prototype.then = function(didFulfill, didReject) {
      if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " + util54.classString(didFulfill);
        if (arguments.length > 1) {
          msg += ", " + util54.classString(didReject);
        }
        this._warn(msg);
      }
      return this._then(didFulfill, didReject, void 0, void 0, void 0);
    };
    Promise2.prototype.done = function(didFulfill, didReject) {
      var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
      promise._setIsFinal();
    };
    Promise2.prototype.spread = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util54.classString(fn));
      }
      return this.all()._then(fn, void 0, void 0, APPLY, void 0);
    };
    Promise2.prototype.toJSON = function() {
      var ret2 = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: void 0,
        rejectionReason: void 0
      };
      if (this.isFulfilled()) {
        ret2.fulfillmentValue = this.value();
        ret2.isFulfilled = true;
      } else if (this.isRejected()) {
        ret2.rejectionReason = this.reason();
        ret2.isRejected = true;
      }
      return ret2;
    };
    Promise2.prototype.all = function() {
      if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
      }
      return new PromiseArray(this).promise();
    };
    Promise2.prototype.error = function(fn) {
      return this.caught(util54.originatesFromRejection, fn);
    };
    Promise2.getNewLibraryCopy = module2.exports;
    Promise2.is = function(val) {
      return val instanceof Promise2;
    };
    Promise2.fromNode = Promise2.fromCallback = function(fn) {
      var ret2 = new Promise2(INTERNAL);
      ret2._captureStackTrace();
      var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
      var result = tryCatch2(fn)(nodebackForPromise(ret2, multiArgs));
      if (result === errorObj2) {
        ret2._rejectCallback(result.e, true);
      }
      if (!ret2._isFateSealed())
        ret2._setAsyncGuaranteed();
      return ret2;
    };
    Promise2.all = function(promises) {
      return new PromiseArray(promises).promise();
    };
    Promise2.cast = function(obj) {
      var ret2 = tryConvertToPromise(obj);
      if (!(ret2 instanceof Promise2)) {
        ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._setFulfilled();
        ret2._rejectionHandler0 = obj;
      }
      return ret2;
    };
    Promise2.resolve = Promise2.fulfilled = Promise2.cast;
    Promise2.reject = Promise2.rejected = function(reason) {
      var ret2 = new Promise2(INTERNAL);
      ret2._captureStackTrace();
      ret2._rejectCallback(reason, true);
      return ret2;
    };
    Promise2.setScheduler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util54.classString(fn));
      }
      return async2.setScheduler(fn);
    };
    Promise2.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
      var haveInternalData = internalData !== void 0;
      var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
      var target = this._target();
      var bitField = target._bitField;
      if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
          if (!((bitField & 50397184) === 0)) {
            receiver = this._boundValue();
          } else {
            receiver = target === this ? void 0 : this._boundTo;
          }
        }
        this._fireEvent("promiseChained", this, promise);
      }
      var domain = getDomain();
      if (!((bitField & 50397184) === 0)) {
        var handler2, value, settler = target._settlePromiseCtx;
        if ((bitField & 33554432) !== 0) {
          value = target._rejectionHandler0;
          handler2 = didFulfill;
        } else if ((bitField & 16777216) !== 0) {
          value = target._fulfillmentHandler0;
          handler2 = didReject;
          target._unsetRejectionIsUnhandled();
        } else {
          settler = target._settlePromiseLateCancellationObserver;
          value = new CancellationError("late cancellation observer");
          target._attachExtraTrace(value);
          handler2 = didReject;
        }
        async2.invoke(settler, target, {
          handler: domain === null ? handler2 : typeof handler2 === "function" && util54.domainBind(domain, handler2),
          promise,
          receiver,
          value
        });
      } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
      }
      return promise;
    };
    Promise2.prototype._length = function() {
      return this._bitField & 65535;
    };
    Promise2.prototype._isFateSealed = function() {
      return (this._bitField & 117506048) !== 0;
    };
    Promise2.prototype._isFollowing = function() {
      return (this._bitField & 67108864) === 67108864;
    };
    Promise2.prototype._setLength = function(len) {
      this._bitField = this._bitField & -65536 | len & 65535;
    };
    Promise2.prototype._setFulfilled = function() {
      this._bitField = this._bitField | 33554432;
      this._fireEvent("promiseFulfilled", this);
    };
    Promise2.prototype._setRejected = function() {
      this._bitField = this._bitField | 16777216;
      this._fireEvent("promiseRejected", this);
    };
    Promise2.prototype._setFollowing = function() {
      this._bitField = this._bitField | 67108864;
      this._fireEvent("promiseResolved", this);
    };
    Promise2.prototype._setIsFinal = function() {
      this._bitField = this._bitField | 4194304;
    };
    Promise2.prototype._isFinal = function() {
      return (this._bitField & 4194304) > 0;
    };
    Promise2.prototype._unsetCancelled = function() {
      this._bitField = this._bitField & ~65536;
    };
    Promise2.prototype._setCancelled = function() {
      this._bitField = this._bitField | 65536;
      this._fireEvent("promiseCancelled", this);
    };
    Promise2.prototype._setWillBeCancelled = function() {
      this._bitField = this._bitField | 8388608;
    };
    Promise2.prototype._setAsyncGuaranteed = function() {
      if (async2.hasCustomScheduler())
        return;
      this._bitField = this._bitField | 134217728;
    };
    Promise2.prototype._receiverAt = function(index) {
      var ret2 = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
      if (ret2 === UNDEFINED_BINDING) {
        return void 0;
      } else if (ret2 === void 0 && this._isBound()) {
        return this._boundValue();
      }
      return ret2;
    };
    Promise2.prototype._promiseAt = function(index) {
      return this[index * 4 - 4 + 2];
    };
    Promise2.prototype._fulfillmentHandlerAt = function(index) {
      return this[index * 4 - 4 + 0];
    };
    Promise2.prototype._rejectionHandlerAt = function(index) {
      return this[index * 4 - 4 + 1];
    };
    Promise2.prototype._boundValue = function() {
    };
    Promise2.prototype._migrateCallback0 = function(follower) {
      var bitField = follower._bitField;
      var fulfill = follower._fulfillmentHandler0;
      var reject = follower._rejectionHandler0;
      var promise = follower._promise0;
      var receiver = follower._receiverAt(0);
      if (receiver === void 0)
        receiver = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject, promise, receiver, null);
    };
    Promise2.prototype._migrateCallbackAt = function(follower, index) {
      var fulfill = follower._fulfillmentHandlerAt(index);
      var reject = follower._rejectionHandlerAt(index);
      var promise = follower._promiseAt(index);
      var receiver = follower._receiverAt(index);
      if (receiver === void 0)
        receiver = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject, promise, receiver, null);
    };
    Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver, domain) {
      var index = this._length();
      if (index >= 65535 - 4) {
        index = 0;
        this._setLength(0);
      }
      if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
          this._fulfillmentHandler0 = domain === null ? fulfill : util54.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
          this._rejectionHandler0 = domain === null ? reject : util54.domainBind(domain, reject);
        }
      } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
          this[base + 0] = domain === null ? fulfill : util54.domainBind(domain, fulfill);
        }
        if (typeof reject === "function") {
          this[base + 1] = domain === null ? reject : util54.domainBind(domain, reject);
        }
      }
      this._setLength(index + 1);
      return index;
    };
    Promise2.prototype._proxy = function(proxyable, arg) {
      this._addCallbacks(void 0, void 0, arg, proxyable, null);
    };
    Promise2.prototype._resolveCallback = function(value, shouldBind) {
      if ((this._bitField & 117506048) !== 0)
        return;
      if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
      var maybePromise = tryConvertToPromise(value, this);
      if (!(maybePromise instanceof Promise2))
        return this._fulfill(value);
      if (shouldBind)
        this._propagateFrom(maybePromise, 2);
      var promise = maybePromise._target();
      if (promise === this) {
        this._reject(makeSelfResolutionError());
        return;
      }
      var bitField = promise._bitField;
      if ((bitField & 50397184) === 0) {
        var len = this._length();
        if (len > 0)
          promise._migrateCallback0(this);
        for (var i = 1; i < len; ++i) {
          promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
      } else if ((bitField & 33554432) !== 0) {
        this._fulfill(promise._value());
      } else if ((bitField & 16777216) !== 0) {
        this._reject(promise._reason());
      } else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason);
        this._reject(reason);
      }
    };
    Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
      var trace = util54.ensureErrorObject(reason);
      var hasStack = trace === reason;
      if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
        var message = "a promise was rejected with a non-error: " + util54.classString(reason);
        this._warn(message, true);
      }
      this._attachExtraTrace(trace, synchronous ? hasStack : false);
      this._reject(reason);
    };
    Promise2.prototype._resolveFromExecutor = function(executor) {
      var promise = this;
      this._captureStackTrace();
      this._pushContext();
      var synchronous = true;
      var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
      }, function(reason) {
        promise._rejectCallback(reason, synchronous);
      });
      synchronous = false;
      this._popContext();
      if (r !== void 0) {
        promise._rejectCallback(r, true);
      }
    };
    Promise2.prototype._settlePromiseFromHandler = function(handler2, receiver, value, promise) {
      var bitField = promise._bitField;
      if ((bitField & 65536) !== 0)
        return;
      promise._pushContext();
      var x;
      if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
          x = errorObj2;
          x.e = new TypeError2("cannot .spread() a non-array: " + util54.classString(value));
        } else {
          x = tryCatch2(handler2).apply(this._boundValue(), value);
        }
      } else {
        x = tryCatch2(handler2).call(receiver, value);
      }
      var promiseCreated = promise._popContext();
      bitField = promise._bitField;
      if ((bitField & 65536) !== 0)
        return;
      if (x === NEXT_FILTER) {
        promise._reject(value);
      } else if (x === errorObj2) {
        promise._rejectCallback(x.e, false);
      } else {
        debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
        promise._resolveCallback(x);
      }
    };
    Promise2.prototype._target = function() {
      var ret2 = this;
      while (ret2._isFollowing())
        ret2 = ret2._followee();
      return ret2;
    };
    Promise2.prototype._followee = function() {
      return this._rejectionHandler0;
    };
    Promise2.prototype._setFollowee = function(promise) {
      this._rejectionHandler0 = promise;
    };
    Promise2.prototype._settlePromise = function(promise, handler2, receiver, value) {
      var isPromise = promise instanceof Promise2;
      var bitField = this._bitField;
      var asyncGuaranteed = (bitField & 134217728) !== 0;
      if ((bitField & 65536) !== 0) {
        if (isPromise)
          promise._invokeInternalOnCancel();
        if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
          receiver.cancelPromise = promise;
          if (tryCatch2(handler2).call(receiver, value) === errorObj2) {
            promise._reject(errorObj2.e);
          }
        } else if (handler2 === reflectHandler) {
          promise._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
          receiver._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
          promise._cancel();
        } else {
          receiver.cancel();
        }
      } else if (typeof handler2 === "function") {
        if (!isPromise) {
          handler2.call(receiver, value, promise);
        } else {
          if (asyncGuaranteed)
            promise._setAsyncGuaranteed();
          this._settlePromiseFromHandler(handler2, receiver, value, promise);
        }
      } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
          if ((bitField & 33554432) !== 0) {
            receiver._promiseFulfilled(value, promise);
          } else {
            receiver._promiseRejected(value, promise);
          }
        }
      } else if (isPromise) {
        if (asyncGuaranteed)
          promise._setAsyncGuaranteed();
        if ((bitField & 33554432) !== 0) {
          promise._fulfill(value);
        } else {
          promise._reject(value);
        }
      }
    };
    Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
      var handler2 = ctx.handler;
      var promise = ctx.promise;
      var receiver = ctx.receiver;
      var value = ctx.value;
      if (typeof handler2 === "function") {
        if (!(promise instanceof Promise2)) {
          handler2.call(receiver, value, promise);
        } else {
          this._settlePromiseFromHandler(handler2, receiver, value, promise);
        }
      } else if (promise instanceof Promise2) {
        promise._reject(value);
      }
    };
    Promise2.prototype._settlePromiseCtx = function(ctx) {
      this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    };
    Promise2.prototype._settlePromise0 = function(handler2, value, bitField) {
      var promise = this._promise0;
      var receiver = this._receiverAt(0);
      this._promise0 = void 0;
      this._receiver0 = void 0;
      this._settlePromise(promise, handler2, receiver, value);
    };
    Promise2.prototype._clearCallbackDataAtIndex = function(index) {
      var base = index * 4 - 4;
      this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
    };
    Promise2.prototype._fulfill = function(value) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16)
        return;
      if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
      }
      this._setFulfilled();
      this._rejectionHandler0 = value;
      if ((bitField & 65535) > 0) {
        if ((bitField & 134217728) !== 0) {
          this._settlePromises();
        } else {
          async2.settlePromises(this);
        }
      }
    };
    Promise2.prototype._reject = function(reason) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16)
        return;
      this._setRejected();
      this._fulfillmentHandler0 = reason;
      if (this._isFinal()) {
        return async2.fatalError(reason, util54.isNode);
      }
      if ((bitField & 65535) > 0) {
        async2.settlePromises(this);
      } else {
        this._ensurePossibleRejectionHandled();
      }
    };
    Promise2.prototype._fulfillPromises = function(len, value) {
      for (var i = 1; i < len; i++) {
        var handler2 = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler2, receiver, value);
      }
    };
    Promise2.prototype._rejectPromises = function(len, reason) {
      for (var i = 1; i < len; i++) {
        var handler2 = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler2, receiver, reason);
      }
    };
    Promise2.prototype._settlePromises = function() {
      var bitField = this._bitField;
      var len = bitField & 65535;
      if (len > 0) {
        if ((bitField & 16842752) !== 0) {
          var reason = this._fulfillmentHandler0;
          this._settlePromise0(this._rejectionHandler0, reason, bitField);
          this._rejectPromises(len, reason);
        } else {
          var value = this._rejectionHandler0;
          this._settlePromise0(this._fulfillmentHandler0, value, bitField);
          this._fulfillPromises(len, value);
        }
        this._setLength(0);
      }
      this._clearCancellationData();
    };
    Promise2.prototype._settledValue = function() {
      var bitField = this._bitField;
      if ((bitField & 33554432) !== 0) {
        return this._rejectionHandler0;
      } else if ((bitField & 16777216) !== 0) {
        return this._fulfillmentHandler0;
      }
    };
    function deferResolve(v) {
      this.promise._resolveCallback(v);
    }
    function deferReject(v) {
      this.promise._rejectCallback(v, false);
    }
    Promise2.defer = Promise2.pending = function() {
      debug.deprecated("Promise.defer", "new Promise");
      var promise = new Promise2(INTERNAL);
      return {
        promise,
        resolve: deferResolve,
        reject: deferReject
      };
    };
    util54.notEnumerableProp(Promise2, "_makeSelfResolutionError", makeSelfResolutionError);
    require_method()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug);
    require_bind()(Promise2, INTERNAL, tryConvertToPromise, debug);
    require_cancel()(Promise2, PromiseArray, apiRejection, debug);
    require_direct_resolve()(Promise2);
    require_synchronous_inspection()(Promise2);
    require_join()(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async2, getDomain);
    Promise2.Promise = Promise2;
    Promise2.version = "3.4.7";
    require_map()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    require_call_get()(Promise2);
    require_using()(Promise2, apiRejection, tryConvertToPromise, createContext2, INTERNAL, debug);
    require_timers()(Promise2, INTERNAL, debug);
    require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
    require_nodeify()(Promise2);
    require_promisify()(Promise2, INTERNAL);
    require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
    require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
    require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    require_settle()(Promise2, PromiseArray, debug);
    require_some()(Promise2, PromiseArray, apiRejection);
    require_filter()(Promise2, INTERNAL);
    require_each()(Promise2, INTERNAL);
    require_any()(Promise2);
    util54.toFastProperties(Promise2);
    util54.toFastProperties(Promise2.prototype);
    function fillTypes(value) {
      var p = new Promise2(INTERNAL);
      p._fulfillmentHandler0 = value;
      p._rejectionHandler0 = value;
      p._promise0 = value;
      p._receiver0 = value;
    }
    fillTypes({a: 1});
    fillTypes({b: 2});
    fillTypes({c: 3});
    fillTypes(1);
    fillTypes(function() {
    });
    fillTypes(void 0);
    fillTypes(false);
    fillTypes(new Promise2(INTERNAL));
    debug.setBounds(Async.firstLineError, util54.lastLineError);
    return Promise2;
  };
});

// node_modules/bluebird/js/release/bluebird.js
var require_bluebird = __commonJS((exports2, module2) => {
  "use strict";
  var old;
  if (typeof Promise !== "undefined")
    old = Promise;
  function noConflict() {
    try {
      if (Promise === bluebird)
        Promise = old;
    } catch (e) {
    }
    return bluebird;
  }
  var bluebird = require_promise()();
  bluebird.noConflict = noConflict;
  module2.exports = bluebird;
});

// node_modules/unzipper/lib/Buffer.js
var require_Buffer2 = __commonJS((exports2, module2) => {
  var Buffer2 = require("buffer").Buffer;
  if (Buffer2.from === void 0) {
    Buffer2.from = function(a, b, c) {
      return new Buffer2(a, b, c);
    };
    Buffer2.alloc = Buffer2.from;
  }
  module2.exports = Buffer2;
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports2, module2) => {
  "use strict";
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module2.exports = {nextTick};
  } else {
    module2.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS((exports2, module2) => {
  module2.exports = require("stream");
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  var buffer4 = require("buffer");
  var Buffer2 = buffer4.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer4;
  } else {
    copyProps(buffer4, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer4.SlowBuffer(size);
  };
});

// node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS((exports2) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports2.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports2.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject2;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports2.isDate = isDate;
  function isError2(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports2.isError = isError2;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction;
  function isPrimitive2(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive2;
  exports2.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports2, module2) => {
  try {
    util54 = require("util");
    if (typeof util54.inherits !== "function")
      throw "";
    module2.exports = util54.inherits;
  } catch (e) {
    module2.exports = require_inherits_browser();
  }
  var util54;
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS((exports2, module2) => {
  "use strict";
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util54 = require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module2.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = {data: v, next: null};
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = {data: v, next: this.head};
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret2 = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret2;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join2(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret2 = "" + p.data;
      while (p = p.next) {
        ret2 += s + p.data;
      }
      return ret2;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret2 = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret2, i);
        i += p.data.length;
        p = p.next;
      }
      return ret2;
    };
    return BufferList;
  }();
  if (util54 && util54.inspect && util54.inspect.custom) {
    module2.exports.prototype[util54.inspect.custom] = function() {
      var obj = util54.inspect({length: this.length});
      return this.constructor.name + " " + obj;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
        pna.nextTick(emitErrorNT, this, err);
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        pna.nextTick(emitErrorNT, _this, err2);
        if (_this._writableState) {
          _this._writableState.errorEmitted = true;
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module2.exports = {
    destroy,
    undestroy
  };
});

// node_modules/util-deprecate/node.js
var require_node2 = __commonJS((exports2, module2) => {
  module2.exports = require("util").deprecate;
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util54 = Object.create(require_util2());
  util54.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node2()
  };
  var Stream = require_stream();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  util54.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object15) {
        if (realHasInstance.call(this, object15))
          return true;
        if (this !== Writable)
          return false;
        return object15 && object15._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object15) {
      return object15 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret2 = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret2;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret2 = state.length < state.highWaterMark;
    if (!ret2)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret2;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer4 = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer4[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer4.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer4, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending && !state.finished)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream.emit("error", err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = corkReq;
    } else {
      state.corkedRequestsFree = corkReq;
    }
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module2.exports = Duplex;
  var util54 = Object.create(require_util2());
  util54.inherits = require_inherits();
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  util54.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS((exports2, module2) => {
  "use strict";
  var pna = require_process_nextick_args();
  module2.exports = Readable;
  var isArray = require_isarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = require_stream();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util54 = Object.create(require_util2());
  util54.inherits = require_inherits();
  var debugUtil = require("util");
  var debug = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList = require_BufferList();
  var destroyImpl = require_destroy();
  var StringDecoder;
  util54.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit("data", chunk);
      stream.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require("string_decoder/").StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret2;
    if (n > 0)
      ret2 = fromList(n, state);
    else
      ret2 = null;
    if (ret2 === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret2 !== null)
      this.emit("data", ret2);
    return ret2;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret2 = dest.write(chunk);
      if (ret2 === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {hasUnpiped: false};
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, unpipeInfo);
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret2 = _this.push(chunk);
      if (!ret2) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret2;
    if (state.objectMode)
      ret2 = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret2 = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret2 = state.buffer.head.data;
      else
        ret2 = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret2 = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret2;
  }
  function fromListPartial(n, list2, hasStrings) {
    var ret2;
    if (n < list2.head.data.length) {
      ret2 = list2.head.data.slice(0, n);
      list2.head.data = list2.head.data.slice(n);
    } else if (n === list2.head.data.length) {
      ret2 = list2.shift();
    } else {
      ret2 = hasStrings ? copyFromBufferString(n, list2) : copyFromBuffer(n, list2);
    }
    return ret2;
  }
  function copyFromBufferString(n, list2) {
    var p = list2.head;
    var c = 1;
    var ret2 = p.data;
    n -= ret2.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret2 += str;
      else
        ret2 += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list2.head = p.next;
          else
            list2.head = list2.tail = null;
        } else {
          list2.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list2.length -= c;
    return ret2;
  }
  function copyFromBuffer(n, list2) {
    var ret2 = Buffer2.allocUnsafe(n);
    var p = list2.head;
    var c = 1;
    p.data.copy(ret2);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret2, ret2.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list2.head = p.next;
          else
            list2.head = list2.tail = null;
        } else {
          list2.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list2.length -= c;
    return ret2;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Transform2;
  var Duplex = require_stream_duplex();
  var util54 = Object.create(require_util2());
  util54.inherits = require_inherits();
  util54.inherits(Transform2, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2))
      return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = PassThrough;
  var Transform2 = require_stream_transform();
  var util54 = Object.create(require_util2());
  util54.inherits = require_inherits();
  util54.inherits(PassThrough, Transform2);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform2.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports2, module2) => {
  var Stream = require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module2.exports = Stream;
    exports2 = module2.exports = Stream.Readable;
    exports2.Readable = Stream.Readable;
    exports2.Writable = Stream.Writable;
    exports2.Duplex = Stream.Duplex;
    exports2.Transform = Stream.Transform;
    exports2.PassThrough = Stream.PassThrough;
    exports2.Stream = Stream;
  } else {
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = Stream || exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
  }
});

// node_modules/unzipper/lib/PullStream.js
var require_PullStream = __commonJS((exports2, module2) => {
  var Stream = require("stream");
  var Promise2 = require_bluebird();
  var util54 = require("util");
  var Buffer2 = require_Buffer2();
  var strFunction = "function";
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable();
  function PullStream() {
    if (!(this instanceof PullStream))
      return new PullStream();
    Stream.Duplex.call(this, {decodeStrings: false, objectMode: true});
    this.buffer = Buffer2.from("");
    var self2 = this;
    self2.on("finish", function() {
      self2.finished = true;
      self2.emit("chunk", false);
    });
  }
  util54.inherits(PullStream, Stream.Duplex);
  PullStream.prototype._write = function(chunk, e, cb) {
    this.buffer = Buffer2.concat([this.buffer, chunk]);
    this.cb = cb;
    this.emit("chunk");
  };
  PullStream.prototype.stream = function(eof, includeEof) {
    var p = Stream.PassThrough();
    var done, self2 = this;
    function cb() {
      if (typeof self2.cb === strFunction) {
        var callback = self2.cb;
        self2.cb = void 0;
        return callback();
      }
    }
    function pull() {
      var packet;
      if (self2.buffer && self2.buffer.length) {
        if (typeof eof === "number") {
          packet = self2.buffer.slice(0, eof);
          self2.buffer = self2.buffer.slice(eof);
          eof -= packet.length;
          done = !eof;
        } else {
          var match3 = self2.buffer.indexOf(eof);
          if (match3 !== -1) {
            self2.match = match3;
            if (includeEof)
              match3 = match3 + eof.length;
            packet = self2.buffer.slice(0, match3);
            self2.buffer = self2.buffer.slice(match3);
            done = true;
          } else {
            var len = self2.buffer.length - eof.length;
            if (len <= 0) {
              cb();
            } else {
              packet = self2.buffer.slice(0, len);
              self2.buffer = self2.buffer.slice(len);
            }
          }
        }
        if (packet)
          p.write(packet, function() {
            if (self2.buffer.length === 0 || eof.length && self2.buffer.length <= eof.length)
              cb();
          });
      }
      if (!done) {
        if (self2.finished && !this.__ended) {
          self2.removeListener("chunk", pull);
          self2.emit("error", new Error("FILE_ENDED"));
          this.__ended = true;
          return;
        }
      } else {
        self2.removeListener("chunk", pull);
        p.end();
      }
    }
    self2.on("chunk", pull);
    pull();
    return p;
  };
  PullStream.prototype.pull = function(eof, includeEof) {
    if (eof === 0)
      return Promise2.resolve("");
    if (!isNaN(eof) && this.buffer.length > eof) {
      var data = this.buffer.slice(0, eof);
      this.buffer = this.buffer.slice(eof);
      return Promise2.resolve(data);
    }
    var buffer4 = Buffer2.from(""), self2 = this;
    var concatStream = Stream.Transform();
    concatStream._transform = function(d, e, cb) {
      buffer4 = Buffer2.concat([buffer4, d]);
      cb();
    };
    var rejectHandler;
    var pullStreamRejectHandler;
    return new Promise2(function(resolve3, reject) {
      rejectHandler = reject;
      pullStreamRejectHandler = function(e) {
        self2.__emittedError = e;
        reject(e);
      };
      if (self2.finished)
        return reject(new Error("FILE_ENDED"));
      self2.once("error", pullStreamRejectHandler);
      self2.stream(eof, includeEof).on("error", reject).pipe(concatStream).on("finish", function() {
        resolve3(buffer4);
      }).on("error", reject);
    }).finally(function() {
      self2.removeListener("error", rejectHandler);
      self2.removeListener("error", pullStreamRejectHandler);
    });
  };
  PullStream.prototype._read = function() {
  };
  module2.exports = PullStream;
});

// node_modules/unzipper/lib/NoopStream.js
var require_NoopStream = __commonJS((exports2, module2) => {
  var Stream = require("stream");
  var util54 = require("util");
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable();
  function NoopStream() {
    if (!(this instanceof NoopStream)) {
      return new NoopStream();
    }
    Stream.Transform.call(this);
  }
  util54.inherits(NoopStream, Stream.Transform);
  NoopStream.prototype._transform = function(d, e, cb) {
    cb();
  };
  module2.exports = NoopStream;
});

// node_modules/unzipper/lib/BufferStream.js
var require_BufferStream = __commonJS((exports2, module2) => {
  var Promise2 = require_bluebird();
  var Stream = require("stream");
  var Buffer2 = require_Buffer2();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable();
  module2.exports = function(entry) {
    return new Promise2(function(resolve3, reject) {
      var chunks = [];
      var bufferStream = Stream.Transform().on("finish", function() {
        resolve3(Buffer2.concat(chunks));
      }).on("error", reject);
      bufferStream._transform = function(d, e, cb) {
        chunks.push(d);
        cb();
      };
      entry.on("error", reject).pipe(bufferStream);
    });
  };
});

// node_modules/unzipper/lib/parseExtraField.js
var require_parseExtraField = __commonJS((exports2, module2) => {
  var binary = require_binary();
  module2.exports = function(extraField, vars) {
    var extra;
    while (!extra && extraField && extraField.length) {
      var candidateExtra = binary.parse(extraField).word16lu("signature").word16lu("partsize").word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offset").word64lu("disknum").vars;
      if (candidateExtra.signature === 1) {
        extra = candidateExtra;
      } else {
        extraField = extraField.slice(candidateExtra.partsize + 4);
      }
    }
    extra = extra || {};
    if (vars.compressedSize === 4294967295)
      vars.compressedSize = extra.compressedSize;
    if (vars.uncompressedSize === 4294967295)
      vars.uncompressedSize = extra.uncompressedSize;
    if (vars.offsetToLocalFileHeader === 4294967295)
      vars.offsetToLocalFileHeader = extra.offset;
    return extra;
  };
});

// node_modules/unzipper/lib/parseDateTime.js
var require_parseDateTime = __commonJS((exports2, module2) => {
  module2.exports = function parseDateTime(date, time) {
    const day = date & 31;
    const month = date >> 5 & 15;
    const year = (date >> 9 & 127) + 1980;
    const seconds = time ? (time & 31) * 2 : 0;
    const minutes = time ? time >> 5 & 63 : 0;
    const hours = time ? time >> 11 : 0;
    return new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds));
  };
});

// node_modules/unzipper/lib/parse.js
var require_parse3 = __commonJS((exports2, module2) => {
  var util54 = require("util");
  var zlib3 = require("zlib");
  var Stream = require("stream");
  var binary = require_binary();
  var Promise2 = require_bluebird();
  var PullStream = require_PullStream();
  var NoopStream = require_NoopStream();
  var BufferStream = require_BufferStream();
  var parseExtraField = require_parseExtraField();
  var Buffer2 = require_Buffer2();
  var parseDateTime = require_parseDateTime();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable();
  var endDirectorySignature = Buffer2.alloc(4);
  endDirectorySignature.writeUInt32LE(101010256, 0);
  function Parse(opts) {
    if (!(this instanceof Parse)) {
      return new Parse(opts);
    }
    var self2 = this;
    self2._opts = opts || {verbose: false};
    PullStream.call(self2, self2._opts);
    self2.on("finish", function() {
      self2.emit("close");
    });
    self2._readRecord().catch(function(e) {
      if (!self2.__emittedError || self2.__emittedError !== e)
        self2.emit("error", e);
    });
  }
  util54.inherits(Parse, PullStream);
  Parse.prototype._readRecord = function() {
    var self2 = this;
    return self2.pull(4).then(function(data) {
      if (data.length === 0)
        return;
      var signature2 = data.readUInt32LE(0);
      if (signature2 === 875721283) {
        return self2._readCrxHeader();
      }
      if (signature2 === 67324752) {
        return self2._readFile();
      } else if (signature2 === 33639248) {
        self2.__ended = true;
        return self2._readCentralDirectoryFileHeader();
      } else if (signature2 === 101010256) {
        return self2._readEndOfCentralDirectoryRecord();
      } else if (self2.__ended) {
        return self2.pull(endDirectorySignature).then(function() {
          return self2._readEndOfCentralDirectoryRecord();
        });
      } else
        self2.emit("error", new Error("invalid signature: 0x" + signature2.toString(16)));
    });
  };
  Parse.prototype._readCrxHeader = function() {
    var self2 = this;
    return self2.pull(12).then(function(data) {
      self2.crxHeader = binary.parse(data).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
      return self2.pull(self2.crxHeader.pubKeyLength + self2.crxHeader.signatureLength);
    }).then(function(data) {
      self2.crxHeader.publicKey = data.slice(0, self2.crxHeader.pubKeyLength);
      self2.crxHeader.signature = data.slice(self2.crxHeader.pubKeyLength);
      self2.emit("crx-header", self2.crxHeader);
      return self2._readRecord();
    });
  };
  Parse.prototype._readFile = function() {
    var self2 = this;
    return self2.pull(26).then(function(data) {
      var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
      vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);
      if (self2.crxHeader)
        vars.crxHeader = self2.crxHeader;
      return self2.pull(vars.fileNameLength).then(function(fileNameBuffer) {
        var fileName = fileNameBuffer.toString("utf8");
        var entry = Stream.PassThrough();
        var __autodraining = false;
        entry.autodrain = function() {
          __autodraining = true;
          var draining = entry.pipe(NoopStream());
          draining.promise = function() {
            return new Promise2(function(resolve3, reject) {
              draining.on("finish", resolve3);
              draining.on("error", reject);
            });
          };
          return draining;
        };
        entry.buffer = function() {
          return BufferStream(entry);
        };
        entry.path = fileName;
        entry.props = {};
        entry.props.path = fileName;
        entry.props.pathBuffer = fileNameBuffer;
        entry.props.flags = {
          isUnicode: vars.flags & 17
        };
        entry.type = vars.uncompressedSize === 0 && /[\/\\]$/.test(fileName) ? "Directory" : "File";
        if (self2._opts.verbose) {
          if (entry.type === "Directory") {
            console.log("   creating:", fileName);
          } else if (entry.type === "File") {
            if (vars.compressionMethod === 0) {
              console.log(" extracting:", fileName);
            } else {
              console.log("  inflating:", fileName);
            }
          }
        }
        return self2.pull(vars.extraFieldLength).then(function(extraField) {
          var extra = parseExtraField(extraField, vars);
          entry.vars = vars;
          entry.extra = extra;
          if (self2._opts.forceStream) {
            self2.push(entry);
          } else {
            self2.emit("entry", entry);
            if (self2._readableState.pipesCount || self2._readableState.pipes && self2._readableState.pipes.length)
              self2.push(entry);
          }
          if (self2._opts.verbose)
            console.log({
              filename: fileName,
              vars,
              extra
            });
          var fileSizeKnown = !(vars.flags & 8) || vars.compressedSize > 0, eof;
          entry.__autodraining = __autodraining;
          var inflater = vars.compressionMethod && !__autodraining ? zlib3.createInflateRaw() : Stream.PassThrough();
          if (fileSizeKnown) {
            entry.size = vars.uncompressedSize;
            eof = vars.compressedSize;
          } else {
            eof = Buffer2.alloc(4);
            eof.writeUInt32LE(134695760, 0);
          }
          return new Promise2(function(resolve3, reject) {
            self2.stream(eof).pipe(inflater).on("error", function(err) {
              self2.emit("error", err);
            }).pipe(entry).on("finish", function() {
              return fileSizeKnown ? self2._readRecord().then(resolve3).catch(reject) : self2._processDataDescriptor(entry).then(resolve3).catch(reject);
            });
          });
        });
      });
    });
  };
  Parse.prototype._processDataDescriptor = function(entry) {
    var self2 = this;
    return self2.pull(16).then(function(data) {
      var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
      entry.size = vars.uncompressedSize;
      return self2._readRecord();
    });
  };
  Parse.prototype._readCentralDirectoryFileHeader = function() {
    var self2 = this;
    return self2.pull(42).then(function(data) {
      var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
      return self2.pull(vars.fileNameLength).then(function(fileName) {
        vars.fileName = fileName.toString("utf8");
        return self2.pull(vars.extraFieldLength);
      }).then(function(extraField) {
        return self2.pull(vars.fileCommentLength);
      }).then(function(fileComment) {
        return self2._readRecord();
      });
    });
  };
  Parse.prototype._readEndOfCentralDirectoryRecord = function() {
    var self2 = this;
    return self2.pull(18).then(function(data) {
      var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
      return self2.pull(vars.commentLength).then(function(comment) {
        comment = comment.toString("utf8");
        self2.end();
        self2.push(null);
      });
    });
  };
  Parse.prototype.promise = function() {
    var self2 = this;
    return new Promise2(function(resolve3, reject) {
      self2.on("finish", resolve3);
      self2.on("error", reject);
    });
  };
  module2.exports = Parse;
});

// node_modules/duplexer2/index.js
var require_duplexer2 = __commonJS((exports2, module2) => {
  "use strict";
  var stream = require_readable();
  function DuplexWrapper(options, writable, readable) {
    if (typeof readable === "undefined") {
      readable = writable;
      writable = options;
      options = null;
    }
    stream.Duplex.call(this, options);
    if (typeof readable.read !== "function") {
      readable = new stream.Readable(options).wrap(readable);
    }
    this._writable = writable;
    this._readable = readable;
    this._waiting = false;
    var self2 = this;
    writable.once("finish", function() {
      self2.end();
    });
    this.once("finish", function() {
      writable.end();
    });
    readable.on("readable", function() {
      if (self2._waiting) {
        self2._waiting = false;
        self2._read();
      }
    });
    readable.once("end", function() {
      self2.push(null);
    });
    if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
      writable.on("error", function(err) {
        self2.emit("error", err);
      });
      readable.on("error", function(err) {
        self2.emit("error", err);
      });
    }
  }
  DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: DuplexWrapper}});
  DuplexWrapper.prototype._write = function _write(input, encoding, done) {
    this._writable.write(input, encoding, done);
  };
  DuplexWrapper.prototype._read = function _read() {
    var buf;
    var reads = 0;
    while ((buf = this._readable.read()) !== null) {
      this.push(buf);
      reads++;
    }
    if (reads === 0) {
      this._waiting = true;
    }
  };
  module2.exports = function duplex2(options, writable, readable) {
    return new DuplexWrapper(options, writable, readable);
  };
  module2.exports.DuplexWrapper = DuplexWrapper;
});

// node_modules/unzipper/lib/parseOne.js
var require_parseOne = __commonJS((exports2, module2) => {
  var Stream = require("stream");
  var Parse = require_parse3();
  var duplexer2 = require_duplexer2();
  var BufferStream = require_BufferStream();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable();
  function parseOne(match3, opts) {
    var inStream = Stream.PassThrough({objectMode: true});
    var outStream = Stream.PassThrough();
    var transform = Stream.Transform({objectMode: true});
    var re = match3 instanceof RegExp ? match3 : match3 && new RegExp(match3);
    var found;
    transform._transform = function(entry, e, cb) {
      if (found || re && !re.exec(entry.path)) {
        entry.autodrain();
        return cb();
      } else {
        found = true;
        out.emit("entry", entry);
        entry.on("error", function(e2) {
          outStream.emit("error", e2);
        });
        entry.pipe(outStream).on("error", function(err) {
          cb(err);
        }).on("finish", function(d) {
          cb(null, d);
        });
      }
    };
    inStream.pipe(Parse(opts)).on("error", function(err) {
      outStream.emit("error", err);
    }).pipe(transform).on("error", Object).on("finish", function() {
      if (!found)
        outStream.emit("error", new Error("PATTERN_NOT_FOUND"));
      else
        outStream.end();
    });
    var out = duplexer2(inStream, outStream);
    out.buffer = function() {
      return BufferStream(outStream);
    };
    return out;
  }
  module2.exports = parseOne;
});

// node_modules/fstream/lib/abstract.js
var require_abstract = __commonJS((exports2, module2) => {
  module2.exports = Abstract;
  var Stream = require("stream").Stream;
  var inherits2 = require_inherits();
  function Abstract() {
    Stream.call(this);
  }
  inherits2(Abstract, Stream);
  Abstract.prototype.on = function(ev, fn) {
    if (ev === "ready" && this.ready) {
      process.nextTick(fn.bind(this));
    } else {
      Stream.prototype.on.call(this, ev, fn);
    }
    return this;
  };
  Abstract.prototype.abort = function() {
    this._aborted = true;
    this.emit("abort");
  };
  Abstract.prototype.destroy = function() {
  };
  Abstract.prototype.warn = function(msg, code) {
    var self2 = this;
    var er = decorate(msg, code, self2);
    if (!self2.listeners("warn")) {
      console.error("%s %s\npath = %s\nsyscall = %s\nfstream_type = %s\nfstream_path = %s\nfstream_unc_path = %s\nfstream_class = %s\nfstream_stack =\n%s\n", code || "UNKNOWN", er.stack, er.path, er.syscall, er.fstream_type, er.fstream_path, er.fstream_unc_path, er.fstream_class, er.fstream_stack.join("\n"));
    } else {
      self2.emit("warn", er);
    }
  };
  Abstract.prototype.info = function(msg, code) {
    this.emit("info", msg, code);
  };
  Abstract.prototype.error = function(msg, code, th) {
    var er = decorate(msg, code, this);
    if (th)
      throw er;
    else
      this.emit("error", er);
  };
  function decorate(er, code, self2) {
    if (!(er instanceof Error))
      er = new Error(er);
    er.code = er.code || code;
    er.path = er.path || self2.path;
    er.fstream_type = er.fstream_type || self2.type;
    er.fstream_path = er.fstream_path || self2.path;
    if (self2._path !== self2.path) {
      er.fstream_unc_path = er.fstream_unc_path || self2._path;
    }
    if (self2.linkpath) {
      er.fstream_linkpath = er.fstream_linkpath || self2.linkpath;
    }
    er.fstream_class = er.fstream_class || self2.constructor.name;
    er.fstream_stack = er.fstream_stack || new Error().stack.split(/\n/).slice(3).map(function(s) {
      return s.replace(/^ {4}at /, "");
    });
    return er;
  }
});

// node_modules/fstream/lib/get-type.js
var require_get_type = __commonJS((exports2, module2) => {
  module2.exports = getType;
  function getType(st) {
    var types11 = [
      "Directory",
      "File",
      "SymbolicLink",
      "Link",
      "BlockDevice",
      "CharacterDevice",
      "FIFO",
      "Socket"
    ];
    var type;
    if (st.type && types11.indexOf(st.type) !== -1) {
      st[st.type] = true;
      return st.type;
    }
    for (var i = 0, l = types11.length; i < l; i++) {
      type = types11[i];
      var is6 = st[type] || st["is" + type];
      if (typeof is6 === "function")
        is6 = is6.call(st);
      if (is6) {
        st[type] = true;
        st.type = type;
        return type;
      }
    }
    return null;
  }
});

// node_modules/fstream/lib/link-reader.js
var require_link_reader = __commonJS((exports2, module2) => {
  module2.exports = LinkReader;
  var fs55 = require_graceful_fs();
  var inherits2 = require_inherits();
  var Reader = require_reader();
  inherits2(LinkReader, Reader);
  function LinkReader(props) {
    var self2 = this;
    if (!(self2 instanceof LinkReader)) {
      throw new Error("LinkReader must be called as constructor.");
    }
    if (!(props.type === "Link" && props.Link || props.type === "SymbolicLink" && props.SymbolicLink)) {
      throw new Error("Non-link type " + props.type);
    }
    Reader.call(self2, props);
  }
  LinkReader.prototype._stat = function(currentStat) {
    var self2 = this;
    fs55.readlink(self2._path, function(er, linkpath) {
      if (er)
        return self2.error(er);
      self2.linkpath = self2.props.linkpath = linkpath;
      self2.emit("linkpath", linkpath);
      Reader.prototype._stat.call(self2, currentStat);
    });
  };
  LinkReader.prototype._read = function() {
    var self2 = this;
    if (self2._paused)
      return;
    if (!self2._ended) {
      self2.emit("end");
      self2.emit("close");
      self2._ended = true;
    }
  };
});

// node_modules/fstream/lib/dir-reader.js
var require_dir_reader = __commonJS((exports2, module2) => {
  module2.exports = DirReader;
  var fs55 = require_graceful_fs();
  var inherits2 = require_inherits();
  var path66 = require("path");
  var Reader = require_reader();
  var assert = require("assert").ok;
  inherits2(DirReader, Reader);
  function DirReader(props) {
    var self2 = this;
    if (!(self2 instanceof DirReader)) {
      throw new Error("DirReader must be called as constructor.");
    }
    if (props.type !== "Directory" || !props.Directory) {
      throw new Error("Non-directory type " + props.type);
    }
    self2.entries = null;
    self2._index = -1;
    self2._paused = false;
    self2._length = -1;
    if (props.sort) {
      this.sort = props.sort;
    }
    Reader.call(this, props);
  }
  DirReader.prototype._getEntries = function() {
    var self2 = this;
    if (self2._gotEntries)
      return;
    self2._gotEntries = true;
    fs55.readdir(self2._path, function(er, entries) {
      if (er)
        return self2.error(er);
      self2.entries = entries;
      self2.emit("entries", entries);
      if (self2._paused)
        self2.once("resume", processEntries);
      else
        processEntries();
      function processEntries() {
        self2._length = self2.entries.length;
        if (typeof self2.sort === "function") {
          self2.entries = self2.entries.sort(self2.sort.bind(self2));
        }
        self2._read();
      }
    });
  };
  DirReader.prototype._read = function() {
    var self2 = this;
    if (!self2.entries)
      return self2._getEntries();
    if (self2._paused || self2._currentEntry || self2._aborted) {
      return;
    }
    self2._index++;
    if (self2._index >= self2.entries.length) {
      if (!self2._ended) {
        self2._ended = true;
        self2.emit("end");
        self2.emit("close");
      }
      return;
    }
    var p = path66.resolve(self2._path, self2.entries[self2._index]);
    assert(p !== self2._path);
    assert(self2.entries[self2._index]);
    self2._currentEntry = p;
    fs55[self2.props.follow ? "stat" : "lstat"](p, function(er, stat) {
      if (er)
        return self2.error(er);
      var who = self2._proxy || self2;
      stat.path = p;
      stat.basename = path66.basename(p);
      stat.dirname = path66.dirname(p);
      var childProps = self2.getChildProps.call(who, stat);
      childProps.path = p;
      childProps.basename = path66.basename(p);
      childProps.dirname = path66.dirname(p);
      var entry = Reader(childProps, stat);
      self2._currentEntry = entry;
      entry.on("pause", function(who2) {
        if (!self2._paused && !entry._disowned) {
          self2.pause(who2);
        }
      });
      entry.on("resume", function(who2) {
        if (self2._paused && !entry._disowned) {
          self2.resume(who2);
        }
      });
      entry.on("stat", function(props) {
        self2.emit("_entryStat", entry, props);
        if (entry._aborted)
          return;
        if (entry._paused) {
          entry.once("resume", function() {
            self2.emit("entryStat", entry, props);
          });
        } else
          self2.emit("entryStat", entry, props);
      });
      entry.on("ready", function EMITCHILD() {
        if (self2._paused) {
          entry.pause(self2);
          return self2.once("resume", EMITCHILD);
        }
        if (entry.type === "Socket") {
          self2.emit("socket", entry);
        } else {
          self2.emitEntry(entry);
        }
      });
      var ended = false;
      entry.on("close", onend);
      entry.on("disown", onend);
      function onend() {
        if (ended)
          return;
        ended = true;
        self2.emit("childEnd", entry);
        self2.emit("entryEnd", entry);
        self2._currentEntry = null;
        if (!self2._paused) {
          self2._read();
        }
      }
      entry.on("error", function(er2) {
        if (entry._swallowErrors) {
          self2.warn(er2);
          entry.emit("end");
          entry.emit("close");
        } else {
          self2.emit("error", er2);
        }
      });
      [
        "child",
        "childEnd",
        "warn"
      ].forEach(function(ev) {
        entry.on(ev, self2.emit.bind(self2, ev));
      });
    });
  };
  DirReader.prototype.disown = function(entry) {
    entry.emit("beforeDisown");
    entry._disowned = true;
    entry.parent = entry.root = null;
    if (entry === this._currentEntry) {
      this._currentEntry = null;
    }
    entry.emit("disown");
  };
  DirReader.prototype.getChildProps = function() {
    return {
      depth: this.depth + 1,
      root: this.root || this,
      parent: this,
      follow: this.follow,
      filter: this.filter,
      sort: this.props.sort,
      hardlinks: this.props.hardlinks
    };
  };
  DirReader.prototype.pause = function(who) {
    var self2 = this;
    if (self2._paused)
      return;
    who = who || self2;
    self2._paused = true;
    if (self2._currentEntry && self2._currentEntry.pause) {
      self2._currentEntry.pause(who);
    }
    self2.emit("pause", who);
  };
  DirReader.prototype.resume = function(who) {
    var self2 = this;
    if (!self2._paused)
      return;
    who = who || self2;
    self2._paused = false;
    self2.emit("resume", who);
    if (self2._paused) {
      return;
    }
    if (self2._currentEntry) {
      if (self2._currentEntry.resume)
        self2._currentEntry.resume(who);
    } else
      self2._read();
  };
  DirReader.prototype.emitEntry = function(entry) {
    this.emit("entry", entry);
    this.emit("child", entry);
  };
});

// node_modules/fstream/lib/file-reader.js
var require_file_reader = __commonJS((exports2, module2) => {
  module2.exports = FileReader;
  var fs55 = require_graceful_fs();
  var inherits2 = require_inherits();
  var Reader = require_reader();
  var EOF = {EOF: true};
  var CLOSE = {CLOSE: true};
  inherits2(FileReader, Reader);
  function FileReader(props) {
    var self2 = this;
    if (!(self2 instanceof FileReader)) {
      throw new Error("FileReader must be called as constructor.");
    }
    if (!(props.type === "Link" && props.Link || props.type === "File" && props.File)) {
      throw new Error("Non-file type " + props.type);
    }
    self2._buffer = [];
    self2._bytesEmitted = 0;
    Reader.call(self2, props);
  }
  FileReader.prototype._getStream = function() {
    var self2 = this;
    var stream = self2._stream = fs55.createReadStream(self2._path, self2.props);
    if (self2.props.blksize) {
      stream.bufferSize = self2.props.blksize;
    }
    stream.on("open", self2.emit.bind(self2, "open"));
    stream.on("data", function(c) {
      self2._bytesEmitted += c.length;
      if (!c.length) {
        return;
      } else if (self2._paused || self2._buffer.length) {
        self2._buffer.push(c);
        self2._read();
      } else
        self2.emit("data", c);
    });
    stream.on("end", function() {
      if (self2._paused || self2._buffer.length) {
        self2._buffer.push(EOF);
        self2._read();
      } else {
        self2.emit("end");
      }
      if (self2._bytesEmitted !== self2.props.size) {
        self2.error("Didn't get expected byte count\nexpect: " + self2.props.size + "\nactual: " + self2._bytesEmitted);
      }
    });
    stream.on("close", function() {
      if (self2._paused || self2._buffer.length) {
        self2._buffer.push(CLOSE);
        self2._read();
      } else {
        self2.emit("close");
      }
    });
    stream.on("error", function(e) {
      self2.emit("error", e);
    });
    self2._read();
  };
  FileReader.prototype._read = function() {
    var self2 = this;
    if (self2._paused) {
      return;
    }
    if (!self2._stream) {
      return self2._getStream();
    }
    if (self2._buffer.length) {
      var buf = self2._buffer;
      for (var i = 0, l = buf.length; i < l; i++) {
        var c = buf[i];
        if (c === EOF) {
          self2.emit("end");
        } else if (c === CLOSE) {
          self2.emit("close");
        } else {
          self2.emit("data", c);
        }
        if (self2._paused) {
          self2._buffer = buf.slice(i);
          return;
        }
      }
      self2._buffer.length = 0;
    }
  };
  FileReader.prototype.pause = function(who) {
    var self2 = this;
    if (self2._paused)
      return;
    who = who || self2;
    self2._paused = true;
    if (self2._stream)
      self2._stream.pause();
    self2.emit("pause", who);
  };
  FileReader.prototype.resume = function(who) {
    var self2 = this;
    if (!self2._paused)
      return;
    who = who || self2;
    self2.emit("resume", who);
    self2._paused = false;
    if (self2._stream)
      self2._stream.resume();
    self2._read();
  };
});

// node_modules/fstream/lib/socket-reader.js
var require_socket_reader = __commonJS((exports2, module2) => {
  module2.exports = SocketReader;
  var inherits2 = require_inherits();
  var Reader = require_reader();
  inherits2(SocketReader, Reader);
  function SocketReader(props) {
    var self2 = this;
    if (!(self2 instanceof SocketReader)) {
      throw new Error("SocketReader must be called as constructor.");
    }
    if (!(props.type === "Socket" && props.Socket)) {
      throw new Error("Non-socket type " + props.type);
    }
    Reader.call(self2, props);
  }
  SocketReader.prototype._read = function() {
    var self2 = this;
    if (self2._paused)
      return;
    if (!self2._ended) {
      self2.emit("end");
      self2.emit("close");
      self2._ended = true;
    }
  };
});

// node_modules/fstream/lib/proxy-reader.js
var require_proxy_reader = __commonJS((exports2, module2) => {
  module2.exports = ProxyReader;
  var Reader = require_reader();
  var getType = require_get_type();
  var inherits2 = require_inherits();
  var fs55 = require_graceful_fs();
  inherits2(ProxyReader, Reader);
  function ProxyReader(props) {
    var self2 = this;
    if (!(self2 instanceof ProxyReader)) {
      throw new Error("ProxyReader must be called as constructor.");
    }
    self2.props = props;
    self2._buffer = [];
    self2.ready = false;
    Reader.call(self2, props);
  }
  ProxyReader.prototype._stat = function() {
    var self2 = this;
    var props = self2.props;
    var stat = props.follow ? "stat" : "lstat";
    fs55[stat](props.path, function(er, current) {
      var type;
      if (er || !current) {
        type = "File";
      } else {
        type = getType(current);
      }
      props[type] = true;
      props.type = self2.type = type;
      self2._old = current;
      self2._addProxy(Reader(props, current));
    });
  };
  ProxyReader.prototype._addProxy = function(proxy) {
    var self2 = this;
    if (self2._proxyTarget) {
      return self2.error("proxy already set");
    }
    self2._proxyTarget = proxy;
    proxy._proxy = self2;
    [
      "error",
      "data",
      "end",
      "close",
      "linkpath",
      "entry",
      "entryEnd",
      "child",
      "childEnd",
      "warn",
      "stat"
    ].forEach(function(ev) {
      proxy.on(ev, self2.emit.bind(self2, ev));
    });
    self2.emit("proxy", proxy);
    proxy.on("ready", function() {
      self2.ready = true;
      self2.emit("ready");
    });
    var calls = self2._buffer;
    self2._buffer.length = 0;
    calls.forEach(function(c) {
      proxy[c[0]].apply(proxy, c[1]);
    });
  };
  ProxyReader.prototype.pause = function() {
    return this._proxyTarget ? this._proxyTarget.pause() : false;
  };
  ProxyReader.prototype.resume = function() {
    return this._proxyTarget ? this._proxyTarget.resume() : false;
  };
});

// node_modules/fstream/lib/reader.js
var require_reader = __commonJS((exports2, module2) => {
  module2.exports = Reader;
  var fs55 = require_graceful_fs();
  var Stream = require("stream").Stream;
  var inherits2 = require_inherits();
  var path66 = require("path");
  var getType = require_get_type();
  var hardLinks = Reader.hardLinks = {};
  var Abstract = require_abstract();
  inherits2(Reader, Abstract);
  var LinkReader = require_link_reader();
  function Reader(props, currentStat) {
    var self2 = this;
    if (!(self2 instanceof Reader))
      return new Reader(props, currentStat);
    if (typeof props === "string") {
      props = {path: props};
    }
    var type;
    var ClassType;
    if (props.type && typeof props.type === "function") {
      type = props.type;
      ClassType = type;
    } else {
      type = getType(props);
      ClassType = Reader;
    }
    if (currentStat && !type) {
      type = getType(currentStat);
      props[type] = true;
      props.type = type;
    }
    switch (type) {
      case "Directory":
        ClassType = require_dir_reader();
        break;
      case "Link":
      case "File":
        ClassType = require_file_reader();
        break;
      case "SymbolicLink":
        ClassType = LinkReader;
        break;
      case "Socket":
        ClassType = require_socket_reader();
        break;
      case null:
        ClassType = require_proxy_reader();
        break;
    }
    if (!(self2 instanceof ClassType)) {
      return new ClassType(props);
    }
    Abstract.call(self2);
    if (!props.path) {
      self2.error("Must provide a path", null, true);
    }
    self2.readable = true;
    self2.writable = false;
    self2.type = type;
    self2.props = props;
    self2.depth = props.depth = props.depth || 0;
    self2.parent = props.parent || null;
    self2.root = props.root || props.parent && props.parent.root || self2;
    self2._path = self2.path = path66.resolve(props.path);
    if (process.platform === "win32") {
      self2.path = self2._path = self2.path.replace(/\?/g, "_");
      if (self2._path.length >= 260) {
        self2._swallowErrors = true;
        self2._path = "\\\\?\\" + self2.path.replace(/\//g, "\\");
      }
    }
    self2.basename = props.basename = path66.basename(self2.path);
    self2.dirname = props.dirname = path66.dirname(self2.path);
    props.parent = props.root = null;
    self2.size = props.size;
    self2.filter = typeof props.filter === "function" ? props.filter : null;
    if (props.sort === "alpha")
      props.sort = alphasort;
    self2._stat(currentStat);
  }
  function alphasort(a, b) {
    return a === b ? 0 : a.toLowerCase() > b.toLowerCase() ? 1 : a.toLowerCase() < b.toLowerCase() ? -1 : a > b ? 1 : -1;
  }
  Reader.prototype._stat = function(currentStat) {
    var self2 = this;
    var props = self2.props;
    var stat = props.follow ? "stat" : "lstat";
    if (currentStat)
      process.nextTick(statCb.bind(null, null, currentStat));
    else
      fs55[stat](self2._path, statCb);
    function statCb(er, props_) {
      if (er)
        return self2.error(er);
      Object.keys(props_).forEach(function(k2) {
        props[k2] = props_[k2];
      });
      if (self2.size !== void 0 && props.size !== self2.size) {
        return self2.error("incorrect size");
      }
      self2.size = props.size;
      var type = getType(props);
      var handleHardlinks = props.hardlinks !== false;
      if (handleHardlinks && type !== "Directory" && props.nlink && props.nlink > 1) {
        var k = props.dev + ":" + props.ino;
        if (hardLinks[k] === self2._path || !hardLinks[k]) {
          hardLinks[k] = self2._path;
        } else {
          type = self2.type = self2.props.type = "Link";
          self2.Link = self2.props.Link = true;
          self2.linkpath = self2.props.linkpath = hardLinks[k];
          self2._stat = self2._read = LinkReader.prototype._read;
        }
      }
      if (self2.type && self2.type !== type) {
        self2.error("Unexpected type: " + type);
      }
      if (self2.filter) {
        var who = self2._proxy || self2;
        if (!self2.filter.call(who, who, props)) {
          if (!self2._disowned) {
            self2.abort();
            self2.emit("end");
            self2.emit("close");
          }
          return;
        }
      }
      var events36 = ["_stat", "stat", "ready"];
      var e = 0;
      (function go() {
        if (self2._aborted) {
          self2.emit("end");
          self2.emit("close");
          return;
        }
        if (self2._paused && self2.type !== "Directory") {
          self2.once("resume", go);
          return;
        }
        var ev = events36[e++];
        if (!ev) {
          return self2._read();
        }
        self2.emit(ev, props);
        go();
      })();
    }
  };
  Reader.prototype.pipe = function(dest) {
    var self2 = this;
    if (typeof dest.add === "function") {
      self2.on("entry", function(entry) {
        var ret2 = dest.add(entry);
        if (ret2 === false) {
          self2.pause();
        }
      });
    }
    return Stream.prototype.pipe.apply(this, arguments);
  };
  Reader.prototype.pause = function(who) {
    this._paused = true;
    who = who || this;
    this.emit("pause", who);
    if (this._stream)
      this._stream.pause(who);
  };
  Reader.prototype.resume = function(who) {
    this._paused = false;
    who = who || this;
    this.emit("resume", who);
    if (this._stream)
      this._stream.resume(who);
    this._read();
  };
  Reader.prototype._read = function() {
    this.error("Cannot read unknown type: " + this.type);
  };
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS((exports2) => {
  var pathModule = require("path");
  var isWindows4 = process.platform === "win32";
  var fs55 = require("fs");
  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        else if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb === "function" ? cb : rethrow();
  }
  var normalize = pathModule.normalize;
  if (isWindows4) {
    nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }
  var nextPartRe;
  if (isWindows4) {
    splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    splitRootRe = /^[\/]*/;
  }
  var splitRootRe;
  exports2.realpathSync = function realpathSync(p, cache) {
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows4 && !knownHard[base]) {
        fs55.lstatSync(base);
        knownHard[base] = true;
      }
    }
    while (pos < p.length) {
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        continue;
      }
      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        resolvedLink = cache[base];
      } else {
        var stat = fs55.lstatSync(base);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          continue;
        }
        var linkTarget = null;
        if (!isWindows4) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs55.statSync(base);
          linkTarget = fs55.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        if (cache)
          cache[base] = resolvedLink;
        if (!isWindows4)
          seenLinks[id] = linkTarget;
      }
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
    if (cache)
      cache[original] = p;
    return p;
  };
  exports2.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== "function") {
      cb = maybeCallback(cache);
      cache = null;
    }
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows4 && !knownHard[base]) {
        fs55.lstat(base, function(err) {
          if (err)
            return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }
    function LOOP() {
      if (pos >= p.length) {
        if (cache)
          cache[original] = p;
        return cb(null, p);
      }
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        return process.nextTick(LOOP);
      }
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        return gotResolvedLink(cache[base]);
      }
      return fs55.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
      if (err)
        return cb(err);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache)
          cache[base] = base;
        return process.nextTick(LOOP);
      }
      if (!isWindows4) {
        var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs55.stat(base, function(err2) {
        if (err2)
          return cb(err2);
        fs55.readlink(base, function(err3, target) {
          if (!isWindows4)
            seenLinks[id] = target;
          gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base2) {
      if (err)
        return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      if (cache)
        cache[base2] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };
});

// node_modules/fs.realpath/index.js
var require_fs3 = __commonJS((exports2, module2) => {
  module2.exports = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;
  var fs55 = require("fs");
  var origRealpath = fs55.realpath;
  var origRealpathSync = fs55.realpathSync;
  var version2 = process.version;
  var ok = /^v[0-5]\./.test(version2);
  var old = require_old();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }
    if (typeof cache === "function") {
      cb = cache;
      cache = null;
    }
    origRealpath(p, cache, function(er, result) {
      if (newError(er)) {
        old.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  }
  function realpathSync(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  }
  function monkeypatch() {
    fs55.realpath = realpath;
    fs55.realpathSync = realpathSync;
  }
  function unmonkeypatch() {
    fs55.realpath = origRealpath;
    fs55.realpathSync = origRealpathSync;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS((exports2, module2) => {
  "use strict";
  function posix(path66) {
    return path66.charAt(0) === "/";
  }
  function win32(path66) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path66);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    return Boolean(result[2] || isUnc);
  }
  module2.exports = process.platform === "win32" ? win32 : posix;
  module2.exports.posix = posix;
  module2.exports.win32 = win32;
});

// node_modules/glob/common.js
var require_common2 = __commonJS((exports2) => {
  exports2.alphasort = alphasort;
  exports2.alphasorti = alphasorti;
  exports2.setopts = setopts;
  exports2.ownProp = ownProp;
  exports2.makeAbs = makeAbs;
  exports2.finish = finish;
  exports2.mark = mark;
  exports2.isIgnored = isIgnored;
  exports2.childrenIgnored = childrenIgnored;
  function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var path66 = require("path");
  var minimatch11 = require_minimatch();
  var isAbsolute = require_path_is_absolute();
  var Minimatch = minimatch11.Minimatch;
  function alphasorti(a, b) {
    return a.toLowerCase().localeCompare(b.toLowerCase());
  }
  function alphasort(a, b) {
    return a.localeCompare(b);
  }
  function setupIgnores(self2, options) {
    self2.ignore = options.ignore || [];
    if (!Array.isArray(self2.ignore))
      self2.ignore = [self2.ignore];
    if (self2.ignore.length) {
      self2.ignore = self2.ignore.map(ignoreMap);
    }
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch(gpattern, {dot: true});
    }
    return {
      matcher: new Minimatch(pattern, {dot: true}),
      gmatcher
    };
  }
  function setopts(self2, pattern, options) {
    if (!options)
      options = {};
    if (options.matchBase && pattern.indexOf("/") === -1) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar");
      }
      pattern = "**/" + pattern;
    }
    self2.silent = !!options.silent;
    self2.pattern = pattern;
    self2.strict = options.strict !== false;
    self2.realpath = !!options.realpath;
    self2.realpathCache = options.realpathCache || Object.create(null);
    self2.follow = !!options.follow;
    self2.dot = !!options.dot;
    self2.mark = !!options.mark;
    self2.nodir = !!options.nodir;
    if (self2.nodir)
      self2.mark = true;
    self2.sync = !!options.sync;
    self2.nounique = !!options.nounique;
    self2.nonull = !!options.nonull;
    self2.nosort = !!options.nosort;
    self2.nocase = !!options.nocase;
    self2.stat = !!options.stat;
    self2.noprocess = !!options.noprocess;
    self2.absolute = !!options.absolute;
    self2.maxLength = options.maxLength || Infinity;
    self2.cache = options.cache || Object.create(null);
    self2.statCache = options.statCache || Object.create(null);
    self2.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self2, options);
    self2.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp(options, "cwd"))
      self2.cwd = cwd;
    else {
      self2.cwd = path66.resolve(options.cwd);
      self2.changedCwd = self2.cwd !== cwd;
    }
    self2.root = options.root || path66.resolve(self2.cwd, "/");
    self2.root = path66.resolve(self2.root);
    if (process.platform === "win32")
      self2.root = self2.root.replace(/\\/g, "/");
    self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
    if (process.platform === "win32")
      self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
    self2.nomount = !!options.nomount;
    options.nonegate = true;
    options.nocomment = true;
    self2.minimatch = new Minimatch(pattern, options);
    self2.options = self2.minimatch.options;
  }
  function finish(self2) {
    var nou = self2.nounique;
    var all = nou ? [] : Object.create(null);
    for (var i = 0, l = self2.matches.length; i < l; i++) {
      var matches = self2.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self2.nonull) {
          var literal = self2.minimatch.globSet[i];
          if (nou)
            all.push(literal);
          else
            all[literal] = true;
        }
      } else {
        var m = Object.keys(matches);
        if (nou)
          all.push.apply(all, m);
        else
          m.forEach(function(m2) {
            all[m2] = true;
          });
      }
    }
    if (!nou)
      all = Object.keys(all);
    if (!self2.nosort)
      all = all.sort(self2.nocase ? alphasorti : alphasort);
    if (self2.mark) {
      for (var i = 0; i < all.length; i++) {
        all[i] = self2._mark(all[i]);
      }
      if (self2.nodir) {
        all = all.filter(function(e) {
          var notDir = !/\/$/.test(e);
          var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
          if (notDir && c)
            notDir = c !== "DIR" && !Array.isArray(c);
          return notDir;
        });
      }
    }
    if (self2.ignore.length)
      all = all.filter(function(m2) {
        return !isIgnored(self2, m2);
      });
    self2.found = all;
  }
  function mark(self2, p) {
    var abs = makeAbs(self2, p);
    var c = self2.cache[abs];
    var m = p;
    if (c) {
      var isDir = c === "DIR" || Array.isArray(c);
      var slash = p.slice(-1) === "/";
      if (isDir && !slash)
        m += "/";
      else if (!isDir && slash)
        m = m.slice(0, -1);
      if (m !== p) {
        var mabs = makeAbs(self2, m);
        self2.statCache[mabs] = self2.statCache[abs];
        self2.cache[mabs] = self2.cache[abs];
      }
    }
    return m;
  }
  function makeAbs(self2, f) {
    var abs = f;
    if (f.charAt(0) === "/") {
      abs = path66.join(self2.root, f);
    } else if (isAbsolute(f) || f === "") {
      abs = f;
    } else if (self2.changedCwd) {
      abs = path66.resolve(self2.cwd, f);
    } else {
      abs = path66.resolve(f);
    }
    if (process.platform === "win32")
      abs = abs.replace(/\\/g, "/");
    return abs;
  }
  function isIgnored(self2, path67) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return item.matcher.match(path67) || !!(item.gmatcher && item.gmatcher.match(path67));
    });
  }
  function childrenIgnored(self2, path67) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path67));
    });
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS((exports2, module2) => {
  module2.exports = globSync;
  globSync.GlobSync = GlobSync;
  var fs55 = require("fs");
  var rp = require_fs3();
  var minimatch11 = require_minimatch();
  var Minimatch = minimatch11.Minimatch;
  var Glob = require_glob().Glob;
  var util54 = require("util");
  var path66 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute();
  var common = require_common2();
  var alphasort = common.alphasort;
  var alphasorti = common.alphasorti;
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  function globSync(pattern, options) {
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options).found;
  }
  function GlobSync(pattern, options) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options);
    setopts(this, pattern, options);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set = self2.matches[index] = Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common.finish(this);
  };
  GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert(this instanceof GlobSync);
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return;
    var isGlobStar = remain[0] === minimatch11.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path66.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index, e) {
    if (isIgnored(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat;
    var stat;
    try {
      lstat = fs55.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    var entries;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs, fs55.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          throw error;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index) {
    var exists = this._stat(prefix);
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return;
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path66.join(this.root, prefix);
      } else {
        prefix = path66.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return c;
      if (needDir && c === "FILE")
        return false;
    }
    var exists;
    var stat = this.statCache[abs];
    if (!stat) {
      var lstat;
      try {
        lstat = fs55.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = fs55.statSync(abs);
        } catch (er) {
          stat = lstat;
        }
      } else {
        stat = lstat;
      }
    }
    this.statCache[abs] = stat;
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return false;
    return c;
  };
  GlobSync.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports2, module2) => {
  module2.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret2 = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret2 === "function" && ret2 !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret2[k] = cb2[k];
        });
      }
      return ret2;
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  module2.exports = wrappy(once);
  module2.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name2 = fn.name || "Function wrapped with `once`";
    f.onceError = name2 + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  var reqs = Object.create(null);
  var once = require_once();
  module2.exports = wrappy(inflight);
  function inflight(key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb);
      return null;
    } else {
      reqs[key] = [cb];
      return makeres(key);
    }
  }
  function makeres(key) {
    return once(function RES() {
      var cbs = reqs[key];
      var len = cbs.length;
      var args = slice(arguments);
      try {
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args);
        }
      } finally {
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key];
        }
      }
    });
  }
  function slice(args) {
    var length = args.length;
    var array6 = [];
    for (var i = 0; i < length; i++)
      array6[i] = args[i];
    return array6;
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS((exports2, module2) => {
  module2.exports = glob;
  var fs55 = require("fs");
  var rp = require_fs3();
  var minimatch11 = require_minimatch();
  var Minimatch = minimatch11.Minimatch;
  var inherits2 = require_inherits();
  var EE = require("events").EventEmitter;
  var path66 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute();
  var globSync = require_sync();
  var common = require_common2();
  var alphasort = common.alphasort;
  var alphasorti = common.alphasorti;
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var inflight = require_inflight();
  var util54 = require("util");
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  var once = require_once();
  function glob(pattern, options, cb) {
    if (typeof options === "function")
      cb = options, options = {};
    if (!options)
      options = {};
    if (options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
  }
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  function extend(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  glob.hasMagic = function(pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern)
      return false;
    if (set.length > 1)
      return true;
    for (var j = 0; j < set[0].length; j++) {
      if (typeof set[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits2(Glob, EE);
  function Glob(pattern, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    if (options && options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === "function") {
      cb = once(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done();
    var sync = true;
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self2 = this;
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self2 = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set = this.matches[index] = Object.create(null);
    found.forEach(function(p, i) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set[real] = true;
        else if (er.syscall === "stat")
          set[p] = true;
        else
          self2.emit("error", er);
        if (--n === 0) {
          self2.matches[index] = set;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    assert(this instanceof Glob);
    assert(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch11.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path66.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted)
      return;
    if (isIgnored(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index, e]);
      return;
    }
    var abs = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\0" + abs;
    var self2 = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb)
      fs55.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self2.cache[abs] = "FILE";
        cb();
      } else
        self2._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self2 = this;
    fs55.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs, er, cb);
      else
        self2._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + " invalid cwd " + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          this.emit("error", error);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists) {
      self2._processSimple2(prefix, index, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path66.join(this.root, prefix);
      } else {
        prefix = path66.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return cb(null, c);
      if (needDir && c === "FILE")
        return cb();
    }
    var exists;
    var stat = this.statCache[abs];
    if (stat !== void 0) {
      if (stat === false)
        return cb(null, stat);
      else {
        var type = stat.isDirectory() ? "DIR" : "FILE";
        if (needDir && type === "FILE")
          return cb();
        else
          return cb(null, type, stat);
      }
    }
    var self2 = this;
    var statcb = inflight("stat\0" + abs, lstatcb_);
    if (statcb)
      fs55.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return fs55.stat(abs, function(er2, stat2) {
          if (er2)
            self2._stat2(f, abs, null, lstat, cb);
          else
            self2._stat2(f, abs, er2, stat2, cb);
        });
      } else {
        self2._stat2(f, abs, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat;
    if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
      return cb(null, false, stat);
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return cb();
    return cb(null, c, stat);
  };
});

// node_modules/fstream/node_modules/rimraf/rimraf.js
var require_rimraf3 = __commonJS((exports2, module2) => {
  module2.exports = rimraf;
  rimraf.sync = rimrafSync;
  var assert = require("assert");
  var path66 = require("path");
  var fs55 = require("fs");
  var glob = void 0;
  try {
    glob = require_glob();
  } catch (_err) {
  }
  var _0666 = parseInt("666", 8);
  var defaultGlobOpts = {
    nosort: true,
    silent: true
  };
  var timeout = 0;
  var isWindows4 = process.platform === "win32";
  function defaults2(options) {
    var methods2 = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods2.forEach(function(m) {
      options[m] = options[m] || fs55[m];
      m = m + "Sync";
      options[m] = options[m] || fs55[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
    options.emfileWait = options.emfileWait || 1e3;
    if (options.glob === false) {
      options.disableGlob = true;
    }
    if (options.disableGlob !== true && glob === void 0) {
      throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
    }
    options.disableGlob = options.disableGlob || false;
    options.glob = options.glob || defaultGlobOpts;
  }
  function rimraf(p, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert.equal(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    defaults2(options);
    var busyTries = 0;
    var errState = null;
    var n = 0;
    if (options.disableGlob || !glob.hasMagic(p))
      return afterGlob(null, [p]);
    options.lstat(p, function(er, stat) {
      if (!er)
        return afterGlob(null, [p]);
      glob(p, options.glob, afterGlob);
    });
    function next(er) {
      errState = errState || er;
      if (--n === 0)
        cb(errState);
    }
    function afterGlob(er, results) {
      if (er)
        return cb(er);
      n = results.length;
      if (n === 0)
        return cb();
      results.forEach(function(p2) {
        rimraf_(p2, options, function CB(er2) {
          if (er2) {
            if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
              busyTries++;
              var time = busyTries * 100;
              return setTimeout(function() {
                rimraf_(p2, options, CB);
              }, time);
            }
            if (er2.code === "EMFILE" && timeout < options.emfileWait) {
              return setTimeout(function() {
                rimraf_(p2, options, CB);
              }, timeout++);
            }
            if (er2.code === "ENOENT")
              er2 = null;
          }
          timeout = 0;
          next(er2);
        });
      });
    }
  }
  function rimraf_(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, function(er, st) {
      if (er && er.code === "ENOENT")
        return cb(null);
      if (er && er.code === "EPERM" && isWindows4)
        fixWinEPERM(p, options, er, cb);
      if (st && st.isDirectory())
        return rmdir(p, options, er, cb);
      options.unlink(p, function(er2) {
        if (er2) {
          if (er2.code === "ENOENT")
            return cb(null);
          if (er2.code === "EPERM")
            return isWindows4 ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          if (er2.code === "EISDIR")
            return rmdir(p, options, er2, cb);
        }
        return cb(er2);
      });
    });
  }
  function fixWinEPERM(p, options, er, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    if (er)
      assert(er instanceof Error);
    options.chmod(p, _0666, function(er2) {
      if (er2)
        cb(er2.code === "ENOENT" ? null : er);
      else
        options.stat(p, function(er3, stats) {
          if (er3)
            cb(er3.code === "ENOENT" ? null : er);
          else if (stats.isDirectory())
            rmdir(p, options, er, cb);
          else
            options.unlink(p, cb);
        });
    });
  }
  function fixWinEPERMSync(p, options, er) {
    assert(p);
    assert(options);
    if (er)
      assert(er instanceof Error);
    try {
      options.chmodSync(p, _0666);
    } catch (er2) {
      if (er2.code === "ENOENT")
        return;
      else
        throw er;
    }
    try {
      var stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT")
        return;
      else
        throw er;
    }
    if (stats.isDirectory())
      rmdirSync(p, options, er);
    else
      options.unlinkSync(p);
  }
  function rmdir(p, options, originalEr, cb) {
    assert(p);
    assert(options);
    if (originalEr)
      assert(originalEr instanceof Error);
    assert(typeof cb === "function");
    options.rmdir(p, function(er) {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
        rmkids(p, options, cb);
      else if (er && er.code === "ENOTDIR")
        cb(originalEr);
      else
        cb(er);
    });
  }
  function rmkids(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, function(er, files) {
      if (er)
        return cb(er);
      var n = files.length;
      if (n === 0)
        return options.rmdir(p, cb);
      var errState;
      files.forEach(function(f) {
        rimraf(path66.join(p, f), options, function(er2) {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--n === 0)
            options.rmdir(p, cb);
        });
      });
    });
  }
  function rimrafSync(p, options) {
    options = options || {};
    defaults2(options);
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    var results;
    if (options.disableGlob || !glob.hasMagic(p)) {
      results = [p];
    } else {
      try {
        options.lstatSync(p);
        results = [p];
      } catch (er) {
        results = glob.sync(p, options.glob);
      }
    }
    if (!results.length)
      return;
    for (var i = 0; i < results.length; i++) {
      var p = results[i];
      try {
        var st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM" && isWindows4)
          fixWinEPERMSync(p, options, er);
      }
      try {
        if (st && st.isDirectory())
          rmdirSync(p, options, null);
        else
          options.unlinkSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM")
          return isWindows4 ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        if (er.code !== "EISDIR")
          throw er;
        rmdirSync(p, options, er);
      }
    }
  }
  function rmdirSync(p, options, originalEr) {
    assert(p);
    assert(options);
    if (originalEr)
      assert(originalEr instanceof Error);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR")
        throw originalEr;
      if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
        rmkidsSync(p, options);
    }
  }
  function rmkidsSync(p, options) {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach(function(f) {
      rimrafSync(path66.join(p, f), options);
    });
    var retries = isWindows4 ? 100 : 1;
    var i = 0;
    do {
      var threw = true;
      try {
        var ret2 = options.rmdirSync(p, options);
        threw = false;
        return ret2;
      } finally {
        if (++i < retries && threw)
          continue;
      }
    } while (true);
  }
});

// node_modules/fstream/node_modules/mkdirp/index.js
var require_mkdirp2 = __commonJS((exports2, module2) => {
  var path66 = require("path");
  var fs55 = require("fs");
  var _0777 = parseInt("0777", 8);
  module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
  function mkdirP(p, opts, f, made) {
    if (typeof opts === "function") {
      f = opts;
      opts = {};
    } else if (!opts || typeof opts !== "object") {
      opts = {mode: opts};
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs55;
    if (mode === void 0) {
      mode = _0777;
    }
    if (!made)
      made = null;
    var cb = f || function() {
    };
    p = path66.resolve(p);
    xfs.mkdir(p, mode, function(er) {
      if (!er) {
        made = made || p;
        return cb(null, made);
      }
      switch (er.code) {
        case "ENOENT":
          if (path66.dirname(p) === p)
            return cb(er);
          mkdirP(path66.dirname(p), opts, function(er2, made2) {
            if (er2)
              cb(er2, made2);
            else
              mkdirP(p, opts, cb, made2);
          });
          break;
        default:
          xfs.stat(p, function(er2, stat) {
            if (er2 || !stat.isDirectory())
              cb(er, made);
            else
              cb(null, made);
          });
          break;
      }
    });
  }
  mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== "object") {
      opts = {mode: opts};
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs55;
    if (mode === void 0) {
      mode = _0777;
    }
    if (!made)
      made = null;
    p = path66.resolve(p);
    try {
      xfs.mkdirSync(p, mode);
      made = made || p;
    } catch (err0) {
      switch (err0.code) {
        case "ENOENT":
          made = sync(path66.dirname(p), opts, made);
          sync(p, opts, made);
          break;
        default:
          var stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory())
            throw err0;
          break;
      }
    }
    return made;
  };
});

// node_modules/fstream/lib/collect.js
var require_collect = __commonJS((exports2, module2) => {
  module2.exports = collect;
  function collect(stream) {
    if (stream._collected)
      return;
    if (stream._paused)
      return stream.on("resume", collect.bind(null, stream));
    stream._collected = true;
    stream.pause();
    stream.on("data", save);
    stream.on("end", save);
    var buf = [];
    function save(b) {
      if (typeof b === "string")
        b = new Buffer(b);
      if (Buffer.isBuffer(b) && !b.length)
        return;
      buf.push(b);
    }
    stream.on("entry", saveEntry);
    var entryBuffer = [];
    function saveEntry(e) {
      collect(e);
      entryBuffer.push(e);
    }
    stream.on("proxy", proxyPause);
    function proxyPause(p) {
      p.pause();
    }
    stream.pipe = function(orig) {
      return function(dest) {
        var e = 0;
        (function unblockEntry() {
          var entry = entryBuffer[e++];
          if (!entry)
            return resume();
          entry.on("end", unblockEntry);
          if (dest)
            dest.add(entry);
          else
            stream.emit("entry", entry);
        })();
        function resume() {
          stream.removeListener("entry", saveEntry);
          stream.removeListener("data", save);
          stream.removeListener("end", save);
          stream.pipe = orig;
          if (dest)
            stream.pipe(dest);
          buf.forEach(function(b) {
            if (b)
              stream.emit("data", b);
            else
              stream.emit("end");
          });
          stream.resume();
        }
        return dest;
      };
    }(stream.pipe);
  }
});

// node_modules/fstream/lib/dir-writer.js
var require_dir_writer = __commonJS((exports2, module2) => {
  module2.exports = DirWriter;
  var Writer = require_writer();
  var inherits2 = require_inherits();
  var mkdir = require_mkdirp2();
  var path66 = require("path");
  var collect = require_collect();
  inherits2(DirWriter, Writer);
  function DirWriter(props) {
    var self2 = this;
    if (!(self2 instanceof DirWriter)) {
      self2.error("DirWriter must be called as constructor.", null, true);
    }
    if (props.type !== "Directory" || !props.Directory) {
      self2.error("Non-directory type " + props.type + " " + JSON.stringify(props), null, true);
    }
    Writer.call(this, props);
  }
  DirWriter.prototype._create = function() {
    var self2 = this;
    mkdir(self2._path, Writer.dirmode, function(er) {
      if (er)
        return self2.error(er);
      self2.ready = true;
      self2.emit("ready");
      self2._process();
    });
  };
  DirWriter.prototype.write = function() {
    return true;
  };
  DirWriter.prototype.end = function() {
    this._ended = true;
    this._process();
  };
  DirWriter.prototype.add = function(entry) {
    var self2 = this;
    collect(entry);
    if (!self2.ready || self2._currentEntry) {
      self2._buffer.push(entry);
      return false;
    }
    if (self2._ended) {
      return self2.error("add after end");
    }
    self2._buffer.push(entry);
    self2._process();
    return this._buffer.length === 0;
  };
  DirWriter.prototype._process = function() {
    var self2 = this;
    if (self2._processing)
      return;
    var entry = self2._buffer.shift();
    if (!entry) {
      self2.emit("drain");
      if (self2._ended)
        self2._finish();
      return;
    }
    self2._processing = true;
    self2.emit("entry", entry);
    var p = entry;
    var pp;
    do {
      pp = p._path || p.path;
      if (pp === self2.root._path || pp === self2._path || pp && pp.indexOf(self2._path) === 0) {
        self2._processing = false;
        if (entry._collected)
          entry.pipe();
        return self2._process();
      }
      p = p.parent;
    } while (p);
    var props = {
      parent: self2,
      root: self2.root || self2,
      type: entry.type,
      depth: self2.depth + 1
    };
    pp = entry._path || entry.path || entry.props.path;
    if (entry.parent) {
      pp = pp.substr(entry.parent._path.length + 1);
    }
    props.path = path66.join(self2.path, path66.join("/", pp));
    props.filter = self2.filter;
    Object.keys(entry.props).forEach(function(k) {
      if (!props.hasOwnProperty(k)) {
        props[k] = entry.props[k];
      }
    });
    var child = self2._currentChild = new Writer(props);
    child.on("ready", function() {
      entry.pipe(child);
      entry.resume();
    });
    child.on("error", function(er) {
      if (child._swallowErrors) {
        self2.warn(er);
        child.emit("end");
        child.emit("close");
      } else {
        self2.emit("error", er);
      }
    });
    child.on("close", onend);
    var ended = false;
    function onend() {
      if (ended)
        return;
      ended = true;
      self2._currentChild = null;
      self2._processing = false;
      self2._process();
    }
  };
});

// node_modules/fstream/lib/link-writer.js
var require_link_writer = __commonJS((exports2, module2) => {
  module2.exports = LinkWriter;
  var fs55 = require_graceful_fs();
  var Writer = require_writer();
  var inherits2 = require_inherits();
  var path66 = require("path");
  var rimraf = require_rimraf3();
  inherits2(LinkWriter, Writer);
  function LinkWriter(props) {
    var self2 = this;
    if (!(self2 instanceof LinkWriter)) {
      throw new Error("LinkWriter must be called as constructor.");
    }
    if (!(props.type === "Link" && props.Link || props.type === "SymbolicLink" && props.SymbolicLink)) {
      throw new Error("Non-link type " + props.type);
    }
    if (props.linkpath === "")
      props.linkpath = ".";
    if (!props.linkpath) {
      self2.error("Need linkpath property to create " + props.type);
    }
    Writer.call(this, props);
  }
  LinkWriter.prototype._create = function() {
    var self2 = this;
    var hard = self2.type === "Link" || process.platform === "win32";
    var link = hard ? "link" : "symlink";
    var lp = hard ? path66.resolve(self2.dirname, self2.linkpath) : self2.linkpath;
    if (hard)
      return clobber(self2, lp, link);
    fs55.readlink(self2._path, function(er, p) {
      if (p && p === lp)
        return finish(self2);
      clobber(self2, lp, link);
    });
  };
  function clobber(self2, lp, link) {
    rimraf(self2._path, function(er) {
      if (er)
        return self2.error(er);
      create(self2, lp, link);
    });
  }
  function create(self2, lp, link) {
    fs55[link](lp, self2._path, function(er) {
      if (er) {
        if ((er.code === "ENOENT" || er.code === "EACCES" || er.code === "EPERM") && process.platform === "win32") {
          self2.ready = true;
          self2.emit("ready");
          self2.emit("end");
          self2.emit("close");
          self2.end = self2._finish = function() {
          };
        } else
          return self2.error(er);
      }
      finish(self2);
    });
  }
  function finish(self2) {
    self2.ready = true;
    self2.emit("ready");
    if (self2._ended && !self2._finished)
      self2._finish();
  }
  LinkWriter.prototype.end = function() {
    this._ended = true;
    if (this.ready) {
      this._finished = true;
      this._finish();
    }
  };
});

// node_modules/fstream/lib/file-writer.js
var require_file_writer = __commonJS((exports2, module2) => {
  module2.exports = FileWriter;
  var fs55 = require_graceful_fs();
  var Writer = require_writer();
  var inherits2 = require_inherits();
  var EOF = {};
  inherits2(FileWriter, Writer);
  function FileWriter(props) {
    var self2 = this;
    if (!(self2 instanceof FileWriter)) {
      throw new Error("FileWriter must be called as constructor.");
    }
    if (props.type !== "File" || !props.File) {
      throw new Error("Non-file type " + props.type);
    }
    self2._buffer = [];
    self2._bytesWritten = 0;
    Writer.call(this, props);
  }
  FileWriter.prototype._create = function() {
    var self2 = this;
    if (self2._stream)
      return;
    var so = {};
    if (self2.props.flags)
      so.flags = self2.props.flags;
    so.mode = Writer.filemode;
    if (self2._old && self2._old.blksize)
      so.bufferSize = self2._old.blksize;
    self2._stream = fs55.createWriteStream(self2._path, so);
    self2._stream.on("open", function() {
      self2.ready = true;
      self2._buffer.forEach(function(c) {
        if (c === EOF)
          self2._stream.end();
        else
          self2._stream.write(c);
      });
      self2.emit("ready");
      self2.emit("drain");
    });
    self2._stream.on("error", function(er) {
      self2.emit("error", er);
    });
    self2._stream.on("drain", function() {
      self2.emit("drain");
    });
    self2._stream.on("close", function() {
      self2._finish();
    });
  };
  FileWriter.prototype.write = function(c) {
    var self2 = this;
    self2._bytesWritten += c.length;
    if (!self2.ready) {
      if (!Buffer.isBuffer(c) && typeof c !== "string") {
        throw new Error("invalid write data");
      }
      self2._buffer.push(c);
      return false;
    }
    var ret2 = self2._stream.write(c);
    if (ret2 === false && self2._stream._queue) {
      return self2._stream._queue.length <= 2;
    } else {
      return ret2;
    }
  };
  FileWriter.prototype.end = function(c) {
    var self2 = this;
    if (c)
      self2.write(c);
    if (!self2.ready) {
      self2._buffer.push(EOF);
      return false;
    }
    return self2._stream.end();
  };
  FileWriter.prototype._finish = function() {
    var self2 = this;
    if (typeof self2.size === "number" && self2._bytesWritten !== self2.size) {
      self2.error("Did not get expected byte count.\nexpect: " + self2.size + "\nactual: " + self2._bytesWritten);
    }
    Writer.prototype._finish.call(self2);
  };
});

// node_modules/fstream/lib/proxy-writer.js
var require_proxy_writer = __commonJS((exports2, module2) => {
  module2.exports = ProxyWriter;
  var Writer = require_writer();
  var getType = require_get_type();
  var inherits2 = require_inherits();
  var collect = require_collect();
  var fs55 = require("fs");
  inherits2(ProxyWriter, Writer);
  function ProxyWriter(props) {
    var self2 = this;
    if (!(self2 instanceof ProxyWriter)) {
      throw new Error("ProxyWriter must be called as constructor.");
    }
    self2.props = props;
    self2._needDrain = false;
    Writer.call(self2, props);
  }
  ProxyWriter.prototype._stat = function() {
    var self2 = this;
    var props = self2.props;
    var stat = props.follow ? "stat" : "lstat";
    fs55[stat](props.path, function(er, current) {
      var type;
      if (er || !current) {
        type = "File";
      } else {
        type = getType(current);
      }
      props[type] = true;
      props.type = self2.type = type;
      self2._old = current;
      self2._addProxy(Writer(props, current));
    });
  };
  ProxyWriter.prototype._addProxy = function(proxy) {
    var self2 = this;
    if (self2._proxy) {
      return self2.error("proxy already set");
    }
    self2._proxy = proxy;
    [
      "ready",
      "error",
      "close",
      "pipe",
      "drain",
      "warn"
    ].forEach(function(ev) {
      proxy.on(ev, self2.emit.bind(self2, ev));
    });
    self2.emit("proxy", proxy);
    var calls = self2._buffer;
    calls.forEach(function(c) {
      proxy[c[0]].apply(proxy, c[1]);
    });
    self2._buffer.length = 0;
    if (self2._needsDrain)
      self2.emit("drain");
  };
  ProxyWriter.prototype.add = function(entry) {
    collect(entry);
    if (!this._proxy) {
      this._buffer.push(["add", [entry]]);
      this._needDrain = true;
      return false;
    }
    return this._proxy.add(entry);
  };
  ProxyWriter.prototype.write = function(c) {
    if (!this._proxy) {
      this._buffer.push(["write", [c]]);
      this._needDrain = true;
      return false;
    }
    return this._proxy.write(c);
  };
  ProxyWriter.prototype.end = function(c) {
    if (!this._proxy) {
      this._buffer.push(["end", [c]]);
      return false;
    }
    return this._proxy.end(c);
  };
});

// node_modules/fstream/lib/writer.js
var require_writer = __commonJS((exports2, module2) => {
  module2.exports = Writer;
  var fs55 = require_graceful_fs();
  var inherits2 = require_inherits();
  var rimraf = require_rimraf3();
  var mkdir = require_mkdirp2();
  var path66 = require("path");
  var umask = process.platform === "win32" ? 0 : process.umask();
  var getType = require_get_type();
  var Abstract = require_abstract();
  inherits2(Writer, Abstract);
  Writer.dirmode = parseInt("0777", 8) & ~umask;
  Writer.filemode = parseInt("0666", 8) & ~umask;
  var DirWriter = require_dir_writer();
  var LinkWriter = require_link_writer();
  var FileWriter = require_file_writer();
  var ProxyWriter = require_proxy_writer();
  function Writer(props, current) {
    var self2 = this;
    if (typeof props === "string") {
      props = {path: props};
    }
    var type = getType(props);
    var ClassType = Writer;
    switch (type) {
      case "Directory":
        ClassType = DirWriter;
        break;
      case "File":
        ClassType = FileWriter;
        break;
      case "Link":
      case "SymbolicLink":
        ClassType = LinkWriter;
        break;
      case null:
      default:
        ClassType = ProxyWriter;
        break;
    }
    if (!(self2 instanceof ClassType))
      return new ClassType(props);
    Abstract.call(self2);
    if (!props.path)
      self2.error("Must provide a path", null, true);
    self2.type = props.type;
    self2.props = props;
    self2.depth = props.depth || 0;
    self2.clobber = props.clobber === false ? props.clobber : true;
    self2.parent = props.parent || null;
    self2.root = props.root || props.parent && props.parent.root || self2;
    self2._path = self2.path = path66.resolve(props.path);
    if (process.platform === "win32") {
      self2.path = self2._path = self2.path.replace(/\?/g, "_");
      if (self2._path.length >= 260) {
        self2._swallowErrors = true;
        self2._path = "\\\\?\\" + self2.path.replace(/\//g, "\\");
      }
    }
    self2.basename = path66.basename(props.path);
    self2.dirname = path66.dirname(props.path);
    self2.linkpath = props.linkpath || null;
    props.parent = props.root = null;
    self2.size = props.size;
    if (typeof props.mode === "string") {
      props.mode = parseInt(props.mode, 8);
    }
    self2.readable = false;
    self2.writable = true;
    self2._buffer = [];
    self2.ready = false;
    self2.filter = typeof props.filter === "function" ? props.filter : null;
    self2._stat(current);
  }
  Writer.prototype._create = function() {
    var self2 = this;
    fs55[self2.props.follow ? "stat" : "lstat"](self2._path, function(er) {
      if (er) {
        return self2.warn("Cannot create " + self2._path + "\nUnsupported type: " + self2.type, "ENOTSUP");
      }
      self2._finish();
    });
  };
  Writer.prototype._stat = function(current) {
    var self2 = this;
    var props = self2.props;
    var stat = props.follow ? "stat" : "lstat";
    var who = self2._proxy || self2;
    if (current)
      statCb(null, current);
    else
      fs55[stat](self2._path, statCb);
    function statCb(er, current2) {
      if (self2.filter && !self2.filter.call(who, who, current2)) {
        self2._aborted = true;
        self2.emit("end");
        self2.emit("close");
        return;
      }
      if (er || !current2) {
        return create(self2);
      }
      self2._old = current2;
      var currentType = getType(current2);
      if (currentType !== self2.type || self2.type === "File" && current2.nlink > 1) {
        return rimraf(self2._path, function(er2) {
          if (er2)
            return self2.error(er2);
          self2._old = null;
          create(self2);
        });
      }
      create(self2);
    }
  };
  function create(self2) {
    mkdir(path66.dirname(self2._path), Writer.dirmode, function(er, made) {
      if (er)
        return self2.error(er);
      self2._madeDir = made;
      return self2._create();
    });
  }
  function endChmod(self2, want, current, path67, cb) {
    var wantMode = want.mode;
    var chmod = want.follow || self2.type !== "SymbolicLink" ? "chmod" : "lchmod";
    if (!fs55[chmod])
      return cb();
    if (typeof wantMode !== "number")
      return cb();
    var curMode = current.mode & parseInt("0777", 8);
    wantMode = wantMode & parseInt("0777", 8);
    if (wantMode === curMode)
      return cb();
    fs55[chmod](path67, wantMode, cb);
  }
  function endChown(self2, want, current, path67, cb) {
    if (process.platform === "win32")
      return cb();
    if (!process.getuid || process.getuid() !== 0)
      return cb();
    if (typeof want.uid !== "number" && typeof want.gid !== "number")
      return cb();
    if (current.uid === want.uid && current.gid === want.gid)
      return cb();
    var chown = self2.props.follow || self2.type !== "SymbolicLink" ? "chown" : "lchown";
    if (!fs55[chown])
      return cb();
    if (typeof want.uid !== "number")
      want.uid = current.uid;
    if (typeof want.gid !== "number")
      want.gid = current.gid;
    fs55[chown](path67, want.uid, want.gid, cb);
  }
  function endUtimes(self2, want, current, path67, cb) {
    if (!fs55.utimes || process.platform === "win32")
      return cb();
    var utimes = want.follow || self2.type !== "SymbolicLink" ? "utimes" : "lutimes";
    if (utimes === "lutimes" && !fs55[utimes]) {
      utimes = "utimes";
    }
    if (!fs55[utimes])
      return cb();
    var curA = current.atime;
    var curM = current.mtime;
    var meA = want.atime;
    var meM = want.mtime;
    if (meA === void 0)
      meA = curA;
    if (meM === void 0)
      meM = curM;
    if (!isDate(meA))
      meA = new Date(meA);
    if (!isDate(meM))
      meA = new Date(meM);
    if (meA.getTime() === curA.getTime() && meM.getTime() === curM.getTime())
      return cb();
    fs55[utimes](path67, meA, meM, cb);
  }
  Writer.prototype._finish = function() {
    var self2 = this;
    if (self2._finishing)
      return;
    self2._finishing = true;
    var todo = 0;
    var errState = null;
    var done = false;
    if (self2._old) {
      self2._old.atime = new Date(0);
      self2._old.mtime = new Date(0);
      setProps(self2._old);
    } else {
      var stat = self2.props.follow ? "stat" : "lstat";
      fs55[stat](self2._path, function(er, current) {
        if (er) {
          if (er.code === "ENOENT" && (self2.type === "Link" || self2.type === "SymbolicLink") && process.platform === "win32") {
            self2.ready = true;
            self2.emit("ready");
            self2.emit("end");
            self2.emit("close");
            self2.end = self2._finish = function() {
            };
            return;
          } else
            return self2.error(er);
        }
        setProps(self2._old = current);
      });
    }
    return;
    function setProps(current) {
      todo += 3;
      endChmod(self2, self2.props, current, self2._path, next("chmod"));
      endChown(self2, self2.props, current, self2._path, next("chown"));
      endUtimes(self2, self2.props, current, self2._path, next("utimes"));
    }
    function next(what) {
      return function(er) {
        if (errState)
          return;
        if (er) {
          er.fstream_finish_call = what;
          return self2.error(errState = er);
        }
        if (--todo > 0)
          return;
        if (done)
          return;
        done = true;
        if (!self2._madeDir)
          return end();
        else
          endMadeDir(self2, self2._path, end);
        function end(er2) {
          if (er2) {
            er2.fstream_finish_call = "setupMadeDir";
            return self2.error(er2);
          }
          self2.emit("end");
          self2.emit("close");
        }
      };
    }
  };
  function endMadeDir(self2, p, cb) {
    var made = self2._madeDir;
    var d = path66.dirname(p);
    endMadeDir_(self2, d, function(er) {
      if (er)
        return cb(er);
      if (d === made) {
        return cb();
      }
      endMadeDir(self2, d, cb);
    });
  }
  function endMadeDir_(self2, p, cb) {
    var dirProps = {};
    Object.keys(self2.props).forEach(function(k) {
      dirProps[k] = self2.props[k];
      if (k === "mode" && self2.type !== "Directory") {
        dirProps[k] = dirProps[k] | parseInt("0111", 8);
      }
    });
    var todo = 3;
    var errState = null;
    fs55.stat(p, function(er, current) {
      if (er)
        return cb(errState = er);
      endChmod(self2, dirProps, current, p, next);
      endChown(self2, dirProps, current, p, next);
      endUtimes(self2, dirProps, current, p, next);
    });
    function next(er) {
      if (errState)
        return;
      if (er)
        return cb(errState = er);
      if (--todo === 0)
        return cb();
    }
  }
  Writer.prototype.pipe = function() {
    this.error("Can't pipe from writable stream");
  };
  Writer.prototype.add = function() {
    this.error("Can't add to non-Directory type");
  };
  Writer.prototype.write = function() {
    return true;
  };
  function objectToString(d) {
    return Object.prototype.toString.call(d);
  }
  function isDate(d) {
    return typeof d === "object" && objectToString(d) === "[object Date]";
  }
});

// node_modules/fstream/fstream.js
var require_fstream = __commonJS((exports2) => {
  exports2.Abstract = require_abstract();
  exports2.Reader = require_reader();
  exports2.Writer = require_writer();
  exports2.File = {
    Reader: require_file_reader(),
    Writer: require_file_writer()
  };
  exports2.Dir = {
    Reader: require_dir_reader(),
    Writer: require_dir_writer()
  };
  exports2.Link = {
    Reader: require_link_reader(),
    Writer: require_link_writer()
  };
  exports2.Proxy = {
    Reader: require_proxy_reader(),
    Writer: require_proxy_writer()
  };
  exports2.Reader.Dir = exports2.DirReader = exports2.Dir.Reader;
  exports2.Reader.File = exports2.FileReader = exports2.File.Reader;
  exports2.Reader.Link = exports2.LinkReader = exports2.Link.Reader;
  exports2.Reader.Proxy = exports2.ProxyReader = exports2.Proxy.Reader;
  exports2.Writer.Dir = exports2.DirWriter = exports2.Dir.Writer;
  exports2.Writer.File = exports2.FileWriter = exports2.File.Writer;
  exports2.Writer.Link = exports2.LinkWriter = exports2.Link.Writer;
  exports2.Writer.Proxy = exports2.ProxyWriter = exports2.Proxy.Writer;
  exports2.collect = require_collect();
});

// node_modules/unzipper/lib/extract.js
var require_extract2 = __commonJS((exports2, module2) => {
  module2.exports = Extract;
  var Parse = require_parse3();
  var Writer = require_fstream().Writer;
  var path66 = require("path");
  var stream = require("stream");
  var duplexer2 = require_duplexer2();
  var Promise2 = require_bluebird();
  function Extract(opts) {
    opts.path = path66.resolve(path66.normalize(opts.path));
    var parser4 = new Parse(opts);
    var outStream = new stream.Writable({objectMode: true});
    outStream._write = function(entry, encoding, cb) {
      if (entry.type == "Directory")
        return cb();
      var extractPath = path66.join(opts.path, entry.path);
      if (extractPath.indexOf(opts.path) != 0) {
        return cb();
      }
      const writer = opts.getWriter ? opts.getWriter({path: extractPath}) : Writer({path: extractPath});
      entry.pipe(writer).on("error", cb).on("close", cb);
    };
    var extract = duplexer2(parser4, outStream);
    parser4.once("crx-header", function(crxHeader) {
      extract.crxHeader = crxHeader;
    });
    parser4.pipe(outStream).on("finish", function() {
      extract.emit("close");
    });
    extract.promise = function() {
      return new Promise2(function(resolve3, reject) {
        extract.on("close", resolve3);
        extract.on("error", reject);
      });
    };
    return extract;
  }
});

// node_modules/big-integer/BigInteger.js
var require_BigInteger = __commonJS((exports2, module2) => {
  var bigInt = function(undefined2) {
    "use strict";
    var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
    var supportsNativeBigInt = typeof BigInt === "function";
    function Integer(v, radix, alphabet, caseSensitive) {
      if (typeof v === "undefined")
        return Integer[0];
      if (typeof radix !== "undefined")
        return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
      return parseValue(v);
    }
    function BigInteger(value, sign) {
      this.value = value;
      this.sign = sign;
      this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);
    function SmallInteger(value) {
      this.value = value;
      this.sign = value < 0;
      this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);
    function NativeBigInt(value) {
      this.value = value;
    }
    NativeBigInt.prototype = Object.create(Integer.prototype);
    function isPrecise(n) {
      return -MAX_INT < n && n < MAX_INT;
    }
    function smallToArray(n) {
      if (n < 1e7)
        return [n];
      if (n < 1e14)
        return [n % 1e7, Math.floor(n / 1e7)];
      return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }
    function arrayToSmall(arr) {
      trim(arr);
      var length = arr.length;
      if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
        switch (length) {
          case 0:
            return 0;
          case 1:
            return arr[0];
          case 2:
            return arr[0] + arr[1] * BASE;
          default:
            return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
        }
      }
      return arr;
    }
    function trim(v) {
      var i2 = v.length;
      while (v[--i2] === 0)
        ;
      v.length = i2 + 1;
    }
    function createArray(length) {
      var x = new Array(length);
      var i2 = -1;
      while (++i2 < length) {
        x[i2] = 0;
      }
      return x;
    }
    function truncate(n) {
      if (n > 0)
        return Math.floor(n);
      return Math.ceil(n);
    }
    function add(a, b) {
      var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum, i2;
      for (i2 = 0; i2 < l_b; i2++) {
        sum = a[i2] + b[i2] + carry;
        carry = sum >= base ? 1 : 0;
        r[i2] = sum - carry * base;
      }
      while (i2 < l_a) {
        sum = a[i2] + carry;
        carry = sum === base ? 1 : 0;
        r[i2++] = sum - carry * base;
      }
      if (carry > 0)
        r.push(carry);
      return r;
    }
    function addAny(a, b) {
      if (a.length >= b.length)
        return add(a, b);
      return add(b, a);
    }
    function addSmall(a, carry) {
      var l = a.length, r = new Array(l), base = BASE, sum, i2;
      for (i2 = 0; i2 < l; i2++) {
        sum = a[i2] - base + carry;
        carry = Math.floor(sum / base);
        r[i2] = sum - carry * base;
        carry += 1;
      }
      while (carry > 0) {
        r[i2++] = carry % base;
        carry = Math.floor(carry / base);
      }
      return r;
    }
    BigInteger.prototype.add = function(v) {
      var n = parseValue(v);
      if (this.sign !== n.sign) {
        return this.subtract(n.negate());
      }
      var a = this.value, b = n.value;
      if (n.isSmall) {
        return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
      }
      return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;
    SmallInteger.prototype.add = function(v) {
      var n = parseValue(v);
      var a = this.value;
      if (a < 0 !== n.sign) {
        return this.subtract(n.negate());
      }
      var b = n.value;
      if (n.isSmall) {
        if (isPrecise(a + b))
          return new SmallInteger(a + b);
        b = smallToArray(Math.abs(b));
      }
      return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;
    NativeBigInt.prototype.add = function(v) {
      return new NativeBigInt(this.value + parseValue(v).value);
    };
    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
    function subtract(a, b) {
      var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i2, difference;
      for (i2 = 0; i2 < b_l; i2++) {
        difference = a[i2] - borrow - b[i2];
        if (difference < 0) {
          difference += base;
          borrow = 1;
        } else
          borrow = 0;
        r[i2] = difference;
      }
      for (i2 = b_l; i2 < a_l; i2++) {
        difference = a[i2] - borrow;
        if (difference < 0)
          difference += base;
        else {
          r[i2++] = difference;
          break;
        }
        r[i2] = difference;
      }
      for (; i2 < a_l; i2++) {
        r[i2] = a[i2];
      }
      trim(r);
      return r;
    }
    function subtractAny(a, b, sign) {
      var value;
      if (compareAbs(a, b) >= 0) {
        value = subtract(a, b);
      } else {
        value = subtract(b, a);
        sign = !sign;
      }
      value = arrayToSmall(value);
      if (typeof value === "number") {
        if (sign)
          value = -value;
        return new SmallInteger(value);
      }
      return new BigInteger(value, sign);
    }
    function subtractSmall(a, b, sign) {
      var l = a.length, r = new Array(l), carry = -b, base = BASE, i2, difference;
      for (i2 = 0; i2 < l; i2++) {
        difference = a[i2] + carry;
        carry = Math.floor(difference / base);
        difference %= base;
        r[i2] = difference < 0 ? difference + base : difference;
      }
      r = arrayToSmall(r);
      if (typeof r === "number") {
        if (sign)
          r = -r;
        return new SmallInteger(r);
      }
      return new BigInteger(r, sign);
    }
    BigInteger.prototype.subtract = function(v) {
      var n = parseValue(v);
      if (this.sign !== n.sign) {
        return this.add(n.negate());
      }
      var a = this.value, b = n.value;
      if (n.isSmall)
        return subtractSmall(a, Math.abs(b), this.sign);
      return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;
    SmallInteger.prototype.subtract = function(v) {
      var n = parseValue(v);
      var a = this.value;
      if (a < 0 !== n.sign) {
        return this.add(n.negate());
      }
      var b = n.value;
      if (n.isSmall) {
        return new SmallInteger(a - b);
      }
      return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
    NativeBigInt.prototype.subtract = function(v) {
      return new NativeBigInt(this.value - parseValue(v).value);
    };
    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
    BigInteger.prototype.negate = function() {
      return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function() {
      var sign = this.sign;
      var small = new SmallInteger(-this.value);
      small.sign = !sign;
      return small;
    };
    NativeBigInt.prototype.negate = function() {
      return new NativeBigInt(-this.value);
    };
    BigInteger.prototype.abs = function() {
      return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function() {
      return new SmallInteger(Math.abs(this.value));
    };
    NativeBigInt.prototype.abs = function() {
      return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
    };
    function multiplyLong(a, b) {
      var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE, product, carry, i2, a_i, b_j;
      for (i2 = 0; i2 < a_l; ++i2) {
        a_i = a[i2];
        for (var j = 0; j < b_l; ++j) {
          b_j = b[j];
          product = a_i * b_j + r[i2 + j];
          carry = Math.floor(product / base);
          r[i2 + j] = product - carry * base;
          r[i2 + j + 1] += carry;
        }
      }
      trim(r);
      return r;
    }
    function multiplySmall(a, b) {
      var l = a.length, r = new Array(l), base = BASE, carry = 0, product, i2;
      for (i2 = 0; i2 < l; i2++) {
        product = a[i2] * b + carry;
        carry = Math.floor(product / base);
        r[i2] = product - carry * base;
      }
      while (carry > 0) {
        r[i2++] = carry % base;
        carry = Math.floor(carry / base);
      }
      return r;
    }
    function shiftLeft(x, n) {
      var r = [];
      while (n-- > 0)
        r.push(0);
      return r.concat(x);
    }
    function multiplyKaratsuba(x, y) {
      var n = Math.max(x.length, y.length);
      if (n <= 30)
        return multiplyLong(x, y);
      n = Math.ceil(n / 2);
      var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);
      var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
      var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
      trim(product);
      return product;
    }
    function useKaratsuba(l1, l2) {
      return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;
    }
    BigInteger.prototype.multiply = function(v) {
      var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;
      if (n.isSmall) {
        if (b === 0)
          return Integer[0];
        if (b === 1)
          return this;
        if (b === -1)
          return this.negate();
        abs = Math.abs(b);
        if (abs < BASE) {
          return new BigInteger(multiplySmall(a, abs), sign);
        }
        b = smallToArray(abs);
      }
      if (useKaratsuba(a.length, b.length))
        return new BigInteger(multiplyKaratsuba(a, b), sign);
      return new BigInteger(multiplyLong(a, b), sign);
    };
    BigInteger.prototype.times = BigInteger.prototype.multiply;
    function multiplySmallAndArray(a, b, sign) {
      if (a < BASE) {
        return new BigInteger(multiplySmall(b, a), sign);
      }
      return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function(a) {
      if (isPrecise(a.value * this.value)) {
        return new SmallInteger(a.value * this.value);
      }
      return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function(a) {
      if (a.value === 0)
        return Integer[0];
      if (a.value === 1)
        return this;
      if (a.value === -1)
        return this.negate();
      return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function(v) {
      return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;
    NativeBigInt.prototype.multiply = function(v) {
      return new NativeBigInt(this.value * parseValue(v).value);
    };
    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
    function square(a) {
      var l = a.length, r = createArray(l + l), base = BASE, product, carry, i2, a_i, a_j;
      for (i2 = 0; i2 < l; i2++) {
        a_i = a[i2];
        carry = 0 - a_i * a_i;
        for (var j = i2; j < l; j++) {
          a_j = a[j];
          product = 2 * (a_i * a_j) + r[i2 + j] + carry;
          carry = Math.floor(product / base);
          r[i2 + j] = product - carry * base;
        }
        r[i2 + l] = carry;
      }
      trim(r);
      return r;
    }
    BigInteger.prototype.square = function() {
      return new BigInteger(square(this.value), false);
    };
    SmallInteger.prototype.square = function() {
      var value = this.value * this.value;
      if (isPrecise(value))
        return new SmallInteger(value);
      return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };
    NativeBigInt.prototype.square = function(v) {
      return new NativeBigInt(this.value * this.value);
    };
    function divMod1(a, b) {
      var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i2, l, q;
      if (remainder.length <= a_l)
        remainder.push(0);
      divisor.push(0);
      divisorMostSignificantDigit = divisor[b_l - 1];
      for (shift = a_l - b_l; shift >= 0; shift--) {
        quotientDigit = base - 1;
        if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
          quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
        }
        carry = 0;
        borrow = 0;
        l = divisor.length;
        for (i2 = 0; i2 < l; i2++) {
          carry += quotientDigit * divisor[i2];
          q = Math.floor(carry / base);
          borrow += remainder[shift + i2] - (carry - q * base);
          carry = q;
          if (borrow < 0) {
            remainder[shift + i2] = borrow + base;
            borrow = -1;
          } else {
            remainder[shift + i2] = borrow;
            borrow = 0;
          }
        }
        while (borrow !== 0) {
          quotientDigit -= 1;
          carry = 0;
          for (i2 = 0; i2 < l; i2++) {
            carry += remainder[shift + i2] - base + divisor[i2];
            if (carry < 0) {
              remainder[shift + i2] = carry + base;
              carry = 0;
            } else {
              remainder[shift + i2] = carry;
              carry = 1;
            }
          }
          borrow += carry;
        }
        result[shift] = quotientDigit;
      }
      remainder = divModSmall(remainder, lambda)[0];
      return [arrayToSmall(result), arrayToSmall(remainder)];
    }
    function divMod2(a, b) {
      var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;
      while (a_l) {
        part.unshift(a[--a_l]);
        trim(part);
        if (compareAbs(part, b) < 0) {
          result.push(0);
          continue;
        }
        xlen = part.length;
        highx = part[xlen - 1] * base + part[xlen - 2];
        highy = b[b_l - 1] * base + b[b_l - 2];
        if (xlen > b_l) {
          highx = (highx + 1) * base;
        }
        guess = Math.ceil(highx / highy);
        do {
          check = multiplySmall(b, guess);
          if (compareAbs(check, part) <= 0)
            break;
          guess--;
        } while (guess);
        result.push(guess);
        part = subtract(part, check);
      }
      result.reverse();
      return [arrayToSmall(result), arrayToSmall(part)];
    }
    function divModSmall(value, lambda) {
      var length = value.length, quotient = createArray(length), base = BASE, i2, q, remainder, divisor;
      remainder = 0;
      for (i2 = length - 1; i2 >= 0; --i2) {
        divisor = remainder * base + value[i2];
        q = truncate(divisor / lambda);
        remainder = divisor - q * lambda;
        quotient[i2] = q | 0;
      }
      return [quotient, remainder | 0];
    }
    function divModAny(self2, v) {
      var value, n = parseValue(v);
      if (supportsNativeBigInt) {
        return [new NativeBigInt(self2.value / n.value), new NativeBigInt(self2.value % n.value)];
      }
      var a = self2.value, b = n.value;
      var quotient;
      if (b === 0)
        throw new Error("Cannot divide by zero");
      if (self2.isSmall) {
        if (n.isSmall) {
          return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
        }
        return [Integer[0], self2];
      }
      if (n.isSmall) {
        if (b === 1)
          return [self2, Integer[0]];
        if (b == -1)
          return [self2.negate(), Integer[0]];
        var abs = Math.abs(b);
        if (abs < BASE) {
          value = divModSmall(a, abs);
          quotient = arrayToSmall(value[0]);
          var remainder = value[1];
          if (self2.sign)
            remainder = -remainder;
          if (typeof quotient === "number") {
            if (self2.sign !== n.sign)
              quotient = -quotient;
            return [new SmallInteger(quotient), new SmallInteger(remainder)];
          }
          return [new BigInteger(quotient, self2.sign !== n.sign), new SmallInteger(remainder)];
        }
        b = smallToArray(abs);
      }
      var comparison = compareAbs(a, b);
      if (comparison === -1)
        return [Integer[0], self2];
      if (comparison === 0)
        return [Integer[self2.sign === n.sign ? 1 : -1], Integer[0]];
      if (a.length + b.length <= 200)
        value = divMod1(a, b);
      else
        value = divMod2(a, b);
      quotient = value[0];
      var qSign = self2.sign !== n.sign, mod = value[1], mSign = self2.sign;
      if (typeof quotient === "number") {
        if (qSign)
          quotient = -quotient;
        quotient = new SmallInteger(quotient);
      } else
        quotient = new BigInteger(quotient, qSign);
      if (typeof mod === "number") {
        if (mSign)
          mod = -mod;
        mod = new SmallInteger(mod);
      } else
        mod = new BigInteger(mod, mSign);
      return [quotient, mod];
    }
    BigInteger.prototype.divmod = function(v) {
      var result = divModAny(this, v);
      return {
        quotient: result[0],
        remainder: result[1]
      };
    };
    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
    BigInteger.prototype.divide = function(v) {
      return divModAny(this, v)[0];
    };
    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
      return new NativeBigInt(this.value / parseValue(v).value);
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
    BigInteger.prototype.mod = function(v) {
      return divModAny(this, v)[1];
    };
    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
      return new NativeBigInt(this.value % parseValue(v).value);
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
    BigInteger.prototype.pow = function(v) {
      var n = parseValue(v), a = this.value, b = n.value, value, x, y;
      if (b === 0)
        return Integer[1];
      if (a === 0)
        return Integer[0];
      if (a === 1)
        return Integer[1];
      if (a === -1)
        return n.isEven() ? Integer[1] : Integer[-1];
      if (n.sign) {
        return Integer[0];
      }
      if (!n.isSmall)
        throw new Error("The exponent " + n.toString() + " is too large.");
      if (this.isSmall) {
        if (isPrecise(value = Math.pow(a, b)))
          return new SmallInteger(truncate(value));
      }
      x = this;
      y = Integer[1];
      while (true) {
        if (b & true) {
          y = y.times(x);
          --b;
        }
        if (b === 0)
          break;
        b /= 2;
        x = x.square();
      }
      return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;
    NativeBigInt.prototype.pow = function(v) {
      var n = parseValue(v);
      var a = this.value, b = n.value;
      var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
      if (b === _0)
        return Integer[1];
      if (a === _0)
        return Integer[0];
      if (a === _1)
        return Integer[1];
      if (a === BigInt(-1))
        return n.isEven() ? Integer[1] : Integer[-1];
      if (n.isNegative())
        return new NativeBigInt(_0);
      var x = this;
      var y = Integer[1];
      while (true) {
        if ((b & _1) === _1) {
          y = y.times(x);
          --b;
        }
        if (b === _0)
          break;
        b /= _2;
        x = x.square();
      }
      return y;
    };
    BigInteger.prototype.modPow = function(exp, mod) {
      exp = parseValue(exp);
      mod = parseValue(mod);
      if (mod.isZero())
        throw new Error("Cannot take modPow with modulus 0");
      var r = Integer[1], base = this.mod(mod);
      if (exp.isNegative()) {
        exp = exp.multiply(Integer[-1]);
        base = base.modInv(mod);
      }
      while (exp.isPositive()) {
        if (base.isZero())
          return Integer[0];
        if (exp.isOdd())
          r = r.multiply(base).mod(mod);
        exp = exp.divide(2);
        base = base.square().mod(mod);
      }
      return r;
    };
    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
    function compareAbs(a, b) {
      if (a.length !== b.length) {
        return a.length > b.length ? 1 : -1;
      }
      for (var i2 = a.length - 1; i2 >= 0; i2--) {
        if (a[i2] !== b[i2])
          return a[i2] > b[i2] ? 1 : -1;
      }
      return 0;
    }
    BigInteger.prototype.compareAbs = function(v) {
      var n = parseValue(v), a = this.value, b = n.value;
      if (n.isSmall)
        return 1;
      return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function(v) {
      var n = parseValue(v), a = Math.abs(this.value), b = n.value;
      if (n.isSmall) {
        b = Math.abs(b);
        return a === b ? 0 : a > b ? 1 : -1;
      }
      return -1;
    };
    NativeBigInt.prototype.compareAbs = function(v) {
      var a = this.value;
      var b = parseValue(v).value;
      a = a >= 0 ? a : -a;
      b = b >= 0 ? b : -b;
      return a === b ? 0 : a > b ? 1 : -1;
    };
    BigInteger.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var n = parseValue(v), a = this.value, b = n.value;
      if (this.sign !== n.sign) {
        return n.sign ? 1 : -1;
      }
      if (n.isSmall) {
        return this.sign ? -1 : 1;
      }
      return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;
    SmallInteger.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var n = parseValue(v), a = this.value, b = n.value;
      if (n.isSmall) {
        return a == b ? 0 : a > b ? 1 : -1;
      }
      if (a < 0 !== n.sign) {
        return a < 0 ? -1 : 1;
      }
      return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
    NativeBigInt.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var a = this.value;
      var b = parseValue(v).value;
      return a === b ? 0 : a > b ? 1 : -1;
    };
    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
    BigInteger.prototype.equals = function(v) {
      return this.compare(v) === 0;
    };
    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
    BigInteger.prototype.notEquals = function(v) {
      return this.compare(v) !== 0;
    };
    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
    BigInteger.prototype.greater = function(v) {
      return this.compare(v) > 0;
    };
    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
    BigInteger.prototype.lesser = function(v) {
      return this.compare(v) < 0;
    };
    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
    BigInteger.prototype.greaterOrEquals = function(v) {
      return this.compare(v) >= 0;
    };
    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
    BigInteger.prototype.lesserOrEquals = function(v) {
      return this.compare(v) <= 0;
    };
    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
    BigInteger.prototype.isEven = function() {
      return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function() {
      return (this.value & 1) === 0;
    };
    NativeBigInt.prototype.isEven = function() {
      return (this.value & BigInt(1)) === BigInt(0);
    };
    BigInteger.prototype.isOdd = function() {
      return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function() {
      return (this.value & 1) === 1;
    };
    NativeBigInt.prototype.isOdd = function() {
      return (this.value & BigInt(1)) === BigInt(1);
    };
    BigInteger.prototype.isPositive = function() {
      return !this.sign;
    };
    SmallInteger.prototype.isPositive = function() {
      return this.value > 0;
    };
    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
    BigInteger.prototype.isNegative = function() {
      return this.sign;
    };
    SmallInteger.prototype.isNegative = function() {
      return this.value < 0;
    };
    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
    BigInteger.prototype.isUnit = function() {
      return false;
    };
    SmallInteger.prototype.isUnit = function() {
      return Math.abs(this.value) === 1;
    };
    NativeBigInt.prototype.isUnit = function() {
      return this.abs().value === BigInt(1);
    };
    BigInteger.prototype.isZero = function() {
      return false;
    };
    SmallInteger.prototype.isZero = function() {
      return this.value === 0;
    };
    NativeBigInt.prototype.isZero = function() {
      return this.value === BigInt(0);
    };
    BigInteger.prototype.isDivisibleBy = function(v) {
      var n = parseValue(v);
      if (n.isZero())
        return false;
      if (n.isUnit())
        return true;
      if (n.compareAbs(2) === 0)
        return this.isEven();
      return this.mod(n).isZero();
    };
    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
    function isBasicPrime(v) {
      var n = v.abs();
      if (n.isUnit())
        return false;
      if (n.equals(2) || n.equals(3) || n.equals(5))
        return true;
      if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5))
        return false;
      if (n.lesser(49))
        return true;
    }
    function millerRabinTest(n, a) {
      var nPrev = n.prev(), b = nPrev, r = 0, d, t, i2, x;
      while (b.isEven())
        b = b.divide(2), r++;
      next:
        for (i2 = 0; i2 < a.length; i2++) {
          if (n.lesser(a[i2]))
            continue;
          x = bigInt(a[i2]).modPow(b, n);
          if (x.isUnit() || x.equals(nPrev))
            continue;
          for (d = r - 1; d != 0; d--) {
            x = x.square().mod(n);
            if (x.isUnit())
              return false;
            if (x.equals(nPrev))
              continue next;
          }
          return false;
        }
      return true;
    }
    BigInteger.prototype.isPrime = function(strict) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined2)
        return isPrime;
      var n = this.abs();
      var bits = n.bitLength();
      if (bits <= 64)
        return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
      var logN = Math.log(2) * bits.toJSNumber();
      var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
      for (var a = [], i2 = 0; i2 < t; i2++) {
        a.push(bigInt(i2 + 2));
      }
      return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
    BigInteger.prototype.isProbablePrime = function(iterations, rng4) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined2)
        return isPrime;
      var n = this.abs();
      var t = iterations === undefined2 ? 5 : iterations;
      for (var a = [], i2 = 0; i2 < t; i2++) {
        a.push(bigInt.randBetween(2, n.minus(2), rng4));
      }
      return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
    BigInteger.prototype.modInv = function(n) {
      var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
      while (!newR.isZero()) {
        q = r.divide(newR);
        lastT = t;
        lastR = r;
        t = newT;
        r = newR;
        newT = lastT.subtract(q.multiply(newT));
        newR = lastR.subtract(q.multiply(newR));
      }
      if (!r.isUnit())
        throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
      if (t.compare(0) === -1) {
        t = t.add(n);
      }
      if (this.isNegative()) {
        return t.negate();
      }
      return t;
    };
    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
    BigInteger.prototype.next = function() {
      var value = this.value;
      if (this.sign) {
        return subtractSmall(value, 1, this.sign);
      }
      return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function() {
      var value = this.value;
      if (value + 1 < MAX_INT)
        return new SmallInteger(value + 1);
      return new BigInteger(MAX_INT_ARR, false);
    };
    NativeBigInt.prototype.next = function() {
      return new NativeBigInt(this.value + BigInt(1));
    };
    BigInteger.prototype.prev = function() {
      var value = this.value;
      if (this.sign) {
        return new BigInteger(addSmall(value, 1), true);
      }
      return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function() {
      var value = this.value;
      if (value - 1 > -MAX_INT)
        return new SmallInteger(value - 1);
      return new BigInteger(MAX_INT_ARR, true);
    };
    NativeBigInt.prototype.prev = function() {
      return new NativeBigInt(this.value - BigInt(1));
    };
    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)
      powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
    function shift_isSmall(n) {
      return Math.abs(n) <= BASE;
    }
    BigInteger.prototype.shiftLeft = function(v) {
      var n = parseValue(v).toJSNumber();
      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }
      if (n < 0)
        return this.shiftRight(-n);
      var result = this;
      if (result.isZero())
        return result;
      while (n >= powers2Length) {
        result = result.multiply(highestPower2);
        n -= powers2Length - 1;
      }
      return result.multiply(powersOfTwo[n]);
    };
    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
    BigInteger.prototype.shiftRight = function(v) {
      var remQuo;
      var n = parseValue(v).toJSNumber();
      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }
      if (n < 0)
        return this.shiftLeft(-n);
      var result = this;
      while (n >= powers2Length) {
        if (result.isZero() || result.isNegative() && result.isUnit())
          return result;
        remQuo = divModAny(result, highestPower2);
        result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        n -= powers2Length - 1;
      }
      remQuo = divModAny(result, powersOfTwo[n]);
      return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
    function bitwise(x, y, fn) {
      y = parseValue(y);
      var xSign = x.isNegative(), ySign = y.isNegative();
      var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
      var xDigit = 0, yDigit = 0;
      var xDivMod = null, yDivMod = null;
      var result = [];
      while (!xRem.isZero() || !yRem.isZero()) {
        xDivMod = divModAny(xRem, highestPower2);
        xDigit = xDivMod[1].toJSNumber();
        if (xSign) {
          xDigit = highestPower2 - 1 - xDigit;
        }
        yDivMod = divModAny(yRem, highestPower2);
        yDigit = yDivMod[1].toJSNumber();
        if (ySign) {
          yDigit = highestPower2 - 1 - yDigit;
        }
        xRem = xDivMod[0];
        yRem = yDivMod[0];
        result.push(fn(xDigit, yDigit));
      }
      var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
      for (var i2 = result.length - 1; i2 >= 0; i2 -= 1) {
        sum = sum.multiply(highestPower2).add(bigInt(result[i2]));
      }
      return sum;
    }
    BigInteger.prototype.not = function() {
      return this.negate().prev();
    };
    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
    BigInteger.prototype.and = function(n) {
      return bitwise(this, n, function(a, b) {
        return a & b;
      });
    };
    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
    BigInteger.prototype.or = function(n) {
      return bitwise(this, n, function(a, b) {
        return a | b;
      });
    };
    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
    BigInteger.prototype.xor = function(n) {
      return bitwise(this, n, function(a, b) {
        return a ^ b;
      });
    };
    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) {
      var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
      return x & -x;
    }
    function integerLogarithm(value, base) {
      if (base.compareTo(value) <= 0) {
        var tmp = integerLogarithm(value, base.square(base));
        var p = tmp.p;
        var e = tmp.e;
        var t = p.multiply(base);
        return t.compareTo(value) <= 0 ? {p: t, e: e * 2 + 1} : {p, e: e * 2};
      }
      return {p: bigInt(1), e: 0};
    }
    BigInteger.prototype.bitLength = function() {
      var n = this;
      if (n.compareTo(bigInt(0)) < 0) {
        n = n.negate().subtract(bigInt(1));
      }
      if (n.compareTo(bigInt(0)) === 0) {
        return bigInt(0);
      }
      return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
    };
    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
    function max(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.greater(b) ? a : b;
    }
    function min(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      if (a.equals(b))
        return a;
      if (a.isZero())
        return b;
      if (b.isZero())
        return a;
      var c = Integer[1], d, t;
      while (a.isEven() && b.isEven()) {
        d = min(roughLOB(a), roughLOB(b));
        a = a.divide(d);
        b = b.divide(d);
        c = c.multiply(d);
      }
      while (a.isEven()) {
        a = a.divide(roughLOB(a));
      }
      do {
        while (b.isEven()) {
          b = b.divide(roughLOB(b));
        }
        if (a.greater(b)) {
          t = b;
          b = a;
          a = t;
        }
        b = b.subtract(a);
      } while (!b.isZero());
      return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b, rng4) {
      a = parseValue(a);
      b = parseValue(b);
      var usedRNG = rng4 || Math.random;
      var low = min(a, b), high = max(a, b);
      var range2 = high.subtract(low).add(1);
      if (range2.isSmall)
        return low.add(Math.floor(usedRNG() * range2));
      var digits = toBase(range2, BASE).value;
      var result = [], restricted = true;
      for (var i2 = 0; i2 < digits.length; i2++) {
        var top = restricted ? digits[i2] : BASE;
        var digit = truncate(usedRNG() * top);
        result.push(digit);
        if (digit < top)
          restricted = false;
      }
      return low.add(Integer.fromArray(result, BASE, false));
    }
    var parseBase = function(text, base, alphabet, caseSensitive) {
      alphabet = alphabet || DEFAULT_ALPHABET;
      text = String(text);
      if (!caseSensitive) {
        text = text.toLowerCase();
        alphabet = alphabet.toLowerCase();
      }
      var length = text.length;
      var i2;
      var absBase = Math.abs(base);
      var alphabetValues = {};
      for (i2 = 0; i2 < alphabet.length; i2++) {
        alphabetValues[alphabet[i2]] = i2;
      }
      for (i2 = 0; i2 < length; i2++) {
        var c = text[i2];
        if (c === "-")
          continue;
        if (c in alphabetValues) {
          if (alphabetValues[c] >= absBase) {
            if (c === "1" && absBase === 1)
              continue;
            throw new Error(c + " is not a valid digit in base " + base + ".");
          }
        }
      }
      base = parseValue(base);
      var digits = [];
      var isNegative = text[0] === "-";
      for (i2 = isNegative ? 1 : 0; i2 < text.length; i2++) {
        var c = text[i2];
        if (c in alphabetValues)
          digits.push(parseValue(alphabetValues[c]));
        else if (c === "<") {
          var start = i2;
          do {
            i2++;
          } while (text[i2] !== ">" && i2 < text.length);
          digits.push(parseValue(text.slice(start + 1, i2)));
        } else
          throw new Error(c + " is not a valid character");
      }
      return parseBaseFromArray(digits, base, isNegative);
    };
    function parseBaseFromArray(digits, base, isNegative) {
      var val = Integer[0], pow = Integer[1], i2;
      for (i2 = digits.length - 1; i2 >= 0; i2--) {
        val = val.add(digits[i2].times(pow));
        pow = pow.times(base);
      }
      return isNegative ? val.negate() : val;
    }
    function stringify2(digit, alphabet) {
      alphabet = alphabet || DEFAULT_ALPHABET;
      if (digit < alphabet.length) {
        return alphabet[digit];
      }
      return "<" + digit + ">";
    }
    function toBase(n, base) {
      base = bigInt(base);
      if (base.isZero()) {
        if (n.isZero())
          return {value: [0], isNegative: false};
        throw new Error("Cannot convert nonzero numbers to base 0.");
      }
      if (base.equals(-1)) {
        if (n.isZero())
          return {value: [0], isNegative: false};
        if (n.isNegative())
          return {
            value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])),
            isNegative: false
          };
        var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
        arr.unshift([1]);
        return {
          value: [].concat.apply([], arr),
          isNegative: false
        };
      }
      var neg = false;
      if (n.isNegative() && base.isPositive()) {
        neg = true;
        n = n.abs();
      }
      if (base.isUnit()) {
        if (n.isZero())
          return {value: [0], isNegative: false};
        return {
          value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
          isNegative: neg
        };
      }
      var out = [];
      var left = n, divmod;
      while (left.isNegative() || left.compareAbs(base) >= 0) {
        divmod = left.divmod(base);
        left = divmod.quotient;
        var digit = divmod.remainder;
        if (digit.isNegative()) {
          digit = base.minus(digit).abs();
          left = left.next();
        }
        out.push(digit.toJSNumber());
      }
      out.push(left.toJSNumber());
      return {value: out.reverse(), isNegative: neg};
    }
    function toBaseString(n, base, alphabet) {
      var arr = toBase(n, base);
      return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
        return stringify2(x, alphabet);
      }).join("");
    }
    BigInteger.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    SmallInteger.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    NativeBigInt.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    BigInteger.prototype.toString = function(radix, alphabet) {
      if (radix === undefined2)
        radix = 10;
      if (radix !== 10)
        return toBaseString(this, radix, alphabet);
      var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
      while (--l >= 0) {
        digit = String(v[l]);
        str += zeros.slice(digit.length) + digit;
      }
      var sign = this.sign ? "-" : "";
      return sign + str;
    };
    SmallInteger.prototype.toString = function(radix, alphabet) {
      if (radix === undefined2)
        radix = 10;
      if (radix != 10)
        return toBaseString(this, radix, alphabet);
      return String(this.value);
    };
    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
      return this.toString();
    };
    BigInteger.prototype.valueOf = function() {
      return parseInt(this.toString(), 10);
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
    SmallInteger.prototype.valueOf = function() {
      return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
      return parseInt(this.toString(), 10);
    };
    function parseStringValue(v) {
      if (isPrecise(+v)) {
        var x = +v;
        if (x === truncate(x))
          return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
        throw new Error("Invalid integer: " + v);
      }
      var sign = v[0] === "-";
      if (sign)
        v = v.slice(1);
      var split = v.split(/e/i);
      if (split.length > 2)
        throw new Error("Invalid integer: " + split.join("e"));
      if (split.length === 2) {
        var exp = split[1];
        if (exp[0] === "+")
          exp = exp.slice(1);
        exp = +exp;
        if (exp !== truncate(exp) || !isPrecise(exp))
          throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
        var text = split[0];
        var decimalPlace = text.indexOf(".");
        if (decimalPlace >= 0) {
          exp -= text.length - decimalPlace - 1;
          text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
        }
        if (exp < 0)
          throw new Error("Cannot include negative exponent part for integers");
        text += new Array(exp + 1).join("0");
        v = text;
      }
      var isValid = /^([0-9][0-9]*)$/.test(v);
      if (!isValid)
        throw new Error("Invalid integer: " + v);
      if (supportsNativeBigInt) {
        return new NativeBigInt(BigInt(sign ? "-" + v : v));
      }
      var r = [], max2 = v.length, l = LOG_BASE, min2 = max2 - l;
      while (max2 > 0) {
        r.push(+v.slice(min2, max2));
        min2 -= l;
        if (min2 < 0)
          min2 = 0;
        max2 -= l;
      }
      trim(r);
      return new BigInteger(r, sign);
    }
    function parseNumberValue(v) {
      if (supportsNativeBigInt) {
        return new NativeBigInt(BigInt(v));
      }
      if (isPrecise(v)) {
        if (v !== truncate(v))
          throw new Error(v + " is not an integer.");
        return new SmallInteger(v);
      }
      return parseStringValue(v.toString());
    }
    function parseValue(v) {
      if (typeof v === "number") {
        return parseNumberValue(v);
      }
      if (typeof v === "string") {
        return parseStringValue(v);
      }
      if (typeof v === "bigint") {
        return new NativeBigInt(v);
      }
      return v;
    }
    for (var i = 0; i < 1e3; i++) {
      Integer[i] = parseValue(i);
      if (i > 0)
        Integer[-i] = parseValue(-i);
    }
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function(x) {
      return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
    };
    Integer.randBetween = randBetween;
    Integer.fromArray = function(digits, base, isNegative) {
      return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };
    return Integer;
  }();
  if (typeof module2 !== "undefined" && module2.hasOwnProperty("exports")) {
    module2.exports = bigInt;
  }
  if (typeof define === "function" && define.amd) {
    define(function() {
      return bigInt;
    });
  }
});

// node_modules/unzipper/lib/Decrypt.js
var require_Decrypt = __commonJS((exports2, module2) => {
  var bigInt = require_BigInteger();
  var Stream = require("stream");
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable();
  var table;
  function generateTable() {
    var poly = 3988292384, c, n, k;
    table = [];
    for (n = 0; n < 256; n++) {
      c = n;
      for (k = 0; k < 8; k++)
        c = c & 1 ? poly ^ c >>> 1 : c = c >>> 1;
      table[n] = c >>> 0;
    }
  }
  function crc(ch, crc2) {
    if (!table)
      generateTable();
    if (ch.charCodeAt)
      ch = ch.charCodeAt(0);
    return bigInt(crc2).shiftRight(8).and(16777215).xor(table[bigInt(crc2).xor(ch).and(255)]).value;
  }
  function Decrypt() {
    if (!(this instanceof Decrypt))
      return new Decrypt();
    this.key0 = 305419896;
    this.key1 = 591751049;
    this.key2 = 878082192;
  }
  Decrypt.prototype.update = function(h) {
    this.key0 = crc(h, this.key0);
    this.key1 = bigInt(this.key0).and(255).and(4294967295).add(this.key1);
    this.key1 = bigInt(this.key1).multiply(134775813).add(1).and(4294967295).value;
    this.key2 = crc(bigInt(this.key1).shiftRight(24).and(255), this.key2);
  };
  Decrypt.prototype.decryptByte = function(c) {
    var k = bigInt(this.key2).or(2);
    c = c ^ bigInt(k).multiply(bigInt(k ^ 1)).shiftRight(8).and(255);
    this.update(c);
    return c;
  };
  Decrypt.prototype.stream = function() {
    var stream = Stream.Transform(), self2 = this;
    stream._transform = function(d, e, cb) {
      for (var i = 0; i < d.length; i++) {
        d[i] = self2.decryptByte(d[i]);
      }
      this.push(d);
      cb();
    };
    return stream;
  };
  module2.exports = Decrypt;
});

// node_modules/unzipper/lib/Open/unzip.js
var require_unzip = __commonJS((exports2, module2) => {
  var Promise2 = require_bluebird();
  var Decrypt = require_Decrypt();
  var PullStream = require_PullStream();
  var Stream = require("stream");
  var binary = require_binary();
  var zlib3 = require("zlib");
  var parseExtraField = require_parseExtraField();
  var Buffer2 = require_Buffer2();
  var parseDateTime = require_parseDateTime();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable();
  module2.exports = function unzip2(source3, offset, _password, directoryVars) {
    var file = PullStream(), entry = Stream.PassThrough();
    var req = source3.stream(offset);
    req.pipe(file).on("error", function(e) {
      entry.emit("error", e);
    });
    entry.vars = file.pull(30).then(function(data) {
      var vars = binary.parse(data).word32lu("signature").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
      vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);
      return file.pull(vars.fileNameLength).then(function(fileName) {
        vars.fileName = fileName.toString("utf8");
        return file.pull(vars.extraFieldLength);
      }).then(function(extraField) {
        var checkEncryption;
        vars.extra = parseExtraField(extraField, vars);
        if (directoryVars && directoryVars.compressedSize)
          vars = directoryVars;
        if (vars.flags & 1)
          checkEncryption = file.pull(12).then(function(header) {
            if (!_password)
              throw new Error("MISSING_PASSWORD");
            var decrypt = Decrypt();
            String(_password).split("").forEach(function(d) {
              decrypt.update(d);
            });
            for (var i = 0; i < header.length; i++)
              header[i] = decrypt.decryptByte(header[i]);
            vars.decrypt = decrypt;
            vars.compressedSize -= 12;
            var check = vars.flags & 8 ? vars.lastModifiedTime >> 8 & 255 : vars.crc32 >> 24 & 255;
            if (header[11] !== check)
              throw new Error("BAD_PASSWORD");
            return vars;
          });
        return Promise2.resolve(checkEncryption).then(function() {
          entry.emit("vars", vars);
          return vars;
        });
      });
    });
    entry.vars.then(function(vars) {
      var fileSizeKnown = !(vars.flags & 8) || vars.compressedSize > 0, eof;
      var inflater = vars.compressionMethod ? zlib3.createInflateRaw() : Stream.PassThrough();
      if (fileSizeKnown) {
        entry.size = vars.uncompressedSize;
        eof = vars.compressedSize;
      } else {
        eof = Buffer2.alloc(4);
        eof.writeUInt32LE(134695760, 0);
      }
      var stream = file.stream(eof);
      if (vars.decrypt)
        stream = stream.pipe(vars.decrypt.stream());
      stream.pipe(inflater).on("error", function(err) {
        entry.emit("error", err);
      }).pipe(entry).on("finish", function() {
        if (req.abort)
          req.abort();
        else if (req.close)
          req.close();
        else if (req.push)
          req.push();
        else
          console.log("warning - unable to close stream");
      });
    }).catch(function(e) {
      entry.emit("error", e);
    });
    return entry;
  };
});

// node_modules/unzipper/lib/Open/directory.js
var require_directory = __commonJS((exports2, module2) => {
  var binary = require_binary();
  var PullStream = require_PullStream();
  var unzip2 = require_unzip();
  var Promise2 = require_bluebird();
  var BufferStream = require_BufferStream();
  var parseExtraField = require_parseExtraField();
  var Buffer2 = require_Buffer2();
  var path66 = require("path");
  var Writer = require_fstream().Writer;
  var parseDateTime = require_parseDateTime();
  var signature2 = Buffer2.alloc(4);
  signature2.writeUInt32LE(101010256, 0);
  function getCrxHeader(source3) {
    var sourceStream = source3.stream(0).pipe(PullStream());
    return sourceStream.pull(4).then(function(data) {
      var signature3 = data.readUInt32LE(0);
      if (signature3 === 875721283) {
        var crxHeader;
        return sourceStream.pull(12).then(function(data2) {
          crxHeader = binary.parse(data2).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
        }).then(function() {
          return sourceStream.pull(crxHeader.pubKeyLength + crxHeader.signatureLength);
        }).then(function(data2) {
          crxHeader.publicKey = data2.slice(0, crxHeader.pubKeyLength);
          crxHeader.signature = data2.slice(crxHeader.pubKeyLength);
          crxHeader.size = 16 + crxHeader.pubKeyLength + crxHeader.signatureLength;
          return crxHeader;
        });
      }
    });
  }
  function getZip64CentralDirectory(source3, zip64CDL) {
    var d64loc = binary.parse(zip64CDL).word32lu("signature").word32lu("diskNumber").word64lu("offsetToStartOfCentralDirectory").word32lu("numberOfDisks").vars;
    if (d64loc.signature != 117853008) {
      throw new Error("invalid zip64 end of central dir locator signature (0x07064b50): 0x" + d64loc.signature.toString(16));
    }
    var dir64 = PullStream();
    source3.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);
    return dir64.pull(56);
  }
  function parseZip64DirRecord(dir64record) {
    var vars = binary.parse(dir64record).word32lu("signature").word64lu("sizeOfCentralDirectory").word16lu("version").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskStart").word64lu("numberOfRecordsOnDisk").word64lu("numberOfRecords").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
    if (vars.signature != 101075792) {
      throw new Error("invalid zip64 end of central dir locator signature (0x06064b50): 0x0" + vars.signature.toString(16));
    }
    return vars;
  }
  module2.exports = function centralDirectory(source3, options) {
    var endDir = PullStream(), records = PullStream(), tailSize = options && options.tailSize || 80, sourceSize, crxHeader, startOffset, vars;
    if (options && options.crx)
      crxHeader = getCrxHeader(source3);
    return source3.size().then(function(size) {
      sourceSize = size;
      source3.stream(Math.max(0, size - tailSize)).on("error", function(error) {
        endDir.emit("error", error);
      }).pipe(endDir);
      return endDir.pull(signature2);
    }).then(function() {
      return Promise2.props({directory: endDir.pull(22), crxHeader});
    }).then(function(d) {
      var data = d.directory;
      startOffset = d.crxHeader && d.crxHeader.size || 0;
      vars = binary.parse(data).word32lu("signature").word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
      if (vars.numberOfRecords == 65535 || vars.numberOfRecords == 65535 || vars.offsetToStartOfCentralDirectory == 4294967295) {
        const zip64CDLSize = 20;
        const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize);
        const zip64CDLStream = PullStream();
        source3.stream(zip64CDLOffset).pipe(zip64CDLStream);
        return zip64CDLStream.pull(zip64CDLSize).then(function(d2) {
          return getZip64CentralDirectory(source3, d2);
        }).then(function(dir64record) {
          vars = parseZip64DirRecord(dir64record);
        });
      } else {
        vars.offsetToStartOfCentralDirectory += startOffset;
      }
    }).then(function() {
      source3.stream(vars.offsetToStartOfCentralDirectory).pipe(records);
      vars.extract = function(opts) {
        if (!opts || !opts.path)
          throw new Error("PATH_MISSING");
        return vars.files.then(function(files) {
          return Promise2.map(files, function(entry) {
            if (entry.type == "Directory")
              return;
            var extractPath = path66.join(opts.path, entry.path);
            if (extractPath.indexOf(opts.path) != 0) {
              return;
            }
            var writer = opts.getWriter ? opts.getWriter({path: extractPath}) : Writer({path: extractPath});
            return new Promise2(function(resolve3, reject) {
              entry.stream(opts.password).on("error", reject).pipe(writer).on("close", resolve3).on("error", reject);
            });
          }, opts.concurrency > 1 ? {concurrency: opts.concurrency || void 0} : void 0);
        });
      };
      vars.files = Promise2.mapSeries(Array(vars.numberOfRecords), function() {
        return records.pull(46).then(function(data) {
          var vars2 = binary.parse(data).word32lu("signature").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
          vars2.offsetToLocalFileHeader += startOffset;
          vars2.lastModifiedDateTime = parseDateTime(vars2.lastModifiedDate, vars2.lastModifiedTime);
          return records.pull(vars2.fileNameLength).then(function(fileNameBuffer) {
            vars2.pathBuffer = fileNameBuffer;
            vars2.path = fileNameBuffer.toString("utf8");
            vars2.isUnicode = vars2.flags & 17;
            return records.pull(vars2.extraFieldLength);
          }).then(function(extraField) {
            vars2.extra = parseExtraField(extraField, vars2);
            return records.pull(vars2.fileCommentLength);
          }).then(function(comment) {
            vars2.comment = comment;
            vars2.type = vars2.uncompressedSize === 0 && /[\/\\]$/.test(vars2.path) ? "Directory" : "File";
            vars2.stream = function(_password) {
              return unzip2(source3, vars2.offsetToLocalFileHeader, _password, vars2);
            };
            vars2.buffer = function(_password) {
              return BufferStream(vars2.stream(_password));
            };
            return vars2;
          });
        });
      });
      return Promise2.props(vars);
    });
  };
});

// node_modules/unzipper/lib/Open/index.js
var require_Open = __commonJS((exports2, module2) => {
  var fs55 = require_graceful_fs();
  var Promise2 = require_bluebird();
  var directory = require_directory();
  var Stream = require("stream");
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = require_readable();
  module2.exports = {
    buffer: function(buffer4, options) {
      var source3 = {
        stream: function(offset, length) {
          var stream = Stream.PassThrough();
          stream.end(buffer4.slice(offset, length));
          return stream;
        },
        size: function() {
          return Promise2.resolve(buffer4.length);
        }
      };
      return directory(source3, options);
    },
    file: function(filename, options) {
      var source3 = {
        stream: function(offset, length) {
          return fs55.createReadStream(filename, {start: offset, end: length && offset + length});
        },
        size: function() {
          return new Promise2(function(resolve3, reject) {
            fs55.stat(filename, function(err, d) {
              if (err)
                reject(err);
              else
                resolve3(d.size);
            });
          });
        }
      };
      return directory(source3, options);
    },
    url: function(request2, params, options) {
      if (typeof params === "string")
        params = {url: params};
      if (!params.url)
        throw "URL missing";
      params.headers = params.headers || {};
      var source3 = {
        stream: function(offset, length) {
          var options2 = Object.create(params);
          options2.headers = Object.create(params.headers);
          options2.headers.range = "bytes=" + offset + "-" + (length ? length : "");
          return request2(options2);
        },
        size: function() {
          return new Promise2(function(resolve3, reject) {
            var req = request2(params);
            req.on("response", function(d) {
              req.abort();
              if (!d.headers["content-length"])
                reject(new Error("Missing content length header"));
              else
                resolve3(d.headers["content-length"]);
            }).on("error", reject);
          });
        }
      };
      return directory(source3, options);
    },
    s3: function(client8, params, options) {
      var source3 = {
        size: function() {
          return new Promise2(function(resolve3, reject) {
            client8.headObject(params, function(err, d) {
              if (err)
                reject(err);
              else
                resolve3(d.ContentLength);
            });
          });
        },
        stream: function(offset, length) {
          var d = {};
          for (var key in params)
            d[key] = params[key];
          d.Range = "bytes=" + offset + "-" + (length ? length : "");
          return client8.getObject(d).createReadStream();
        }
      };
      return directory(source3, options);
    }
  };
});

// node_modules/unzipper/unzip.js
var require_unzip2 = __commonJS((exports2) => {
  "use strict";
  require_listenercount();
  require_buffer_indexof_polyfill();
  require_setImmediate();
  exports2.Parse = require_parse3();
  exports2.ParseOne = require_parseOne();
  exports2.Extract = require_extract2();
  exports2.Open = require_Open();
});

// node_modules/@tootallnate/once/dist/index.js
var require_dist = __commonJS((exports2, module2) => {
  "use strict";
  function noop() {
  }
  function once(emitter, name2) {
    const o = once.spread(emitter, name2);
    const r = o.then((args) => args[0]);
    r.cancel = o.cancel;
    return r;
  }
  (function(once2) {
    function spread(emitter, name2) {
      let c = null;
      const p = new Promise((resolve3, reject) => {
        function cancel() {
          emitter.removeListener(name2, onEvent);
          emitter.removeListener("error", onError);
          p.cancel = noop;
        }
        function onEvent(...args) {
          cancel();
          resolve3(args);
        }
        function onError(err) {
          cancel();
          reject(err);
        }
        c = cancel;
        emitter.on(name2, onEvent);
        emitter.on("error", onError);
      });
      if (!c) {
        throw new TypeError("Could not get `cancel()` function");
      }
      p.cancel = c;
      return p;
    }
    once2.spread = spread;
  })(once || (once = {}));
  module2.exports = once;
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function promisify(fn) {
    return function(req, opts) {
      return new Promise((resolve3, reject) => {
        fn.call(this, req, opts, (err, rtn) => {
          if (err) {
            reject(err);
          } else {
            resolve3(rtn);
          }
        });
      });
    };
  }
  exports2.default = promisify;
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS((exports2, module2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  var events_1 = require("events");
  var debug_1 = __importDefault(require_src());
  var promisify_1 = __importDefault(require_promisify2());
  var debug = debug_1.default("agent-base");
  function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === "function";
  }
  function isSecureEndpoint() {
    const {stack} = new Error();
    if (typeof stack !== "string")
      return false;
    return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
  }
  function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
  }
  (function(createAgent2) {
    class Agent extends events_1.EventEmitter {
      constructor(callback, _opts) {
        super();
        let opts = _opts;
        if (typeof callback === "function") {
          this.callback = callback;
        } else if (callback) {
          opts = callback;
        }
        this.timeout = null;
        if (opts && typeof opts.timeout === "number") {
          this.timeout = opts.timeout;
        }
        this.maxFreeSockets = 1;
        this.maxSockets = 1;
        this.maxTotalSockets = Infinity;
        this.sockets = {};
        this.freeSockets = {};
        this.requests = {};
        this.options = {};
      }
      get defaultPort() {
        if (typeof this.explicitDefaultPort === "number") {
          return this.explicitDefaultPort;
        }
        return isSecureEndpoint() ? 443 : 80;
      }
      set defaultPort(v) {
        this.explicitDefaultPort = v;
      }
      get protocol() {
        if (typeof this.explicitProtocol === "string") {
          return this.explicitProtocol;
        }
        return isSecureEndpoint() ? "https:" : "http:";
      }
      set protocol(v) {
        this.explicitProtocol = v;
      }
      callback(req, opts, fn) {
        throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
      }
      addRequest(req, _opts) {
        const opts = Object.assign({}, _opts);
        if (typeof opts.secureEndpoint !== "boolean") {
          opts.secureEndpoint = isSecureEndpoint();
        }
        if (opts.host == null) {
          opts.host = "localhost";
        }
        if (opts.port == null) {
          opts.port = opts.secureEndpoint ? 443 : 80;
        }
        if (opts.protocol == null) {
          opts.protocol = opts.secureEndpoint ? "https:" : "http:";
        }
        if (opts.host && opts.path) {
          delete opts.path;
        }
        delete opts.agent;
        delete opts.hostname;
        delete opts._defaultAgent;
        delete opts.defaultPort;
        delete opts.createConnection;
        req._last = true;
        req.shouldKeepAlive = false;
        let timedOut = false;
        let timeoutId = null;
        const timeoutMs = opts.timeout || this.timeout;
        const onerror = (err) => {
          if (req._hadError)
            return;
          req.emit("error", err);
          req._hadError = true;
        };
        const ontimeout = () => {
          timeoutId = null;
          timedOut = true;
          const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
          err.code = "ETIMEOUT";
          onerror(err);
        };
        const callbackError = (err) => {
          if (timedOut)
            return;
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          onerror(err);
        };
        const onsocket = (socket) => {
          if (timedOut)
            return;
          if (timeoutId != null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          if (isAgent(socket)) {
            debug("Callback returned another Agent instance %o", socket.constructor.name);
            socket.addRequest(req, opts);
            return;
          }
          if (socket) {
            socket.once("free", () => {
              this.freeSocket(socket, opts);
            });
            req.onSocket(socket);
            return;
          }
          const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
          onerror(err);
        };
        if (typeof this.callback !== "function") {
          onerror(new Error("`callback` is not defined"));
          return;
        }
        if (!this.promisifiedCallback) {
          if (this.callback.length >= 3) {
            debug("Converting legacy callback function to promise");
            this.promisifiedCallback = promisify_1.default(this.callback);
          } else {
            this.promisifiedCallback = this.callback;
          }
        }
        if (typeof timeoutMs === "number" && timeoutMs > 0) {
          timeoutId = setTimeout(ontimeout, timeoutMs);
        }
        if ("port" in opts && typeof opts.port !== "number") {
          opts.port = Number(opts.port);
        }
        try {
          debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
          Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
        } catch (err) {
          Promise.reject(err).catch(callbackError);
        }
      }
      freeSocket(socket, opts) {
        debug("Freeing socket %o %o", socket.constructor.name, opts);
        socket.destroy();
      }
      destroy() {
        debug("Destroying agent %o", this.constructor.name);
      }
    }
    createAgent2.Agent = Agent;
    createAgent2.prototype = createAgent2.Agent.prototype;
  })(createAgent || (createAgent = {}));
  module2.exports = createAgent;
});

// node_modules/http-proxy-agent/dist/agent.js
var require_agent = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve3) {
        resolve3(value);
      });
    }
    return new (P || (P = Promise))(function(resolve3, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var net_1 = __importDefault(require("net"));
  var tls_1 = __importDefault(require("tls"));
  var url_1 = __importDefault(require("url"));
  var debug_1 = __importDefault(require_src());
  var once_1 = __importDefault(require_dist());
  var agent_base_1 = require_src2();
  var debug = debug_1.default("http-proxy-agent");
  function isHTTPS(protocol) {
    return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
  }
  var HttpProxyAgent2 = class extends agent_base_1.Agent {
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      }
      debug("Creating new HttpProxyAgent instance: %o", opts);
      super(opts);
      const proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
      proxy.host = proxy.hostname || proxy.host;
      if (typeof proxy.port === "string") {
        proxy.port = parseInt(proxy.port, 10);
      }
      if (!proxy.port && proxy.host) {
        proxy.port = this.secureProxy ? 443 : 80;
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
    }
    callback(req, opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const {proxy, secureProxy} = this;
        const parsed = url_1.default.parse(req.path);
        if (!parsed.protocol) {
          parsed.protocol = "http:";
        }
        if (!parsed.hostname) {
          parsed.hostname = opts.hostname || opts.host || null;
        }
        if (parsed.port == null && typeof opts.port) {
          parsed.port = String(opts.port);
        }
        if (parsed.port === "80") {
          delete parsed.port;
        }
        req.path = url_1.default.format(parsed);
        if (proxy.auth) {
          req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
        }
        let socket;
        if (secureProxy) {
          debug("Creating `tls.Socket`: %o", proxy);
          socket = tls_1.default.connect(proxy);
        } else {
          debug("Creating `net.Socket`: %o", proxy);
          socket = net_1.default.connect(proxy);
        }
        if (req._header) {
          let first;
          let endOfHeaders;
          debug("Regenerating stored HTTP header string for request");
          req._header = null;
          req._implicitHeader();
          if (req.output && req.output.length > 0) {
            debug("Patching connection write() output buffer with updated header");
            first = req.output[0];
            endOfHeaders = first.indexOf("\r\n\r\n") + 4;
            req.output[0] = req._header + first.substring(endOfHeaders);
            debug("Output buffer: %o", req.output);
          } else if (req.outputData && req.outputData.length > 0) {
            debug("Patching connection write() output buffer with updated header");
            first = req.outputData[0].data;
            endOfHeaders = first.indexOf("\r\n\r\n") + 4;
            req.outputData[0].data = req._header + first.substring(endOfHeaders);
            debug("Output buffer: %o", req.outputData[0].data);
          }
        }
        yield once_1.default(socket, "connect");
        return socket;
      });
    }
  };
  exports2.default = HttpProxyAgent2;
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist2 = __commonJS((exports2, module2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  var agent_1 = __importDefault(require_agent());
  function createHttpProxyAgent2(opts) {
    return new agent_1.default(opts);
  }
  (function(createHttpProxyAgent3) {
    createHttpProxyAgent3.HttpProxyAgent = agent_1.default;
    createHttpProxyAgent3.prototype = agent_1.default.prototype;
  })(createHttpProxyAgent2 || (createHttpProxyAgent2 = {}));
  module2.exports = createHttpProxyAgent2;
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var debug_1 = __importDefault(require_src());
  var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve3, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("close", onclose);
        socket.removeListener("readable", read);
      }
      function onclose(err) {
        debug("onclose had error %o", err);
      }
      function onend() {
        debug("onend");
      }
      function onerror(err) {
        cleanup();
        debug("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf("\r\n\r\n");
        if (endOfHeaders === -1) {
          debug("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
        const statusCode = +firstLine.split(" ")[1];
        debug("got proxy server response: %o", firstLine);
        resolve3({
          statusCode,
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("close", onclose);
      socket.on("end", onend);
      read();
    });
  }
  exports2.default = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent2 = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve3) {
        resolve3(value);
      });
    }
    return new (P || (P = Promise))(function(resolve3, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var net_1 = __importDefault(require("net"));
  var tls_1 = __importDefault(require("tls"));
  var url_1 = __importDefault(require("url"));
  var assert_1 = __importDefault(require("assert"));
  var debug_1 = __importDefault(require_src());
  var agent_base_1 = require_src2();
  var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
  var debug = debug_1.default("https-proxy-agent:agent");
  var HttpsProxyAgent2 = class extends agent_base_1.Agent {
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      }
      debug("creating new HttpsProxyAgent instance: %o", opts);
      super(opts);
      const proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
      proxy.host = proxy.hostname || proxy.host;
      if (typeof proxy.port === "string") {
        proxy.port = parseInt(proxy.port, 10);
      }
      if (!proxy.port && proxy.host) {
        proxy.port = this.secureProxy ? 443 : 80;
      }
      if (this.secureProxy && !("ALPNProtocols" in proxy)) {
        proxy.ALPNProtocols = ["http 1.1"];
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
    }
    callback(req, opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const {proxy, secureProxy} = this;
        let socket;
        if (secureProxy) {
          debug("Creating `tls.Socket`: %o", proxy);
          socket = tls_1.default.connect(proxy);
        } else {
          debug("Creating `net.Socket`: %o", proxy);
          socket = net_1.default.connect(proxy);
        }
        const headers = Object.assign({}, proxy.headers);
        const hostname = `${opts.host}:${opts.port}`;
        let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
        if (proxy.auth) {
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
        }
        let {host, port, secureEndpoint} = opts;
        if (!isDefaultPort(port, secureEndpoint)) {
          host += `:${port}`;
        }
        headers.Host = host;
        headers.Connection = "close";
        for (const name2 of Object.keys(headers)) {
          payload += `${name2}: ${headers[name2]}\r
`;
        }
        const proxyResponsePromise = parse_proxy_response_1.default(socket);
        socket.write(`${payload}\r
`);
        const {statusCode, buffered} = yield proxyResponsePromise;
        if (statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            const servername = opts.servername || opts.host;
            if (!servername) {
              throw new Error('Could not determine "servername"');
            }
            debug("Upgrading socket connection to TLS");
            return tls_1.default.connect(Object.assign(Object.assign({}, omit2(opts, "host", "hostname", "path", "port")), {
              socket,
              servername
            }));
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net_1.default.Socket();
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug("replaying proxy buffer for failed request");
          assert_1.default(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      });
    }
  };
  exports2.default = HttpsProxyAgent2;
  function resume(socket) {
    socket.resume();
  }
  function isDefaultPort(port, secure) {
    return Boolean(!secure && port === 80 || secure && port === 443);
  }
  function isHTTPS(protocol) {
    return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
  }
  function omit2(obj, ...keys) {
    const ret2 = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret2[key] = obj[key];
      }
    }
    return ret2;
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS((exports2, module2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  var agent_1 = __importDefault(require_agent2());
  function createHttpsProxyAgent2(opts) {
    return new agent_1.default(opts);
  }
  (function(createHttpsProxyAgent3) {
    createHttpsProxyAgent3.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent3.prototype = agent_1.default.prototype;
  })(createHttpsProxyAgent2 || (createHttpsProxyAgent2 = {}));
  module2.exports = createHttpsProxyAgent2;
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS((exports2, module2) => {
  /*!
   * content-disposition
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  "use strict";
  module2.exports = contentDisposition2;
  module2.exports.parse = parse4;
  var basename = require("path").basename;
  var Buffer2 = require_safe_buffer().Buffer;
  var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
  var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
  var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
  var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
  var QESC_REGEXP = /\\([\u0000-\u007f])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
  var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
  var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
  var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
  function contentDisposition2(filename, options) {
    var opts = options || {};
    var type = opts.type || "attachment";
    var params = createparams(filename, opts.fallback);
    return format4(new ContentDisposition(type, params));
  }
  function createparams(filename, fallback) {
    if (filename === void 0) {
      return;
    }
    var params = {};
    if (typeof filename !== "string") {
      throw new TypeError("filename must be a string");
    }
    if (fallback === void 0) {
      fallback = true;
    }
    if (typeof fallback !== "string" && typeof fallback !== "boolean") {
      throw new TypeError("fallback must be a string or boolean");
    }
    if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
      throw new TypeError("fallback must be ISO-8859-1 string");
    }
    var name2 = basename(filename);
    var isQuotedString = TEXT_REGEXP.test(name2);
    var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name2) : basename(fallback);
    var hasFallback = typeof fallbackName === "string" && fallbackName !== name2;
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name2)) {
      params["filename*"] = name2;
    }
    if (isQuotedString || hasFallback) {
      params.filename = hasFallback ? fallbackName : name2;
    }
    return params;
  }
  function format4(obj) {
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
      throw new TypeError("invalid type");
    }
    var string23 = String(type).toLowerCase();
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
        string23 += "; " + param + "=" + val;
      }
    }
    return string23;
  }
  function decodefield(str) {
    var match3 = EXT_VALUE_REGEXP.exec(str);
    if (!match3) {
      throw new TypeError("invalid extended field value");
    }
    var charset = match3[1].toLowerCase();
    var encoded = match3[2];
    var value;
    var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
    switch (charset) {
      case "iso-8859-1":
        value = getlatin1(binary);
        break;
      case "utf-8":
        value = Buffer2.from(binary, "binary").toString("utf8");
        break;
      default:
        throw new TypeError("unsupported charset in extended field");
    }
    return value;
  }
  function getlatin1(val) {
    return String(val).replace(NON_LATIN1_REGEXP, "?");
  }
  function parse4(string23) {
    if (!string23 || typeof string23 !== "string") {
      throw new TypeError("argument string is required");
    }
    var match3 = DISPOSITION_TYPE_REGEXP.exec(string23);
    if (!match3) {
      throw new TypeError("invalid type format");
    }
    var index = match3[0].length;
    var type = match3[1].toLowerCase();
    var key;
    var names = [];
    var params = {};
    var value;
    index = PARAM_REGEXP.lastIndex = match3[0].substr(-1) === ";" ? index - 1 : index;
    while (match3 = PARAM_REGEXP.exec(string23)) {
      if (match3.index !== index) {
        throw new TypeError("invalid parameter format");
      }
      index += match3[0].length;
      key = match3[1].toLowerCase();
      value = match3[2];
      if (names.indexOf(key) !== -1) {
        throw new TypeError("invalid duplicate parameter");
      }
      names.push(key);
      if (key.indexOf("*") + 1 === key.length) {
        key = key.slice(0, -1);
        value = decodefield(value);
        params[key] = value;
        continue;
      }
      if (typeof params[key] === "string") {
        continue;
      }
      if (value[0] === '"') {
        value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string23.length) {
      throw new TypeError("invalid parameter format");
    }
    return new ContentDisposition(type, params);
  }
  function pdecode(str, hex) {
    return String.fromCharCode(parseInt(hex, 16));
  }
  function pencode(char) {
    return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
  }
  function qstring(val) {
    var str = String(val);
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ustring(val) {
    var str = String(val);
    var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return "UTF-8''" + encoded;
  }
  function ContentDisposition(type, parameters) {
    this.type = type;
    this.parameters = parameters;
  }
});

// node_modules/is-docker/index.js
var require_is_docker = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require("fs");
  var isDocker;
  function hasDockerEnv() {
    try {
      fs55.statSync("/.dockerenv");
      return true;
    } catch (_) {
      return false;
    }
  }
  function hasDockerCGroup() {
    try {
      return fs55.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
    } catch (_) {
      return false;
    }
  }
  module2.exports = () => {
    if (isDocker === void 0) {
      isDocker = hasDockerEnv() || hasDockerCGroup();
    }
    return isDocker;
  };
});

// node_modules/is-wsl/index.js
var require_is_wsl = __commonJS((exports2, module2) => {
  "use strict";
  var os15 = require("os");
  var fs55 = require("fs");
  var isDocker = require_is_docker();
  var isWsl = () => {
    if (process.platform !== "linux") {
      return false;
    }
    if (os15.release().toLowerCase().includes("microsoft")) {
      if (isDocker()) {
        return false;
      }
      return true;
    }
    try {
      return fs55.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
    } catch (_) {
      return false;
    }
  };
  if (process.env.__IS_WSL_TEST__) {
    module2.exports = isWsl;
  } else {
    module2.exports = isWsl();
  }
});

// node_modules/nice-try/src/index.js
var require_src3 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(fn) {
    try {
      return fn();
    } catch (e) {
    }
  };
});

// node_modules/execa/node_modules/which/which.js
var require_which2 = __commonJS((exports2, module2) => {
  module2.exports = which11;
  which11.sync = whichSync;
  var isWindows4 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path66 = require("path");
  var COLON = isWindows4 ? ";" : ":";
  var isexe = require_isexe();
  function getNotFoundError(cmd) {
    var er = new Error("not found: " + cmd);
    er.code = "ENOENT";
    return er;
  }
  function getPathInfo(cmd, opt) {
    var colon = opt.colon || COLON;
    var pathEnv = opt.path || process.env.PATH || "";
    var pathExt = [""];
    pathEnv = pathEnv.split(colon);
    var pathExtExe = "";
    if (isWindows4) {
      pathEnv.unshift(process.cwd());
      pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
      pathExt = pathExtExe.split(colon);
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    if (cmd.match(/\//) || isWindows4 && cmd.match(/\\/))
      pathEnv = [""];
    return {
      env: pathEnv,
      ext: pathExt,
      extExe: pathExtExe
    };
  }
  function which11(cmd, opt, cb) {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    (function F(i, l) {
      if (i === l) {
        if (opt.all && found.length)
          return cb(null, found);
        else
          return cb(getNotFoundError(cmd));
      }
      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1);
      var p = path66.join(pathPart, cmd);
      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }
      ;
      (function E(ii, ll) {
        if (ii === ll)
          return F(i + 1, l);
        var ext = pathExt[ii];
        isexe(p + ext, {pathExt: pathExtExe}, function(er, is6) {
          if (!er && is6) {
            if (opt.all)
              found.push(p + ext);
            else
              return cb(null, p + ext);
          }
          return E(ii + 1, ll);
        });
      })(0, pathExt.length);
    })(0, pathEnv.length);
  }
  function whichSync(cmd, opt) {
    opt = opt || {};
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    for (var i = 0, l = pathEnv.length; i < l; i++) {
      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1);
      var p = path66.join(pathPart, cmd);
      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }
      for (var j = 0, ll = pathExt.length; j < ll; j++) {
        var cur = p + pathExt[j];
        var is6;
        try {
          is6 = isexe.sync(cur, {pathExt: pathExtExe});
          if (is6) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  }
});

// node_modules/path-key/index.js
var require_path_key = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (opts) => {
    opts = opts || {};
    const env2 = opts.env || process.env;
    const platform3 = opts.platform || process.platform;
    if (platform3 !== "win32") {
      return "PATH";
    }
    return Object.keys(env2).find((x) => x.toUpperCase() === "PATH") || "Path";
  };
});

// node_modules/execa/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports2, module2) => {
  "use strict";
  var path66 = require("path");
  var which11 = require_which2();
  var pathKey = require_path_key()();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    if (hasCustomCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {
      }
    }
    let resolved;
    try {
      resolved = which11.sync(parsed.command, {
        path: (parsed.options.env || process.env)[pathKey],
        pathExt: withoutPathExt ? path66.delimiter : void 0
      });
    } catch (e) {
    } finally {
      process.chdir(cwd);
    }
    if (resolved) {
      resolved = path66.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module2.exports = resolveCommand;
});

// node_modules/execa/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS((exports2, module2) => {
  "use strict";
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    arg = `${arg}`;
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');
    arg = arg.replace(/(\\*)$/, "$1$1");
    arg = `"${arg}"`;
    arg = arg.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg = arg.replace(metaCharsRegExp, "^$1");
    }
    return arg;
  }
  module2.exports.command = escapeCommand;
  module2.exports.argument = escapeArgument;
});

// node_modules/execa/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = /^#!.*/;
});

// node_modules/execa/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports2, module2) => {
  "use strict";
  var shebangRegex = require_shebang_regex();
  module2.exports = function(str) {
    var match3 = str.match(shebangRegex);
    if (!match3) {
      return null;
    }
    var arr = match3[0].replace(/#! ?/, "").split(" ");
    var bin = arr[0].split("/").pop();
    var arg = arr[1];
    return bin === "env" ? arg : bin + (arg ? " " + arg : "");
  };
});

// node_modules/execa/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports2, module2) => {
  "use strict";
  var fs55 = require("fs");
  var shebangCommand = require_shebang_command();
  function readShebang(command) {
    const size = 150;
    let buffer4;
    if (Buffer.alloc) {
      buffer4 = Buffer.alloc(size);
    } else {
      buffer4 = new Buffer(size);
      buffer4.fill(0);
    }
    let fd;
    try {
      fd = fs55.openSync(command, "r");
      fs55.readSync(fd, buffer4, 0, size, 0);
      fs55.closeSync(fd);
    } catch (e) {
    }
    return shebangCommand(buffer4.toString());
  }
  module2.exports = readShebang;
});

// node_modules/execa/node_modules/semver/semver.js
var require_semver3 = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++;
  var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
  var LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  var TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  var CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse4;
  function parse4(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 !== "string") {
      return null;
    }
    if (version2.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[LOOSE] : re[FULL];
    if (!r.test(version2)) {
      return null;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version2, options) {
    var v = parse4(version2, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version2, options) {
    var s = parse4(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version2 instanceof SemVer) {
      if (version2.loose === options.loose) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError("Invalid Version: " + version2);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version2, options);
    }
    debug("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version2.trim().match(options.loose ? re[LOOSE] : re[FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version2);
    }
    this.raw = version2;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version2, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version2, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff3;
  function diff3(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v12 = parse4(version1);
      var v2 = parse4(version2);
      var prefix = "";
      if (v12.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v12) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v12[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list2, loose) {
    return list2.sort(function(a, b) {
      return exports2.compare(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list2, loose) {
    return list2.sort(function(a, b) {
      return exports2.rcompare(a, b, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1];
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version2) {
    debug("Comparator.test", version2, this.options.loose);
    if (this.semver === ANY) {
      return true;
    }
    if (typeof version2 === "string") {
      version2 = new SemVer(version2, this.options);
    }
    return cmp(version2, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      rangeTmp = new Range34(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      rangeTmp = new Range34(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range34;
  function Range34(range2, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range2 instanceof Range34) {
      if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
        return range2;
      } else {
        return new Range34(range2.raw, options);
      }
    }
    if (range2 instanceof Comparator) {
      return new Range34(range2.value, options);
    }
    if (!(this instanceof Range34)) {
      return new Range34(range2, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range2;
    this.set = range2.split(/\s*\|\|\s*/).map(function(range3) {
      return this.parseRange(range3.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range2);
    }
    this.format();
  }
  Range34.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range34.prototype.toString = function() {
    return this.range;
  };
  Range34.prototype.parseRange = function(range2) {
    var loose = this.options.loose;
    range2 = range2.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range2 = range2.replace(hr, hyphenReplace);
    debug("hyphen replace", range2);
    range2 = range2.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range2, re[COMPARATORTRIM]);
    range2 = range2.replace(re[TILDETRIM], tildeTrimReplace);
    range2 = range2.replace(re[CARETTRIM], caretTrimReplace);
    range2 = range2.split(/\s+/).join(" ");
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range2.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range34.prototype.intersects = function(range2, options) {
    if (!(range2 instanceof Range34)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return thisComparators.every(function(thisComparator) {
        return range2.set.some(function(rangeComparators) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports2.toComparators = toComparators;
  function toComparators(range2, options) {
    return new Range34(range2, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret2;
      if (isX(M)) {
        ret2 = "";
      } else if (isX(m)) {
        ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret2);
      return ret2;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret2;
      if (isX(M)) {
        ret2 = "";
      } else if (isX(m)) {
        ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret2 = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret2 = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret2 = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret2 = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret2);
      return ret2;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function(ret2, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret2, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret2 = "<0.0.0";
        } else {
          ret2 = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret2 = gtlt + M + "." + m + "." + p;
      } else if (xm) {
        ret2 = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (xp) {
        ret2 = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      }
      debug("xRange return", ret2);
      return ret2;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range34.prototype.test = function(version2) {
    if (!version2) {
      return false;
    }
    if (typeof version2 === "string") {
      version2 = new SemVer(version2, this.options);
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version2, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version2, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version2, range2, options) {
    try {
      range2 = new Range34(range2, options);
    } catch (er) {
      return false;
    }
    return range2.test(version2);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range2, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range34(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range2, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range34(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range2, loose) {
    range2 = new Range34(range2, loose);
    var minver = new SemVer("0.0.0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range2.set.length; ++i2) {
      var comparators = range2.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range2.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range2, options) {
    try {
      return new Range34(range2, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version2, range2, options) {
    return outside(version2, range2, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version2, range2, options) {
    return outside(version2, range2, ">", options);
  }
  exports2.outside = outside;
  function outside(version2, range2, hilo, options) {
    version2 = new SemVer(version2, options);
    range2 = new Range34(range2, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range2, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range2.set.length; ++i2) {
      var comparators = range2.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version2, options) {
    var parsed = parse4(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range34(r1, options);
    r2 = new Range34(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version2) {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 !== "string") {
      return null;
    }
    var match3 = version2.match(re[COERCE]);
    if (match3 == null) {
      return null;
    }
    return parse4(match3[1] + "." + (match3[2] || "0") + "." + (match3[3] || "0"));
  }
});

// node_modules/execa/node_modules/cross-spawn/lib/parse.js
var require_parse4 = __commonJS((exports2, module2) => {
  "use strict";
  var path66 = require("path");
  var niceTry = require_src3();
  var resolveCommand = require_resolveCommand();
  var escape = require_escape();
  var readShebang = require_readShebang();
  var semver9 = require_semver3();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  var supportsShellOption = niceTry(() => semver9.satisfies(process.version, "^4.8.0 || ^5.7.0 || >= 6.0.0", true)) || false;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path66.normalize(parsed.command);
      parsed.command = escape.command(parsed.command);
      parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parseShell(parsed) {
    if (supportsShellOption) {
      return parsed;
    }
    const shellCommand = [parsed.command].concat(parsed.args).join(" ");
    if (isWin) {
      parsed.command = typeof parsed.options.shell === "string" ? parsed.options.shell : process.env.comspec || "cmd.exe";
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.options.windowsVerbatimArguments = true;
    } else {
      if (typeof parsed.options.shell === "string") {
        parsed.command = parsed.options.shell;
      } else if (process.platform === "android") {
        parsed.command = "/system/bin/sh";
      } else {
        parsed.command = "/bin/sh";
      }
      parsed.args = ["-c", shellCommand];
    }
    return parsed;
  }
  function parse4(command, args, options) {
    if (args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command,
      args,
      options,
      file: void 0,
      original: {
        command,
        args
      }
    };
    return options.shell ? parseShell(parsed) : parseNonShell(parsed);
  }
  module2.exports = parse4;
});

// node_modules/execa/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports2, module2) => {
  "use strict";
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp3, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp3.emit;
    cp3.emit = function(name2, arg1) {
      if (name2 === "exit") {
        const err = verifyENOENT(arg1, parsed, "spawn");
        if (err) {
          return originalEmit.call(cp3, "error", err);
        }
      }
      return originalEmit.apply(cp3, arguments);
    };
  }
  function verifyENOENT(status3, parsed) {
    if (isWin && status3 === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status3, parsed) {
    if (isWin && status3 === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module2.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// node_modules/execa/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports2, module2) => {
  "use strict";
  var cp3 = require("child_process");
  var parse4 = require_parse4();
  var enoent = require_enoent();
  function spawn4(command, args, options) {
    const parsed = parse4(command, args, options);
    const spawned = cp3.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync2(command, args, options) {
    const parsed = parse4(command, args, options);
    const result = cp3.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module2.exports = spawn4;
  module2.exports.spawn = spawn4;
  module2.exports.sync = spawnSync2;
  module2.exports._parse = parse4;
  module2.exports._enoent = enoent;
});

// node_modules/strip-eof/index.js
var require_strip_eof = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(x) {
    var lf = typeof x === "string" ? "\n" : "\n".charCodeAt();
    var cr = typeof x === "string" ? "\r" : "\r".charCodeAt();
    if (x[x.length - 1] === lf) {
      x = x.slice(0, x.length - 1);
    }
    if (x[x.length - 1] === cr) {
      x = x.slice(0, x.length - 1);
    }
    return x;
  };
});

// node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS((exports2, module2) => {
  "use strict";
  var path66 = require("path");
  var pathKey = require_path_key();
  module2.exports = (opts) => {
    opts = Object.assign({
      cwd: process.cwd(),
      path: process.env[pathKey()]
    }, opts);
    let prev;
    let pth = path66.resolve(opts.cwd);
    const ret2 = [];
    while (prev !== pth) {
      ret2.push(path66.join(pth, "node_modules/.bin"));
      prev = pth;
      pth = path66.resolve(pth, "..");
    }
    ret2.push(path66.dirname(process.execPath));
    return ret2.concat(opts.path).join(path66.delimiter);
  };
  module2.exports.env = (opts) => {
    opts = Object.assign({
      env: process.env
    }, opts);
    const env2 = Object.assign({}, opts.env);
    const path67 = pathKey({env: env2});
    opts.path = env2[path67];
    env2[path67] = module2.exports(opts);
    return env2;
  };
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports2, module2) => {
  "use strict";
  var isStream = module2.exports = function(stream) {
    return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  };
  isStream.writable = function(stream) {
    return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  };
  isStream.readable = function(stream) {
    return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  };
  isStream.duplex = function(stream) {
    return isStream.writable(stream) && isStream.readable(stream);
  };
  isStream.transform = function(stream) {
    return isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
  };
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS((exports2, module2) => {
  var once = require_once();
  var noop = function() {
  };
  var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  };
  var isChildProcess = function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
  };
  var eos = function(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var ws = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
      if (!stream.writable)
        onfinish();
    };
    var onfinish = function() {
      writable = false;
      if (!readable)
        callback.call(stream);
    };
    var onend = function() {
      readable = false;
      if (!writable)
        callback.call(stream);
    };
    var onexit = function(exitCode) {
      callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
    };
    var onerror = function(err) {
      callback.call(stream, err);
    };
    var onclose = function() {
      process.nextTick(onclosenexttick);
    };
    var onclosenexttick = function() {
      if (cancelled)
        return;
      if (readable && !(rs && (rs.ended && !rs.destroyed)))
        return callback.call(stream, new Error("premature close"));
      if (writable && !(ws && (ws.ended && !ws.destroyed)))
        return callback.call(stream, new Error("premature close"));
    };
    var onrequest = function() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !ws) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (isChildProcess(stream))
      stream.on("exit", onexit);
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      cancelled = true;
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("exit", onexit);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  };
  module2.exports = eos;
});

// node_modules/pump/index.js
var require_pump = __commonJS((exports2, module2) => {
  var once = require_once();
  var eos = require_end_of_stream();
  var fs55 = require("fs");
  var noop = function() {
  };
  var ancient = /^v?\.0/.test(process.version);
  var isFn = function(fn) {
    return typeof fn === "function";
  };
  var isFS = function(stream) {
    if (!ancient)
      return false;
    if (!fs55)
      return false;
    return (stream instanceof (fs55.ReadStream || noop) || stream instanceof (fs55.WriteStream || noop)) && isFn(stream.close);
  };
  var isRequest = function(stream) {
    return stream.setHeader && isFn(stream.abort);
  };
  var destroyer = function(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    eos(stream, {readable: reading, writable: writing}, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isFS(stream))
        return stream.close(noop);
      if (isRequest(stream))
        return stream.abort();
      if (isFn(stream.destroy))
        return stream.destroy();
      callback(err || new Error("stream was destroyed"));
    };
  };
  var call = function(fn) {
    fn();
  };
  var pipe = function(from, to) {
    return from.pipe(to);
  };
  var pump = function() {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2)
      throw new Error("pump requires two streams per minimum");
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  };
  module2.exports = pump;
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS((exports2, module2) => {
  "use strict";
  var {PassThrough} = require("stream");
  module2.exports = (options) => {
    options = Object.assign({}, options);
    const {array: array6} = options;
    let {encoding} = options;
    const buffer4 = encoding === "buffer";
    let objectMode = false;
    if (array6) {
      objectMode = !(encoding || buffer4);
    } else {
      encoding = encoding || "utf8";
    }
    if (buffer4) {
      encoding = null;
    }
    let len = 0;
    const ret2 = [];
    const stream = new PassThrough({objectMode});
    if (encoding) {
      stream.setEncoding(encoding);
    }
    stream.on("data", (chunk) => {
      ret2.push(chunk);
      if (objectMode) {
        len = ret2.length;
      } else {
        len += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array6) {
        return ret2;
      }
      return buffer4 ? Buffer.concat(ret2, len) : ret2.join("");
    };
    stream.getBufferedLength = () => len;
    return stream;
  };
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS((exports2, module2) => {
  "use strict";
  var pump = require_pump();
  var bufferStream = require_buffer_stream();
  var MaxBufferError = class extends Error {
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  };
  function getStream(inputStream, options) {
    if (!inputStream) {
      return Promise.reject(new Error("Expected a stream"));
    }
    options = Object.assign({maxBuffer: Infinity}, options);
    const {maxBuffer} = options;
    let stream;
    return new Promise((resolve3, reject) => {
      const rejectPromise = (error) => {
        if (error) {
          error.bufferedData = stream.getBufferedValue();
        }
        reject(error);
      };
      stream = pump(inputStream, bufferStream(options), (error) => {
        if (error) {
          rejectPromise(error);
          return;
        }
        resolve3();
      });
      stream.on("data", () => {
        if (stream.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError());
        }
      });
    }).then(() => stream.getBufferedValue());
  }
  module2.exports = getStream;
  module2.exports.buffer = (stream, options) => getStream(stream, Object.assign({}, options, {encoding: "buffer"}));
  module2.exports.array = (stream, options) => getStream(stream, Object.assign({}, options, {array: true}));
  module2.exports.MaxBufferError = MaxBufferError;
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (promise, onFinally) => {
    onFinally = onFinally || (() => {
    });
    return promise.then((val) => new Promise((resolve3) => {
      resolve3(onFinally());
    }).then(() => val), (err) => new Promise((resolve3) => {
      resolve3(onFinally());
    }).then(() => {
      throw err;
    }));
  };
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS((exports2, module2) => {
  module2.exports = [
    "SIGABRT",
    "SIGALRM",
    "SIGHUP",
    "SIGINT",
    "SIGTERM"
  ];
  if (process.platform !== "win32") {
    module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
  }
  if (process.platform === "linux") {
    module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var signals = require_signals();
  var isWin = /^win/i.test(process.platform);
  var EE = require("events");
  if (typeof EE !== "function") {
    EE = EE.EventEmitter;
  }
  var emitter;
  if (process.__signal_exit_emitter__) {
    emitter = process.__signal_exit_emitter__;
  } else {
    emitter = process.__signal_exit_emitter__ = new EE();
    emitter.count = 0;
    emitter.emitted = {};
  }
  if (!emitter.infinite) {
    emitter.setMaxListeners(Infinity);
    emitter.infinite = true;
  }
  module2.exports = function(cb, opts) {
    assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
    if (loaded === false) {
      load();
    }
    var ev = "exit";
    if (opts && opts.alwaysLast) {
      ev = "afterexit";
    }
    var remove = function() {
      emitter.removeListener(ev, cb);
      if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
        unload();
      }
    };
    emitter.on(ev, cb);
    return remove;
  };
  module2.exports.unload = unload;
  function unload() {
    if (!loaded) {
      return;
    }
    loaded = false;
    signals.forEach(function(sig) {
      try {
        process.removeListener(sig, sigListeners[sig]);
      } catch (er) {
      }
    });
    process.emit = originalProcessEmit;
    process.reallyExit = originalProcessReallyExit;
    emitter.count -= 1;
  }
  function emit(event, code, signal) {
    if (emitter.emitted[event]) {
      return;
    }
    emitter.emitted[event] = true;
    emitter.emit(event, code, signal);
  }
  var sigListeners = {};
  signals.forEach(function(sig) {
    sigListeners[sig] = function listener() {
      var listeners = process.listeners(sig);
      if (listeners.length === emitter.count) {
        unload();
        emit("exit", null, sig);
        emit("afterexit", null, sig);
        if (isWin && sig === "SIGHUP") {
          sig = "SIGINT";
        }
        process.kill(process.pid, sig);
      }
    };
  });
  module2.exports.signals = function() {
    return signals;
  };
  module2.exports.load = load;
  var loaded = false;
  function load() {
    if (loaded) {
      return;
    }
    loaded = true;
    emitter.count += 1;
    signals = signals.filter(function(sig) {
      try {
        process.on(sig, sigListeners[sig]);
        return true;
      } catch (er) {
        return false;
      }
    });
    process.emit = processEmit;
    process.reallyExit = processReallyExit;
  }
  var originalProcessReallyExit = process.reallyExit;
  function processReallyExit(code) {
    process.exitCode = code || 0;
    emit("exit", process.exitCode, null);
    emit("afterexit", process.exitCode, null);
    originalProcessReallyExit.call(process, process.exitCode);
  }
  var originalProcessEmit = process.emit;
  function processEmit(ev, arg) {
    if (ev === "exit") {
      if (arg !== void 0) {
        process.exitCode = arg;
      }
      var ret2 = originalProcessEmit.apply(this, arguments);
      emit("exit", process.exitCode, null);
      emit("afterexit", process.exitCode, null);
      return ret2;
    } else {
      return originalProcessEmit.apply(this, arguments);
    }
  }
});

// node_modules/execa/lib/errname.js
var require_errname = __commonJS((exports2, module2) => {
  "use strict";
  var util54 = require("util");
  var uv;
  if (typeof util54.getSystemErrorName === "function") {
    module2.exports = util54.getSystemErrorName;
  } else {
    try {
      uv = process.binding("uv");
      if (typeof uv.errname !== "function") {
        throw new TypeError("uv.errname is not a function");
      }
    } catch (err) {
      console.error("execa/lib/errname: unable to establish process.binding('uv')", err);
      uv = null;
    }
    module2.exports = (code) => errname(uv, code);
  }
  module2.exports.__test__ = errname;
  function errname(uv2, code) {
    if (uv2) {
      return uv2.errname(code);
    }
    if (!(code < 0)) {
      throw new Error("err >= 0");
    }
    return `Unknown system error ${code}`;
  }
});

// node_modules/execa/lib/stdio.js
var require_stdio = __commonJS((exports2, module2) => {
  "use strict";
  var alias = ["stdin", "stdout", "stderr"];
  var hasAlias = (opts) => alias.some((x) => Boolean(opts[x]));
  module2.exports = (opts) => {
    if (!opts) {
      return null;
    }
    if (opts.stdio && hasAlias(opts)) {
      throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${alias.map((x) => `\`${x}\``).join(", ")}`);
    }
    if (typeof opts.stdio === "string") {
      return opts.stdio;
    }
    const stdio = opts.stdio || [];
    if (!Array.isArray(stdio)) {
      throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    }
    const result = [];
    const len = Math.max(stdio.length, alias.length);
    for (let i = 0; i < len; i++) {
      let value = null;
      if (stdio[i] !== void 0) {
        value = stdio[i];
      } else if (opts[alias[i]] !== void 0) {
        value = opts[alias[i]];
      }
      result[i] = value;
    }
    return result;
  };
});

// node_modules/execa/index.js
var require_execa = __commonJS((exports2, module2) => {
  "use strict";
  var path66 = require("path");
  var childProcess = require("child_process");
  var crossSpawn = require_cross_spawn();
  var stripEof = require_strip_eof();
  var npmRunPath = require_npm_run_path();
  var isStream = require_is_stream();
  var _getStream = require_get_stream();
  var pFinally = require_p_finally();
  var onExit = require_signal_exit();
  var errname = require_errname();
  var stdio = require_stdio();
  var TEN_MEGABYTES = 1e3 * 1e3 * 10;
  function handleArgs(cmd, args, opts) {
    let parsed;
    opts = Object.assign({
      extendEnv: true,
      env: {}
    }, opts);
    if (opts.extendEnv) {
      opts.env = Object.assign({}, process.env, opts.env);
    }
    if (opts.__winShell === true) {
      delete opts.__winShell;
      parsed = {
        command: cmd,
        args,
        options: opts,
        file: cmd,
        original: {
          cmd,
          args
        }
      };
    } else {
      parsed = crossSpawn._parse(cmd, args, opts);
    }
    opts = Object.assign({
      maxBuffer: TEN_MEGABYTES,
      buffer: true,
      stripEof: true,
      preferLocal: true,
      localDir: parsed.options.cwd || process.cwd(),
      encoding: "utf8",
      reject: true,
      cleanup: true
    }, parsed.options);
    opts.stdio = stdio(opts);
    if (opts.preferLocal) {
      opts.env = npmRunPath.env(Object.assign({}, opts, {cwd: opts.localDir}));
    }
    if (opts.detached) {
      opts.cleanup = false;
    }
    if (process.platform === "win32" && path66.basename(parsed.command) === "cmd.exe") {
      parsed.args.unshift("/q");
    }
    return {
      cmd: parsed.command,
      args: parsed.args,
      opts,
      parsed
    };
  }
  function handleInput(spawned, input) {
    if (input === null || input === void 0) {
      return;
    }
    if (isStream(input)) {
      input.pipe(spawned.stdin);
    } else {
      spawned.stdin.end(input);
    }
  }
  function handleOutput(opts, val) {
    if (val && opts.stripEof) {
      val = stripEof(val);
    }
    return val;
  }
  function handleShell(fn, cmd, opts) {
    let file = "/bin/sh";
    let args = ["-c", cmd];
    opts = Object.assign({}, opts);
    if (process.platform === "win32") {
      opts.__winShell = true;
      file = process.env.comspec || "cmd.exe";
      args = ["/s", "/c", `"${cmd}"`];
      opts.windowsVerbatimArguments = true;
    }
    if (opts.shell) {
      file = opts.shell;
      delete opts.shell;
    }
    return fn(file, args, opts);
  }
  function getStream(process2, stream, {encoding, buffer: buffer4, maxBuffer}) {
    if (!process2[stream]) {
      return null;
    }
    let ret2;
    if (!buffer4) {
      ret2 = new Promise((resolve3, reject) => {
        process2[stream].once("end", resolve3).once("error", reject);
      });
    } else if (encoding) {
      ret2 = _getStream(process2[stream], {
        encoding,
        maxBuffer
      });
    } else {
      ret2 = _getStream.buffer(process2[stream], {maxBuffer});
    }
    return ret2.catch((err) => {
      err.stream = stream;
      err.message = `${stream} ${err.message}`;
      throw err;
    });
  }
  function makeError(result, options) {
    const {stdout, stderr} = result;
    let err = result.error;
    const {code, signal} = result;
    const {parsed, joinedCmd} = options;
    const timedOut = options.timedOut || false;
    if (!err) {
      let output = "";
      if (Array.isArray(parsed.opts.stdio)) {
        if (parsed.opts.stdio[2] !== "inherit") {
          output += output.length > 0 ? stderr : `
${stderr}`;
        }
        if (parsed.opts.stdio[1] !== "inherit") {
          output += `
${stdout}`;
        }
      } else if (parsed.opts.stdio !== "inherit") {
        output = `
${stderr}${stdout}`;
      }
      err = new Error(`Command failed: ${joinedCmd}${output}`);
      err.code = code < 0 ? errname(code) : code;
    }
    err.stdout = stdout;
    err.stderr = stderr;
    err.failed = true;
    err.signal = signal || null;
    err.cmd = joinedCmd;
    err.timedOut = timedOut;
    return err;
  }
  function joinCmd(cmd, args) {
    let joinedCmd = cmd;
    if (Array.isArray(args) && args.length > 0) {
      joinedCmd += " " + args.join(" ");
    }
    return joinedCmd;
  }
  module2.exports = (cmd, args, opts) => {
    const parsed = handleArgs(cmd, args, opts);
    const {encoding, buffer: buffer4, maxBuffer} = parsed.opts;
    const joinedCmd = joinCmd(cmd, args);
    let spawned;
    try {
      spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
    } catch (err) {
      return Promise.reject(err);
    }
    let removeExitHandler;
    if (parsed.opts.cleanup) {
      removeExitHandler = onExit(() => {
        spawned.kill();
      });
    }
    let timeoutId = null;
    let timedOut = false;
    const cleanup = () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      if (removeExitHandler) {
        removeExitHandler();
      }
    };
    if (parsed.opts.timeout > 0) {
      timeoutId = setTimeout(() => {
        timeoutId = null;
        timedOut = true;
        spawned.kill(parsed.opts.killSignal);
      }, parsed.opts.timeout);
    }
    const processDone = new Promise((resolve3) => {
      spawned.on("exit", (code, signal) => {
        cleanup();
        resolve3({code, signal});
      });
      spawned.on("error", (err) => {
        cleanup();
        resolve3({error: err});
      });
      if (spawned.stdin) {
        spawned.stdin.on("error", (err) => {
          cleanup();
          resolve3({error: err});
        });
      }
    });
    function destroy() {
      if (spawned.stdout) {
        spawned.stdout.destroy();
      }
      if (spawned.stderr) {
        spawned.stderr.destroy();
      }
    }
    const handlePromise = () => pFinally(Promise.all([
      processDone,
      getStream(spawned, "stdout", {encoding, buffer: buffer4, maxBuffer}),
      getStream(spawned, "stderr", {encoding, buffer: buffer4, maxBuffer})
    ]).then((arr) => {
      const result = arr[0];
      result.stdout = arr[1];
      result.stderr = arr[2];
      if (result.error || result.code !== 0 || result.signal !== null) {
        const err = makeError(result, {
          joinedCmd,
          parsed,
          timedOut
        });
        err.killed = err.killed || spawned.killed;
        if (!parsed.opts.reject) {
          return err;
        }
        throw err;
      }
      return {
        stdout: handleOutput(parsed.opts, result.stdout),
        stderr: handleOutput(parsed.opts, result.stderr),
        code: 0,
        failed: false,
        killed: false,
        signal: null,
        cmd: joinedCmd,
        timedOut: false
      };
    }), destroy);
    crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);
    handleInput(spawned, parsed.opts.input);
    spawned.then = (onfulfilled, onrejected) => handlePromise().then(onfulfilled, onrejected);
    spawned.catch = (onrejected) => handlePromise().catch(onrejected);
    return spawned;
  };
  module2.exports.stdout = (...args) => module2.exports(...args).then((x) => x.stdout);
  module2.exports.stderr = (...args) => module2.exports(...args).then((x) => x.stderr);
  module2.exports.shell = (cmd, opts) => handleShell(module2.exports, cmd, opts);
  module2.exports.sync = (cmd, args, opts) => {
    const parsed = handleArgs(cmd, args, opts);
    const joinedCmd = joinCmd(cmd, args);
    if (isStream(parsed.opts.input)) {
      throw new TypeError("The `input` option cannot be a stream in sync mode");
    }
    const result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);
    result.code = result.status;
    if (result.error || result.status !== 0 || result.signal !== null) {
      const err = makeError(result, {
        joinedCmd,
        parsed
      });
      if (!parsed.opts.reject) {
        return err;
      }
      throw err;
    }
    return {
      stdout: handleOutput(parsed.opts, result.stdout),
      stderr: handleOutput(parsed.opts, result.stderr),
      code: 0,
      failed: false,
      signal: null,
      cmd: joinedCmd,
      timedOut: false
    };
  };
  module2.exports.shellSync = (cmd, opts) => handleShell(module2.exports.sync, cmd, opts);
});

// node_modules/clipboardy/lib/termux.js
var require_termux = __commonJS((exports2, module2) => {
  "use strict";
  var execa = require_execa();
  var handler2 = (error) => {
    if (error.code === "ENOENT") {
      throw new Error("Couldn't find the termux-api scripts. You can install them with: apt install termux-api");
    }
    throw error;
  };
  module2.exports = {
    copy: async (options) => {
      try {
        await execa("termux-clipboard-set", options);
      } catch (error) {
        handler2(error);
      }
    },
    paste: async (options) => {
      try {
        return await execa.stdout("termux-clipboard-get", options);
      } catch (error) {
        handler2(error);
      }
    },
    copySync: (options) => {
      try {
        execa.sync("termux-clipboard-set", options);
      } catch (error) {
        handler2(error);
      }
    },
    pasteSync: (options) => {
      try {
        return execa.sync("termux-clipboard-get", options);
      } catch (error) {
        handler2(error);
      }
    }
  };
});

// node_modules/clipboardy/lib/linux.js
var require_linux = __commonJS((exports2, module2) => {
  "use strict";
  var path66 = require("path");
  var execa = require_execa();
  var xsel = "xsel";
  var xselFallback = path66.join(__dirname, "../fallbacks/linux/xsel");
  var copyArguments = ["--clipboard", "--input"];
  var pasteArguments = ["--clipboard", "--output"];
  var makeError = (xselError, fallbackError) => {
    let error;
    if (xselError.code === "ENOENT") {
      error = new Error("Couldn't find the `xsel` binary and fallback didn't work. On Debian/Ubuntu you can install xsel with: sudo apt install xsel");
    } else {
      error = new Error("Both xsel and fallback failed");
      error.xselError = xselError;
    }
    error.fallbackError = fallbackError;
    return error;
  };
  var xselWithFallback = async (argumentList, options) => {
    try {
      return await execa.stdout(xsel, argumentList, options);
    } catch (xselError) {
      try {
        return await execa.stdout(xselFallback, argumentList, options);
      } catch (fallbackError) {
        throw makeError(xselError, fallbackError);
      }
    }
  };
  var xselWithFallbackSync = (argumentList, options) => {
    try {
      return execa.sync(xsel, argumentList, options);
    } catch (xselError) {
      try {
        return execa.sync(xselFallback, argumentList, options);
      } catch (fallbackError) {
        throw makeError(xselError, fallbackError);
      }
    }
  };
  module2.exports = {
    copy: async (options) => {
      await xselWithFallback(copyArguments, options);
    },
    copySync: (options) => {
      xselWithFallbackSync(copyArguments, options);
    },
    paste: (options) => xselWithFallback(pasteArguments, options),
    pasteSync: (options) => xselWithFallbackSync(pasteArguments, options)
  };
});

// node_modules/clipboardy/lib/macos.js
var require_macos = __commonJS((exports2, module2) => {
  "use strict";
  var execa = require_execa();
  var env2 = {
    ...process.env,
    LC_CTYPE: "UTF-8"
  };
  module2.exports = {
    copy: async (options) => execa("pbcopy", {...options, env: env2}),
    paste: async (options) => execa.stdout("pbpaste", {...options, env: env2}),
    copySync: (options) => execa.sync("pbcopy", {...options, env: env2}),
    pasteSync: (options) => execa.sync("pbpaste", {...options, env: env2})
  };
});

// node_modules/arch/index.js
var require_arch = __commonJS((exports2, module2) => {
  var cp3 = require("child_process");
  var fs55 = require("fs");
  var path66 = require("path");
  module2.exports = function arch() {
    if (process.arch === "x64") {
      return "x64";
    }
    if (process.platform === "darwin") {
      return "x64";
    }
    if (process.platform === "win32") {
      var useEnv = false;
      try {
        useEnv = !!(process.env.SYSTEMROOT && fs55.statSync(process.env.SYSTEMROOT));
      } catch (err) {
      }
      var sysRoot = useEnv ? process.env.SYSTEMROOT : "C:\\Windows";
      var isWOW64 = false;
      try {
        isWOW64 = !!fs55.statSync(path66.join(sysRoot, "sysnative"));
      } catch (err) {
      }
      return isWOW64 ? "x64" : "x86";
    }
    if (process.platform === "linux") {
      var output = cp3.execSync("getconf LONG_BIT", {encoding: "utf8"});
      return output === "64\n" ? "x64" : "x86";
    }
    return "x86";
  };
});

// node_modules/clipboardy/lib/windows.js
var require_windows2 = __commonJS((exports2, module2) => {
  "use strict";
  var path66 = require("path");
  var execa = require_execa();
  var arch = require_arch();
  var windowBinaryPath = arch() === "x64" ? path66.join(__dirname, "../fallbacks/windows/clipboard_x86_64.exe") : path66.join(__dirname, "../fallbacks/windows/clipboard_i686.exe");
  module2.exports = {
    copy: async (options) => execa(windowBinaryPath, ["--copy"], options),
    paste: async (options) => execa.stdout(windowBinaryPath, ["--paste"], options),
    copySync: (options) => execa.sync(windowBinaryPath, ["--copy"], options),
    pasteSync: (options) => execa.sync(windowBinaryPath, ["--paste"], options)
  };
});

// node_modules/clipboardy/index.js
var require_clipboardy = __commonJS((exports2) => {
  "use strict";
  var isWSL = require_is_wsl();
  var termux = require_termux();
  var linux = require_linux();
  var macos = require_macos();
  var windows = require_windows2();
  var platformLib = (() => {
    switch (process.platform) {
      case "darwin":
        return macos;
      case "win32":
        return windows;
      case "android":
        if (process.env.PREFIX !== "/data/data/com.termux/files/usr") {
          throw new Error("You need to install Termux for this module to work on Android: https://termux.com");
        }
        return termux;
      default:
        if (isWSL) {
          return windows;
        }
        return linux;
    }
  })();
  exports2.write = async (text) => {
    if (typeof text !== "string") {
      throw new TypeError(`Expected a string, got ${typeof text}`);
    }
    await platformLib.copy({input: text});
  };
  exports2.read = async () => platformLib.paste({stripEof: false});
  exports2.writeSync = (text) => {
    if (typeof text !== "string") {
      throw new TypeError(`Expected a string, got ${typeof text}`);
    }
    platformLib.copySync({input: text});
  };
  exports2.readSync = () => platformLib.pasteSync({stripEof: false}).stdout;
});

// src/index.ts
var require_src4 = __commonJS((exports2) => {
  __export(exports2, {
    BaseLanguageClient: () => BaseLanguageClient,
    BasicList: () => basic_default,
    Buffer: () => neovim.Buffer,
    CancellationToken: () => vscode_languageserver_protocol84.CancellationToken,
    CancellationTokenSource: () => vscode_languageserver_protocol84.CancellationTokenSource,
    ClientState: () => ClientState,
    CloseAction: () => CloseAction,
    CompletionItemKind: () => vscode_languageserver_protocol84.CompletionItemKind,
    ConfigurationTarget: () => ConfigurationTarget,
    Diagnostic: () => vscode_languageserver_protocol84.Diagnostic,
    DiagnosticSeverity: () => vscode_languageserver_protocol84.DiagnosticSeverity,
    Disposable: () => vscode_languageserver_protocol84.Disposable,
    Document: () => document_default,
    Emitter: () => vscode_languageserver_protocol84.Emitter,
    ErrorAction: () => ErrorAction,
    Event: () => vscode_languageserver_protocol84.Event,
    ExtensionType: () => ExtensionType,
    FileSystemWatcher: () => fileSystemWatcher_default,
    FloatFactory: () => floatFactory_default,
    Highligher: () => highligher_default,
    InsertTextFormat: () => vscode_languageserver_protocol84.InsertTextFormat,
    LanguageClient: () => LanguageClient,
    Location: () => vscode_languageserver_protocol84.Location,
    LocationLink: () => vscode_languageserver_protocol84.LocationLink,
    MessageLevel: () => MessageLevel,
    MessageTransports: () => MessageTransports,
    Mru: () => mru_default,
    Mutex: () => Mutex,
    Neovim: () => neovim.Neovim,
    NotificationType: () => vscode_languageserver_protocol84.NotificationType,
    NotificationType0: () => vscode_languageserver_protocol84.NotificationType0,
    NullLogger: () => NullLogger,
    PatternType: () => PatternType,
    Position: () => vscode_languageserver_protocol84.Position,
    ProgressType: () => vscode_jsonrpc.ProgressType,
    ProposedFeatures: () => ProposedFeatures,
    Range: () => vscode_languageserver_protocol84.Range,
    RequestType: () => vscode_languageserver_protocol84.RequestType,
    RequestType0: () => vscode_languageserver_protocol84.RequestType0,
    RevealOutputChannelOn: () => RevealOutputChannelOn,
    ServiceStat: () => ServiceStat,
    SettingMonitor: () => SettingMonitor,
    SourceType: () => SourceType,
    State: () => State2,
    TextDocumentFeature: () => TextDocumentFeature,
    TextEdit: () => vscode_languageserver_protocol84.TextEdit,
    TransportKind: () => TransportKind,
    Uri: () => URI,
    Watchman: () => watchman_default,
    Window: () => neovim.Window,
    ansiparse: () => ansiparse,
    commands: () => commands_default,
    concurrent: () => concurrent,
    diagnosticManager: () => manager_default,
    disposeAll: () => disposeAll,
    download: () => download,
    events: () => events_default,
    executable: () => executable,
    extensions: () => extensions_default,
    fetch: () => fetch,
    isRunning: () => isRunning,
    languages: () => languages_default,
    listManager: () => manager_default4,
    runCommand: () => runCommand,
    services: () => services_default,
    snippetManager: () => manager_default3,
    sources: () => sources_default,
    wait: () => wait,
    watchFile: () => watchFile,
    window: () => window_default,
    workspace: () => workspace_default
  });
  var neovim = __toModule(require_lib5());
  var vscode_languageserver_protocol84 = __toModule(require_main3());
  var vscode_jsonrpc = __toModule(require_main());
});

// src/source/around.ts
var require_around = __commonJS((exports2) => {
  __export(exports2, {
    default: () => around_default,
    regist: () => regist
  });
  var vscode_languageserver_protocol84 = __toModule(require_main3());
  var logger93 = require_logger2()("source-around");
  var Around = class extends source_default {
    constructor() {
      super({
        name: "around",
        filepath: __filename
      });
    }
    doComplete(opt) {
      let {bufnr, input} = opt;
      if (input.length === 0)
        return null;
      let document3 = workspace_default.getDocument(bufnr);
      if (!document3)
        return null;
      let words = document3.words;
      let moreWords = document3.getMoreWords();
      words.push(...moreWords);
      words = this.filterWords(words, opt);
      return Promise.resolve({
        items: words.map((word) => ({
          word,
          menu: this.menu
        }))
      });
    }
  };
  var around_default = Around;
  function regist(sourceMap) {
    sourceMap.set("around", new Around());
    return vscode_languageserver_protocol84.Disposable.create(() => {
      sourceMap.delete("around");
    });
  }
});

// src/source/buffer.ts
var require_buffer2 = __commonJS((exports2) => {
  __export(exports2, {
    default: () => buffer_default3,
    regist: () => regist
  });
  var vscode_languageserver_protocol84 = __toModule(require_main3());
  var logger93 = require_logger2()("source-buffer");
  var Buffer2 = class extends source_default {
    constructor() {
      super({
        name: "buffer",
        filepath: __filename
      });
    }
    get ignoreGitignore() {
      return this.getConfig("ignoreGitignore", true);
    }
    getWords(bufnr) {
      let {ignoreGitignore} = this;
      let words = [];
      workspace_default.documents.forEach((document3) => {
        if (document3.bufnr == bufnr)
          return;
        if (ignoreGitignore && document3.isIgnored)
          return;
        for (let word of document3.words) {
          if (!words.includes(word)) {
            words.push(word);
          }
        }
      });
      return words;
    }
    doComplete(opt) {
      let {bufnr, input} = opt;
      if (input.length == 0)
        return null;
      let words = this.getWords(bufnr);
      words = this.filterWords(words, opt);
      return Promise.resolve({
        items: words.map((word) => ({
          word,
          menu: this.menu
        }))
      });
    }
  };
  var buffer_default3 = Buffer2;
  function regist(sourceMap) {
    sourceMap.set("buffer", new Buffer2());
    return vscode_languageserver_protocol84.Disposable.create(() => {
      sourceMap.delete("buffer");
    });
  }
});

// src/source/file.ts
var require_file4 = __commonJS((exports2) => {
  __export(exports2, {
    default: () => file_default,
    regist: () => regist
  });
  var fs56 = __toModule(require("fs"));
  var minimatch12 = __toModule(require_minimatch());
  var path67 = __toModule(require("path"));
  var util55 = __toModule(require("util"));
  var vscode_languageserver_protocol84 = __toModule(require_main3());
  var logger93 = require_logger2()("source-file");
  var pathRe = /(?:\.{0,2}|~|\$HOME|([\w]+)|)\/(?:[\w.@()-]+\/)*(?:[\w.@()-])*$/;
  var File = class extends source_default {
    constructor() {
      super({
        name: "file",
        filepath: __filename
      });
    }
    resolveEnvVariables(str) {
      let replaced = str;
      replaced = replaced.replace(/%([^%]+)%/g, (_, n) => process.env[n]);
      replaced = replaced.replace(/\$([A-Z_]+[A-Z0-9_]*)|\${([A-Z0-9_]*)}/gi, (_, a, b) => process.env[a || b]);
      return replaced;
    }
    getPathOption(opt) {
      let {line, colnr} = opt;
      let part = byteSlice(line, 0, colnr - 1);
      part = this.resolveEnvVariables(part);
      if (!part || part.endsWith("//"))
        return null;
      let ms = part.match(pathRe);
      if (ms && ms.length) {
        const pathstr = workspace_default.expand(ms[0]);
        let input = ms[0].match(/[^/]*$/)[0];
        return {pathstr, part: ms[1], startcol: colnr - input.length - 1, input};
      }
      return null;
    }
    async getFileItem(root, filename) {
      let f = path67.default.join(root, filename);
      let stat = await statAsync(f);
      if (stat) {
        let abbr = stat.isDirectory() ? filename + "/" : filename;
        let word = filename;
        return {word, abbr};
      }
      return null;
    }
    filterFiles(files) {
      let ignoreHidden = this.getConfig("ignoreHidden", true);
      let ignorePatterns = this.getConfig("ignorePatterns", []);
      return files.filter((f) => {
        if (f == null)
          return false;
        if (ignoreHidden && f.startsWith("."))
          return false;
        for (let p of ignorePatterns) {
          if (minimatch12.default(f, p, {dot: true}))
            return false;
        }
        return true;
      });
    }
    async getItemsFromRoot(pathstr, root) {
      let res = [];
      let part = pathstr.endsWith("/") ? pathstr : path67.default.dirname(pathstr);
      let dir = path67.default.isAbsolute(pathstr) ? part : path67.default.join(root, part);
      try {
        let stat = await statAsync(dir);
        if (stat && stat.isDirectory()) {
          let files = await util55.default.promisify(fs56.default.readdir)(dir);
          files = this.filterFiles(files);
          let items = await Promise.all(files.map((filename) => this.getFileItem(dir, filename)));
          res = res.concat(items);
        }
        res = res.filter((item) => item != null);
        return res;
      } catch (e) {
        logger93.error(`Error on list files:`, e);
        return res;
      }
    }
    get trimSameExts() {
      return this.getConfig("trimSameExts", []);
    }
    async doComplete(opt) {
      let {col, filepath} = opt;
      let option = this.getPathOption(opt);
      if (!option)
        return null;
      let {pathstr, part, startcol, input} = option;
      if (startcol < opt.col)
        return null;
      let startPart = opt.col == startcol ? "" : byteSlice(opt.line, opt.col, startcol);
      let dirname4 = path67.default.dirname(filepath);
      let ext = path67.default.extname(path67.default.basename(filepath));
      let cwd = await this.nvim.call("getcwd", []);
      let root;
      if (pathstr.startsWith(".")) {
        root = filepath ? path67.default.dirname(filepath) : cwd;
      } else if (pathstr.startsWith("/")) {
        root = pathstr.endsWith("/") ? pathstr : path67.default.dirname(pathstr);
      } else if (part) {
        if (fs56.default.existsSync(path67.default.join(dirname4, part))) {
          root = dirname4;
        } else if (fs56.default.existsSync(path67.default.join(cwd, part))) {
          root = cwd;
        }
      } else {
        root = cwd;
      }
      if (!root)
        return null;
      let items = await this.getItemsFromRoot(pathstr, root);
      let trimExt = this.trimSameExts.includes(ext);
      let first = input[0];
      if (first && col == startcol)
        items = items.filter((o) => o.word[0] === first);
      return {
        items: items.map((item) => {
          let ex = path67.default.extname(item.word);
          item.word = trimExt && ex === ext ? item.word.replace(ext, "") : item.word;
          return {
            word: `${startPart}${item.word}`,
            abbr: `${startPart}${item.abbr}`,
            menu: this.menu
          };
        })
      };
    }
  };
  var file_default = File;
  function regist(sourceMap) {
    sourceMap.set("file", new File());
    return vscode_languageserver_protocol84.Disposable.create(() => {
      sourceMap.delete("file");
    });
  }
});

// src/attach.ts
var require_attach2 = __commonJS((exports2) => {
  __export(exports2, {
    default: () => attach_default
  });
  var neovim = __toModule(require_lib5());
  var log4js2 = __toModule(require_log4js());
  var semver10 = __toModule(require_semver2());
  var logger93 = require_logger2()("attach");
  var isTest = global.hasOwnProperty("__TEST__");
  var attach_default = (opts, requestApi = true) => {
    const nvim = neovim.attach(opts, log4js2.default.getLogger("node-client"), requestApi);
    if (!global.hasOwnProperty("__TEST__")) {
      nvim.call("coc#util#path_replace_patterns").then((prefixes) => {
        if (objectLiteral(prefixes)) {
          const old_uri = URI.file;
          URI.file = (path66) => {
            path66 = path66.replace(/\\/g, "/");
            Object.keys(prefixes).forEach((k) => path66 = path66.replace(new RegExp("^" + k), prefixes[k]));
            return old_uri(path66);
          };
        }
      }).logError();
    }
    nvim.setVar("coc_process_pid", process.pid, true);
    const plugin2 = new plugin_default(nvim);
    let clientReady = false;
    let initialized = false;
    nvim.on("notification", async (method, args) => {
      switch (method) {
        case "VimEnter": {
          if (!initialized && clientReady) {
            initialized = true;
            await plugin2.init();
          }
          break;
        }
        case "TaskExit":
        case "TaskStderr":
        case "TaskStdout":
        case "GlobalChange":
        case "PromptInsert":
        case "InputChar":
        case "MenuInput":
        case "OptionSet":
        case "FloatBtnClick":
          await events_default.fire(method, args);
          break;
        case "CocAutocmd":
          logger93.debug("Notification autocmd:", ...args);
          await events_default.fire(args[0], args.slice(1));
          break;
        default: {
          let exists = plugin2.hasAction(method);
          if (!exists) {
            if (global.hasOwnProperty("__TEST__"))
              return;
            console.error(`action "${method}" not registered`);
            return;
          }
          try {
            if (!plugin2.isReady) {
              logger93.warn(`Plugin not ready when received "${method}"`, args);
            } else {
              logger93.info("receive notification:", method, args);
            }
            await plugin2.ready;
            await plugin2.cocAction(method, ...args);
          } catch (e) {
            console.error(`Error on notification "${method}": ${e.message || e.toString()}`);
            logger93.error(`Notification error:`, method, args, e);
          }
        }
      }
    });
    nvim.on("request", async (method, args, resp) => {
      if (method != "redraw") {
        logger93.info("receive request:", method, args);
      }
      let timer = setTimeout(() => {
        logger93.error("Request cost more than 3s", method, args);
      }, 3e3);
      try {
        if (method == "CocAutocmd") {
          logger93.debug("Request autocmd:", ...args);
          await events_default.fire(args[0], args.slice(1));
          resp.send();
        } else {
          if (!plugin2.isReady) {
            logger93.warn(`Plugin not ready when received "${method}"`, args);
          }
          let res = await plugin2.cocAction(method, ...args);
          resp.send(res);
        }
        clearTimeout(timer);
      } catch (e) {
        clearTimeout(timer);
        resp.send(e.message || e.toString(), true);
        logger93.error(`Request error:`, method, args, e);
      }
    });
    nvim.channelId.then(async (channelId) => {
      clientReady = true;
      if (isTest)
        nvim.command(`let g:coc_node_channel_id = ${channelId}`, true);
      let json = require_package2();
      let {major, minor, patch} = semver10.default.parse(json.version);
      nvim.setClientInfo("coc", {major, minor, patch}, "remote", {}, {});
      let entered = await nvim.getVvar("vim_did_enter");
      if (entered && !initialized) {
        initialized = true;
        await plugin2.init();
      }
    }).catch((e) => {
      console.error(`Channel create error: ${e.message}`);
    });
    return plugin2;
  };
});

// src/main.ts
var semver7 = __toModule(require_semver2());
var promiseFinally = require_promise_prototype();
var version = process.version.replace("v", "");
if (!semver7.default.gte(version, "8.10.0")) {
  console.error("node version " + version + ' < 8.10.0, please upgrade nodejs, or use `let g:coc_node_path = "/path/to/node"` in your vimrc');
  process.exit();
}
if (!semver7.default.gte(version, "10.12.0")) {
  if (process.env.COC_NO_WARNINGS != "1") {
    console.error("node version " + version + " < 10.12.0, upgrade nodejs or use `let g:coc_disable_startup_warning = 1` to disable this warning.");
  }
}
Object.defineProperty(console, "log", {
  value() {
    logger92.info(...arguments);
  }
});
promiseFinally.shim();
var logger92 = require_logger2()("server");

// src/events.ts
var vscode_languageserver_protocol2 = __toModule(require_main3());

// src/util/index.ts
var child_process = __toModule(require("child_process"));
var debounce = __toModule(require_debounce());
var fs = __toModule(require("fs"));
var isuri = __toModule(require_isuri());
var path = __toModule(require("path"));
var vscode_languageserver_protocol = __toModule(require_main3());

// node_modules/vscode-uri/lib/esm/index.js
"use strict";
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _a;
var isWindows;
if (typeof process === "object") {
  isWindows = process.platform === "win32";
} else if (typeof navigator === "object") {
  userAgent = navigator.userAgent;
  isWindows = userAgent.indexOf("Windows") >= 0;
}
var userAgent;
var _schemePattern = /^\w[\w\d+.-]*$/;
var _singleSlashStart = /^\//;
var _doubleSlashStart = /^\/\//;
function _validateUri(ret2, _strict) {
  if (!ret2.scheme && _strict) {
    throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "' + ret2.authority + '", path: "' + ret2.path + '", query: "' + ret2.query + '", fragment: "' + ret2.fragment + '"}');
  }
  if (ret2.scheme && !_schemePattern.test(ret2.scheme)) {
    throw new Error("[UriError]: Scheme contains illegal characters.");
  }
  if (ret2.path) {
    if (ret2.authority) {
      if (!_singleSlashStart.test(ret2.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret2.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
}
function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return "file";
  }
  return scheme;
}
function _referenceResolution(scheme, path66) {
  switch (scheme) {
    case "https":
    case "http":
    case "file":
      if (!path66) {
        path66 = _slash;
      } else if (path66[0] !== _slash) {
        path66 = _slash + path66;
      }
      break;
  }
  return path66;
}
var _empty = "";
var _slash = "/";
var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
var URI = function() {
  function URI2(schemeOrData, authority, path66, query, fragment, _strict) {
    if (_strict === void 0) {
      _strict = false;
    }
    if (typeof schemeOrData === "object") {
      this.scheme = schemeOrData.scheme || _empty;
      this.authority = schemeOrData.authority || _empty;
      this.path = schemeOrData.path || _empty;
      this.query = schemeOrData.query || _empty;
      this.fragment = schemeOrData.fragment || _empty;
    } else {
      this.scheme = _schemeFix(schemeOrData, _strict);
      this.authority = authority || _empty;
      this.path = _referenceResolution(this.scheme, path66 || _empty);
      this.query = query || _empty;
      this.fragment = fragment || _empty;
      _validateUri(this, _strict);
    }
  }
  URI2.isUri = function(thing) {
    if (thing instanceof URI2) {
      return true;
    }
    if (!thing) {
      return false;
    }
    return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "function" && typeof thing.with === "function" && typeof thing.toString === "function";
  };
  Object.defineProperty(URI2.prototype, "fsPath", {
    get: function() {
      return uriToFsPath(this, false);
    },
    enumerable: true,
    configurable: true
  });
  URI2.prototype.with = function(change) {
    if (!change) {
      return this;
    }
    var scheme = change.scheme, authority = change.authority, path66 = change.path, query = change.query, fragment = change.fragment;
    if (scheme === void 0) {
      scheme = this.scheme;
    } else if (scheme === null) {
      scheme = _empty;
    }
    if (authority === void 0) {
      authority = this.authority;
    } else if (authority === null) {
      authority = _empty;
    }
    if (path66 === void 0) {
      path66 = this.path;
    } else if (path66 === null) {
      path66 = _empty;
    }
    if (query === void 0) {
      query = this.query;
    } else if (query === null) {
      query = _empty;
    }
    if (fragment === void 0) {
      fragment = this.fragment;
    } else if (fragment === null) {
      fragment = _empty;
    }
    if (scheme === this.scheme && authority === this.authority && path66 === this.path && query === this.query && fragment === this.fragment) {
      return this;
    }
    return new _URI(scheme, authority, path66, query, fragment);
  };
  URI2.parse = function(value, _strict) {
    if (_strict === void 0) {
      _strict = false;
    }
    var match3 = _regexp.exec(value);
    if (!match3) {
      return new _URI(_empty, _empty, _empty, _empty, _empty);
    }
    return new _URI(match3[2] || _empty, percentDecode(match3[4] || _empty), percentDecode(match3[5] || _empty), percentDecode(match3[7] || _empty), percentDecode(match3[9] || _empty), _strict);
  };
  URI2.file = function(path66) {
    var authority = _empty;
    if (isWindows) {
      path66 = path66.replace(/\\/g, _slash);
    }
    if (path66[0] === _slash && path66[1] === _slash) {
      var idx = path66.indexOf(_slash, 2);
      if (idx === -1) {
        authority = path66.substring(2);
        path66 = _slash;
      } else {
        authority = path66.substring(2, idx);
        path66 = path66.substring(idx) || _slash;
      }
    }
    return new _URI("file", authority, path66, _empty, _empty);
  };
  URI2.from = function(components) {
    return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
  };
  URI2.prototype.toString = function(skipEncoding) {
    if (skipEncoding === void 0) {
      skipEncoding = false;
    }
    return _asFormatted(this, skipEncoding);
  };
  URI2.prototype.toJSON = function() {
    return this;
  };
  URI2.revive = function(data) {
    if (!data) {
      return data;
    } else if (data instanceof URI2) {
      return data;
    } else {
      var result = new _URI(data);
      result._formatted = data.external;
      result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
      return result;
    }
  };
  return URI2;
}();
var _pathSepMarker = isWindows ? 1 : void 0;
var _URI = function(_super) {
  __extends(_URI2, _super);
  function _URI2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._formatted = null;
    _this._fsPath = null;
    return _this;
  }
  Object.defineProperty(_URI2.prototype, "fsPath", {
    get: function() {
      if (!this._fsPath) {
        this._fsPath = uriToFsPath(this, false);
      }
      return this._fsPath;
    },
    enumerable: true,
    configurable: true
  });
  _URI2.prototype.toString = function(skipEncoding) {
    if (skipEncoding === void 0) {
      skipEncoding = false;
    }
    if (!skipEncoding) {
      if (!this._formatted) {
        this._formatted = _asFormatted(this, false);
      }
      return this._formatted;
    } else {
      return _asFormatted(this, true);
    }
  };
  _URI2.prototype.toJSON = function() {
    var res = {
      $mid: 1
    };
    if (this._fsPath) {
      res.fsPath = this._fsPath;
      res._sep = _pathSepMarker;
    }
    if (this._formatted) {
      res.external = this._formatted;
    }
    if (this.path) {
      res.path = this.path;
    }
    if (this.scheme) {
      res.scheme = this.scheme;
    }
    if (this.authority) {
      res.authority = this.authority;
    }
    if (this.query) {
      res.query = this.query;
    }
    if (this.fragment) {
      res.fragment = this.fragment;
    }
    return res;
  };
  return _URI2;
}(URI);
var encodeTable = (_a = {}, _a[58] = "%3A", _a[47] = "%2F", _a[63] = "%3F", _a[35] = "%23", _a[91] = "%5B", _a[93] = "%5D", _a[64] = "%40", _a[33] = "%21", _a[36] = "%24", _a[38] = "%26", _a[39] = "%27", _a[40] = "%28", _a[41] = "%29", _a[42] = "%2A", _a[43] = "%2B", _a[44] = "%2C", _a[59] = "%3B", _a[61] = "%3D", _a[32] = "%20", _a);
function encodeURIComponentFast(uriComponent, allowSlash) {
  var res = void 0;
  var nativeEncodePos = -1;
  for (var pos = 0; pos < uriComponent.length; pos++) {
    var code = uriComponent.charCodeAt(pos);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || allowSlash && code === 47) {
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      }
      if (res !== void 0) {
        res += uriComponent.charAt(pos);
      }
    } else {
      if (res === void 0) {
        res = uriComponent.substr(0, pos);
      }
      var escaped = encodeTable[code];
      if (escaped !== void 0) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        res += escaped;
      } else if (nativeEncodePos === -1) {
        nativeEncodePos = pos;
      }
    }
  }
  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }
  return res !== void 0 ? res : uriComponent;
}
function encodeURIComponentMinimal(path66) {
  var res = void 0;
  for (var pos = 0; pos < path66.length; pos++) {
    var code = path66.charCodeAt(pos);
    if (code === 35 || code === 63) {
      if (res === void 0) {
        res = path66.substr(0, pos);
      }
      res += encodeTable[code];
    } else {
      if (res !== void 0) {
        res += path66[pos];
      }
    }
  }
  return res !== void 0 ? res : path66;
}
function uriToFsPath(uri, keepDriveLetterCasing) {
  var value;
  if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
    value = "//" + uri.authority + uri.path;
  } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
    if (!keepDriveLetterCasing) {
      value = uri.path[1].toLowerCase() + uri.path.substr(2);
    } else {
      value = uri.path.substr(1);
    }
  } else {
    value = uri.path;
  }
  if (isWindows) {
    value = value.replace(/\//g, "\\");
  }
  return value;
}
function _asFormatted(uri, skipEncoding) {
  var encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  var res = "";
  var scheme = uri.scheme, authority = uri.authority, path66 = uri.path, query = uri.query, fragment = uri.fragment;
  if (scheme) {
    res += scheme;
    res += ":";
  }
  if (authority || scheme === "file") {
    res += _slash;
    res += _slash;
  }
  if (authority) {
    var idx = authority.indexOf("@");
    if (idx !== -1) {
      var userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.indexOf(":");
      if (idx === -1) {
        res += encoder(userinfo, false);
      } else {
        res += encoder(userinfo.substr(0, idx), false);
        res += ":";
        res += encoder(userinfo.substr(idx + 1), false);
      }
      res += "@";
    }
    authority = authority.toLowerCase();
    idx = authority.indexOf(":");
    if (idx === -1) {
      res += encoder(authority, false);
    } else {
      res += encoder(authority.substr(0, idx), false);
      res += authority.substr(idx);
    }
  }
  if (path66) {
    if (path66.length >= 3 && path66.charCodeAt(0) === 47 && path66.charCodeAt(2) === 58) {
      var code = path66.charCodeAt(1);
      if (code >= 65 && code <= 90) {
        path66 = "/" + String.fromCharCode(code + 32) + ":" + path66.substr(3);
      }
    } else if (path66.length >= 2 && path66.charCodeAt(1) === 58) {
      var code = path66.charCodeAt(0);
      if (code >= 65 && code <= 90) {
        path66 = String.fromCharCode(code + 32) + ":" + path66.substr(2);
      }
    }
    res += encoder(path66, true);
  }
  if (query) {
    res += "?";
    res += encoder(query, false);
  }
  if (fragment) {
    res += "#";
    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
  }
  return res;
}
function decodeURIComponentGraceful(str) {
  try {
    return decodeURIComponent(str);
  } catch (_a2) {
    if (str.length > 3) {
      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
    } else {
      return str;
    }
  }
}
var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
  if (!str.match(_rEncodedAsHex)) {
    return str;
  }
  return str.replace(_rEncodedAsHex, function(match3) {
    return decodeURIComponentGraceful(match3);
  });
}

// src/util/index.ts
var which = __toModule(require_which());

// src/util/platform.ts
var platform_exports = {};
__export(platform_exports, {
  OS: () => OS,
  OperatingSystem: () => OperatingSystem,
  Platform: () => Platform,
  globals: () => globals,
  isLinux: () => isLinux,
  isMacintosh: () => isMacintosh,
  isNative: () => isNative,
  isWeb: () => isWeb,
  isWindows: () => isWindows2,
  language: () => language,
  platform: () => platform
});
var _isWindows = false;
var _isMacintosh = false;
var _isLinux = false;
var _isNative = false;
var _isWeb = false;
var language = "en";
if (typeof process === "object" && typeof process.nextTick === "function" && typeof process.platform === "string") {
  _isWindows = process.platform === "win32";
  _isMacintosh = process.platform === "darwin";
  _isLinux = process.platform === "linux";
  _isNative = true;
}
var Platform;
(function(Platform2) {
  Platform2[Platform2["Web"] = 0] = "Web";
  Platform2[Platform2["Mac"] = 1] = "Mac";
  Platform2[Platform2["Linux"] = 2] = "Linux";
  Platform2[Platform2["Windows"] = 3] = "Windows";
})(Platform || (Platform = {}));
var _platform = 0;
if (_isNative) {
  if (_isMacintosh) {
    _platform = 1;
  } else if (_isWindows) {
    _platform = 3;
  } else if (_isLinux) {
    _platform = 2;
  }
}
var isWindows2 = _isWindows;
var isMacintosh = _isMacintosh;
var isLinux = _isLinux;
var isNative = _isNative;
var isWeb = _isWeb;
var platform = _platform;
var _globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
var globals = _globals;
var OperatingSystem;
(function(OperatingSystem2) {
  OperatingSystem2[OperatingSystem2["Windows"] = 1] = "Windows";
  OperatingSystem2[OperatingSystem2["Macintosh"] = 2] = "Macintosh";
  OperatingSystem2[OperatingSystem2["Linux"] = 3] = "Linux";
})(OperatingSystem || (OperatingSystem = {}));
var OS = _isMacintosh ? 2 : _isWindows ? 1 : 3;

// src/util/index.ts
var logger = require_logger2()("util-index");
var CONFIG_FILE_NAME = "coc-settings.json";
function wait(ms) {
  return new Promise((resolve3) => {
    setTimeout(() => {
      resolve3(void 0);
    }, ms);
  });
}
function getUri(fullpath, id, buftype, isCygwin) {
  if (!fullpath)
    return `untitled:${id}`;
  if (isWindows2 && !isCygwin && !fullpath.startsWith("jdt://"))
    fullpath = path.default.win32.normalize(fullpath);
  if (path.default.isAbsolute(fullpath))
    return URI.file(fullpath).toString();
  if (isuri.default.isValid(fullpath))
    return URI.parse(fullpath).toString();
  if (buftype != "")
    return `${buftype}:${id}`;
  return `unknown:${id}`;
}
function disposeAll(disposables) {
  while (disposables.length) {
    const item = disposables.pop();
    if (item) {
      item.dispose();
    }
  }
}
function executable(command) {
  try {
    which.default.sync(command);
  } catch (e) {
    return false;
  }
  return true;
}
function runCommand(cmd, opts = {}, timeout) {
  if (!isWindows2) {
    opts.shell = opts.shell || process.env.SHELL;
  }
  opts.maxBuffer = 500 * 1024;
  return new Promise((resolve3, reject) => {
    let timer;
    if (timeout) {
      timer = setTimeout(() => {
        reject(new Error(`timeout after ${timeout}s`));
      }, timeout * 1e3);
    }
    child_process.exec(cmd, opts, (err, stdout, stderr) => {
      if (timer)
        clearTimeout(timer);
      if (err) {
        reject(new Error(`exited with ${err.code}
${err}
${stderr}`));
        return;
      }
      resolve3(stdout);
    });
  });
}
function watchFile(filepath, onChange) {
  let callback = debounce.default(onChange, 100);
  try {
    let watcher = fs.default.watch(filepath, {
      persistent: true,
      recursive: false,
      encoding: "utf8"
    }, () => {
      callback();
    });
    return vscode_languageserver_protocol.Disposable.create(() => {
      callback.clear();
      watcher.close();
    });
  } catch (e) {
    return vscode_languageserver_protocol.Disposable.create(() => {
      callback.clear();
    });
  }
}
function isRunning(pid) {
  try {
    let res = process.kill(pid, 0);
    return res == true;
  } catch (e) {
    return e.code === "EPERM";
  }
}
function getKeymapModifier(mode) {
  if (mode == "n" || mode == "o" || mode == "x" || mode == "v")
    return "<C-U>";
  if (mode == "i")
    return "<C-o>";
  if (mode == "s")
    return "<Esc>";
  return "";
}
function concurrent(arr, fn, limit = 3) {
  if (arr.length == 0)
    return Promise.resolve();
  let finished = 0;
  let total = arr.length;
  let remain = arr.slice();
  return new Promise((resolve3) => {
    let run = (val) => {
      let cb = () => {
        finished = finished + 1;
        if (finished == total) {
          resolve3();
        } else if (remain.length) {
          let next = remain.shift();
          run(next);
        }
      };
      fn(val).then(cb, cb);
    };
    for (let i = 0; i < Math.min(limit, remain.length); i++) {
      let val = remain.shift();
      run(val);
    }
  });
}

// src/util/is.ts
var hasOwnProperty = Object.prototype.hasOwnProperty;
function boolean(value) {
  return typeof value === "boolean";
}
function string(value) {
  return typeof value === "string";
}
function number(value) {
  return typeof value === "number";
}
function func(value) {
  return typeof value == "function";
}
function objectLiteral(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
function emptyObject(obj) {
  if (!objectLiteral(obj)) {
    return false;
  }
  for (let key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}

// src/util/object.ts
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.keys(obj).forEach((key) => {
    if (obj[key] && typeof obj[key] === "object") {
      result[key] = deepClone(obj[key]);
    } else {
      result[key] = obj[key];
    }
  });
  return result;
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    let obj2 = stack.shift();
    Object.freeze(obj2);
    for (const key in obj2) {
      if (_hasOwnProperty.call(obj2, key)) {
        let prop = obj2[key];
        if (typeof prop === "object" && !Object.isFrozen(prop)) {
          stack.push(prop);
        }
      }
    }
  }
  return obj;
}
function mixin(destination, source3, overwrite = true) {
  if (!objectLiteral(destination)) {
    return source3;
  }
  if (objectLiteral(source3)) {
    Object.keys(source3).forEach((key) => {
      if (key in destination) {
        if (overwrite) {
          if (objectLiteral(destination[key]) && objectLiteral(source3[key])) {
            mixin(destination[key], source3[key], overwrite);
          } else {
            destination[key] = source3[key];
          }
        }
      } else {
        destination[key] = source3[key];
      }
    });
  }
  return destination;
}
function equals(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}

// src/events.ts
var logger2 = require_logger2()("events");
var Events = class {
  constructor() {
    this.handlers = new Map();
    this.insertMode = false;
  }
  get cursor() {
    return this._cursor;
  }
  async fire(event, args) {
    let cbs = this.handlers.get(event);
    if (event == "InsertEnter") {
      this.insertMode = true;
    } else if (event == "InsertLeave") {
      this.insertMode = false;
    } else if (!this.insertMode && (event == "CursorHoldI" || event == "CursorMovedI")) {
      this.insertMode = true;
      await this.fire("InsertEnter", [args[0]]);
    } else if (this.insertMode && (event == "CursorHold" || event == "CursorMoved")) {
      this.insertMode = false;
      await this.fire("InsertLeave", [args[0]]);
    }
    if (event == "CursorMoved" || event == "CursorMovedI") {
      let cursor = {
        bufnr: args[0],
        lnum: args[1][0],
        col: args[1][1],
        insert: event == "CursorMovedI"
      };
      if (this._cursor && equals(this._cursor, cursor))
        return;
      this._cursor = cursor;
    }
    if (cbs) {
      try {
        await Promise.all(cbs.map((fn) => fn(args)));
      } catch (e) {
        if (e.message && e.message.indexOf("transport disconnected") == -1) {
          console.error(`Error on ${event}: ${e.message}${e.stack ? "\n" + e.stack : ""} `);
        }
        logger2.error(`Handler Error on ${event}`, e.stack);
      }
    }
  }
  on(event, handler2, thisArg, disposables) {
    if (Array.isArray(event)) {
      let arr = disposables || [];
      for (let ev of event) {
        this.on(ev, handler2, thisArg, arr);
      }
      return vscode_languageserver_protocol2.Disposable.create(() => {
        disposeAll(arr);
      });
    } else {
      let arr = this.handlers.get(event) || [];
      let stack = Error().stack;
      let wrappedhandler = (args) => new Promise((resolve3, reject) => {
        let timer;
        try {
          Promise.resolve(handler2.apply(thisArg || null, args)).then(() => {
            if (timer)
              clearTimeout(timer);
            resolve3(void 0);
          }, (e) => {
            if (timer)
              clearTimeout(timer);
            reject(e);
          });
          timer = setTimeout(() => {
            logger2.warn(`Handler of ${event} blocked more than 2s:`, stack);
          }, 2e3);
        } catch (e) {
          reject(e);
        }
      });
      arr.push(wrappedhandler);
      this.handlers.set(event, arr);
      let disposable = vscode_languageserver_protocol2.Disposable.create(() => {
        let idx = arr.indexOf(wrappedhandler);
        if (idx !== -1) {
          arr.splice(idx, 1);
        }
      });
      if (disposables) {
        disposables.push(disposable);
      }
      return disposable;
    }
  }
};
var events_default = new Events();

// src/plugin.ts
var events34 = __toModule(require("events"));
var path64 = __toModule(require("path"));
var fs53 = __toModule(require("fs"));
var vscode_languageserver_protocol83 = __toModule(require_main3());

// src/commands.ts
var vscode_languageserver_protocol69 = __toModule(require_main3());

// src/diagnostic/manager.ts
var debounce9 = __toModule(require_debounce());
var semver = __toModule(require_semver2());
var vscode_languageserver_protocol18 = __toModule(require_main3());

// src/model/floatFactory.ts
var debounce3 = __toModule(require_debounce());
var vscode_languageserver_protocol3 = __toModule(require_main3());

// src/markdown/index.ts
var marked = __toModule(require_marked());

// src/markdown/renderer.ts
var cli_table = __toModule(require_lib6());

// src/markdown/styles.ts
var ansi_styles = __toModule(require_ansi_styles2());
function gray(str) {
  return `${ansi_styles.default.gray.open}${str}${ansi_styles.default.gray.close}`;
}
function magenta(str) {
  return `${ansi_styles.default.magenta.open}${str}${ansi_styles.default.magenta.close}`;
}
function bold(str) {
  return `${ansi_styles.default.bold.open}${str}${ansi_styles.default.bold.close}`;
}
function underline(str) {
  return `${ansi_styles.default.underline.open}${str}${ansi_styles.default.underline.close}`;
}
function italic(str) {
  return `${ansi_styles.default.italic.open}${str}${ansi_styles.default.italic.close}`;
}
function yellow(str) {
  return `${ansi_styles.default.yellow.open}${str}${ansi_styles.default.yellow.close}`;
}
function blue(str) {
  return `${ansi_styles.default.blue.open}${str}${ansi_styles.default.blue.close}`;
}

// src/markdown/renderer.ts
var logger3 = require_logger2()("markdown-renderer");
var TABLE_CELL_SPLIT = "^*||*^";
var TABLE_ROW_WRAP = "*|*|*|*";
var TABLE_ROW_WRAP_REGEXP = new RegExp(escapeRegExp(TABLE_ROW_WRAP), "g");
var COLON_REPLACER = "*#COLON|*";
var COLON_REPLACER_REGEXP = new RegExp(escapeRegExp(COLON_REPLACER), "g");
var TAB_ALLOWED_CHARACTERS = ["	"];
var HARD_RETURN = "\r";
var defaultOptions = {
  code: identity,
  blockquote: identity,
  html: gray,
  heading: magenta,
  firstHeading: magenta,
  hr: identity,
  listitem: identity,
  list,
  table: identity,
  paragraph: identity,
  strong: bold,
  em: italic,
  codespan: yellow,
  del: underline,
  link: underline,
  href: underline,
  text: identity,
  unescape: true,
  emoji: false,
  width: 80,
  showSectionPrefix: true,
  tab: 2,
  tableOptions: {}
};
function fixHardReturn(text, reflow) {
  return reflow ? text.replace(HARD_RETURN, /\n/g) : text;
}
function sanitizeTab(tab, fallbackTab) {
  if (typeof tab === "number") {
    return new Array(tab + 1).join(" ");
  } else if (typeof tab === "string" && isAllowedTabString(tab)) {
    return tab;
  } else {
    return new Array(fallbackTab + 1).join(" ");
  }
}
function isAllowedTabString(str) {
  return TAB_ALLOWED_CHARACTERS.some(function(char) {
    return str.match("^(" + char + ")+$");
  });
}
function indentLines(indent, text) {
  return text.replace(/(^|\n)(.+)/g, "$1" + indent + "$2");
}
function indentify(indent, text) {
  if (!text)
    return text;
  return indent + text.split("\n").join("\n" + indent);
}
var BULLET_POINT_REGEX = "\\*";
var NUMBERED_POINT_REGEX = "\\d+\\.";
var POINT_REGEX = "(?:" + [BULLET_POINT_REGEX, NUMBERED_POINT_REGEX].join("|") + ")";
function fixNestedLists(body, indent) {
  let regex = new RegExp("(\\S(?: |  )?)((?:" + indent + ")+)(" + POINT_REGEX + "(?:.*)+)$", "gm");
  return body.replace(regex, "$1\n" + indent + "$2$3");
}
var isPointedLine = function(line, indent) {
  return line.match("^(?:" + indent + ")*" + POINT_REGEX);
};
function toSpaces(str) {
  return " ".repeat(str.length);
}
var BULLET_POINT = "* ";
function bulletPointLine(indent, line) {
  return isPointedLine(line, indent) ? line : toSpaces(BULLET_POINT) + line;
}
function bulletPointLines(lines, indent) {
  let transform = bulletPointLine.bind(null, indent);
  return lines.split("\n").filter(identity).map(transform).join("\n");
}
var numberedPoint = function(n) {
  return n + ". ";
};
function numberedLine(indent, line, num) {
  return isPointedLine(line, indent) ? {
    num: num + 1,
    line: line.replace(BULLET_POINT, numberedPoint(num + 1))
  } : {
    num,
    line: toSpaces(numberedPoint(num)) + line
  };
}
function numberedLines(lines, indent) {
  let transform = numberedLine.bind(null, indent);
  let num = 0;
  return lines.split("\n").filter(identity).map((line) => {
    const numbered = transform(line, num);
    num = numbered.num;
    return numbered.line;
  }).join("\n");
}
function list(body, ordered, indent) {
  body = body.trim();
  body = ordered ? numberedLines(body, indent) : bulletPointLines(body, indent);
  return body;
}
function section(text) {
  return text + "\n\n";
}
function undoColon(str) {
  return str.replace(COLON_REPLACER_REGEXP, ":");
}
function generateTableRow(text, escape = null) {
  if (!text)
    return [];
  escape = escape || identity;
  let lines = escape(text).split("\n");
  let data = [];
  lines.forEach(function(line) {
    if (!line)
      return;
    let parsed = line.replace(TABLE_ROW_WRAP_REGEXP, "").split(TABLE_CELL_SPLIT);
    data.push(parsed.splice(0, parsed.length - 1));
  });
  return data;
}
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function unescapeEntities(html) {
  return html.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
}
function identity(str) {
  return str;
}
var links = new Map();
var Renderer = class {
  constructor(options = {}, highlightOptions = {}) {
    this.options = options;
    this.highlightOptions = highlightOptions;
    this.o = Object.assign({}, defaultOptions, options);
    this.tab = sanitizeTab(this.o.tab, defaultOptions.tab);
    this.tableSettings = this.o.tableOptions;
    this.unescape = this.o.unescape ? unescapeEntities : identity;
    this.highlightOptions = highlightOptions || {};
    this.transform = this.compose(undoColon, this.unescape);
  }
  textLength(str) {
    return str.replace(/\u001b\[(?:\d{1,3})(?:;\d{1,3})*m/g, "").length;
  }
  text(t) {
    return this.o.text(t);
  }
  code(code, lang, _escaped) {
    return "``` " + lang + "\n" + code + "\n```\n";
  }
  blockquote(quote) {
    return section(this.o.blockquote(indentify(this.tab, quote.trim())));
  }
  html(html) {
    return this.o.html(html);
  }
  heading(text, level, _raw) {
    text = this.transform(text);
    let prefix = this.o.showSectionPrefix ? new Array(level + 1).join("#") + " " : "";
    text = prefix + text;
    return section(level === 1 ? this.o.firstHeading(text) : this.o.heading(text));
  }
  hr() {
    return `---

`;
  }
  list(body, ordered) {
    body = this.o.list(body, ordered, this.tab);
    return section(fixNestedLists(indentLines(this.tab, body), this.tab));
  }
  listitem(text) {
    let transform = this.compose(this.o.listitem, this.transform);
    let isNested = text.indexOf("\n") !== -1;
    if (isNested)
      text = text.trim();
    return "\n" + BULLET_POINT + transform(text);
  }
  checkbox(checked) {
    return "[" + (checked ? "X" : " ") + "] ";
  }
  paragraph(text) {
    let transform = this.compose(this.o.paragraph, this.transform);
    text = transform(text);
    return section(text);
  }
  table(header, body) {
    let table = new cli_table.default(Object.assign({}, {
      head: generateTableRow(header)[0]
    }, this.tableSettings));
    generateTableRow(body, this.transform).forEach(function(row) {
      table.push(row);
    });
    return section(this.o.table(table.toString()));
  }
  tablerow(content) {
    return TABLE_ROW_WRAP + content + TABLE_ROW_WRAP + "\n";
  }
  tablecell(content, _flags) {
    return content + TABLE_CELL_SPLIT;
  }
  strong(text) {
    return this.o.strong(text);
  }
  em(text) {
    text = fixHardReturn(text, this.o.reflowText);
    return this.o.em(text);
  }
  codespan(text) {
    text = fixHardReturn(text, this.o.reflowText);
    return this.o.codespan(text.replace(/:/g, COLON_REPLACER));
  }
  br() {
    return "\n";
  }
  del(text) {
    return this.o.del(text);
  }
  link(href, title, text) {
    let prot;
    if (this.options.sanitize) {
      try {
        prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, "").toLowerCase();
      } catch (e) {
        return "";
      }
      if (prot.startsWith("javascript:")) {
        return "";
      }
    }
    if (text && href && text != href) {
      links.set(text, href);
    }
    if (text && text != href)
      return blue(text);
    let out = this.o.href(href);
    return this.o.link(out);
  }
  image(href, title, text) {
    if (typeof this.o.image === "function") {
      return this.o.image(href, title, text);
    }
    let out = "![" + text;
    if (title)
      out += " \u2013 " + title;
    return out + "](" + href + ")\n";
  }
  compose(...funcs) {
    return (...args) => {
      for (let i = funcs.length; i-- > 0; ) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  }
  static getLinks() {
    let res = [];
    for (let [text, href] of links.entries()) {
      res.push(`${blue(text)}: ${href}`);
    }
    links.clear();
    return res;
  }
};
var renderer_default = Renderer;

// src/util/string.ts
function byteLength(str) {
  return Buffer.byteLength(str);
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function byteIndex(content, index) {
  let s = content.slice(0, index);
  return Buffer.byteLength(s);
}
function characterIndex(content, byteIndex2) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(0, byteIndex2).toString("utf8").length;
}
function byteSlice(content, start, end) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(start, end).toString("utf8");
}
function isWord(character) {
  let code = character.charCodeAt(0);
  if (code > 128)
    return false;
  if (code == 95)
    return true;
  if (code >= 48 && code <= 57)
    return true;
  if (code >= 65 && code <= 90)
    return true;
  if (code >= 97 && code <= 122)
    return true;
  return false;
}

// src/util/ansiparse.ts
var foregroundColors = {
  30: "black",
  31: "red",
  32: "green",
  33: "yellow",
  34: "blue",
  35: "magenta",
  36: "cyan",
  37: "white",
  90: "grey"
};
var backgroundColors = {
  40: "black",
  41: "red",
  42: "green",
  43: "yellow",
  44: "blue",
  45: "magenta",
  46: "cyan",
  47: "white"
};
var styles2 = {
  1: "bold",
  3: "italic",
  4: "underline"
};
function parseAnsiHighlights(line, markdown3 = false) {
  let items = ansiparse(line);
  let highlights2 = [];
  let newLabel = "";
  for (let item of items) {
    if (!item.text)
      continue;
    let {foreground, background, bold: bold2, italic: italic2, underline: underline2} = item;
    let len = byteLength(newLabel);
    if (foreground || background || bold2 || italic2 || underline2) {
      let span = [len, len + byteLength(item.text)];
      let hlGroup = "";
      if (foreground && background) {
        hlGroup = `CocList${upperFirst(foreground)}${upperFirst(background)}`;
      } else if (foreground) {
        if (markdown3) {
          if (foreground == "yellow") {
            hlGroup = "CocMarkdownCode";
          } else if (foreground == "blue") {
            hlGroup = "CocMarkdownLink";
          } else if (foreground == "magenta") {
            hlGroup = "CocMarkdownHeader";
          } else {
            hlGroup = `CocListFg${upperFirst(foreground)}`;
          }
        } else {
          hlGroup = `CocListFg${upperFirst(foreground)}`;
        }
      } else if (background) {
        hlGroup = `CocListBg${upperFirst(background)}`;
      } else if (bold2) {
        hlGroup = "CocBold";
      } else if (italic2) {
        hlGroup = "CocItalic";
      } else if (underline2) {
        hlGroup = "CocUnderline";
      }
      highlights2.push({span, hlGroup});
    }
    newLabel = newLabel + item.text;
  }
  return {line: newLabel, highlights: highlights2};
}
function ansiparse(str) {
  let matchingControl = null;
  let matchingData = null;
  let matchingText = "";
  let ansiState = [];
  let result = [];
  let state = {};
  let eraseChar;
  eraseChar = () => {
    let index;
    let text;
    if (matchingText.length) {
      matchingText = matchingText.substr(0, matchingText.length - 1);
    } else if (result.length) {
      index = result.length - 1;
      text = result[index].text;
      if (text.length === 1) {
        result.pop();
      } else {
        result[index].text = text.substr(0, text.length - 1);
      }
    }
  };
  for (let i = 0; i < str.length; i++) {
    if (matchingControl != null) {
      if (matchingControl == "" && str[i] == "[") {
        if (matchingText) {
          state.text = matchingText;
          result.push(state);
          state = {};
          matchingText = "";
        }
        if (matchingText == "" && (str[i + 1] == "m" || str[i + 1] == "K")) {
          if (state.foreground || state.background) {
            state.text = "";
            result.push(state);
          }
          state = {};
        }
        matchingControl = null;
        matchingData = "";
      } else {
        matchingText += matchingControl + str[i];
        matchingControl = null;
      }
      continue;
    } else if (matchingData != null) {
      if (str[i] == ";") {
        ansiState.push(matchingData);
        matchingData = "";
      } else if (str[i] == "m" || str[i] == "K") {
        ansiState.push(matchingData);
        matchingData = null;
        matchingText = "";
        ansiState.forEach((ansiCode) => {
          if (foregroundColors[ansiCode]) {
            state.foreground = foregroundColors[ansiCode];
          } else if (backgroundColors[ansiCode]) {
            state.background = backgroundColors[ansiCode];
          } else if (ansiCode == 39) {
            delete state.foreground;
          } else if (ansiCode == 49) {
            delete state.background;
          } else if (styles2[ansiCode]) {
            state[styles2[ansiCode]] = true;
          } else if (ansiCode == 22) {
            state.bold = false;
          } else if (ansiCode == 23) {
            state.italic = false;
          } else if (ansiCode == 24) {
            state.underline = false;
          }
        });
        ansiState = [];
      } else {
        matchingData += str[i];
      }
      continue;
    }
    if (str[i] == "") {
      matchingControl = str[i];
    } else if (str[i] == "\b") {
      eraseChar();
    } else {
      matchingText += str[i];
    }
  }
  if (matchingText) {
    state.text = matchingText + (matchingControl ? matchingControl : "");
    result.push(state);
  }
  return result;
}

// src/markdown/index.ts
var diagnosticFiletypes = ["Error", "Warning", "Info", "Hint"];
var logger4 = require_logger2()("markdown-index");
marked.default.setOptions({
  renderer: new renderer_default()
});
function parseDocuments(docs) {
  let lines = [];
  let highlights2 = [];
  let codes = [];
  let idx = 0;
  for (let doc of docs) {
    let currline = lines.length;
    let {content, filetype} = doc;
    if (filetype == "markdown") {
      let info = parseMarkdown(content);
      codes.push(...info.codes.map((o) => {
        o.startLine = o.startLine + currline;
        o.endLine = o.endLine + currline;
        return o;
      }));
      highlights2.push(...info.highlights.map((o) => {
        o.lnum = o.lnum + currline;
        return o;
      }));
      lines.push(...info.lines);
    } else {
      let parts = content.trim().split(/\r?\n/);
      if (diagnosticFiletypes.includes(doc.filetype)) {
        codes.push({hlGroup: `Coc${filetype}Float`, startLine: currline, endLine: currline + parts.length});
      } else {
        codes.push({filetype: doc.filetype, startLine: currline, endLine: currline + parts.length});
      }
      lines.push(...parts);
    }
    if (doc.active) {
      let arr = getHighlightItems(content, currline, doc.active);
      if (arr.length)
        highlights2.push(...arr);
    }
    if (idx != docs.length - 1) {
      lines.push("\u2014");
    }
    idx = idx + 1;
  }
  return {lines, highlights: highlights2, codes};
}
function getHighlightItems(content, currline, active) {
  let res = [];
  let [start, end] = active;
  let lines = content.split(/\r?\n/);
  let used = 0;
  let inRange = false;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    if (!inRange) {
      if (used + line.length > start) {
        inRange = true;
        let colStart = byteLength(line.slice(0, start - used));
        if (used + line.length > end) {
          let colEnd = byteLength(line.slice(0, end - used));
          inRange = false;
          res.push({colStart, colEnd, lnum: i + currline, hlGroup: "CocUnderline"});
          break;
        } else {
          let colEnd = byteLength(line);
          res.push({colStart, colEnd, lnum: i + currline, hlGroup: "CocUnderline"});
        }
      }
    } else {
      if (used + line.length > end) {
        let colEnd = byteLength(line.slice(0, end - used));
        res.push({colStart: 0, colEnd, lnum: i + currline, hlGroup: "CocUnderline"});
        inRange = false;
        break;
      } else {
        let colEnd = byteLength(line);
        res.push({colStart: 0, colEnd, lnum: i + currline, hlGroup: "CocUnderline"});
      }
    }
    used = used + line.length + 1;
  }
  return res;
}
function parseMarkdown(content) {
  let lines = [];
  let highlights2 = [];
  let codes = [];
  let currline = 0;
  let inCodeBlock = false;
  let filetype;
  let startLnum = 0;
  let parsed = marked.default(content);
  let links3 = renderer_default.getLinks();
  if (links3.length) {
    parsed = parsed + "\n\n" + links3.join("\n");
  }
  for (let line of parsed.replace(/\s*$/, "").split(/\n/)) {
    if (!line.length) {
      let pre = lines[lines.length - 1];
      if (pre && pre.length) {
        lines.push(line);
        currline++;
      }
      continue;
    }
    if (line.startsWith("```")) {
      let pre = lines[lines.length - 1];
      if (!inCodeBlock) {
        inCodeBlock = true;
        filetype = line.replace(/^```\s*/, "");
        if (filetype == "js")
          filetype = "javascript";
        if (filetype == "ts")
          filetype = "typescript";
        startLnum = currline;
      } else {
        inCodeBlock = false;
        codes.push({
          filetype,
          startLine: startLnum,
          endLine: currline
        });
      }
      if (pre && pre.length) {
        lines.push("");
        currline++;
      }
      continue;
    }
    if (inCodeBlock) {
      lines.push(line);
      currline++;
      continue;
    }
    let res = parseAnsiHighlights(line, true);
    if (res.highlights) {
      for (let hi of res.highlights) {
        let {hlGroup, span} = hi;
        highlights2.push({
          hlGroup,
          lnum: currline,
          colStart: span[0],
          colEnd: span[1]
        });
      }
    }
    lines.push(res.line);
    currline++;
  }
  return {lines, highlights: highlights2, codes};
}

// src/util/mutex.ts
var Mutex = class {
  constructor() {
    this.tasks = [];
    this.count = 1;
  }
  sched() {
    if (this.count > 0 && this.tasks.length > 0) {
      this.count--;
      let next = this.tasks.shift();
      next();
    }
  }
  get busy() {
    return this.count == 0;
  }
  acquire() {
    return new Promise((res) => {
      let task2 = () => {
        let released = false;
        res(() => {
          if (!released) {
            released = true;
            this.count++;
            this.sched();
          }
        });
      };
      this.tasks.push(task2);
      process.nextTick(this.sched.bind(this));
    });
  }
  use(f) {
    return this.acquire().then((release) => f().then((res) => {
      release();
      return res;
    }).catch((err) => {
      release();
      throw err;
    }));
  }
};

// src/model/floatFactory.ts
var isVim = process.env.VIM_NODE_RPC == "1";
var logger5 = require_logger2()("model-float");
var FloatFactory = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.winid = 0;
    this._bufnr = 0;
    this.mutex = new Mutex();
    this.disposables = [];
    this.alignTop = false;
    this.pumAlignTop = false;
    this.autoHide = true;
    this.mutex = new Mutex();
    events_default.on("BufEnter", (bufnr) => {
      if (bufnr == this._bufnr || bufnr == this.targetBufnr)
        return;
      this.close();
    }, null, this.disposables);
    events_default.on("InsertEnter", (bufnr) => {
      if (bufnr == this._bufnr || !this.autoHide)
        return;
      this.close();
    }, null, this.disposables);
    events_default.on("InsertLeave", () => {
      this.close();
    }, null, this.disposables);
    events_default.on("MenuPopupChanged", (ev, cursorline) => {
      let pumAlignTop = this.pumAlignTop = cursorline > ev.row;
      if (pumAlignTop == this.alignTop) {
        this.close();
      }
    }, null, this.disposables);
    this.onCursorMoved = debounce3.default(this._onCursorMoved.bind(this), 300);
    events_default.on("CursorMoved", this.onCursorMoved.bind(this, false), null, this.disposables);
    events_default.on("CursorMovedI", this.onCursorMoved.bind(this, true), null, this.disposables);
    this.disposables.push(vscode_languageserver_protocol3.Disposable.create(() => {
      this.onCursorMoved.clear();
      this.cancel();
    }));
  }
  _onCursorMoved(insertMode, bufnr, cursor) {
    if (bufnr == this._bufnr)
      return;
    if (bufnr == this.targetBufnr && equals(cursor, this.cursor)) {
      return;
    }
    if (this.autoHide) {
      this.close();
      return;
    }
    if (!insertMode || bufnr != this.targetBufnr) {
      this.close();
      return;
    }
  }
  async create(docs, _allowSelection = false, offsetX = 0) {
    this.onCursorMoved.clear();
    if (docs.length == 0 || docs.every((doc) => doc.content.length == 0)) {
      this.close();
      return;
    }
    let release = await this.mutex.acquire();
    try {
      await this.createPopup(docs, {offsetX});
      release();
    } catch (e) {
      release();
      logger5.error(`Error on create popup:`, e.message);
      this.close();
    }
  }
  async show(docs, config = {}) {
    this.onCursorMoved.clear();
    if (docs.length == 0 || docs.every((doc) => doc.content.length == 0)) {
      this.close();
      return;
    }
    let release = await this.mutex.acquire();
    try {
      await this.createPopup(docs, config);
      release();
    } catch (e) {
      release();
      logger5.error(`Error on create popup:`, e.message);
      this.close();
    }
  }
  async createPopup(docs, opts) {
    let tokenSource = this.tokenSource = new vscode_languageserver_protocol3.CancellationTokenSource();
    let token = tokenSource.token;
    docs = docs.filter((o) => o.content.trim().length > 0);
    let {lines, codes, highlights: highlights2} = parseDocuments(docs);
    let config = {
      pumAlignTop: this.pumAlignTop,
      preferTop: typeof opts.preferTop === "boolean" ? opts.preferTop : false,
      offsetX: opts.offsetX || 0,
      title: opts.title || "",
      close: opts.close ? 1 : 0,
      codes,
      highlights: highlights2,
      modes: opts.modes || ["n", "i", "ic", "s"]
    };
    if (opts.maxHeight)
      config.maxHeight = opts.maxHeight;
    if (opts.maxWidth)
      config.maxWidth = opts.maxWidth;
    if (opts.border && !opts.border.every((o) => o == 0)) {
      config.border = opts.border;
    }
    if (opts.title && !config.border)
      config.border = [1, 1, 1, 1];
    if (opts.highlight)
      config.highlight = opts.highlight;
    if (opts.borderhighlight)
      config.borderhighlight = [opts.borderhighlight];
    if (opts.cursorline)
      config.cursorline = 1;
    this.autoHide = opts.autoHide == false ? false : true;
    if (this.autoHide)
      config.autohide = 1;
    let arr = await this.nvim.call("coc#float#create_cursor_float", [this.winid, this._bufnr, lines, config]);
    if (isVim)
      this.nvim.command("redraw", true);
    if (!arr || arr.length == 0) {
      this.winid = null;
      return;
    }
    let [targetBufnr, cursor, winid, bufnr] = arr;
    this.winid = winid;
    if (token.isCancellationRequested) {
      this.close();
      return;
    }
    let pos = await this.nvim.call("coc#float#cursor_relative", [winid]);
    if (pos)
      this.alignTop = pos.row < 0;
    this._bufnr = bufnr;
    this.tokenSource.dispose();
    this.tokenSource = null;
    this.targetBufnr = targetBufnr;
    this.cursor = cursor;
    this.onCursorMoved.clear();
  }
  close() {
    let {winid, nvim} = this;
    this.cancel();
    if (winid) {
      this.winid = 0;
      nvim.pauseNotification();
      nvim.call("coc#float#close", [winid], true);
      if (isVim)
        this.nvim.command("redraw", true);
      nvim.resumeNotification(false, true);
    }
  }
  cancel() {
    let {tokenSource} = this;
    if (tokenSource) {
      tokenSource.cancel();
      this.tokenSource = null;
    }
  }
  dispose() {
    disposeAll(this.disposables);
  }
  get bufnr() {
    return this._bufnr;
  }
  get buffer() {
    return this.bufnr ? this.nvim.createBuffer(this.bufnr) : null;
  }
  get window() {
    return this.winid ? this.nvim.createWindow(this.winid) : null;
  }
  async activated() {
    if (!this.winid)
      return false;
    return await this.nvim.call("coc#float#valid", [this.winid]) != 0;
  }
};
var floatFactory_default = FloatFactory;

// src/util/position.ts
function rangeInRange(r, range2) {
  return positionInRange(r.start, range2) === 0 && positionInRange(r.end, range2) === 0;
}
function rangeOverlap(r, range2) {
  let {start, end} = r;
  if (comparePosition(end, range2.start) <= 0) {
    return false;
  }
  if (comparePosition(start, range2.end) >= 0) {
    return false;
  }
  return true;
}
function rangeIntersect(r, range2) {
  if (positionInRange(r.start, range2) == 0) {
    return true;
  }
  if (positionInRange(r.end, range2) == 0) {
    return true;
  }
  if (rangeInRange(range2, r)) {
    return true;
  }
  return false;
}
function lineInRange(line, range2) {
  let {start, end} = range2;
  return line >= start.line && line <= end.line;
}
function emptyRange(range2) {
  let {start, end} = range2;
  return start.line == end.line && start.character == end.character;
}
function positionInRange(position15, range2) {
  let {start, end} = range2;
  if (comparePosition(position15, start) < 0)
    return -1;
  if (comparePosition(position15, end) > 0)
    return 1;
  return 0;
}
function comparePosition(position15, other) {
  if (position15.line > other.line)
    return 1;
  if (other.line == position15.line && position15.character > other.character)
    return 1;
  if (other.line == position15.line && position15.character == other.character)
    return 0;
  return -1;
}
function isSingleLine(range2) {
  return range2.start.line == range2.end.line;
}
function getChangedPosition(start, edit2) {
  let {range: range2, newText} = edit2;
  if (comparePosition(range2.end, start) <= 0) {
    let lines = newText.split("\n");
    let lineCount = lines.length - (range2.end.line - range2.start.line) - 1;
    let characterCount = 0;
    if (range2.end.line == start.line) {
      let single = isSingleLine(range2) && lineCount == 0;
      let removed = single ? range2.end.character - range2.start.character : range2.end.character;
      let added = single ? newText.length : lines[lines.length - 1].length;
      characterCount = added - removed;
    }
    return {line: lineCount, character: characterCount};
  }
  return {line: 0, character: 0};
}
function adjustPosition(pos, edit2) {
  let {range: range2, newText} = edit2;
  if (comparePosition(range2.start, pos) > 1)
    return pos;
  let {start, end} = range2;
  let newLines = newText.split("\n");
  let delta = end.line - start.line - newLines.length + 1;
  let lastLine = newLines[newLines.length - 1];
  let line = pos.line - delta;
  if (pos.line != end.line)
    return {line, character: pos.character};
  let pre = newLines.length == 1 && start.line != end.line ? start.character : 0;
  let removed = start.line == end.line && newLines.length == 1 ? end.character - start.character : end.character;
  let character = pre + pos.character + lastLine.length - removed;
  return {
    line,
    character
  };
}
function positionToOffset(lines, line, character) {
  let offset = 0;
  for (let i = 0; i <= line; i++) {
    if (i == line) {
      offset += character;
    } else {
      offset += lines[i].length + 1;
    }
  }
  return offset;
}
function editRange(range2, text, edit2) {
  if (!rangeInRange(edit2.range, range2))
    return text;
  let {start, end} = edit2.range;
  let lines = text.split("\n");
  let character = start.line == range2.start.line ? start.character - range2.start.character : start.character;
  let startOffset = positionToOffset(lines, start.line - range2.start.line, character);
  character = end.line == range2.start.line ? end.character - range2.start.character : end.character;
  let endOffset = positionToOffset(lines, end.line - range2.start.line, character);
  return `${text.slice(0, startOffset)}${edit2.newText}${text.slice(endOffset, text.length)}`;
}
function getChangedFromEdits(start, edits) {
  let changed = {line: 0, character: 0};
  for (let edit2 of edits) {
    let d = getChangedPosition(start, edit2);
    changed = {line: changed.line + d.line, character: changed.character + d.character};
  }
  return changed.line == 0 && changed.character == 0 ? null : changed;
}

// src/window.ts
var fs17 = __toModule(require("fs"));
var os9 = __toModule(require("os"));
var path23 = __toModule(require("path"));
var vscode_languageserver_protocol14 = __toModule(require_main3());

// src/model/outputChannel.ts
var logger6 = require_logger2()("outpubChannel");
var BufferChannel = class {
  constructor(name2, nvim) {
    this.name = name2;
    this.nvim = nvim;
    this._disposed = false;
    this.lines = [""];
    this.disposables = [];
  }
  get content() {
    return this.lines.join("\n");
  }
  _append(value) {
    let {nvim} = this;
    let idx = this.lines.length - 1;
    let newlines = value.split("\n");
    let lastline = this.lines[idx] + newlines[0];
    this.lines[idx] = lastline;
    let append = newlines.slice(1);
    this.lines = this.lines.concat(append);
    nvim.pauseNotification();
    nvim.call("setbufline", [this.bufname, "$", lastline], true);
    if (append.length) {
      nvim.call("appendbufline", [this.bufname, "$", append], true);
    }
    nvim.resumeNotification(false, true);
  }
  append(value) {
    if (!this.validate())
      return;
    this._append(value);
  }
  appendLine(value) {
    if (!this.validate())
      return;
    this._append(value + "\n");
  }
  clear(keep) {
    if (!this.validate())
      return;
    let {nvim} = this;
    this.lines = keep ? this.lines.slice(-keep) : [];
    nvim.pauseNotification();
    nvim.call("deletebufline", [this.bufname, 1, "$"], true);
    if (this.lines.length) {
      nvim.call("appendbufline", [this.bufname, "$", this.lines], true);
    }
    nvim.resumeNotification(false, true);
  }
  hide() {
    this.nvim.command(`exe 'silent! bd! '.fnameescape('${this.bufname}')`, true);
  }
  get bufname() {
    return `output:///${this.name}`;
  }
  show(preserveFocus) {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command(`exe 'vsplit '.fnameescape('${this.bufname}')`, true);
    if (preserveFocus) {
      nvim.command("wincmd p", true);
    }
    nvim.command("redraw", true);
    nvim.resumeNotification(false, true);
  }
  validate() {
    if (this._disposed)
      return false;
    return true;
  }
  dispose() {
    if (this._disposed)
      return;
    this._disposed = true;
    this.hide();
    this.lines = [];
    disposeAll(this.disposables);
  }
};
var outputChannel_default = BufferChannel;

// src/channels.ts
var outputChannels = new Map();
var Channels = class {
  getProvider(nvim) {
    let provider = {
      onDidChange: null,
      provideTextDocumentContent: async (uri) => {
        let channel = this.get(uri.path.slice(1));
        if (!channel)
          return "";
        nvim.pauseNotification();
        nvim.command("setlocal nospell nofoldenable nowrap noswapfile", true);
        nvim.command("setlocal buftype=nofile bufhidden=hide", true);
        nvim.command("setfiletype log", true);
        await nvim.resumeNotification();
        return channel.content;
      }
    };
    return provider;
  }
  get names() {
    return Array.from(outputChannels.keys());
  }
  get(channelName) {
    return outputChannels.get(channelName);
  }
  create(name2, nvim) {
    if (outputChannels.has(name2))
      return outputChannels.get(name2);
    if (!/^[\w\s-.]+$/.test(name2))
      throw new Error(`Invalid channel name "${name2}", only word characters and white space allowed.`);
    let channel = new outputChannel_default(name2, nvim);
    outputChannels.set(name2, channel);
    return channel;
  }
  show(name2, preserveFocus) {
    let channel = outputChannels.get(name2);
    if (!channel)
      return;
    channel.show(preserveFocus);
  }
  dispose() {
    for (let channel of outputChannels.values()) {
      channel.dispose();
    }
    outputChannels.clear();
  }
};
var channels_default = new Channels();

// src/model/dialog.ts
var logger7 = require_logger2()("model-dialog");
var Dialog = class {
  constructor(nvim, config) {
    this.nvim = nvim;
    this.config = config;
    this.disposables = [];
    events_default.on("BufWinLeave", (bufnr) => {
      if (bufnr == this.bufnr) {
        this.dispose();
        if (config.callback)
          config.callback(-1);
      }
    }, null, this.disposables);
    events_default.on("FloatBtnClick", (bufnr, idx) => {
      if (bufnr == this.bufnr) {
        this.dispose();
        let btns = config == null ? void 0 : config.buttons.filter((o) => o.disabled != true);
        if (config.callback)
          config.callback(btns[idx].index);
      }
    }, null, this.disposables);
  }
  get lines() {
    return [...this.config.content.split(/\r?\n/)];
  }
  async show(preferences) {
    let {nvim} = this;
    let {title, close, buttons} = this.config;
    let borderhighlight = this.config.borderhighlight || preferences.floatBorderHighlight;
    let highlight = this.config.highlight || preferences.floatHighlight;
    let opts = {maxwidth: preferences.maxWidth || 80};
    if (title)
      opts.title = title;
    if (close || typeof close === "undefined")
      opts.close = 1;
    if (preferences.maxHeight)
      opts.maxHeight = preferences.maxHeight;
    if (preferences.maxWidth)
      opts.maxWidth = preferences.maxWidth;
    if (highlight)
      opts.highlight = highlight;
    if (borderhighlight)
      opts.borderhighlight = [borderhighlight];
    if (buttons)
      opts.buttons = buttons.filter((o) => !o.disabled).map((o) => o.text);
    let res = await nvim.call("coc#float#create_dialog", [this.lines, opts]);
    if (!res[1])
      return;
    this.bufnr = res[1];
    nvim.command("redraw", true);
  }
  get winid() {
    if (!this.bufnr)
      return Promise.resolve(null);
    return this.nvim.call("bufwinid", [this.bufnr]);
  }
  dispose() {
    this.bufnr = void 0;
    disposeAll(this.disposables);
    this.disposables = [];
  }
};
var dialog_default = Dialog;

// src/model/menu.ts
var vscode_languageserver_protocol4 = __toModule(require_main3());

// src/model/popup.ts
var isVim2 = process.env.VIM_NODE_RPC == "1";
var Popup = class {
  constructor(nvim, winid, bufnr) {
    this.nvim = nvim;
    this.winid = winid;
    this.bufnr = bufnr;
  }
  get valid() {
    return this.nvim.call("coc#float#valid", [this.winid]).then((res) => {
      return !!res;
    });
  }
  close() {
    this.nvim.call("coc#float#close", [this.winid], true);
  }
  refreshScrollbar() {
    if (!isVim2)
      this.nvim.call("coc#float#nvim_scrollbar", [this.winid], true);
  }
  execute(cmd) {
    this.nvim.call("coc#float#execute", [this.winid, cmd], true);
  }
  click(lnum, col) {
    let {nvim} = this;
    nvim.call("win_gotoid", [this.winid], true);
    nvim.call("cursor", [lnum, col], true);
    nvim.call("coc#float#nvim_float_click", [], true);
  }
  async scrollForward() {
    let {nvim, bufnr, winid} = this;
    let buf = nvim.createBuffer(bufnr);
    let total = await buf.length;
    let botline;
    if (!isVim2) {
      let infos = await nvim.call("getwininfo", [winid]);
      if (!infos || !infos.length)
        return;
      botline = infos[0].botline;
    } else {
      botline = await nvim.eval(`get(popup_getpos(${winid}), 'lastline', 0)`);
    }
    if (botline >= total || botline == 0)
      return;
    nvim.pauseNotification();
    this.setCursor(botline - 1);
    this.execute(`normal! ${botline}Gzt`);
    this.refreshScrollbar();
    nvim.command("redraw", true);
    nvim.resumeNotification(false, true);
  }
  async scrollBackward() {
    let {nvim, winid} = this;
    let topline;
    if (!isVim2) {
      let infos = await nvim.call("getwininfo", [winid]);
      if (!infos || !infos.length)
        return;
      topline = infos[0].topline;
    } else {
      topline = await nvim.eval(`get(popup_getpos(${winid}), 'firstline', 0)`);
    }
    if (topline == 1)
      return;
    nvim.pauseNotification();
    this.setCursor(topline - 1);
    this.execute(`normal! ${topline}Gzb`);
    this.refreshScrollbar();
    nvim.command("redraw", true);
    nvim.resumeNotification(false, true);
  }
  setCursor(index) {
    let {nvim, bufnr, winid} = this;
    if (isVim2) {
      nvim.call("win_execute", [winid, `exe ${index + 1}`], true);
    } else {
      let win = nvim.createWindow(winid);
      win.notify("nvim_win_set_cursor", [[index + 1, 0]]);
      nvim.command(`sign unplace 6 buffer=${bufnr}`, true);
      nvim.command(`sign place 6 line=${index + 1} name=CocCurrentLine buffer=${bufnr}`, true);
    }
  }
};
var popup_default = Popup;

// src/model/menu.ts
var logger8 = require_logger2()("model-menu");
var Menu = class {
  constructor(nvim, config, token) {
    this.nvim = nvim;
    this.config = config;
    this.currIndex = 0;
    this.disposables = [];
    this.keyMappings = new Map();
    this._onDidClose = new vscode_languageserver_protocol4.Emitter();
    this.onDidClose = this._onDidClose.event;
    this.total = config.items.length;
    if (token) {
      token.onCancellationRequested(() => {
        var _a2;
        (_a2 = this.win) == null ? void 0 : _a2.close();
      });
    }
    this.disposables.push(this._onDidClose);
    this.addKeymappings();
  }
  attachEvents() {
    events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
    events_default.on("BufWinLeave", (bufnr) => {
      if (bufnr == this.bufnr) {
        this._onDidClose.fire(-1);
        this.bufnr = void 0;
        this.win = void 0;
        this.dispose();
      }
    }, null, this.disposables);
  }
  addKeymappings() {
    let {nvim} = this;
    this.addKeys(["<esc>", "<C-c>"], () => {
      this._onDidClose.fire(-1);
      this.dispose();
    });
    this.addKeys(["\r", "<cr>"], () => {
      this._onDidClose.fire(this.currIndex);
      this.dispose();
    });
    let setCursorIndex = (idx) => {
      var _a2;
      if (!this.win)
        return;
      nvim.pauseNotification();
      this.setCursor(idx);
      (_a2 = this.win) == null ? void 0 : _a2.refreshScrollbar();
      nvim.command("redraw", true);
      nvim.resumeNotification(false, true);
    };
    this.addKeys("<C-f>", async () => {
      var _a2;
      await ((_a2 = this.win) == null ? void 0 : _a2.scrollForward());
    });
    this.addKeys("<C-b>", async () => {
      var _a2;
      await ((_a2 = this.win) == null ? void 0 : _a2.scrollBackward());
    });
    this.addKeys(["j", "<down>", "<tab>", "<C-n>"], () => {
      let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;
      setCursorIndex(idx);
    });
    this.addKeys(["k", "<up>", "<s-tab>", "<C-p>"], () => {
      let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;
      setCursorIndex(idx);
    });
    this.addKeys(["g"], () => {
      setCursorIndex(0);
    });
    this.addKeys(["G"], () => {
      setCursorIndex(this.total - 1);
    });
    let timer;
    let firstNumber;
    this.addKeys(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], (character) => {
      if (timer)
        clearTimeout(timer);
      let n = parseInt(character, 10);
      if (isNaN(n) || n > this.total)
        return;
      if (firstNumber == null && n == 0)
        return;
      if (firstNumber) {
        let count = firstNumber * 10 + n;
        firstNumber = void 0;
        this._onDidClose.fire(count - 1);
        this.dispose();
        return;
      }
      if (this.total < 10 || n * 10 > this.total) {
        this._onDidClose.fire(n - 1);
        this.dispose();
        return;
      }
      timer = setTimeout(async () => {
        this._onDidClose.fire(n - 1);
        this.dispose();
      }, 200);
      firstNumber = n;
    });
  }
  async show(preferences = {}) {
    let {nvim} = this;
    let {title, items} = this.config;
    let opts = {};
    if (title)
      opts.title = title;
    if (preferences.maxHeight)
      opts.maxHeight = preferences.maxHeight;
    if (preferences.maxWidth)
      opts.maxWidth = preferences.maxWidth;
    if (preferences.floatHighlight)
      opts.highlight = preferences.floatHighlight;
    if (preferences.floatBorderHighlight)
      opts.borderhighlight = [preferences.floatBorderHighlight];
    let lines = items.map((v, i) => {
      if (i < 99)
        return `${i + 1}. ${v}`;
      return v;
    });
    if (preferences.confirmKey && preferences.confirmKey != "<cr>") {
      this.addKeys(preferences.confirmKey, () => {
        this._onDidClose.fire(this.currIndex);
        this.dispose();
      });
    }
    let res = await nvim.call("coc#float#create_menu", [lines, opts]);
    this.win = new popup_default(nvim, res[0], res[1]);
    this.bufnr = res[1];
    this.attachEvents();
    nvim.call("coc#prompt#start_prompt", ["menu"], true);
    return res[0];
  }
  get buffer() {
    return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
  }
  dispose() {
    var _a2;
    disposeAll(this.disposables);
    this.disposables = [];
    this.nvim.call("coc#prompt#stop_prompt", ["menu"], true);
    (_a2 = this.win) == null ? void 0 : _a2.close();
    this.win = void 0;
  }
  async onInputChar(session4, character) {
    if (session4 != "menu" || !this.win)
      return;
    let fn = this.keyMappings.get(character);
    if (fn) {
      await Promise.resolve(fn(character));
    } else {
      logger8.warn(`Ignored key press: ${character}`);
    }
  }
  setCursor(index) {
    if (!this.win)
      return;
    this.currIndex = index;
    this.win.setCursor(index);
  }
  addKeys(keys, fn) {
    if (Array.isArray(keys)) {
      for (let key of keys) {
        this.keyMappings.set(key, fn);
      }
    } else {
      this.keyMappings.set(keys, fn);
    }
  }
};
var menu_default = Menu;

// src/model/notification.ts
var isVim3 = process.env.VIM_NODE_RPC == "1";
var logger9 = require_logger2()("model-notification");
var Notification = class {
  constructor(nvim, config, attachEvents = true) {
    this.nvim = nvim;
    this.config = config;
    this.disposables = [];
    this._disposed = false;
    if (attachEvents) {
      events_default.on("BufWinLeave", (bufnr) => {
        if (bufnr == this.bufnr) {
          this.dispose();
          if (config.callback)
            config.callback(-1);
        }
      }, null, this.disposables);
      events_default.on("FloatBtnClick", (bufnr, idx) => {
        if (bufnr == this.bufnr) {
          this.dispose();
          let btns = config == null ? void 0 : config.buttons.filter((o) => o.disabled != true);
          if (config.callback)
            config.callback(btns[idx].index);
        }
      }, null, this.disposables);
    }
  }
  get lines() {
    return this.config.content.split(/\r?\n/);
  }
  async show(preferences) {
    let {nvim} = this;
    let {title, close, timeout, buttons, borderhighlight} = this.config;
    let opts = Object.assign({}, preferences);
    opts.close = close ? 1 : 0;
    if (title)
      opts.title = title;
    if (borderhighlight)
      opts.borderhighlight = borderhighlight;
    if (buttons)
      opts.buttons = buttons.filter((o) => !o.disabled).map((o) => o.text);
    if (timeout)
      opts.timeout = timeout;
    let res = await nvim.call("coc#float#create_notification", [this.lines, opts]);
    if (!res)
      return false;
    if (this._disposed) {
      this.nvim.call("coc#float#close", [res[0]], true);
      if (isVim3)
        this.nvim.command("redraw", true);
    } else {
      this._winid = res[0];
      this.bufnr = res[1];
    }
    return this._winid != void 0;
  }
  get winid() {
    return this._winid;
  }
  dispose() {
    if (this._disposed)
      return;
    this._disposed = true;
    let {winid} = this;
    if (winid) {
      this.nvim.call("coc#float#close", [winid], true);
      if (isVim3)
        this.nvim.command("redraw", true);
    }
    this.bufnr = void 0;
    this._winid = void 0;
    disposeAll(this.disposables);
    this.disposables = [];
  }
};
var notification_default = Notification;

// src/model/picker.ts
var vscode_languageserver_protocol5 = __toModule(require_main3());
var logger10 = require_logger2()("model-dialog");
var isVim4 = process.env.VIM_NODE_RPC == "1";
var Picker = class {
  constructor(nvim, config, token) {
    this.nvim = nvim;
    this.config = config;
    this.picked = new Set();
    this.currIndex = 0;
    this.disposables = [];
    this.keyMappings = new Map();
    this._onDidClose = new vscode_languageserver_protocol5.Emitter();
    this.onDidClose = this._onDidClose.event;
    for (let i = 0; i < config.items.length; i++) {
      let item = config.items[i];
      if (item.picked)
        this.picked.add(i);
    }
    this.total = config.items.length;
    if (token) {
      token.onCancellationRequested(() => {
        var _a2;
        (_a2 = this.win) == null ? void 0 : _a2.close();
      });
    }
    this.disposables.push(this._onDidClose);
    this.addKeymappings();
  }
  attachEvents() {
    events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
    events_default.on("BufWinLeave", (bufnr) => {
      if (bufnr == this.bufnr) {
        this._onDidClose.fire(void 0);
        this.bufnr = void 0;
        this.win = void 0;
        this.dispose();
      }
    }, null, this.disposables);
    events_default.on("FloatBtnClick", (bufnr, idx) => {
      if (bufnr == this.bufnr) {
        if (idx == 0) {
          let selected = Array.from(this.picked);
          this._onDidClose.fire(selected.length ? selected : void 0);
        } else {
          this._onDidClose.fire(void 0);
        }
        this.dispose();
      }
    }, null, this.disposables);
  }
  addKeymappings() {
    let {nvim} = this;
    const toggleSelect = (idx) => {
      if (this.picked.has(idx)) {
        this.picked.delete(idx);
      } else {
        this.picked.add(idx);
      }
    };
    this.addKeys("<LeftRelease>", async () => {
      if (isVim4 || !this.win)
        return;
      let [winid, lnum, col] = await nvim.eval("[v:mouse_winid,v:mouse_lnum,v:mouse_col]");
      if (global.hasOwnProperty("__TEST__")) {
        let res = await nvim.getVar("mouse_position");
        winid = res[0];
        lnum = res[1];
        col = res[2];
      }
      nvim.pauseNotification();
      if (winid == this.win.winid) {
        if (col <= 3) {
          toggleSelect(lnum - 1);
          this.changeLine(lnum - 1);
        } else {
          this.setCursor(lnum - 1);
        }
      }
      nvim.call("win_gotoid", [winid], true);
      nvim.call("cursor", [lnum, col], true);
      nvim.call("coc#float#nvim_float_click", [], true);
      nvim.command("redraw", true);
      await nvim.resumeNotification();
    });
    this.addKeys(["<esc>", "<C-c>"], () => {
      this._onDidClose.fire(void 0);
      this.dispose();
    });
    this.addKeys("<cr>", () => {
      if (this.picked.size == 0) {
        this._onDidClose.fire(void 0);
      } else {
        let selected = Array.from(this.picked);
        this._onDidClose.fire(selected);
      }
      this.dispose();
    });
    let setCursorIndex = (idx) => {
      nvim.pauseNotification();
      this.setCursor(idx);
      this.win.refreshScrollbar();
      nvim.command("redraw", true);
      nvim.resumeNotification(false, true);
    };
    this.addKeys(["j", "<down>", "<tab>", "<C-n>"], () => {
      let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;
      setCursorIndex(idx);
    });
    this.addKeys(["k", "<up>", "<s-tab>", "<C-p>"], () => {
      let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;
      setCursorIndex(idx);
    });
    this.addKeys(["g"], () => {
      setCursorIndex(0);
    });
    this.addKeys(["G"], () => {
      setCursorIndex(this.total - 1);
    });
    this.addKeys(" ", async () => {
      let idx = this.currIndex;
      toggleSelect(idx);
      nvim.pauseNotification();
      this.changeLine(idx);
      if (this.currIndex != this.total - 1) {
        this.setCursor(this.currIndex + 1);
      }
      nvim.command("redraw", true);
      await nvim.resumeNotification();
    });
    this.addKeys("<C-f>", async () => {
      var _a2;
      await ((_a2 = this.win) == null ? void 0 : _a2.scrollForward());
    });
    this.addKeys("<C-b>", async () => {
      var _a2;
      await ((_a2 = this.win) == null ? void 0 : _a2.scrollBackward());
    });
  }
  async show(preferences = {}) {
    let {nvim} = this;
    let {title, items} = this.config;
    let opts = {close: 1, cursorline: 1};
    if (preferences.maxHeight)
      opts.maxHeight = preferences.maxHeight;
    if (preferences.maxWidth)
      opts.maxWidth = preferences.maxWidth;
    if (title)
      opts.title = title;
    opts.close = 1;
    opts.cursorline = 1;
    if (preferences.floatHighlight) {
      opts.highlight = preferences.floatHighlight;
    }
    if (preferences.floatBorderHighlight) {
      opts.borderhighlight = [preferences.floatBorderHighlight];
    }
    if (preferences.pickerButtons) {
      let shortcut = preferences.pickerButtonShortcut;
      opts.buttons = ["Submit" + (shortcut ? " <cr>" : ""), "Cancel" + (shortcut ? " <esc>" : "")];
    }
    if (preferences.confirmKey && preferences.confirmKey != "<cr>") {
      this.addKeys(preferences.confirmKey, () => {
        this._onDidClose.fire(void 0);
        this.dispose();
      });
    }
    let lines = [];
    let positions2 = [];
    for (let i = 0; i < items.length; i++) {
      let item = items[i];
      let line = `[${item.picked ? "x" : " "}] ${item.label}`;
      positions2.push([i, byteLength(line)]);
      if (item.description)
        line = line + ` ${item.description}`;
      lines.push(line);
    }
    let res = await nvim.call("coc#float#create_dialog", [lines, opts]);
    this.win = new popup_default(nvim, res[0], res[1]);
    this.bufnr = res[1];
    this.attachEvents();
    let buf = nvim.createBuffer(this.bufnr);
    nvim.pauseNotification();
    for (let pos of positions2) {
      buf.addHighlight({hlGroup: "Comment", line: pos[0], srcId: 1, colStart: pos[1], colEnd: -1});
    }
    nvim.command("redraw", true);
    nvim.resumeNotification(false, true);
    nvim.call("coc#prompt#start_prompt", ["picker"], true);
    return res[0];
  }
  get buffer() {
    return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
  }
  dispose() {
    var _a2;
    disposeAll(this.disposables);
    this.disposables = [];
    this.nvim.call("coc#prompt#stop_prompt", ["picker"], true);
    (_a2 = this.win) == null ? void 0 : _a2.close();
    this.win = void 0;
  }
  async onInputChar(session4, character) {
    if (session4 != "picker" || !this.win)
      return;
    let fn = this.keyMappings.get(character);
    if (fn) {
      await Promise.resolve(fn(character));
    } else {
      logger10.warn(`Ignored key press: ${character}`);
    }
  }
  changeLine(index) {
    let {nvim} = this;
    let item = this.config.items[index];
    if (!item)
      return;
    let line = `[${this.picked.has(index) ? "x" : " "}] ${item.label}`;
    let col = byteLength(line);
    if (item.description)
      line = line + ` ${item.description}`;
    nvim.call("setbufline", [this.bufnr, index + 1, line], true);
    if (!isVim4) {
      let buf = nvim.createBuffer(this.bufnr);
      buf.addHighlight({hlGroup: "Comment", line: index, srcId: 1, colStart: col, colEnd: -1});
    }
  }
  setCursor(index) {
    if (!this.win)
      return;
    this.currIndex = index;
    this.win.setCursor(index);
  }
  addKeys(keys, fn) {
    if (Array.isArray(keys)) {
      for (let key of keys) {
        this.keyMappings.set(key, fn);
      }
    } else {
      this.keyMappings.set(keys, fn);
    }
  }
};
var picker_default = Picker;

// src/model/progress.ts
var vscode_languageserver_protocol6 = __toModule(require_main3());
var ProgressNotification = class extends notification_default {
  constructor(nvim, option) {
    super(nvim, {
      content: "\n",
      close: option.cancellable == true,
      title: option.title
    }, false);
    this.option = option;
    events_default.on("BufWinLeave", (bufnr) => {
      if (bufnr == this.bufnr) {
        if (this.tokenSource) {
          this.tokenSource.cancel();
        }
        this.dispose();
      }
    }, null, this.disposables);
  }
  async show(preferences) {
    let {task: task2} = this.option;
    let tokenSource = this.tokenSource = new vscode_languageserver_protocol6.CancellationTokenSource();
    this.disposables.push(tokenSource);
    let total = 0;
    let res = await new Promise((resolve3, reject) => {
      tokenSource.token.onCancellationRequested(() => {
        resolve3(void 0);
      });
      super.show(Object.assign({minWidth: preferences.minProgressWidth || 30, progress: 1}, preferences)).then((shown) => {
        if (!shown)
          reject(new Error("Failed to create float window"));
      }).catch(reject);
      task2({
        report: (p) => {
          if (!this.bufnr)
            return;
          let text = "";
          if (p.message)
            text += p.message.replace(/\r?\n/g, " ");
          if (p.increment) {
            total += p.increment;
            text = text + (text.length ? ` ${total}%` : `${total}%`);
          }
          this.nvim.call("setbufline", [this.bufnr, 2, text], true);
        }
      }, tokenSource.token).then((res2) => {
        if (this._disposed)
          return;
        setTimeout(() => {
          this.dispose();
        }, 100);
        resolve3(res2);
      }, (err) => {
        if (this._disposed)
          return;
        this.dispose();
        if (err instanceof Error) {
          reject(err);
        } else {
          resolve3(void 0);
        }
      });
    });
    return res;
  }
  dispose() {
    super.dispose();
    this.tokenSource = void 0;
  }
};
var progress_default = ProgressNotification;

// node_modules/uuid/dist/esm-node/rng.js
var crypto = __toModule(require("crypto"));
function rng() {
  return crypto.default.randomBytes(16);
}

// node_modules/uuid/dist/esm-node/bytesToUuid.js
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 256).toString(16).substr(1);
}
function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join("");
}
var bytesToUuid_default = bytesToUuid;

// node_modules/uuid/dist/esm-node/v1.js
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf ? buf : bytesToUuid_default(b);
}
var v1_default = v1;

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  var i = buf && offset || 0;
  if (typeof options == "string") {
    buf = options === "binary" ? new Array(16) : null;
    options = null;
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }
  return buf || bytesToUuid_default(rnds);
}
var v4_default = v4;

// src/model/status.ts
var logger11 = require_logger2()("model-status");
var frames = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
var StatusLine = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.items = new Map();
    this.shownIds = new Set();
    this._text = "";
    this.interval = setInterval(() => {
      this.setStatusText().logError();
    }, 100);
  }
  dispose() {
    clearInterval(this.interval);
  }
  createStatusBarItem(priority = 0, isProgress = false) {
    let uid = v1_default();
    let item = {
      text: "",
      priority,
      isProgress,
      show: () => {
        this.shownIds.add(uid);
      },
      hide: () => {
        this.shownIds.delete(uid);
      },
      dispose: () => {
        this.shownIds.delete(uid);
        this.items.delete(uid);
      }
    };
    this.items.set(uid, item);
    return item;
  }
  getText() {
    if (this.shownIds.size == 0)
      return "";
    let d = new Date();
    let idx = Math.floor(d.getMilliseconds() / 100);
    let text = "";
    let items = [];
    for (let [id, item] of this.items) {
      if (this.shownIds.has(id)) {
        items.push(item);
      }
    }
    items.sort((a, b) => a.priority - b.priority);
    for (let item of items) {
      if (!item.isProgress) {
        text = `${text} ${item.text}`;
      } else {
        text = `${text} ${frames[idx]} ${item.text}`;
      }
    }
    return text;
  }
  async setStatusText() {
    let text = this.getText();
    let {nvim} = this;
    if (text != this._text) {
      this._text = text;
      nvim.pauseNotification();
      this.nvim.setVar("coc_status", text, true);
      this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
      await nvim.resumeNotification(false, true);
    }
  }
};
var status_default = StatusLine;

// src/types.ts
var PatternType;
(function(PatternType2) {
  PatternType2[PatternType2["Buffer"] = 0] = "Buffer";
  PatternType2[PatternType2["LanguageServer"] = 1] = "LanguageServer";
  PatternType2[PatternType2["Global"] = 2] = "Global";
})(PatternType || (PatternType = {}));
var ExtensionType;
(function(ExtensionType2) {
  ExtensionType2[ExtensionType2["Global"] = 0] = "Global";
  ExtensionType2[ExtensionType2["Local"] = 1] = "Local";
  ExtensionType2[ExtensionType2["SingleFile"] = 2] = "SingleFile";
  ExtensionType2[ExtensionType2["Internal"] = 3] = "Internal";
})(ExtensionType || (ExtensionType = {}));
var SourceType;
(function(SourceType2) {
  SourceType2[SourceType2["Native"] = 0] = "Native";
  SourceType2[SourceType2["Remote"] = 1] = "Remote";
  SourceType2[SourceType2["Service"] = 2] = "Service";
})(SourceType || (SourceType = {}));
var MessageLevel;
(function(MessageLevel2) {
  MessageLevel2[MessageLevel2["More"] = 0] = "More";
  MessageLevel2[MessageLevel2["Warning"] = 1] = "Warning";
  MessageLevel2[MessageLevel2["Error"] = 2] = "Error";
})(MessageLevel || (MessageLevel = {}));
var ConfigurationTarget;
(function(ConfigurationTarget3) {
  ConfigurationTarget3[ConfigurationTarget3["Global"] = 0] = "Global";
  ConfigurationTarget3[ConfigurationTarget3["User"] = 1] = "User";
  ConfigurationTarget3[ConfigurationTarget3["Workspace"] = 2] = "Workspace";
})(ConfigurationTarget || (ConfigurationTarget = {}));
var ServiceStat;
(function(ServiceStat2) {
  ServiceStat2[ServiceStat2["Initial"] = 0] = "Initial";
  ServiceStat2[ServiceStat2["Starting"] = 1] = "Starting";
  ServiceStat2[ServiceStat2["StartFailed"] = 2] = "StartFailed";
  ServiceStat2[ServiceStat2["Running"] = 3] = "Running";
  ServiceStat2[ServiceStat2["Stopping"] = 4] = "Stopping";
  ServiceStat2[ServiceStat2["Stopped"] = 5] = "Stopped";
})(ServiceStat || (ServiceStat = {}));

// src/workspace.ts
var bytes = __toModule(require_bytes());
var fast_diff2 = __toModule(require_diff2());
var fs_extra4 = __toModule(require_lib7());
var os7 = __toModule(require("os"));
var path21 = __toModule(require("path"));
var vscode_languageserver_protocol13 = __toModule(require_main3());
var which3 = __toModule(require_which());

// src/configuration/index.ts
var os3 = __toModule(require("os"));
var fs6 = __toModule(require("fs"));
var path7 = __toModule(require("path"));
var vscode_languageserver_protocol8 = __toModule(require_main3());

// src/configuration/util.ts
var vscode_languageserver_protocol7 = __toModule(require_main3());

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
"use strict";
var FullTextDocument = function() {
  function FullTextDocument2(uri, languageId, version2, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version2;
    this._content = content;
    this._lineOffsets = void 0;
  }
  Object.defineProperty(FullTextDocument2.prototype, "uri", {
    get: function() {
      return this._uri;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FullTextDocument2.prototype, "languageId", {
    get: function() {
      return this._languageId;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(FullTextDocument2.prototype, "version", {
    get: function() {
      return this._version;
    },
    enumerable: true,
    configurable: true
  });
  FullTextDocument2.prototype.getText = function(range2) {
    if (range2) {
      var start = this.offsetAt(range2.start);
      var end = this.offsetAt(range2.end);
      return this._content.substring(start, end);
    }
    return this._content;
  };
  FullTextDocument2.prototype.update = function(changes, version2) {
    for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
      var change = changes_1[_i];
      if (FullTextDocument2.isIncremental(change)) {
        var range2 = getWellformedRange(change.range);
        var startOffset = this.offsetAt(range2.start);
        var endOffset = this.offsetAt(range2.end);
        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
        var startLine = Math.max(range2.start.line, 0);
        var endLine = Math.max(range2.end.line, 0);
        var lineOffsets = this._lineOffsets;
        var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
        if (endLine - startLine === addedLineOffsets.length) {
          for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
            lineOffsets[i + startLine + 1] = addedLineOffsets[i];
          }
        } else {
          if (addedLineOffsets.length < 1e4) {
            lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));
          } else {
            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
          }
        }
        var diff3 = change.text.length - (endOffset - startOffset);
        if (diff3 !== 0) {
          for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
            lineOffsets[i] = lineOffsets[i] + diff3;
          }
        }
      } else if (FullTextDocument2.isFull(change)) {
        this._content = change.text;
        this._lineOffsets = void 0;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = version2;
  };
  FullTextDocument2.prototype.getLineOffsets = function() {
    if (this._lineOffsets === void 0) {
      this._lineOffsets = computeLineOffsets(this._content, true);
    }
    return this._lineOffsets;
  };
  FullTextDocument2.prototype.positionAt = function(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    var lineOffsets = this.getLineOffsets();
    var low = 0, high = lineOffsets.length;
    if (high === 0) {
      return {line: 0, character: offset};
    }
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    var line = low - 1;
    return {line, character: offset - lineOffsets[line]};
  };
  FullTextDocument2.prototype.offsetAt = function(position15) {
    var lineOffsets = this.getLineOffsets();
    if (position15.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position15.line < 0) {
      return 0;
    }
    var lineOffset = lineOffsets[position15.line];
    var nextLineOffset = position15.line + 1 < lineOffsets.length ? lineOffsets[position15.line + 1] : this._content.length;
    return Math.max(Math.min(lineOffset + position15.character, nextLineOffset), lineOffset);
  };
  Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
    get: function() {
      return this.getLineOffsets().length;
    },
    enumerable: true,
    configurable: true
  });
  FullTextDocument2.isIncremental = function(event) {
    var candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
  };
  FullTextDocument2.isFull = function(event) {
    var candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
  };
  return FullTextDocument2;
}();
var TextDocument;
(function(TextDocument5) {
  function create(uri, languageId, version2, content) {
    return new FullTextDocument(uri, languageId, version2, content);
  }
  TextDocument5.create = create;
  function update(document3, changes, version2) {
    if (document3 instanceof FullTextDocument) {
      document3.update(changes, version2);
      return document3;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  }
  TextDocument5.update = update;
  function applyEdits2(document3, edits) {
    var text = document3.getText();
    var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
      var diff3 = a.range.start.line - b.range.start.line;
      if (diff3 === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff3;
    });
    var lastModifiedOffset = 0;
    var spans = [];
    for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
      var e = sortedEdits_1[_i];
      var startOffset = document3.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) {
        throw new Error("Overlapping edit");
      } else if (startOffset > lastModifiedOffset) {
        spans.push(text.substring(lastModifiedOffset, startOffset));
      }
      if (e.newText.length) {
        spans.push(e.newText);
      }
      lastModifiedOffset = document3.offsetAt(e.range.end);
    }
    spans.push(text.substr(lastModifiedOffset));
    return spans.join("");
  }
  TextDocument5.applyEdits = applyEdits2;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  var p = data.length / 2 | 0;
  var left = data.slice(0, p);
  var right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  var leftIdx = 0;
  var rightIdx = 0;
  var i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    var ret2 = compare(left[leftIdx], right[rightIdx]);
    if (ret2 <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset) {
  if (textOffset === void 0) {
    textOffset = 0;
  }
  var result = isAtLineStart ? [textOffset] : [];
  for (var i = 0; i < text.length; i++) {
    var ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function getWellformedRange(range2) {
  var start = range2.start;
  var end = range2.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return {start: end, end: start};
  }
  return range2;
}
function getWellformedEdit(textEdit) {
  var range2 = getWellformedRange(textEdit.range);
  if (range2 !== textEdit.range) {
    return {newText: textEdit.newText, range: range2};
  }
  return textEdit;
}

// node_modules/jsonc-parser/lib/esm/impl/scanner.js
"use strict";
function createScanner(text, ignoreTrivia) {
  if (ignoreTrivia === void 0) {
    ignoreTrivia = false;
  }
  var len = text.length;
  var pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count, exact) {
    var digits = 0;
    var value2 = 0;
    while (digits < count || !exact) {
      var ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    var start = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start, pos);
      }
    }
    var end = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start, end);
  }
  function scanString() {
    var result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start, pos);
        scanError = 2;
        break;
      }
      var ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        var ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            var ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    var code = text.charCodeAt(pos);
    if (isWhiteSpace(code)) {
      do {
        pos++;
        value += String.fromCharCode(code);
        code = text.charCodeAt(pos);
      } while (isWhiteSpace(code));
      return token = 15;
    }
    if (isLineBreak(code)) {
      pos++;
      value += String.fromCharCode(code);
      if (code === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code) {
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      case 47:
        var start = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          var safeLength = len - 1;
          var commentClosed = false;
          while (pos < safeLength) {
            var ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
      case 45:
        value += String.fromCharCode(code);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      default:
        while (pos < len && isUnknownContentCharacter(code)) {
          pos++;
          code = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code) {
    if (isWhiteSpace(code) || isLineBreak(code)) {
      return false;
    }
    switch (code) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    var result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: function() {
      return pos;
    },
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: function() {
      return token;
    },
    getTokenValue: function() {
      return value;
    },
    getTokenOffset: function() {
      return tokenOffset;
    },
    getTokenLength: function() {
      return pos - tokenOffset;
    },
    getTokenStartLine: function() {
      return lineStartOffset;
    },
    getTokenStartCharacter: function() {
      return tokenOffset - prevTokenLineStartOffset;
    },
    getTokenError: function() {
      return scanError;
    }
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch === 5760 || ch >= 8192 && ch <= 8203 || ch === 8239 || ch === 8287 || ch === 12288 || ch === 65279;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}

// node_modules/jsonc-parser/lib/esm/impl/format.js
"use strict";
function format(documentText, range2, options) {
  var initialIndentLevel;
  var formatText;
  var formatTextStart;
  var rangeStart;
  var rangeEnd;
  if (range2) {
    rangeStart = range2.offset;
    rangeEnd = rangeStart + range2.length;
    formatTextStart = rangeStart;
    while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
      formatTextStart--;
    }
    var endOffset = rangeEnd;
    while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
      endOffset++;
    }
    formatText = documentText.substring(formatTextStart, endOffset);
    initialIndentLevel = computeIndentLevel(formatText, options);
  } else {
    formatText = documentText;
    initialIndentLevel = 0;
    formatTextStart = 0;
    rangeStart = 0;
    rangeEnd = documentText.length;
  }
  var eol = getEOL(options, documentText);
  var lineBreak = false;
  var indentLevel = 0;
  var indentValue;
  if (options.insertSpaces) {
    indentValue = repeat(" ", options.tabSize || 4);
  } else {
    indentValue = "	";
  }
  var scanner4 = createScanner(formatText, false);
  var hasError = false;
  function newLineAndIndent() {
    return eol + repeat(indentValue, initialIndentLevel + indentLevel);
  }
  function scanNext() {
    var token = scanner4.scan();
    lineBreak = false;
    while (token === 15 || token === 14) {
      lineBreak = lineBreak || token === 14;
      token = scanner4.scan();
    }
    hasError = token === 16 || scanner4.getTokenError() !== 0;
    return token;
  }
  var editOperations = [];
  function addEdit(text, startOffset, endOffset2) {
    if (!hasError && startOffset < rangeEnd && endOffset2 > rangeStart && documentText.substring(startOffset, endOffset2) !== text) {
      editOperations.push({offset: startOffset, length: endOffset2 - startOffset, content: text});
    }
  }
  var firstToken = scanNext();
  if (firstToken !== 17) {
    var firstTokenStart = scanner4.getTokenOffset() + formatTextStart;
    var initialIndent = repeat(indentValue, initialIndentLevel);
    addEdit(initialIndent, formatTextStart, firstTokenStart);
  }
  while (firstToken !== 17) {
    var firstTokenEnd = scanner4.getTokenOffset() + scanner4.getTokenLength() + formatTextStart;
    var secondToken = scanNext();
    var replaceContent = "";
    while (!lineBreak && (secondToken === 12 || secondToken === 13)) {
      var commentTokenStart = scanner4.getTokenOffset() + formatTextStart;
      addEdit(" ", firstTokenEnd, commentTokenStart);
      firstTokenEnd = scanner4.getTokenOffset() + scanner4.getTokenLength() + formatTextStart;
      replaceContent = secondToken === 12 ? newLineAndIndent() : "";
      secondToken = scanNext();
    }
    if (secondToken === 2) {
      if (firstToken !== 1) {
        indentLevel--;
        replaceContent = newLineAndIndent();
      }
    } else if (secondToken === 4) {
      if (firstToken !== 3) {
        indentLevel--;
        replaceContent = newLineAndIndent();
      }
    } else {
      switch (firstToken) {
        case 3:
        case 1:
          indentLevel++;
          replaceContent = newLineAndIndent();
          break;
        case 5:
        case 12:
          replaceContent = newLineAndIndent();
          break;
        case 13:
          if (lineBreak) {
            replaceContent = newLineAndIndent();
          } else {
            replaceContent = " ";
          }
          break;
        case 6:
          replaceContent = " ";
          break;
        case 10:
          if (secondToken === 6) {
            replaceContent = "";
            break;
          }
        case 7:
        case 8:
        case 9:
        case 11:
        case 2:
        case 4:
          if (secondToken === 12 || secondToken === 13) {
            replaceContent = " ";
          } else if (secondToken !== 5 && secondToken !== 17) {
            hasError = true;
          }
          break;
        case 16:
          hasError = true;
          break;
      }
      if (lineBreak && (secondToken === 12 || secondToken === 13)) {
        replaceContent = newLineAndIndent();
      }
    }
    var secondTokenStart = scanner4.getTokenOffset() + formatTextStart;
    addEdit(replaceContent, firstTokenEnd, secondTokenStart);
    firstToken = secondToken;
  }
  return editOperations;
}
function repeat(s, count) {
  var result = "";
  for (var i = 0; i < count; i++) {
    result += s;
  }
  return result;
}
function computeIndentLevel(content, options) {
  var i = 0;
  var nChars = 0;
  var tabSize = options.tabSize || 4;
  while (i < content.length) {
    var ch = content.charAt(i);
    if (ch === " ") {
      nChars++;
    } else if (ch === "	") {
      nChars += tabSize;
    } else {
      break;
    }
    i++;
  }
  return Math.floor(nChars / tabSize);
}
function getEOL(options, text) {
  for (var i = 0; i < text.length; i++) {
    var ch = text.charAt(i);
    if (ch === "\r") {
      if (i + 1 < text.length && text.charAt(i + 1) === "\n") {
        return "\r\n";
      }
      return "\r";
    } else if (ch === "\n") {
      return "\n";
    }
  }
  return options && options.eol || "\n";
}
function isEOL(text, offset) {
  return "\r\n".indexOf(text.charAt(offset)) !== -1;
}

// node_modules/jsonc-parser/lib/esm/impl/parser.js
"use strict";
var ParseOptions;
(function(ParseOptions2) {
  ParseOptions2.DEFAULT = {
    allowTrailingComma: false
  };
})(ParseOptions || (ParseOptions = {}));
function parse(text, errors, options) {
  if (errors === void 0) {
    errors = [];
  }
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var currentProperty = null;
  var currentParent = [];
  var previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  var visitor = {
    onObjectBegin: function() {
      var object15 = {};
      onValue(object15);
      previousParents.push(currentParent);
      currentParent = object15;
      currentProperty = null;
    },
    onObjectProperty: function(name2) {
      currentProperty = name2;
    },
    onObjectEnd: function() {
      currentParent = previousParents.pop();
    },
    onArrayBegin: function() {
      var array6 = [];
      onValue(array6);
      previousParents.push(currentParent);
      currentParent = array6;
      currentProperty = null;
    },
    onArrayEnd: function() {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: function(error, offset, length) {
      errors.push({error, offset, length});
    }
  };
  visit(text, visitor, options);
  return currentParent[0];
}
function parseTree(text, errors, options) {
  if (errors === void 0) {
    errors = [];
  }
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var currentParent = {type: "array", offset: -1, length: -1, children: [], parent: void 0};
  function ensurePropertyComplete(endOffset) {
    if (currentParent.type === "property") {
      currentParent.length = endOffset - currentParent.offset;
      currentParent = currentParent.parent;
    }
  }
  function onValue(valueNode) {
    currentParent.children.push(valueNode);
    return valueNode;
  }
  var visitor = {
    onObjectBegin: function(offset) {
      currentParent = onValue({type: "object", offset, length: -1, parent: currentParent, children: []});
    },
    onObjectProperty: function(name2, offset, length) {
      currentParent = onValue({type: "property", offset, length: -1, parent: currentParent, children: []});
      currentParent.children.push({type: "string", value: name2, offset, length, parent: currentParent});
    },
    onObjectEnd: function(offset, length) {
      ensurePropertyComplete(offset + length);
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onArrayBegin: function(offset, length) {
      currentParent = onValue({type: "array", offset, length: -1, parent: currentParent, children: []});
    },
    onArrayEnd: function(offset, length) {
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onLiteralValue: function(value, offset, length) {
      onValue({type: getNodeType(value), offset, length, parent: currentParent, value});
      ensurePropertyComplete(offset + length);
    },
    onSeparator: function(sep, offset, length) {
      if (currentParent.type === "property") {
        if (sep === ":") {
          currentParent.colonOffset = offset;
        } else if (sep === ",") {
          ensurePropertyComplete(offset);
        }
      }
    },
    onError: function(error, offset, length) {
      errors.push({error, offset, length});
    }
  };
  visit(text, visitor, options);
  var result = currentParent.children[0];
  if (result) {
    delete result.parent;
  }
  return result;
}
function findNodeAtLocation(root, path66) {
  if (!root) {
    return void 0;
  }
  var node = root;
  for (var _i = 0, path_1 = path66; _i < path_1.length; _i++) {
    var segment = path_1[_i];
    if (typeof segment === "string") {
      if (node.type !== "object" || !Array.isArray(node.children)) {
        return void 0;
      }
      var found = false;
      for (var _a2 = 0, _b = node.children; _a2 < _b.length; _a2++) {
        var propertyNode = _b[_a2];
        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
          node = propertyNode.children[1];
          found = true;
          break;
        }
      }
      if (!found) {
        return void 0;
      }
    } else {
      var index = segment;
      if (node.type !== "array" || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
        return void 0;
      }
      node = node.children[index];
    }
  }
  return node;
}
function visit(text, visitor, options) {
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var _scanner = createScanner(text, false);
  function toNoArgVisit(visitFunction) {
    return visitFunction ? function() {
      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? function(arg) {
      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  var disallowComments = options && options.disallowComments;
  var allowTrailingComma = options && options.allowTrailingComma;
  function scanNext() {
    while (true) {
      var token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(14);
          break;
        case 5:
          handleError(15);
          break;
        case 3:
          handleError(13);
          break;
        case 1:
          if (!disallowComments) {
            handleError(11);
          }
          break;
        case 2:
          handleError(12);
          break;
        case 6:
          handleError(16);
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(10);
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(1);
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error, skipUntilAfter, skipUntil) {
    if (skipUntilAfter === void 0) {
      skipUntilAfter = [];
    }
    if (skipUntil === void 0) {
      skipUntil = [];
    }
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      var token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    var value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        var tokenValue = _scanner.getTokenValue();
        var value = Number(tokenValue);
        if (isNaN(value)) {
          handleError(2);
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [2, 5]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [2, 5]);
      }
    } else {
      handleError(5, [], [2, 5]);
    }
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [2, 5]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [2], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseValue()) {
        handleError(4, [], [4, 5]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (_scanner.getToken() !== 4) {
      handleError(8, [4], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}
function getNodeType(value) {
  switch (typeof value) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    case "object": {
      if (!value) {
        return "null";
      } else if (Array.isArray(value)) {
        return "array";
      }
      return "object";
    }
    default:
      return "null";
  }
}

// node_modules/jsonc-parser/lib/esm/impl/edit.js
"use strict";
function setProperty(text, originalPath, value, options) {
  var _a2;
  var path66 = originalPath.slice();
  var errors = [];
  var root = parseTree(text, errors);
  var parent = void 0;
  var lastSegment = void 0;
  while (path66.length > 0) {
    lastSegment = path66.pop();
    parent = findNodeAtLocation(root, path66);
    if (parent === void 0 && value !== void 0) {
      if (typeof lastSegment === "string") {
        value = (_a2 = {}, _a2[lastSegment] = value, _a2);
      } else {
        value = [value];
      }
    } else {
      break;
    }
  }
  if (!parent) {
    if (value === void 0) {
      throw new Error("Can not delete in empty document");
    }
    return withFormatting(text, {offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value)}, options);
  } else if (parent.type === "object" && typeof lastSegment === "string" && Array.isArray(parent.children)) {
    var existing = findNodeAtLocation(parent, [lastSegment]);
    if (existing !== void 0) {
      if (value === void 0) {
        if (!existing.parent) {
          throw new Error("Malformed AST");
        }
        var propertyIndex = parent.children.indexOf(existing.parent);
        var removeBegin = void 0;
        var removeEnd = existing.parent.offset + existing.parent.length;
        if (propertyIndex > 0) {
          var previous = parent.children[propertyIndex - 1];
          removeBegin = previous.offset + previous.length;
        } else {
          removeBegin = parent.offset + 1;
          if (parent.children.length > 1) {
            var next = parent.children[1];
            removeEnd = next.offset;
          }
        }
        return withFormatting(text, {offset: removeBegin, length: removeEnd - removeBegin, content: ""}, options);
      } else {
        return withFormatting(text, {offset: existing.offset, length: existing.length, content: JSON.stringify(value)}, options);
      }
    } else {
      if (value === void 0) {
        return [];
      }
      var newProperty = JSON.stringify(lastSegment) + ": " + JSON.stringify(value);
      var index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(function(p) {
        return p.children[0].value;
      })) : parent.children.length;
      var edit2 = void 0;
      if (index > 0) {
        var previous = parent.children[index - 1];
        edit2 = {offset: previous.offset + previous.length, length: 0, content: "," + newProperty};
      } else if (parent.children.length === 0) {
        edit2 = {offset: parent.offset + 1, length: 0, content: newProperty};
      } else {
        edit2 = {offset: parent.offset + 1, length: 0, content: newProperty + ","};
      }
      return withFormatting(text, edit2, options);
    }
  } else if (parent.type === "array" && typeof lastSegment === "number" && Array.isArray(parent.children)) {
    var insertIndex = lastSegment;
    if (insertIndex === -1) {
      var newProperty = "" + JSON.stringify(value);
      var edit2 = void 0;
      if (parent.children.length === 0) {
        edit2 = {offset: parent.offset + 1, length: 0, content: newProperty};
      } else {
        var previous = parent.children[parent.children.length - 1];
        edit2 = {offset: previous.offset + previous.length, length: 0, content: "," + newProperty};
      }
      return withFormatting(text, edit2, options);
    } else if (value === void 0 && parent.children.length >= 0) {
      var removalIndex = lastSegment;
      var toRemove = parent.children[removalIndex];
      var edit2 = void 0;
      if (parent.children.length === 1) {
        edit2 = {offset: parent.offset + 1, length: parent.length - 2, content: ""};
      } else if (parent.children.length - 1 === removalIndex) {
        var previous = parent.children[removalIndex - 1];
        var offset = previous.offset + previous.length;
        var parentEndOffset = parent.offset + parent.length;
        edit2 = {offset, length: parentEndOffset - 2 - offset, content: ""};
      } else {
        edit2 = {offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: ""};
      }
      return withFormatting(text, edit2, options);
    } else if (value !== void 0) {
      var edit2 = void 0;
      var newProperty = "" + JSON.stringify(value);
      if (!options.isArrayInsertion && parent.children.length > lastSegment) {
        var toModify = parent.children[lastSegment];
        edit2 = {offset: toModify.offset, length: toModify.length, content: newProperty};
      } else if (parent.children.length === 0 || lastSegment === 0) {
        edit2 = {offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + ","};
      } else {
        var index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
        var previous = parent.children[index - 1];
        edit2 = {offset: previous.offset + previous.length, length: 0, content: "," + newProperty};
      }
      return withFormatting(text, edit2, options);
    } else {
      throw new Error("Can not " + (value === void 0 ? "remove" : options.isArrayInsertion ? "insert" : "modify") + " Array index " + insertIndex + " as length is not sufficient");
    }
  } else {
    throw new Error("Can not add " + (typeof lastSegment !== "number" ? "index" : "property") + " to parent of type " + parent.type);
  }
}
function withFormatting(text, edit2, options) {
  if (!options.formattingOptions) {
    return [edit2];
  }
  var newText = applyEdit(text, edit2);
  var begin = edit2.offset;
  var end = edit2.offset + edit2.content.length;
  if (edit2.length === 0 || edit2.content.length === 0) {
    while (begin > 0 && !isEOL(newText, begin - 1)) {
      begin--;
    }
    while (end < newText.length && !isEOL(newText, end)) {
      end++;
    }
  }
  var edits = format(newText, {offset: begin, length: end - begin}, options.formattingOptions);
  for (var i = edits.length - 1; i >= 0; i--) {
    var edit_1 = edits[i];
    newText = applyEdit(newText, edit_1);
    begin = Math.min(begin, edit_1.offset);
    end = Math.max(end, edit_1.offset + edit_1.length);
    end += edit_1.content.length - edit_1.length;
  }
  var editLength = text.length - (newText.length - end) - begin;
  return [{offset: begin, length: editLength, content: newText.substring(begin, end)}];
}
function applyEdit(text, edit2) {
  return text.substring(0, edit2.offset) + edit2.content + text.substring(edit2.offset + edit2.length);
}

// node_modules/jsonc-parser/lib/esm/main.js
"use strict";
var parse2 = parse;
function modify(text, path66, value, options) {
  return setProperty(text, path66, value, options);
}
function applyEdits(text, edits) {
  for (var i = edits.length - 1; i >= 0; i--) {
    text = applyEdit(text, edits[i]);
  }
  return text;
}

// src/configuration/util.ts
var fs3 = __toModule(require("fs"));
var path3 = __toModule(require("path"));
var logger12 = require_logger2()("configuration-util");
var pluginRoot = path3.dirname(__dirname);
function parseContentFromFile(filepath, onError) {
  if (!filepath || !fs3.default.existsSync(filepath))
    return {contents: {}};
  let content;
  let uri = URI.file(filepath).toString();
  try {
    content = fs3.default.readFileSync(filepath, "utf8");
  } catch (_e) {
    content = "";
  }
  let [errors, contents] = parseConfiguration(content);
  if (errors && errors.length) {
    onError(convertErrors(uri, content, errors));
  }
  return {contents};
}
function parseConfiguration(content) {
  if (content.length == 0)
    return [[], {}];
  let errors = [];
  let data = parse2(content, errors, {allowTrailingComma: true});
  function addProperty(current, key, remains, value) {
    if (remains.length == 0) {
      current[key] = convert5(value);
    } else {
      if (!current[key])
        current[key] = {};
      let o = current[key];
      let first = remains.shift();
      addProperty(o, first, remains, value);
    }
  }
  function convert5(obj, split = false) {
    if (!objectLiteral(obj))
      return obj;
    if (emptyObject(obj))
      return {};
    let dest = {};
    for (let key of Object.keys(obj)) {
      if (split && key.includes(".")) {
        let parts = key.split(".");
        let first = parts.shift();
        addProperty(dest, first, parts, obj[key]);
      } else {
        dest[key] = convert5(obj[key]);
      }
    }
    return dest;
  }
  return [errors, convert5(data, true)];
}
function convertErrors(uri, content, errors) {
  let items = [];
  let document3 = TextDocument.create(uri, "json", 0, content);
  for (let err of errors) {
    let msg = "parse error";
    switch (err.error) {
      case 2:
        msg = "invalid number";
        break;
      case 8:
        msg = "close brace expected";
        break;
      case 5:
        msg = "colon expected";
        break;
      case 6:
        msg = "comma expected";
        break;
      case 9:
        msg = "end of file expected";
        break;
      case 16:
        msg = "invaliad character";
        break;
      case 10:
        msg = "invalid commment token";
        break;
      case 15:
        msg = "invalid escape character";
        break;
      case 1:
        msg = "invalid symbol";
        break;
      case 14:
        msg = "invalid unicode";
        break;
      case 3:
        msg = "property name expected";
        break;
      case 13:
        msg = "unexpected end of number";
        break;
      case 12:
        msg = "unexpected end of string";
        break;
      case 11:
        msg = "unexpected end of comment";
        break;
      case 4:
        msg = "value expected";
        break;
      default:
        msg = "Unknwn error";
        break;
    }
    let range2 = {
      start: document3.positionAt(err.offset),
      end: document3.positionAt(err.offset + err.length)
    };
    let loc = vscode_languageserver_protocol7.Location.create(uri, range2);
    items.push({location: loc, message: msg});
  }
  return items;
}
function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
  const segments = key.split(".");
  const last = segments.pop();
  let curr = settingsTreeRoot;
  for (let i = 0; i < segments.length; i++) {
    let s = segments[i];
    let obj = curr[s];
    switch (typeof obj) {
      case "function": {
        obj = curr[s] = {};
        break;
      }
      case "undefined": {
        obj = curr[s] = {};
        break;
      }
      case "object":
        break;
      default:
        conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join(".")} is ${JSON.stringify(obj)}`);
        return;
    }
    curr = obj;
  }
  if (typeof curr === "object") {
    curr[last] = value;
  } else {
    conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
  }
}
function removeFromValueTree(valueTree, key) {
  const segments = key.split(".");
  doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
  const first = segments.shift();
  if (segments.length === 0) {
    delete valueTree[first];
    return;
  }
  if (Object.keys(valueTree).includes(first)) {
    const value = valueTree[first];
    if (typeof value === "object" && !Array.isArray(value)) {
      doRemoveFromValueTree(value, segments);
      if (Object.keys(value).length === 0) {
        delete valueTree[first];
      }
    }
  }
}
function getConfigurationValue(config, settingPath, defaultValue) {
  function accessSetting(config2, path67) {
    let current = config2;
    for (let i = 0; i < path67.length; i++) {
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[path67[i]];
    }
    return current;
  }
  const path66 = settingPath.split(".");
  const result = accessSetting(config, path66);
  return typeof result === "undefined" ? defaultValue : result;
}
function loadDefaultConfigurations() {
  let file = path3.default.join(pluginRoot, "data/schema.json");
  if (!fs3.default.existsSync(file)) {
    console.error("schema.json not found, reinstall coc.nvim to fix this!");
    return {contents: {}};
  }
  let content = fs3.default.readFileSync(file, "utf8");
  let {properties} = JSON.parse(content);
  let config = {};
  Object.keys(properties).forEach((key) => {
    let value = properties[key].default;
    if (value !== void 0) {
      addToValueTree(config, key, value, (message) => {
        logger12.error(message);
      });
    }
  });
  return {contents: config};
}
function getKeys(obj, curr) {
  let keys = [];
  for (let key of Object.keys(obj)) {
    let val = obj[key];
    let newKey = curr ? `${curr}.${key}` : key;
    keys.push(newKey);
    if (objectLiteral(val)) {
      keys.push(...getKeys(val, newKey));
    }
  }
  return keys;
}
function getChangedKeys(from, to) {
  let keys = [];
  let fromKeys = getKeys(from);
  let toKeys = getKeys(to);
  const added = toKeys.filter((key) => !fromKeys.includes(key));
  const removed = fromKeys.filter((key) => !toKeys.includes(key));
  keys.push(...added);
  keys.push(...removed);
  for (const key of fromKeys) {
    if (!toKeys.includes(key))
      continue;
    const value1 = getConfigurationValue(from, key);
    const value2 = getConfigurationValue(to, key);
    if (!equals(value1, value2)) {
      keys.push(key);
    }
  }
  return keys;
}

// src/configuration/model.ts
var ConfigurationModel = class {
  constructor(_contents = {}) {
    this._contents = _contents;
  }
  get contents() {
    return this._contents;
  }
  clone() {
    return new ConfigurationModel(deepClone(this._contents));
  }
  getValue(section2) {
    let res = section2 ? getConfigurationValue(this.contents, section2) : this.contents;
    return res;
  }
  merge(...others) {
    const contents = deepClone(this.contents);
    for (const other of others) {
      this.mergeContents(contents, other.contents);
    }
    return new ConfigurationModel(contents);
  }
  freeze() {
    if (!Object.isFrozen(this._contents)) {
      Object.freeze(this._contents);
    }
    return this;
  }
  mergeContents(source3, target) {
    for (const key of Object.keys(target)) {
      if (key in source3) {
        if (objectLiteral(source3[key]) && objectLiteral(target[key])) {
          this.mergeContents(source3[key], target[key]);
          continue;
        }
      }
      source3[key] = deepClone(target[key]);
    }
  }
  setValue(key, value) {
    addToValueTree(this.contents, key, value, (message) => {
      console.error(message);
    });
  }
  removeValue(key) {
    removeFromValueTree(this.contents, key);
  }
};

// src/configuration/configuration.ts
var Configuration = class {
  constructor(_defaultConfiguration, _userConfiguration, _workspaceConfiguration, _memoryConfiguration = new ConfigurationModel()) {
    this._defaultConfiguration = _defaultConfiguration;
    this._userConfiguration = _userConfiguration;
    this._workspaceConfiguration = _workspaceConfiguration;
    this._memoryConfiguration = _memoryConfiguration;
  }
  getConsolidateConfiguration() {
    if (!this._consolidateConfiguration) {
      this._consolidateConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
      this._consolidateConfiguration = this._consolidateConfiguration.freeze();
    }
    return this._consolidateConfiguration;
  }
  getValue(section2) {
    let configuration7 = this.getConsolidateConfiguration();
    return configuration7.getValue(section2);
  }
  inspect(key) {
    const consolidateConfigurationModel = this.getConsolidateConfiguration();
    const {_workspaceConfiguration, _memoryConfiguration} = this;
    return {
      default: this._defaultConfiguration.freeze().getValue(key),
      user: this._userConfiguration.freeze().getValue(key),
      workspace: _workspaceConfiguration.freeze().getValue(key),
      memory: _memoryConfiguration.freeze().getValue(key),
      value: consolidateConfigurationModel.getValue(key)
    };
  }
  get defaults() {
    return this._defaultConfiguration;
  }
  get user() {
    return this._userConfiguration;
  }
  get workspace() {
    return this._workspaceConfiguration;
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents
      },
      user: {
        contents: this._userConfiguration.contents
      },
      workspace: {
        contents: this._workspaceConfiguration.contents
      }
    };
  }
};

// src/util/fs.ts
var child_process2 = __toModule(require("child_process"));
var fs_extra = __toModule(require_lib7());
var net = __toModule(require("net"));
var os = __toModule(require("os"));
var path5 = __toModule(require("path"));
var readline = __toModule(require("readline"));
var util9 = __toModule(require("util"));
var minimatch = __toModule(require_minimatch());
var logger13 = require_logger2()("util-fs");
async function statAsync(filepath) {
  let stat = null;
  try {
    stat = await fs_extra.default.stat(filepath);
  } catch (e) {
  }
  return stat;
}
function renameAsync(oldPath, newPath) {
  return new Promise((resolve3, reject) => {
    fs_extra.default.rename(oldPath, newPath, (err) => {
      if (err)
        return reject(err);
      resolve3();
    });
  });
}
function resolveRoot(folder, subs, cwd) {
  let home = os.default.homedir();
  let dir = fixDriver(folder);
  if (isParentFolder(dir, home, true))
    return null;
  if (cwd && isParentFolder(cwd, dir, true) && inDirectory(cwd, subs))
    return cwd;
  let parts = dir.split(path5.default.sep);
  let curr = [parts.shift()];
  for (let part of parts) {
    curr.push(part);
    let dir2 = curr.join(path5.default.sep);
    if (dir2 != home && inDirectory(dir2, subs)) {
      return dir2;
    }
  }
  return null;
}
function inDirectory(dir, subs) {
  try {
    let files = fs_extra.default.readdirSync(dir);
    for (let pattern of subs) {
      let is_wildcard = pattern.includes("*");
      let res = is_wildcard ? minimatch.default.match(files, pattern, {nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true}).length !== 0 : files.includes(pattern);
      if (res)
        return true;
    }
  } catch (e) {
  }
  return false;
}
function findUp(name2, cwd) {
  let root = path5.default.parse(cwd).root;
  let subs = Array.isArray(name2) ? name2 : [name2];
  while (cwd && cwd !== root) {
    let find = inDirectory(cwd, subs);
    if (find) {
      for (let sub of subs) {
        let filepath = path5.default.join(cwd, sub);
        if (fs_extra.default.existsSync(filepath)) {
          return filepath;
        }
      }
    }
    cwd = path5.default.dirname(cwd);
  }
  return null;
}
function readFile(fullpath, encoding) {
  return new Promise((resolve3, reject) => {
    fs_extra.default.readFile(fullpath, encoding, (err, content) => {
      if (err)
        reject(err);
      resolve3(content);
    });
  });
}
function getFileLineCount(filepath) {
  let i;
  let count = 0;
  return new Promise((resolve3, reject) => {
    fs_extra.default.createReadStream(filepath).on("error", (e) => reject(e)).on("data", (chunk) => {
      for (i = 0; i < chunk.length; ++i)
        if (chunk[i] == 10)
          count++;
    }).on("end", () => resolve3(count));
  });
}
function readFileLines(fullpath, start, end) {
  if (!fs_extra.default.existsSync(fullpath)) {
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  }
  let res = [];
  const rl = readline.default.createInterface({
    input: fs_extra.default.createReadStream(fullpath, {encoding: "utf8"}),
    crlfDelay: Infinity,
    terminal: false
  });
  let n = 0;
  return new Promise((resolve3, reject) => {
    rl.on("line", (line) => {
      if (n == 0 && line.startsWith("\uFEFF")) {
        line = line.slice(1);
      }
      if (n >= start && n <= end) {
        res.push(line);
      }
      if (n == end) {
        rl.close();
      }
      n = n + 1;
    });
    rl.on("close", () => {
      resolve3(res);
    });
    rl.on("error", reject);
  });
}
function readFileLine(fullpath, count) {
  if (!fs_extra.default.existsSync(fullpath)) {
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  }
  const rl = readline.default.createInterface({
    input: fs_extra.default.createReadStream(fullpath, {encoding: "utf8"}),
    crlfDelay: Infinity,
    terminal: false
  });
  let n = 0;
  return new Promise((resolve3, reject) => {
    rl.on("line", (line) => {
      if (n == count) {
        if (n == 0 && line.startsWith("\uFEFF")) {
          line = line.slice(1);
        }
        rl.close();
        resolve3(line);
        return;
      }
      n = n + 1;
    });
    rl.on("error", reject);
  });
}
async function writeFile(fullpath, content) {
  await fs_extra.default.writeFile(fullpath, content, {encoding: "utf8"});
}
function isFile(uri) {
  return uri.startsWith("file:");
}
function isParentFolder(folder, filepath, checkEqual = false) {
  let pdir = fixDriver(path5.default.resolve(path5.default.normalize(folder)));
  let dir = fixDriver(path5.default.resolve(path5.default.normalize(filepath)));
  if (pdir == "//")
    pdir = "/";
  if (pdir == dir)
    return checkEqual ? true : false;
  if (pdir.endsWith(path5.default.sep))
    return dir.startsWith(pdir);
  return dir.startsWith(pdir) && dir[pdir.length] == path5.default.sep;
}
function fixDriver(filepath) {
  if (os.default.platform() != "win32" || filepath[1] != ":")
    return filepath;
  return filepath[0].toUpperCase() + filepath.slice(1);
}

// src/configuration/index.ts
var logger14 = require_logger2()("configurations");
function lookUp(tree, key) {
  if (key) {
    if (tree && tree.hasOwnProperty(key))
      return tree[key];
    const parts = key.split(".");
    let node = tree;
    for (let i = 0; node && i < parts.length; i++) {
      node = node[parts[i]];
    }
    return node;
  }
  return tree;
}
var Configurations = class {
  constructor(userConfigFile, _proxy) {
    this.userConfigFile = userConfigFile;
    this._proxy = _proxy;
    this._errorItems = [];
    this._folderConfigurations = new Map();
    this._onError = new vscode_languageserver_protocol8.Emitter();
    this._onChange = new vscode_languageserver_protocol8.Emitter();
    this.disposables = [];
    this.onError = this._onError.event;
    this.onDidChange = this._onChange.event;
    let user = this.parseContentFromFile(userConfigFile);
    let data = {
      defaults: loadDefaultConfigurations(),
      user,
      workspace: {contents: {}}
    };
    this._configuration = Configurations.parse(data);
    this.watchFile(userConfigFile, ConfigurationTarget.User);
    let folderConfigFile = path7.default.join(process.cwd(), `.vim/${CONFIG_FILE_NAME}`);
    if (folderConfigFile != userConfigFile && fs6.default.existsSync(folderConfigFile)) {
      this.addFolderFile(folderConfigFile);
    }
  }
  parseContentFromFile(filepath) {
    if (!filepath)
      return {contents: {}};
    let uri = URI.file(filepath).toString();
    this._errorItems = this._errorItems.filter((o) => o.location.uri != uri);
    let res = parseContentFromFile(filepath, (errors) => {
      this._errorItems.push(...errors);
    });
    this._onError.fire(this._errorItems);
    return res;
  }
  get errorItems() {
    return this._errorItems;
  }
  get foldConfigurations() {
    return this._folderConfigurations;
  }
  extendsDefaults(props) {
    let {defaults: defaults2} = this._configuration;
    let {contents} = defaults2;
    contents = deepClone(contents);
    Object.keys(props).forEach((key) => {
      addToValueTree(contents, key, props[key], (msg) => {
        logger14.error(msg);
      });
    });
    let data = {
      defaults: {contents},
      user: this._configuration.user,
      workspace: this._configuration.workspace
    };
    this._configuration = Configurations.parse(data);
  }
  updateUserConfig(props) {
    if (!props || Object.keys(props).length == 0)
      return;
    let {user} = this._configuration;
    let model3 = user.clone();
    Object.keys(props).forEach((key) => {
      let val = props[key];
      if (val === void 0) {
        model3.removeValue(key);
      } else if (objectLiteral(val)) {
        for (let k of Object.keys(val)) {
          model3.setValue(`${key}.${k}`, val[k]);
        }
      } else {
        model3.setValue(key, val);
      }
    });
    this.changeConfiguration(ConfigurationTarget.User, model3);
  }
  get defaults() {
    return this._configuration.defaults;
  }
  get user() {
    return this._configuration.user;
  }
  get workspace() {
    return this._configuration.workspace;
  }
  addFolderFile(filepath) {
    let {_folderConfigurations} = this;
    if (_folderConfigurations.has(filepath))
      return;
    if (path7.default.resolve(filepath, "../..") == os3.default.homedir())
      return;
    let model3 = this.parseContentFromFile(filepath);
    this.watchFile(filepath, ConfigurationTarget.Workspace);
    this.changeConfiguration(ConfigurationTarget.Workspace, model3, filepath);
  }
  watchFile(filepath, target) {
    if (!fs6.default.existsSync(filepath) || global.hasOwnProperty("__TEST__"))
      return;
    let disposable = watchFile(filepath, () => {
      let model3 = this.parseContentFromFile(filepath);
      this.changeConfiguration(target, model3, filepath);
    });
    this.disposables.push(disposable);
  }
  changeConfiguration(target, model3, configFile) {
    let {defaults: defaults2, user, workspace: workspace52} = this._configuration;
    let {workspaceConfigFile} = this;
    let data = {
      defaults: target == ConfigurationTarget.Global ? model3 : defaults2,
      user: target == ConfigurationTarget.User ? model3 : user,
      workspace: target == ConfigurationTarget.Workspace ? model3 : workspace52
    };
    let configuration7 = Configurations.parse(data);
    let changed = getChangedKeys(this._configuration.getValue(), configuration7.getValue());
    if (target == ConfigurationTarget.Workspace && configFile) {
      this._folderConfigurations.set(configFile, new ConfigurationModel(model3.contents));
      this.workspaceConfigFile = configFile;
    }
    if (changed.length == 0)
      return;
    this._configuration = configuration7;
    this._onChange.fire({
      affectsConfiguration: (section2, resource) => {
        if (!resource || target != ConfigurationTarget.Workspace)
          return changed.includes(section2);
        let u = URI.parse(resource);
        if (u.scheme !== "file")
          return changed.includes(section2);
        let filepath = u.fsPath;
        let preRoot = workspaceConfigFile ? path7.default.resolve(workspaceConfigFile, "../..") : "";
        if (configFile && !isParentFolder(preRoot, filepath, true) && !isParentFolder(path7.default.resolve(configFile, "../.."), filepath)) {
          return false;
        }
        return changed.includes(section2);
      }
    });
  }
  setFolderConfiguration(uri) {
    let u = URI.parse(uri);
    if (u.scheme != "file")
      return;
    let filepath = u.fsPath;
    for (let [configFile, model3] of this.foldConfigurations) {
      let root = path7.default.resolve(configFile, "../..");
      if (isParentFolder(root, filepath, true) && this.workspaceConfigFile != configFile) {
        this.changeConfiguration(ConfigurationTarget.Workspace, model3, configFile);
        break;
      }
    }
  }
  hasFolderConfiguration(filepath) {
    let {folders: folders2} = this;
    return folders2.findIndex((f) => isParentFolder(f, filepath, true)) !== -1;
  }
  getConfigFile(target) {
    if (target == ConfigurationTarget.Global)
      return null;
    if (target == ConfigurationTarget.User)
      return this.userConfigFile;
    return this.workspaceConfigFile;
  }
  get folders() {
    let res = [];
    let {_folderConfigurations} = this;
    for (let folder of _folderConfigurations.keys()) {
      res.push(path7.default.resolve(folder, "../.."));
    }
    return res;
  }
  get configuration() {
    return this._configuration;
  }
  getConfiguration(section2, resource) {
    let configuration7;
    if (resource) {
      let {defaults: defaults2, user} = this._configuration;
      configuration7 = new Configuration(defaults2, user, this.getFolderConfiguration(resource));
    } else {
      configuration7 = this._configuration;
    }
    const config = Object.freeze(lookUp(configuration7.getValue(null), section2));
    const result = {
      has(key) {
        return typeof lookUp(config, key) !== "undefined";
      },
      get: (key, defaultValue) => {
        let result2 = lookUp(config, key);
        if (result2 == null)
          return defaultValue;
        return result2;
      },
      update: (key, value, isUser = false) => {
        let s = section2 ? `${section2}.${key}` : key;
        let target = isUser ? ConfigurationTarget.User : ConfigurationTarget.Workspace;
        let model3 = target == ConfigurationTarget.User ? this.user.clone() : this.workspace.clone();
        if (value == void 0) {
          model3.removeValue(s);
        } else {
          model3.setValue(s, value);
        }
        if (target == ConfigurationTarget.Workspace && !this.workspaceConfigFile && this._proxy) {
          let file = this.workspaceConfigFile = this._proxy.workspaceConfigFile;
          if (!fs6.default.existsSync(file)) {
            let folder = path7.default.dirname(file);
            if (!fs6.default.existsSync(folder))
              fs6.default.mkdirSync(folder);
            fs6.default.writeFileSync(file, "{}", {encoding: "utf8"});
          }
        }
        this.changeConfiguration(target, model3, target == ConfigurationTarget.Workspace ? this.workspaceConfigFile : this.userConfigFile);
        if (this._proxy && !global.hasOwnProperty("__TEST__")) {
          if (value == void 0) {
            this._proxy.$removeConfigurationOption(target, s);
          } else {
            this._proxy.$updateConfigurationOption(target, s, value);
          }
        }
      },
      inspect: (key) => {
        key = section2 ? `${section2}.${key}` : key;
        const config2 = this._configuration.inspect(key);
        if (config2) {
          return {
            key,
            defaultValue: config2.default,
            globalValue: config2.user,
            workspaceValue: config2.workspace
          };
        }
        return void 0;
      }
    };
    Object.defineProperty(result, "has", {
      enumerable: false
    });
    Object.defineProperty(result, "get", {
      enumerable: false
    });
    Object.defineProperty(result, "update", {
      enumerable: false
    });
    Object.defineProperty(result, "inspect", {
      enumerable: false
    });
    if (typeof config === "object") {
      mixin(result, config, false);
    }
    return deepFreeze(result);
  }
  getFolderConfiguration(uri) {
    let u = URI.parse(uri);
    if (u.scheme != "file")
      return new ConfigurationModel();
    let filepath = u.fsPath;
    for (let [configFile, model3] of this.foldConfigurations) {
      let root = path7.default.resolve(configFile, "../..");
      if (isParentFolder(root, filepath, true))
        return model3;
    }
    return new ConfigurationModel();
  }
  checkFolderConfiguration(uri) {
    let u = URI.parse(uri);
    if (u.scheme != "file")
      return;
    let rootPath = path7.default.dirname(u.fsPath);
    if (!this.hasFolderConfiguration(rootPath)) {
      let folder = findUp(".vim", rootPath);
      if (folder && folder != os3.default.homedir()) {
        let file = path7.default.join(folder, CONFIG_FILE_NAME);
        if (fs6.default.existsSync(file)) {
          this.addFolderFile(file);
        }
      }
    } else {
      this.setFolderConfiguration(uri);
    }
  }
  static parse(data) {
    const defaultConfiguration = new ConfigurationModel(data.defaults.contents);
    const userConfiguration = new ConfigurationModel(data.user.contents);
    const workspaceConfiguration = new ConfigurationModel(data.workspace.contents);
    return new Configuration(defaultConfiguration, userConfiguration, workspaceConfiguration, new ConfigurationModel());
  }
  dispose() {
    disposeAll(this.disposables);
  }
};
var configuration_default = Configurations;

// src/configuration/shape.ts
var fs9 = __toModule(require("fs"));
var path9 = __toModule(require("path"));
var logger15 = require_logger2()("configuration-shape");
var ConfigurationProxy = class {
  constructor(workspace52) {
    this.workspace = workspace52;
  }
  get nvim() {
    return this.workspace.nvim;
  }
  async modifyConfiguration(target, key, value) {
    let {nvim, workspace: workspace52} = this;
    let file = workspace52.getConfigFile(target);
    if (!file)
      return;
    let formattingOptions = {tabSize: 2, insertSpaces: true};
    let content = fs9.default.readFileSync(file, "utf8");
    value = value == null ? void 0 : value;
    let edits = modify(content, [key], value, {formattingOptions});
    content = applyEdits(content, edits);
    fs9.default.writeFileSync(file, content, "utf8");
    let doc = workspace52.getDocument(URI.file(file).toString());
    if (doc)
      nvim.command("checktime", true);
    return;
  }
  get workspaceConfigFile() {
    let folder = path9.default.join(this.workspace.root, ".vim");
    return path9.default.join(folder, CONFIG_FILE_NAME);
  }
  $updateConfigurationOption(target, key, value) {
    this.modifyConfiguration(target, key, value).logError();
  }
  $removeConfigurationOption(target, key) {
    this.modifyConfiguration(target, key).logError();
  }
};
var shape_default = ConfigurationProxy;

// src/model/db.ts
var fs_extra2 = __toModule(require_lib7());
var path11 = __toModule(require("path"));
var DB = class {
  constructor(filepath) {
    this.filepath = filepath;
  }
  fetch(key) {
    let obj = this.load();
    if (!key)
      return obj;
    let parts = key.split(".");
    for (let part of parts) {
      if (typeof obj[part] == "undefined") {
        return void 0;
      }
      obj = obj[part];
    }
    return obj;
  }
  exists(key) {
    let obj = this.load();
    let parts = key.split(".");
    for (let part of parts) {
      if (typeof obj[part] == "undefined") {
        return false;
      }
      obj = obj[part];
    }
    return true;
  }
  delete(key) {
    let obj = this.load();
    let origin = obj;
    let parts = key.split(".");
    let len = parts.length;
    for (let i = 0; i < len; i++) {
      if (typeof obj[parts[i]] == "undefined") {
        break;
      }
      if (i == len - 1) {
        delete obj[parts[i]];
        fs_extra2.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2), "utf8");
        break;
      }
      obj = obj[parts[i]];
    }
  }
  push(key, data) {
    let origin = this.load() || {};
    let obj = origin;
    let parts = key.split(".");
    let len = parts.length;
    if (obj == null) {
      let dir = path11.default.dirname(this.filepath);
      fs_extra2.default.mkdirpSync(dir);
      obj = origin;
    }
    for (let i = 0; i < len; i++) {
      let key2 = parts[i];
      if (i == len - 1) {
        obj[key2] = data;
        fs_extra2.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2));
        break;
      }
      if (typeof obj[key2] == "undefined") {
        obj[key2] = {};
        obj = obj[key2];
      } else {
        obj = obj[key2];
      }
    }
  }
  load() {
    let dir = path11.default.dirname(this.filepath);
    let stat = fs_extra2.default.statSync(dir);
    if (!stat || !stat.isDirectory()) {
      fs_extra2.default.mkdirpSync(dir);
      fs_extra2.default.writeFileSync(this.filepath, "{}", "utf8");
      return {};
    }
    try {
      let content = fs_extra2.default.readFileSync(this.filepath, "utf8");
      return JSON.parse(content.trim());
    } catch (e) {
      fs_extra2.default.writeFileSync(this.filepath, "{}", "utf8");
      return {};
    }
  }
  clear() {
    let stat = fs_extra2.default.statSync(this.filepath);
    if (!stat || !stat.isFile())
      return;
    fs_extra2.default.writeFileSync(this.filepath, "{}", "utf8");
  }
  destroy() {
    if (fs_extra2.default.existsSync(this.filepath)) {
      fs_extra2.default.unlinkSync(this.filepath);
    }
  }
};
var db_default = DB;

// src/model/document.ts
var debounce5 = __toModule(require_debounce());
var vscode_languageserver_protocol9 = __toModule(require_main3());

// src/util/diff.ts
var fast_diff = __toModule(require_diff2());
var logger16 = require_logger2()("util-diff");
function diffLines(oldLines, newLines) {
  let start = 0;
  let end = oldLines.length;
  let oldLen = end;
  let len = newLines.length;
  for (let i = 0; i <= end; i++) {
    if (newLines[i] !== oldLines[i]) {
      start = i;
      break;
    }
    if (i == end) {
      start = end;
    }
  }
  if (start != newLines.length) {
    let maxRemain = Math.min(end - start, len - start);
    for (let j = 0; j < maxRemain; j++) {
      if (oldLines[oldLen - j - 1] != newLines[len - j - 1]) {
        break;
      }
      end = end - 1;
    }
  }
  return {
    start,
    end,
    replacement: newLines.slice(start, len - (oldLen - end))
  };
}
function getChange(oldStr, newStr, cursorEnd) {
  let ol = oldStr.length;
  let nl = newStr.length;
  let max = Math.min(ol, nl);
  let newText = "";
  let startOffset = 0;
  let endOffset = -1;
  let shouldLimit = false;
  for (let i = 0; i <= max; i++) {
    if (cursorEnd != null && i == cursorEnd) {
      endOffset = i;
      shouldLimit = true;
      break;
    }
    if (oldStr[ol - i - 1] != newStr[nl - i - 1]) {
      endOffset = i;
      break;
    }
  }
  if (endOffset == -1)
    return null;
  let remain = max - endOffset;
  if (remain == 0) {
    startOffset = 0;
  } else {
    for (let i = 0; i <= remain; i++) {
      if (oldStr[i] != newStr[i] || i == remain) {
        startOffset = i;
        break;
      }
    }
  }
  remain = remain - startOffset;
  if (shouldLimit && remain > 0) {
    let end2 = endOffset;
    for (let i = 0; i < remain; i++) {
      let oc = oldStr[ol - end2 - 1 - i];
      let nc = newStr[nl - end2 - 1 - i];
      if (oc == nc) {
        endOffset = endOffset + 1;
      } else {
        break;
      }
    }
  }
  let end = ol - endOffset;
  if (ol == nl && startOffset == end)
    return null;
  newText = newStr.slice(startOffset, nl - endOffset);
  if (startOffset == end) {
    let pre = startOffset == 0 ? "" : newStr[startOffset - 1];
    if (pre && pre != "\n" && oldStr[startOffset] == "\n" && newText.startsWith("\n")) {
      return {start: startOffset + 1, end: end + 1, newText: newText.slice(1) + "\n"};
    }
  }
  return {start: startOffset, end, newText};
}
function patchLine(from, to, fill = " ") {
  if (from == to)
    return to;
  let idx = to.indexOf(from);
  if (idx !== -1)
    return fill.repeat(idx) + from;
  let result = fast_diff.default(from, to);
  let str = "";
  for (let item of result) {
    if (item[0] == fast_diff.default.DELETE) {
      return to;
    } else if (item[0] == fast_diff.default.INSERT) {
      str = str + fill.repeat(byteLength(item[1]));
    } else {
      str = str + item[1];
    }
  }
  return str;
}

// src/model/chars.ts
var logger17 = require_logger2()("model-chars");
var Range2 = class {
  constructor(start, end) {
    this.start = start;
    this.end = end ? end : start;
  }
  static fromKeywordOption(keywordOption) {
    let parts = keywordOption.split(",");
    let ranges = [];
    for (let part of parts) {
      if (part == "@") {
        ranges.push(new Range2(65, 90));
        ranges.push(new Range2(97, 122));
      } else if (part == "@-@") {
        ranges.push(new Range2(64));
      } else if (/^([A-Za-z])-([A-Za-z])$/.test(part)) {
        let ms = part.match(/^([A-Za-z])-([A-Za-z])$/);
        ranges.push(new Range2(ms[1].charCodeAt(0), ms[2].charCodeAt(0)));
      } else if (/^\d+-\d+$/.test(part)) {
        let ms = part.match(/^(\d+)-(\d+)$/);
        ranges.push(new Range2(Number(ms[1]), Number(ms[2])));
      } else if (/^\d+$/.test(part)) {
        ranges.push(new Range2(Number(part)));
      } else {
        let c = part.charCodeAt(0);
        if (!ranges.some((o) => o.contains(c))) {
          ranges.push(new Range2(c));
        }
      }
    }
    return ranges;
  }
  contains(c) {
    return c >= this.start && c <= this.end;
  }
};
var Chars = class {
  constructor(keywordOption) {
    this.ranges = [];
    if (keywordOption)
      this.ranges = Range2.fromKeywordOption(keywordOption);
  }
  addKeyword(ch) {
    let c = ch.charCodeAt(0);
    let {ranges} = this;
    if (!ranges.some((o) => o.contains(c))) {
      ranges.push(new Range2(c));
    }
  }
  clone() {
    let chars2 = new Chars();
    chars2.ranges = this.ranges.slice();
    return chars2;
  }
  setKeywordOption(keywordOption) {
    this.ranges = Range2.fromKeywordOption(keywordOption);
  }
  matchKeywords(content, min = 3) {
    let length = content.length;
    if (length == 0)
      return [];
    let res = new Set();
    let str = "";
    let len = 0;
    for (let i = 0; i < length; i++) {
      let ch = content[i];
      let code = ch.codePointAt(0);
      if (len == 0 && code == 45)
        continue;
      let isKeyword = this.isKeywordCode(code);
      if (isKeyword) {
        if (len == 48)
          continue;
        str = str + ch;
        len = len + 1;
      } else {
        if (len >= min && len < 48)
          res.add(str);
        str = "";
        len = 0;
      }
    }
    if (len != 0)
      res.add(str);
    return Array.from(res);
  }
  isKeywordCode(code) {
    if (code > 255)
      return true;
    if (code < 33)
      return false;
    return this.ranges.some((r) => r.contains(code));
  }
  isKeywordChar(ch) {
    let {ranges} = this;
    let c = ch.charCodeAt(0);
    if (c > 255)
      return true;
    if (c < 33)
      return false;
    return ranges.some((r) => r.contains(c));
  }
  isKeyword(word) {
    let {ranges} = this;
    for (let i = 0, l = word.length; i < l; i++) {
      let ch = word.charCodeAt(i);
      if (ch > 255)
        return false;
      if (ranges.some((r) => r.contains(ch)))
        continue;
      return false;
    }
    return true;
  }
};

// src/model/textdocument.ts
function computeLineOffsets2(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    let ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
var LinesTextDoucment = class {
  constructor(uri, languageId, version2, lines, eol) {
    this.uri = uri;
    this.languageId = languageId;
    this.version = version2;
    this.lines = lines;
    this.eol = eol;
  }
  get _content() {
    return this.lines.join("\n") + (this.eol ? "\n" : "");
  }
  get lineCount() {
    return this.lines.length + (this.eol ? 1 : 0);
  }
  getText(range2) {
    if (range2) {
      const start = this.offsetAt(range2.start);
      const end = this.offsetAt(range2.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    let lineOffsets = this.getLineOffsets();
    let low = 0;
    let high = lineOffsets.length;
    if (high === 0) {
      return {line: 0, character: offset};
    }
    while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    let line = low - 1;
    return {line, character: offset - lineOffsets[line]};
  }
  offsetAt(position15) {
    let lineOffsets = this.getLineOffsets();
    if (position15.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position15.line < 0) {
      return 0;
    }
    let lineOffset = lineOffsets[position15.line];
    let nextLineOffset = position15.line + 1 < lineOffsets.length ? lineOffsets[position15.line + 1] : this._content.length;
    return Math.max(Math.min(lineOffset + position15.character, nextLineOffset), lineOffset);
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      this._lineOffsets = computeLineOffsets2(this._content, true);
    }
    return this._lineOffsets;
  }
};

// src/model/document.ts
var logger18 = require_logger2()("model-document");
var Document = class {
  constructor(buffer4, env2, maxFileSize) {
    this.buffer = buffer4;
    this.env = env2;
    this.maxFileSize = maxFileSize;
    this.isIgnored = false;
    this.mutex = new Mutex();
    this._version = 1;
    this.size = 0;
    this.eol = true;
    this.lines = [];
    this.syncLines = [];
    this._attached = false;
    this._previewwindow = false;
    this._winid = -1;
    this._words = [];
    this._onDocumentChange = new vscode_languageserver_protocol9.Emitter();
    this._onDocumentDetach = new vscode_languageserver_protocol9.Emitter();
    this.disposables = [];
    this.onDocumentChange = this._onDocumentChange.event;
    this.onDocumentDetach = this._onDocumentDetach.event;
    this.fireContentChanges = debounce5.default(() => {
      this._fireContentChanges();
    }, 100);
    this.fetchContent = debounce5.default(() => {
      this._fetchContent().logError();
    }, 100);
  }
  get content() {
    return this.syncLines.join("\n") + (this.eol ? "\n" : "");
  }
  get version() {
    return this._version;
  }
  get bufnr() {
    return this.buffer.id;
  }
  get filetype() {
    return this._filetype;
  }
  get uri() {
    return this._uri;
  }
  get shouldAttach() {
    let {buftype, maxFileSize} = this;
    if (!this.getVar("enabled", true))
      return false;
    if (this.uri.endsWith("%5BCommand%20Line%5D"))
      return true;
    if (this.size == -2)
      return false;
    if (maxFileSize && this.size > maxFileSize)
      return false;
    return buftype == "" || buftype == "acwrite";
  }
  get isCommandLine() {
    return this.uri && this.uri.endsWith("%5BCommand%20Line%5D");
  }
  get enabled() {
    return this.getVar("enabled", true);
  }
  get words() {
    return this._words;
  }
  convertFiletype(filetype) {
    let map = this.env.filetypeMap;
    if (filetype == "javascript.jsx")
      return "javascriptreact";
    if (filetype == "typescript.jsx" || filetype == "typescript.tsx")
      return "typescriptreact";
    return map[filetype] || filetype;
  }
  get changedtick() {
    return this._changedtick;
  }
  get schema() {
    return URI.parse(this.uri).scheme;
  }
  get lineCount() {
    return this.lines.length;
  }
  get winid() {
    return this._winid;
  }
  get previewwindow() {
    return this._previewwindow;
  }
  async init(nvim, token) {
    this.nvim = nvim;
    let opts = await nvim.call("coc#util#get_bufoptions", [this.bufnr, this.maxFileSize]);
    if (opts == null)
      return false;
    let buftype = this.buftype = opts.buftype;
    this._previewwindow = opts.previewwindow;
    this._winid = opts.winid;
    this.size = typeof opts.size == "number" ? opts.size : 0;
    this.variables = opts.variables || {};
    this._changedtick = opts.changedtick;
    this.eol = opts.eol == 1;
    this._uri = getUri(opts.fullpath, this.bufnr, buftype, this.env.isCygwin);
    if (token.isCancellationRequested)
      return false;
    if (this.shouldAttach) {
      this.lines = opts.lines;
      this.syncLines = this.lines;
      let res = await this.attach();
      if (!res)
        return false;
      this._attached = true;
    }
    this._filetype = this.convertFiletype(opts.filetype);
    this.setIskeyword(opts.iskeyword);
    if (token.isCancellationRequested) {
      this.detach();
      return false;
    }
    return true;
  }
  async attach() {
    let attached = await this.buffer.attach(true);
    if (!attached)
      return false;
    this.buffer.listen("lines", this.onChange.bind(this), this.disposables);
    this.buffer.listen("detach", async (buf) => {
      this._onDocumentDetach.fire(buf.id);
    }, this.disposables);
    return true;
  }
  async onChange(buf, tick, firstline, lastline, linedata) {
    if (buf.id !== this.bufnr || !this._attached || tick == null)
      return;
    if (this.mutex.busy)
      return;
    if (tick > this._changedtick) {
      this._changedtick = tick;
      this.lines = [...this.lines.slice(0, firstline), ...linedata, ...this.lines.slice(lastline)];
      this.fireContentChanges();
    }
  }
  async checkDocument() {
    let {buffer: buffer4} = this;
    let release = await this.mutex.acquire();
    this.fireContentChanges.clear();
    this._changedtick = await buffer4.changedtick;
    this.lines = await buffer4.lines;
    let changed = this._fireContentChanges();
    if (changed)
      await wait(30);
    release();
  }
  get dirty() {
    if (this.lines === this.syncLines)
      return false;
    return !equals(this.lines, this.syncLines);
  }
  _fireContentChanges() {
    let {cursor} = events_default;
    let {textDocument} = this;
    try {
      let endOffset = null;
      if (cursor && cursor.bufnr == this.bufnr) {
        endOffset = this.getEndOffset(cursor.lnum, cursor.col, cursor.insert);
      }
      let content = this.getDocumentContent();
      let change = getChange(textDocument.getText(), content, endOffset);
      if (change == null)
        return;
      let start = textDocument.positionAt(change.start);
      let end = textDocument.positionAt(change.end);
      let original = textDocument.getText(vscode_languageserver_protocol9.Range.create(start, end));
      this._version = this._version + 1;
      this.syncLines = this.lines;
      let changes = [{
        range: {start, end},
        rangeLength: change.end - change.start,
        text: change.newText
      }];
      this._onDocumentChange.fire({
        bufnr: this.bufnr,
        original,
        textDocument: {version: this.version, uri: this.uri},
        contentChanges: changes
      });
      this._words = this.chars.matchKeywords(content);
      return true;
    } catch (e) {
      logger18.error(e.message);
    }
    return false;
  }
  async applyEdits(edits) {
    if (!Array.isArray(arguments[0]) && Array.isArray(arguments[1])) {
      edits = arguments[1];
    }
    if (edits.length == 0)
      return;
    let current = this.getDocumentContent();
    let textDocument = TextDocument.create(this.uri, this.filetype, 1, current);
    let applied = TextDocument.applyEdits(textDocument, edits);
    if (current !== applied) {
      let newLines = (this.eol && applied.endsWith("\n") ? applied.slice(0, -1) : applied).split("\n");
      let d = diffLines(this.lines, newLines);
      let release = await this.mutex.acquire();
      try {
        let res = await this.nvim.call("coc#util#set_lines", [this.bufnr, d.replacement, d.start, d.end]);
        this._changedtick = res.changedtick;
        this.lines = newLines;
        this.fireContentChanges.clear();
        this._fireContentChanges();
        if (!equals(newLines, res.lines)) {
          process.nextTick(() => {
            this.lines = res.lines;
            this.fireContentChanges.clear();
            this._fireContentChanges();
          });
        }
        release();
      } catch (e) {
        logger18.error("Error on applyEdits: ", e);
        release();
      }
    }
  }
  async changeLines(lines) {
    let filtered = [];
    let newLines = this.lines.slice();
    for (let [lnum, text] of lines) {
      if (newLines[lnum] != text) {
        filtered.push([lnum, text]);
        newLines[lnum] = text;
      }
    }
    if (!filtered.length)
      return;
    let release = await this.mutex.acquire();
    try {
      let res = await this.nvim.call("coc#util#change_lines", [this.bufnr, filtered]);
      if (res != null) {
        this.lines = newLines;
        this._changedtick = res.changedtick;
        this.fireContentChanges.clear();
        this._fireContentChanges();
        if (!equals(newLines, res.lines)) {
          process.nextTick(() => {
            this.lines = res.lines;
            this.fireContentChanges.clear();
            this._fireContentChanges();
          });
        }
      }
      release();
    } catch (e) {
      release();
    }
  }
  forceSync() {
    if (this.mutex.busy)
      return;
    this.fireContentChanges.clear();
    this._fireContentChanges();
  }
  getOffset(lnum, col) {
    return this.textDocument.offsetAt({
      line: lnum - 1,
      character: col
    });
  }
  isWord(word) {
    return this.chars.isKeyword(word);
  }
  getMoreWords() {
    let res = [];
    let {words, chars: chars2} = this;
    if (!chars2.isKeywordChar("-"))
      return res;
    for (let word of words) {
      word = word.replace(/^-+/, "");
      if (word.includes("-")) {
        let parts = word.split("-");
        for (let part of parts) {
          if (part.length > 2 && !res.includes(part) && !words.includes(part)) {
            res.push(part);
          }
        }
      }
    }
    return res;
  }
  getWordRangeAtPosition(position15, extraChars, current = true) {
    let chars2 = this.chars.clone();
    if (extraChars && extraChars.length) {
      for (let ch of extraChars) {
        chars2.addKeyword(ch);
      }
    }
    let line = this.getline(position15.line, current);
    if (line.length == 0 || position15.character >= line.length)
      return null;
    if (!chars2.isKeywordChar(line[position15.character]))
      return null;
    let start = position15.character;
    let end = position15.character + 1;
    if (!chars2.isKeywordChar(line[start])) {
      return vscode_languageserver_protocol9.Range.create(position15, {line: position15.line, character: position15.character + 1});
    }
    while (start >= 0) {
      let ch = line[start - 1];
      if (!ch || !chars2.isKeyword(ch))
        break;
      start = start - 1;
    }
    while (end <= line.length) {
      let ch = line[end];
      if (!ch || !chars2.isKeywordChar(ch))
        break;
      end = end + 1;
    }
    return vscode_languageserver_protocol9.Range.create(position15.line, start, position15.line, end);
  }
  get textDocument() {
    let {version: version2, filetype, uri} = this;
    return new LinesTextDoucment(uri, filetype, version2, this.syncLines, this.eol);
  }
  async _fetchContent() {
    if (!this.env.isVim || !this._attached)
      return;
    let {nvim, bufnr, changedtick} = this;
    let release = await this.mutex.acquire();
    let o = await nvim.call("coc#util#get_buf_lines", [bufnr, changedtick]);
    if (o && o.changedtick >= this._changedtick) {
      this._changedtick = o.changedtick;
      this.lines = o.lines;
      this.fireContentChanges.clear();
      this._fireContentChanges();
    }
    release();
  }
  async patchChange(currentLine) {
    if (!this._attached)
      return;
    if (this.env.isVim) {
      if (currentLine) {
        let change = await this.nvim.call("coc#util#get_changeinfo", []);
        if (change.changedtick < this._changedtick)
          return;
        let {lnum, line, changedtick} = change;
        let newLines = this.lines.slice();
        this._changedtick = changedtick;
        if (newLines[lnum - 1] == line)
          return;
        newLines[lnum - 1] = line;
        this.lines = newLines;
        this.forceSync();
      } else {
        this.fetchContent.clear();
        await this._fetchContent();
      }
    } else {
      this.forceSync();
    }
  }
  getSymbolRanges(word) {
    this.forceSync();
    let res = [];
    let {textDocument} = this;
    let content = textDocument.getText();
    let str = "";
    for (let i = 0, l = content.length; i < l; i++) {
      let ch = content[i];
      if (ch == "-" && str.length == 0) {
        continue;
      }
      let isKeyword = this.chars.isKeywordChar(ch);
      if (isKeyword) {
        str = str + ch;
      }
      if (str.length > 0 && !isKeyword && str == word) {
        res.push(vscode_languageserver_protocol9.Range.create(textDocument.positionAt(i - str.length), textDocument.positionAt(i)));
      }
      if (!isKeyword) {
        str = "";
      }
    }
    return res;
  }
  fixStartcol(position15, valids) {
    let line = this.getline(position15.line);
    if (!line)
      return null;
    let {character} = position15;
    let start = line.slice(0, character);
    let col = byteLength(start);
    let {chars: chars2} = this;
    for (let i = start.length - 1; i >= 0; i--) {
      let c = start[i];
      if (c == " ")
        break;
      if (!chars2.isKeywordChar(c) && !valids.includes(c)) {
        break;
      }
      col = col - byteLength(c);
    }
    return col;
  }
  getline(line, current = true) {
    if (current)
      return this.lines[line] || "";
    return this.syncLines[line] || "";
  }
  getLines(start, end) {
    return this.lines.slice(start, end);
  }
  getDocumentContent() {
    let content = this.lines.join("\n");
    return this.eol ? content + "\n" : content;
  }
  getVar(key, defaultValue) {
    let val = this.variables[`coc_${key}`];
    return val === void 0 ? defaultValue : val;
  }
  getPosition(lnum, col) {
    let line = this.getline(lnum - 1);
    if (!line || col == 0)
      return {line: lnum - 1, character: 0};
    let pre = byteSlice(line, 0, col - 1);
    return {line: lnum - 1, character: pre.length};
  }
  getEndOffset(lnum, col, insert) {
    let total = 0;
    let len = this.lines.length;
    for (let i = lnum - 1; i < len; i++) {
      let line = this.lines[i];
      let l = line.length;
      if (i == lnum - 1 && l != 0) {
        let buf = global.Buffer.from(line, "utf8");
        let isEnd = buf.byteLength <= col - 1;
        if (!isEnd) {
          total = total + buf.slice(col - 1, buf.length).toString("utf8").length;
          if (!insert)
            total = total - 1;
        }
      } else {
        total = total + l;
      }
      if (!this.eol && i == len - 1)
        break;
      total = total + 1;
    }
    return total;
  }
  setFiletype(filetype) {
    this._filetype = this.convertFiletype(filetype);
    this._version = this._version + 1;
  }
  setIskeyword(iskeyword) {
    let chars2 = this.chars = new Chars(iskeyword);
    let additional = this.getVar("additional_keywords", []);
    if (additional && Array.isArray(additional)) {
      for (let ch of additional) {
        chars2.addKeyword(ch);
      }
    }
    let lines = this.lines.length > 3e4 ? this.lines.slice(0, 3e4) : this.lines;
    this._words = this.chars.matchKeywords(lines.join("\n"));
  }
  get attached() {
    return this._attached;
  }
  detach() {
    this._attached = false;
    disposeAll(this.disposables);
    this.disposables = [];
    this.fetchContent.clear();
    this.fireContentChanges.clear();
    this._onDocumentChange.dispose();
    this._onDocumentDetach.dispose();
  }
  getLocalifyBonus(sp, ep) {
    let res = new Map();
    let {chars: chars2} = this;
    let startLine = Math.max(0, sp.line - 100);
    let endLine = Math.min(this.lineCount, sp.line + 100);
    let content = this.lines.slice(startLine, endLine).join("\n");
    sp = vscode_languageserver_protocol9.Position.create(sp.line - startLine, sp.character);
    ep = vscode_languageserver_protocol9.Position.create(ep.line - startLine, ep.character);
    let doc = TextDocument.create(this.uri, this.filetype, 1, content);
    let headCount = doc.offsetAt(sp);
    let len = content.length;
    let tailCount = len - doc.offsetAt(ep);
    let start = 0;
    let preKeyword = false;
    for (let i = 0; i < headCount; i++) {
      let iskeyword = chars2.isKeyword(content[i]);
      if (!preKeyword && iskeyword) {
        start = i;
      } else if (preKeyword && (!iskeyword || i == headCount - 1)) {
        if (i - start > 1) {
          let str = content.slice(start, i);
          res.set(str, i / headCount);
        }
      }
      preKeyword = iskeyword;
    }
    start = len - tailCount;
    preKeyword = false;
    for (let i = start; i < content.length; i++) {
      let iskeyword = chars2.isKeyword(content[i]);
      if (!preKeyword && iskeyword) {
        start = i;
      } else if (preKeyword && (!iskeyword || i == len - 1)) {
        if (i - start > 1) {
          let end = i == len - 1 ? i + 1 : i;
          let str = content.slice(start, end);
          let score6 = res.get(str) || 0;
          res.set(str, Math.max(score6, (len - i + (end - start)) / tailCount));
        }
      }
      preKeyword = iskeyword;
    }
    return res;
  }
};
var document_default = Document;

// src/model/fileSystemWatcher.ts
var vscode_languageserver_protocol10 = __toModule(require_main3());
var minimatch3 = __toModule(require_minimatch());
var path13 = __toModule(require("path"));

// src/util/array.ts
function intersect(array6, other) {
  for (let item of other) {
    if (array6.includes(item)) {
      return true;
    }
  }
  return false;
}
function splitArray(array6, fn) {
  let res = [[], []];
  for (let item of array6) {
    if (fn(item)) {
      res[0].push(item);
    } else {
      res[1].push(item);
    }
  }
  return res;
}
function group(array6, size) {
  let len = array6.length;
  let res = [];
  for (let i = 0; i < Math.ceil(len / size); i++) {
    res.push(array6.slice(i * size, (i + 1) * size));
  }
  return res;
}
function distinct(array6, keyFn) {
  if (!keyFn) {
    return array6.filter((element, position15) => array6.indexOf(element) === position15);
  }
  const seen = Object.create(null);
  return array6.filter((elem) => {
    const key = keyFn(elem);
    if (seen[key]) {
      return false;
    }
    seen[key] = true;
    return true;
  });
}

// src/model/fileSystemWatcher.ts
var logger19 = require_logger2()("filesystem-watcher");
var FileSystemWatcher = class {
  constructor(clientPromise, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
    this.globPattern = globPattern;
    this.ignoreCreateEvents = ignoreCreateEvents;
    this.ignoreChangeEvents = ignoreChangeEvents;
    this.ignoreDeleteEvents = ignoreDeleteEvents;
    this._onDidCreate = new vscode_languageserver_protocol10.Emitter();
    this._onDidChange = new vscode_languageserver_protocol10.Emitter();
    this._onDidDelete = new vscode_languageserver_protocol10.Emitter();
    this._onDidRename = new vscode_languageserver_protocol10.Emitter();
    this.onDidCreate = this._onDidCreate.event;
    this.onDidChange = this._onDidChange.event;
    this.onDidDelete = this._onDidDelete.event;
    this.onDidRename = this._onDidRename.event;
    this.disposables = [];
    if (!clientPromise)
      return;
    clientPromise.then((client8) => {
      if (client8)
        return this.listen(client8);
    }).catch((error) => {
      logger19.error("watchman initialize failed");
      logger19.error(error.stack);
    });
  }
  async listen(client8) {
    let {
      globPattern,
      ignoreCreateEvents,
      ignoreChangeEvents,
      ignoreDeleteEvents
    } = this;
    let disposable = await client8.subscribe(globPattern, (change) => {
      let {root, files} = change;
      files = files.filter((f) => f.type == "f" && minimatch3.default(f.name, globPattern, {dot: true}));
      for (let file of files) {
        let uri = URI.file(path13.default.join(root, file.name));
        if (!file.exists) {
          if (!ignoreDeleteEvents)
            this._onDidDelete.fire(uri);
        } else {
          if (file.new === true) {
            if (!ignoreCreateEvents)
              this._onDidCreate.fire(uri);
          } else {
            if (!ignoreChangeEvents)
              this._onDidChange.fire(uri);
          }
        }
      }
      if (files.length == 2 && !files[0].exists && files[1].exists) {
        let oldFile = files[0];
        let newFile = files[1];
        if (oldFile.size == newFile.size) {
          this._onDidRename.fire({
            oldUri: URI.file(path13.default.join(root, oldFile.name)),
            newUri: URI.file(path13.default.join(root, newFile.name))
          });
        }
      }
      if (files.length >= 2) {
        let [oldFiles, newFiles] = splitArray(files, (o) => o.exists === false);
        if (oldFiles.length == newFiles.length) {
          for (let oldFile of oldFiles) {
            let newFile = newFiles.find((o) => o.size == oldFile.size && o.mtime_ms == oldFile.mtime_ms);
            if (newFile) {
              this._onDidRename.fire({
                oldUri: URI.file(path13.default.join(root, oldFile.name)),
                newUri: URI.file(path13.default.join(root, newFile.name))
              });
            }
          }
        }
      }
    });
    this.disposables.push(disposable);
    return disposable;
  }
  dispose() {
    disposeAll(this.disposables);
  }
};
var fileSystemWatcher_default = FileSystemWatcher;

// src/model/mru.ts
var path15 = __toModule(require("path"));
var fs_extra3 = __toModule(require_lib7());
var Mru = class {
  constructor(name2, base) {
    this.name = name2;
    this.file = path15.default.join(base || process.env.COC_DATA_HOME, name2);
  }
  async load() {
    let dir = path15.default.dirname(this.file);
    try {
      fs_extra3.default.mkdirpSync(dir);
      if (!fs_extra3.default.existsSync(this.file)) {
        fs_extra3.default.writeFileSync(this.file, "", "utf8");
      }
      let content = await fs_extra3.default.readFile(this.file, "utf8");
      content = content.trim();
      return content.length ? content.trim().split("\n") : [];
    } catch (e) {
      return [];
    }
  }
  async add(item) {
    let items = await this.load();
    let idx = items.indexOf(item);
    if (idx !== -1)
      items.splice(idx, 1);
    items.unshift(item);
    fs_extra3.default.writeFileSync(this.file, items.join("\n"), "utf8");
  }
  async remove(item) {
    let items = await this.load();
    let idx = items.indexOf(item);
    if (idx !== -1) {
      items.splice(idx, 1);
      fs_extra3.default.writeFileSync(this.file, items.join("\n"), "utf8");
    }
  }
  async clean() {
    try {
      await fs_extra3.default.unlink(this.file);
    } catch (e) {
    }
  }
};
var mru_default = Mru;

// src/model/resolver.ts
var path17 = __toModule(require("path"));

// src/util/decorator.ts
var logger20 = require_logger2()("util-decorator");
function memorize(_target, key, descriptor) {
  let fn = descriptor.value;
  if (typeof fn !== "function")
    return;
  let memoKey = "$" + key;
  descriptor.value = function(...args) {
    if (this.hasOwnProperty(memoKey))
      return Promise.resolve(this[memoKey]);
    return new Promise((resolve3, reject) => {
      Promise.resolve(fn.apply(this, args)).then((res) => {
        this[memoKey] = res;
        resolve3(res);
      }, (e) => {
        reject(e);
      });
    });
  };
}

// src/model/resolver.ts
var logger21 = require_logger2()("model-resolver");
var Resolver = class {
  get nodeFolder() {
    if (!executable("npm"))
      return Promise.resolve("");
    return runCommand("npm --loglevel silent root -g", {}, 3e3).then((root) => root.trim());
  }
  get yarnFolder() {
    if (!executable("yarnpkg"))
      return Promise.resolve("");
    return runCommand("yarnpkg global dir", {}, 3e3).then((root) => path17.default.join(root.trim(), "node_modules"));
  }
  async resolveModule(mod) {
    let nodeFolder = await this.nodeFolder;
    let yarnFolder = await this.yarnFolder;
    if (yarnFolder) {
      let s = await statAsync(path17.default.join(yarnFolder, mod, "package.json"));
      if (s && s.isFile())
        return path17.default.join(yarnFolder, mod);
    }
    if (nodeFolder) {
      let s = await statAsync(path17.default.join(nodeFolder, mod, "package.json"));
      if (s && s.isFile())
        return path17.default.join(nodeFolder, mod);
    }
    return null;
  }
};
__decorate([
  memorize
], Resolver.prototype, "nodeFolder", 1);
__decorate([
  memorize
], Resolver.prototype, "yarnFolder", 1);
var resolver_default = Resolver;

// src/model/task.ts
var vscode_languageserver_protocol11 = __toModule(require_main3());
var Task = class {
  constructor(nvim, id) {
    this.nvim = nvim;
    this.id = id;
    this.disposables = [];
    this._onExit = new vscode_languageserver_protocol11.Emitter();
    this._onStderr = new vscode_languageserver_protocol11.Emitter();
    this._onStdout = new vscode_languageserver_protocol11.Emitter();
    this.onExit = this._onExit.event;
    this.onStdout = this._onStdout.event;
    this.onStderr = this._onStderr.event;
    events_default.on("TaskExit", (id2, code) => {
      if (id2 == this.id) {
        this._onExit.fire(code);
      }
    }, null, this.disposables);
    events_default.on("TaskStderr", (id2, lines) => {
      if (id2 == this.id) {
        this._onStderr.fire(lines);
      }
    }, null, this.disposables);
    let stdout = [];
    let timer;
    events_default.on("TaskStdout", (id2, lines) => {
      if (id2 == this.id) {
        if (timer)
          clearTimeout(timer);
        stdout.push(...lines);
        timer = setTimeout(() => {
          this._onStdout.fire(stdout);
          stdout = [];
        }, 100);
      }
    }, null, this.disposables);
  }
  async start(opts) {
    let {nvim} = this;
    return await nvim.call("coc#task#start", [this.id, opts]);
  }
  async stop() {
    let {nvim} = this;
    await nvim.call("coc#task#stop", [this.id]);
  }
  get running() {
    let {nvim} = this;
    return nvim.call("coc#task#running", [this.id]);
  }
  dispose() {
    let {nvim} = this;
    nvim.call("coc#task#stop", [this.id], true);
    this._onStdout.dispose();
    this._onStderr.dispose();
    this._onExit.dispose();
    disposeAll(this.disposables);
  }
};
var task_default = Task;

// src/model/terminal.ts
var logger22 = require_logger2()("model-terminal");
var TerminalModel = class {
  constructor(cmd, args, nvim, _name) {
    this.cmd = cmd;
    this.args = args;
    this.nvim = nvim;
    this._name = _name;
    this.pid = 0;
  }
  async start(cwd, env2) {
    let {nvim} = this;
    let cmd = [this.cmd, ...this.args];
    let [bufnr, pid] = await nvim.call("coc#terminal#start", [cmd, cwd, env2 || {}]);
    this.bufnr = bufnr;
    this.pid = pid;
  }
  get name() {
    return this._name || this.cmd;
  }
  get processId() {
    return Promise.resolve(this.pid);
  }
  sendText(text, addNewLine = true) {
    if (!this.bufnr)
      return;
    this.nvim.call("coc#terminal#send", [this.bufnr, text, addNewLine], true);
  }
  async show(preserveFocus) {
    let {bufnr, nvim} = this;
    if (!bufnr)
      return;
    let [loaded, winid, curr] = await nvim.eval(`[bufloaded(${bufnr}),bufwinid(${bufnr}),win_getid()]`);
    if (!loaded)
      return false;
    if (curr == winid)
      return true;
    nvim.pauseNotification();
    if (winid == -1) {
      nvim.command(`below ${bufnr}sb`, true);
      nvim.command("resize 8", true);
      nvim.call("coc#util#do_autocmd", ["CocTerminalOpen"], true);
    } else {
      nvim.call("win_gotoid", [winid], true);
    }
    nvim.command("normal! G", true);
    if (preserveFocus) {
      nvim.command("wincmd p", true);
    }
    await nvim.resumeNotification();
    return true;
  }
  async hide() {
    let {bufnr, nvim} = this;
    if (!bufnr)
      return;
    let winnr = await nvim.call("bufwinnr", bufnr);
    if (winnr == -1)
      return;
    await nvim.command(`${winnr}close!`);
  }
  dispose() {
    let {bufnr, nvim} = this;
    if (!bufnr)
      return;
    nvim.call("coc#terminal#close", [bufnr], true);
  }
};
var terminal_default = TerminalModel;

// src/model/bufferSync.ts
var BufferSync = class {
  constructor(_create, workspace52) {
    this._create = _create;
    this.workspace = workspace52;
    this.disposables = [];
    this.itemsMap = new Map();
    let {disposables} = this;
    for (let doc of workspace52.documents) {
      this.create(doc);
    }
    workspace52.onDidOpenTextDocument((e) => {
      let doc = workspace52.getDocument(e.bufnr);
      if (doc)
        this.create(doc);
    }, null, disposables);
    workspace52.onDidChangeTextDocument((e) => {
      this.onChange(e);
    }, null, disposables);
    workspace52.onDidCloseTextDocument((e) => {
      this.delete(e.bufnr);
    }, null, disposables);
  }
  get items() {
    return Array.from(this.itemsMap.values()).map((x) => x.item);
  }
  getItem(bufnr) {
    var _a2;
    if (typeof bufnr === "number") {
      return (_a2 = this.itemsMap.get(bufnr)) == null ? void 0 : _a2.item;
    }
    let o = Array.from(this.itemsMap.values()).find((v) => {
      return v.uri == bufnr;
    });
    return o ? o.item : void 0;
  }
  create(doc) {
    if (!doc || doc.isCommandLine || !doc.attached)
      return;
    let o = this.itemsMap.get(doc.bufnr);
    if (o)
      o.item.dispose();
    let item = this._create(doc);
    if (item)
      this.itemsMap.set(doc.bufnr, {uri: doc.uri, item});
  }
  onChange(e) {
    let o = this.itemsMap.get(e.bufnr);
    if (o && typeof o.item.onChange == "function") {
      o.item.onChange(e);
    }
  }
  delete(bufnr) {
    let o = this.itemsMap.get(bufnr);
    if (o) {
      this.itemsMap.delete(bufnr);
      o.item.dispose();
    }
  }
  reset() {
    for (let o of this.itemsMap.values()) {
      o.item.dispose();
    }
    this.itemsMap.clear();
  }
  dispose() {
    disposeAll(this.disposables);
    for (let o of this.itemsMap.values()) {
      o.item.dispose();
    }
    this.itemsMap.clear();
  }
};
var bufferSync_default = BufferSync;

// src/util/match.ts
var minimatch5 = __toModule(require_minimatch());
function score(selector, uri, languageId) {
  if (Array.isArray(selector)) {
    let ret2 = 0;
    for (const filter of selector) {
      const value = score(filter, uri, languageId);
      if (value === 10) {
        return value;
      }
      if (value > ret2) {
        ret2 = value;
      }
    }
    return ret2;
  } else if (typeof selector === "string") {
    if (selector === "*") {
      return 5;
    } else if (selector === languageId) {
      return 10;
    } else {
      return 0;
    }
  } else if (selector) {
    let u = URI.parse(uri);
    const {language: language2, pattern, scheme} = selector;
    let ret2 = 0;
    if (scheme) {
      if (scheme === u.scheme) {
        ret2 = 5;
      } else if (scheme === "*") {
        ret2 = 3;
      } else {
        return 0;
      }
    }
    if (language2) {
      if (language2 === languageId) {
        ret2 = 10;
      } else if (language2 === "*") {
        ret2 = Math.max(ret2, 5);
      } else {
        return 0;
      }
    }
    if (pattern) {
      let caseInsensitive = isWindows2 || isMacintosh;
      let p = caseInsensitive ? pattern.toLowerCase() : pattern;
      let f = caseInsensitive ? u.fsPath.toLowerCase() : u.fsPath;
      if (p === f || minimatch5.default(f, p, {dot: true})) {
        ret2 = 5;
      } else {
        return 0;
      }
    }
    return ret2;
  } else {
    return 0;
  }
}

// src/watchman.ts
var fb_watchman = __toModule(require_fb_watchman());
var os5 = __toModule(require("os"));
var path19 = __toModule(require("path"));
var vscode_languageserver_protocol12 = __toModule(require_main3());
var minimatch7 = __toModule(require_minimatch());
var logger23 = require_logger2()("watchman");
var requiredCapabilities = ["relative_root", "cmd-watch-project", "wildmatch", "field-new"];
var clientsMap = new Map();
var Watchman = class {
  constructor(binaryPath, channel) {
    this.channel = channel;
    this._disposed = false;
    this.client = new fb_watchman.default.Client({
      watchmanBinaryPath: binaryPath
    });
    this.client.setMaxListeners(300);
  }
  checkCapability() {
    let {client: client8} = this;
    return new Promise((resolve3, reject) => {
      client8.capabilityCheck({
        optional: [],
        required: requiredCapabilities
      }, (error, resp) => {
        if (error)
          return reject(error);
        let {capabilities} = resp;
        for (let key of Object.keys(capabilities)) {
          if (!capabilities[key])
            return resolve3(false);
        }
        resolve3(true);
      });
    });
  }
  async watchProject(root) {
    try {
      let resp = await this.command(["watch-project", root]);
      let {watch, warning, relative_path} = resp;
      if (warning)
        logger23.warn(warning);
      this.watch = watch;
      this.relative_path = relative_path;
      logger23.info(`watchman watching project: ${root}`);
      this.appendOutput(`watchman watching project: ${root}`);
    } catch (e) {
      logger23.error(e);
      return false;
    }
    return true;
  }
  command(args) {
    return new Promise((resolve3, reject) => {
      this.client.command(args, (error, resp) => {
        if (error)
          return reject(error);
        resolve3(resp);
      });
    });
  }
  async subscribe(globPattern, cb) {
    let {watch, relative_path} = this;
    if (!watch) {
      this.appendOutput(`watchman not watching: ${watch}`, "Error");
      return null;
    }
    let {clock} = await this.command(["clock", watch]);
    let uid = v1_default();
    let sub = {
      expression: ["allof", ["match", "**/*", "wholename"]],
      fields: ["name", "size", "new", "exists", "type", "mtime_ms", "ctime_ms"],
      since: clock
    };
    let root = watch;
    if (relative_path) {
      sub.relative_root = relative_path;
      root = path19.default.join(watch, relative_path);
    }
    let {subscribe} = await this.command(["subscribe", watch, uid, sub]);
    if (global.hasOwnProperty("__TEST__"))
      global.subscribe = subscribe;
    this.appendOutput(`subscribing "${globPattern}" in ${root}`);
    this.client.on("subscription", (resp) => {
      if (!resp || resp.subscription != uid)
        return;
      let {files} = resp;
      if (!files)
        return;
      files = files.filter((f) => f.type == "f" && minimatch7.default(f.name, globPattern, {dot: true}));
      if (!files.length)
        return;
      let ev = Object.assign({}, resp);
      if (this.relative_path)
        ev.root = path19.default.resolve(resp.root, this.relative_path);
      this.appendOutput(`file change detected: ${JSON.stringify(ev, null, 2)}`);
      cb(ev);
    });
    return vscode_languageserver_protocol12.Disposable.create(() => this.unsubscribe(subscribe));
  }
  unsubscribe(subscription) {
    if (this._disposed)
      return Promise.resolve();
    let {watch} = this;
    if (!watch)
      return;
    this.appendOutput(`unsubscribe "${subscription}" in: ${watch}`);
    return this.command(["unsubscribe", watch, subscription]).catch((e) => {
      logger23.error(e);
    });
  }
  dispose() {
    if (this._disposed)
      return;
    this._disposed = true;
    this.client.removeAllListeners();
    this.client.end();
  }
  appendOutput(message, type = "Info") {
    if (this.channel) {
      this.channel.appendLine(`[${type}  - ${new Date().toLocaleTimeString()}] ${message}`);
    }
  }
  static dispose() {
    for (let promise of clientsMap.values()) {
      promise.then((client8) => {
        client8.dispose();
      }, (_e) => {
      });
    }
  }
  static createClient(binaryPath, root, channel) {
    if (!isValidWatchRoot(root))
      return null;
    let client8 = clientsMap.get(root);
    if (client8)
      return client8;
    let promise = new Promise(async (resolve3, reject) => {
      try {
        let watchman4 = new Watchman(binaryPath, channel);
        let valid = await watchman4.checkCapability();
        if (!valid)
          return resolve3(null);
        let watching = await watchman4.watchProject(root);
        if (!watching)
          return resolve3(null);
        resolve3(watchman4);
      } catch (e) {
        reject(e);
      }
    });
    clientsMap.set(root, promise);
    return promise;
  }
};
var watchman_default = Watchman;
function isValidWatchRoot(root) {
  if (root == "/" || root == "/tmp" || root == "/private/tmp")
    return false;
  if (root.toLowerCase() === os5.default.homedir().toLowerCase())
    return false;
  if (path19.default.parse(root).base == root)
    return false;
  if (root.startsWith("/tmp/") || root.startsWith("/private/tmp/"))
    return false;
  if (isParentFolder(os5.default.tmpdir(), root, true))
    return false;
  return true;
}

// src/workspace.ts
var APIVERSION = 8;
var logger24 = require_logger2()("workspace");
var NAME_SPACE = 2e3;
var methods = [
  "showMessage",
  "runTerminalCommand",
  "openTerminal",
  "showQuickpick",
  "menuPick",
  "openLocalConfig",
  "showPrompt",
  "createStatusBarItem",
  "createOutputChannel",
  "showOutputChannel",
  "requestInput",
  "echoLines",
  "getCursorPosition",
  "moveTo",
  "getOffset"
];
var Workspace = class {
  constructor() {
    this.keymaps = new Map();
    this.resolver = new resolver_default();
    this.rootPatterns = new Map();
    this._workspaceFolders = [];
    this._insertMode = false;
    this._cwd = process.cwd();
    this._initialized = false;
    this._attached = false;
    this.buffers = new Map();
    this.autocmdMaxId = 0;
    this.autocmds = new Map();
    this.terminals = new Map();
    this.creatingSources = new Map();
    this.schemeProviderMap = new Map();
    this.namespaceMap = new Map();
    this.disposables = [];
    this.watchedOptions = new Set();
    this._dynAutocmd = false;
    this._disposed = false;
    this._onDidOpenDocument = new vscode_languageserver_protocol13.Emitter();
    this._onDidCloseDocument = new vscode_languageserver_protocol13.Emitter();
    this._onDidChangeDocument = new vscode_languageserver_protocol13.Emitter();
    this._onWillSaveDocument = new vscode_languageserver_protocol13.Emitter();
    this._onDidSaveDocument = new vscode_languageserver_protocol13.Emitter();
    this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol13.Emitter();
    this._onDidChangeConfiguration = new vscode_languageserver_protocol13.Emitter();
    this._onDidWorkspaceInitialized = new vscode_languageserver_protocol13.Emitter();
    this._onDidOpenTerminal = new vscode_languageserver_protocol13.Emitter();
    this._onDidCloseTerminal = new vscode_languageserver_protocol13.Emitter();
    this._onDidRuntimePathChange = new vscode_languageserver_protocol13.Emitter();
    this.onDidCloseTerminal = this._onDidCloseTerminal.event;
    this.onDidOpenTerminal = this._onDidOpenTerminal.event;
    this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
    this.onDidOpenTextDocument = this._onDidOpenDocument.event;
    this.onDidCloseTextDocument = this._onDidCloseDocument.event;
    this.onDidChangeTextDocument = this._onDidChangeDocument.event;
    this.onWillSaveTextDocument = this._onWillSaveDocument.event;
    this.onDidSaveTextDocument = this._onDidSaveDocument.event;
    this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    this.onDidWorkspaceInitialized = this._onDidWorkspaceInitialized.event;
    this.onDidRuntimePathChange = this._onDidRuntimePathChange.event;
    let json = require_package2();
    this.version = json.version;
    this.configurations = this.createConfigurations();
    let cwd = process.cwd();
    if (cwd != os7.default.homedir() && inDirectory(cwd, [".vim"])) {
      this._workspaceFolders.push({
        uri: URI.file(cwd).toString(),
        name: path21.default.basename(cwd)
      });
    }
  }
  async init() {
    let {nvim} = this;
    for (let method of methods) {
      Object.defineProperty(this, method, {
        get: () => {
          return (...args) => {
            return window_default[method].apply(window_default, args);
          };
        }
      });
    }
    this._env = await nvim.call("coc#util#vim_info");
    if (this._env.apiversion != APIVERSION) {
      console.error(`API version ${this._env.apiversion} is not ${APIVERSION}, please build coc.nvim by 'yarn install' after pull source code.`);
      process.exit();
    }
    this._insertMode = this._env.mode.startsWith("insert");
    let preferences = this.getConfiguration("coc.preferences");
    let maxFileSize = preferences.get("maxFileSize", "10MB");
    this.maxFileSize = bytes.default.parse(maxFileSize);
    if (this._env.workspaceFolders) {
      this._workspaceFolders = this._env.workspaceFolders.map((f) => ({
        uri: URI.file(f).toString(),
        name: path21.default.dirname(f)
      }));
    }
    this.configurations.updateUserConfig(this._env.config);
    events_default.on(["InsertEnter", "CursorMovedI"], () => {
      this._insertMode = true;
    }, null, this.disposables);
    events_default.on(["InsertLeave", "CursorMoved"], () => {
      this._insertMode = false;
    }, null, this.disposables);
    let forceSync = async (bufnr) => {
      let doc = this.getDocument(bufnr);
      if (doc)
        doc.forceSync();
    };
    events_default.on("InsertLeave", forceSync, null, this.disposables);
    events_default.on("CursorHold", forceSync, null, this.disposables);
    events_default.on("BufWinLeave", (_, winid) => {
      if (winid == -1)
        return;
      this.nvim.call("coc#highlight#clear_match_group", [winid, "^Coc"], true);
    }, null, this.disposables);
    events_default.on("BufEnter", this.onBufEnter, this, this.disposables);
    events_default.on("CursorMoved", this.checkCurrentBuffer, this, this.disposables);
    events_default.on("CursorMovedI", this.checkCurrentBuffer, this, this.disposables);
    events_default.on("DirChanged", this.onDirChanged, this, this.disposables);
    events_default.on("BufCreate", this.onBufCreate, this, this.disposables);
    events_default.on("BufUnload", this.onBufUnload, this, this.disposables);
    events_default.on("TermOpen", this.onBufCreate, this, this.disposables);
    events_default.on("TermClose", this.onBufUnload, this, this.disposables);
    events_default.on("BufWritePost", this.onBufWritePost, this, this.disposables);
    events_default.on("BufWritePre", this.onBufWritePre, this, this.disposables);
    events_default.on("FileType", this.onFileTypeChange, this, this.disposables);
    events_default.on("CursorHold", this.checkCurrentBuffer, this, this.disposables);
    events_default.on("TextChanged", this.checkBuffer, this, this.disposables);
    events_default.on("BufReadCmd", this.onBufReadCmd, this, this.disposables);
    events_default.on("VimResized", (columns, lines) => {
      Object.assign(this._env, {columns, lines});
    }, null, this.disposables);
    await this.attach();
    this.attachChangedEvents();
    this.configurations.onDidChange((e) => {
      this._onDidChangeConfiguration.fire(e);
    }, null, this.disposables);
    this.watchOption("runtimepath", (oldValue, newValue) => {
      let result = fast_diff2.default(oldValue, newValue);
      for (let [changeType, value] of result) {
        if (changeType == 1) {
          let paths = value.replace(/,$/, "").split(",");
          this._onDidRuntimePathChange.fire(paths);
        }
      }
      this._env.runtimepath = newValue;
    }, this.disposables);
    this.watchOption("completeopt", async (_, newValue) => {
      this.env.completeOpt = newValue;
      if (!this._attached)
        return;
      if (this.insertMode) {
        let suggest = this.getConfiguration("suggest");
        if (suggest.get("autoTrigger") == "always") {
          let content = await this.nvim.call("execute", ["verbose set completeopt"]);
          let lines = content.split(/\r?\n/);
          console.error(`Some plugin change completeopt on insert mode: ${lines[lines.length - 1].trim()}!`);
        }
      }
    }, this.disposables);
    this.watchGlobal("coc_sources_disable_map", async (_, newValue) => {
      this.env.disabledSources = newValue;
    });
    this.disposables.push(this.registerTextDocumentContentProvider("output", channels_default.getProvider(nvim)));
  }
  getConfigFile(target) {
    return this.configurations.getConfigFile(target);
  }
  registerAutocmd(autocmd) {
    this.autocmdMaxId += 1;
    let id = this.autocmdMaxId;
    this.autocmds.set(id, autocmd);
    this.setupDynamicAutocmd();
    return vscode_languageserver_protocol13.Disposable.create(() => {
      this.autocmds.delete(id);
      this.setupDynamicAutocmd();
    });
  }
  watchOption(key, callback, disposables) {
    let watching = this.watchedOptions.has(key);
    if (!watching) {
      this.watchedOptions.add(key);
      this.setupDynamicAutocmd();
    }
    let disposable = events_default.on("OptionSet", async (changed, oldValue, newValue) => {
      if (changed == key && callback) {
        await Promise.resolve(callback(oldValue, newValue));
      }
    });
    if (disposables) {
      disposables.push(vscode_languageserver_protocol13.Disposable.create(() => {
        disposable.dispose();
        if (watching)
          return;
        this.watchedOptions.delete(key);
        this.setupDynamicAutocmd();
      }));
    }
  }
  watchGlobal(key, callback, disposables) {
    let {nvim} = this;
    nvim.call("coc#_watch", key, true);
    let disposable = events_default.on("GlobalChange", async (changed, oldValue, newValue) => {
      if (changed == key && callback) {
        await Promise.resolve(callback(oldValue, newValue));
      }
    });
    if (disposables) {
      disposables.push(vscode_languageserver_protocol13.Disposable.create(() => {
        disposable.dispose();
        nvim.call("coc#_unwatch", key, true);
      }));
    }
  }
  get cwd() {
    return this._cwd;
  }
  get env() {
    return this._env;
  }
  get root() {
    return this._root || this.cwd;
  }
  get rootPath() {
    return this.root;
  }
  get workspaceFolders() {
    return this._workspaceFolders;
  }
  get uri() {
    let {bufnr} = this;
    if (bufnr) {
      let document3 = this.getDocument(bufnr);
      if (document3 && document3.schema == "file") {
        return document3.uri;
      }
    }
    return null;
  }
  get workspaceFolder() {
    let {rootPath} = this;
    if (rootPath == os7.default.homedir())
      return null;
    return {
      uri: URI.file(rootPath).toString(),
      name: path21.default.basename(rootPath)
    };
  }
  get textDocuments() {
    let docs = [];
    for (let b of this.buffers.values()) {
      docs.push(b.textDocument);
    }
    return docs;
  }
  get documents() {
    return Array.from(this.buffers.values());
  }
  createNameSpace(name2 = "") {
    if (this.namespaceMap.has(name2))
      return this.namespaceMap.get(name2);
    NAME_SPACE = NAME_SPACE + 1;
    this.namespaceMap.set(name2, NAME_SPACE);
    return NAME_SPACE;
  }
  get channelNames() {
    return channels_default.names;
  }
  get pluginRoot() {
    return path21.default.dirname(__dirname);
  }
  get isVim() {
    return this._env.isVim;
  }
  get isNvim() {
    return !this._env.isVim;
  }
  get completeOpt() {
    return this._env.completeOpt;
  }
  get initialized() {
    return this._initialized;
  }
  get ready() {
    if (this._initialized)
      return Promise.resolve();
    return new Promise((resolve3) => {
      let disposable = this.onDidWorkspaceInitialized(() => {
        disposable.dispose();
        resolve3();
      });
    });
  }
  get filetypes() {
    let res = new Set();
    for (let doc of this.documents) {
      res.add(doc.filetype);
    }
    return res;
  }
  match(selector, document3) {
    return score(selector, document3.uri, document3.languageId);
  }
  async findUp(filename) {
    let {cwd} = this;
    let filepath = await this.nvim.call("expand", "%:p");
    filepath = path21.default.normalize(filepath);
    let isFile2 = filepath && path21.default.isAbsolute(filepath);
    if (isFile2 && !isParentFolder(cwd, filepath, true)) {
      return findUp(filename, path21.default.dirname(filepath));
    }
    let res = findUp(filename, cwd);
    if (res && res != os7.default.homedir())
      return res;
    if (isFile2)
      return findUp(filename, path21.default.dirname(filepath));
    return null;
  }
  async resolveRootFolder(uri, patterns) {
    let {cwd} = this;
    if (uri.scheme != "file")
      return cwd;
    let filepath = path21.default.normalize(uri.fsPath);
    let dir = path21.default.dirname(filepath);
    return resolveRoot(dir, patterns) || dir;
  }
  createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete) {
    let watchmanPath = global.hasOwnProperty("__TEST__") ? null : this.getWatchmanPath();
    let channel = watchmanPath ? window_default.createOutputChannel("watchman") : null;
    let promise = watchmanPath ? watchman_default.createClient(watchmanPath, this.root, channel) : Promise.resolve(null);
    let watcher = new fileSystemWatcher_default(promise, globPattern, !!ignoreCreate, !!ignoreChange, !!ignoreDelete);
    return watcher;
  }
  getWatchmanPath() {
    const preferences = this.getConfiguration("coc.preferences");
    let watchmanPath = preferences.get("watchmanPath", "watchman");
    try {
      return which3.default.sync(watchmanPath);
    } catch (e) {
      return null;
    }
  }
  getConfiguration(section2, resource) {
    return this.configurations.getConfiguration(section2, resource);
  }
  getDocument(uri) {
    if (typeof uri === "number") {
      return this.buffers.get(uri);
    }
    const caseInsensitive = platform_exports.isWindows || platform_exports.isMacintosh;
    uri = URI.parse(uri).toString();
    for (let doc of this.buffers.values()) {
      if (!doc)
        continue;
      if (doc.uri === uri)
        return doc;
      if (caseInsensitive && doc.uri.toLowerCase() === uri.toLowerCase())
        return doc;
    }
    return null;
  }
  async applyEdit(edit2) {
    let {nvim} = this;
    let {documentChanges, changes} = edit2;
    let [bufnr, cursor] = await nvim.eval('[bufnr("%"),coc#util#cursor()]');
    let document3 = this.getDocument(bufnr);
    let uri = document3 ? document3.uri : null;
    let currEdits = null;
    let locations = [];
    let changeCount = 0;
    const preferences = this.getConfiguration("coc.preferences");
    let promptUser = !global.hasOwnProperty("__TEST__") && preferences.get("promptWorkspaceEdit", true);
    let listTarget = preferences.get("listOfWorkspaceEdit", "quickfix");
    try {
      if (documentChanges && documentChanges.length) {
        let changedUris = this.getChangedUris(documentChanges);
        changeCount = changedUris.length;
        if (promptUser) {
          let diskCount = changedUris.reduce((p, c) => {
            return p + (this.getDocument(c) == null ? 1 : 0);
          }, 0);
          if (diskCount) {
            let res = await window_default.showPrompt(`${diskCount} documents on disk would be loaded for change, confirm?`);
            if (!res)
              return;
          }
        }
        let changedMap = new Map();
        let textEdits = [];
        for (let i = 0; i < documentChanges.length; i++) {
          let change = documentChanges[i];
          if (vscode_languageserver_protocol13.TextDocumentEdit.is(change)) {
            let {textDocument, edits} = change;
            let next = documentChanges[i + 1];
            textEdits.push(...edits);
            if (next && vscode_languageserver_protocol13.TextDocumentEdit.is(next) && equals(next.textDocument, textDocument)) {
              continue;
            }
            let doc = await this.loadFile(textDocument.uri);
            if (textDocument.uri == uri)
              currEdits = textEdits;
            await doc.applyEdits(textEdits);
            for (let edit3 of textEdits) {
              locations.push({uri: doc.uri, range: edit3.range});
            }
            textEdits = [];
          } else if (vscode_languageserver_protocol13.CreateFile.is(change)) {
            let file = URI.parse(change.uri).fsPath;
            await this.createFile(file, change.options);
          } else if (vscode_languageserver_protocol13.RenameFile.is(change)) {
            changedMap.set(change.oldUri, change.newUri);
            await this.renameFile(URI.parse(change.oldUri).fsPath, URI.parse(change.newUri).fsPath, change.options);
          } else if (vscode_languageserver_protocol13.DeleteFile.is(change)) {
            await this.deleteFile(URI.parse(change.uri).fsPath, change.options);
          }
        }
        if (changedMap.size) {
          locations.forEach((location5) => {
            let newUri = changedMap.get(location5.uri);
            if (newUri)
              location5.uri = newUri;
          });
        }
      } else if (changes) {
        let uris = Object.keys(changes);
        let unloaded = uris.filter((uri2) => this.getDocument(uri2) == null);
        if (unloaded.length) {
          if (promptUser) {
            let res = await window_default.showPrompt(`${unloaded.length} documents on disk would be loaded for change, confirm?`);
            if (!res)
              return;
          }
          await this.loadFiles(unloaded);
        }
        for (let uri2 of Object.keys(changes)) {
          let document4 = this.getDocument(uri2);
          if (URI.parse(uri2).toString() == uri2)
            currEdits = changes[uri2];
          let edits = changes[uri2];
          for (let edit3 of edits) {
            locations.push({uri: document4.uri, range: edit3.range});
          }
          await document4.applyEdits(edits);
        }
        changeCount = uris.length;
      }
      if (currEdits) {
        let changed = getChangedFromEdits({line: cursor[0], character: cursor[1]}, currEdits);
        if (changed)
          await window_default.moveTo({
            line: cursor[0] + changed.line,
            character: cursor[1] + changed.character
          });
      }
      if (locations.length) {
        let items = await Promise.all(locations.map((loc) => this.getQuickfixItem(loc)));
        let silent = locations.every((l) => l.uri == uri);
        if (listTarget == "quickfix") {
          await this.nvim.call("setqflist", [items]);
          if (!silent)
            window_default.showMessage(`changed ${changeCount} buffers, use :wa to save changes to disk and :copen to open quickfix list`, "more");
        } else if (listTarget == "location") {
          await nvim.setVar("coc_jump_locations", items);
          if (!silent)
            window_default.showMessage(`changed ${changeCount} buffers, use :wa to save changes to disk and :CocList location to manage changed locations`, "more");
        }
      }
    } catch (e) {
      logger24.error(e);
      window_default.showMessage(`Error on applyEdits: ${e.message}`, "error");
      return false;
    }
    await wait(50);
    return true;
  }
  async getQuickfixItem(loc, text, type = "", module2) {
    if (vscode_languageserver_protocol13.LocationLink.is(loc)) {
      loc = vscode_languageserver_protocol13.Location.create(loc.targetUri, loc.targetRange);
    }
    let doc = this.getDocument(loc.uri);
    let {uri, range: range2} = loc;
    let {line, character} = range2.start;
    let u = URI.parse(uri);
    let bufnr = doc ? doc.bufnr : -1;
    if (!text && u.scheme == "file") {
      text = await this.getLine(uri, line);
      character = byteIndex(text, character);
    }
    let item = {
      uri,
      filename: u.scheme == "file" ? u.fsPath : uri,
      lnum: line + 1,
      col: character + 1,
      text: text || "",
      range: range2
    };
    if (module2)
      item.module = module2;
    if (type)
      item.type = type;
    if (bufnr != -1)
      item.bufnr = bufnr;
    return item;
  }
  createMru(name2) {
    return new mru_default(name2);
  }
  async getSelectedRange(mode, document3) {
    let {nvim} = this;
    if (mode == "n") {
      let line = await nvim.call("line", ["."]);
      let content = document3.getline(line - 1);
      if (!content.length)
        return null;
      return vscode_languageserver_protocol13.Range.create(line - 1, 0, line - 1, content.length);
    }
    if (!["v", "V", "char", "line", ""].includes(mode)) {
      throw new Error(`Mode '${mode}' not supported`);
    }
    let isVisual = ["v", "V", ""].includes(mode);
    let [, sl, sc] = await nvim.call("getpos", isVisual ? `'<` : `'[`);
    let [, el, ec] = await nvim.call("getpos", isVisual ? `'>` : `']`);
    let range2 = vscode_languageserver_protocol13.Range.create(document3.getPosition(sl, sc), document3.getPosition(el, ec));
    if (mode == "v" || mode == "") {
      range2.end.character = range2.end.character + 1;
    }
    return range2;
  }
  async selectRange(range2) {
    let {nvim} = this;
    let {start, end} = range2;
    let [bufnr, ve, selection] = await nvim.eval(`[bufnr('%'), &virtualedit, &selection, mode()]`);
    let document3 = this.getDocument(bufnr);
    if (!document3)
      return;
    let line = document3.getline(start.line);
    let col = line ? byteLength(line.slice(0, start.character)) : 0;
    let endLine = document3.getline(end.line);
    let endCol = endLine ? byteLength(endLine.slice(0, end.character)) : 0;
    let move_cmd = "";
    let resetVirtualEdit = false;
    move_cmd += "v";
    endCol = await nvim.eval(`virtcol([${end.line + 1}, ${endCol}])`);
    if (selection == "inclusive") {
      if (end.character == 0) {
        move_cmd += `${end.line}G`;
      } else {
        move_cmd += `${end.line + 1}G${endCol}|`;
      }
    } else if (selection == "old") {
      move_cmd += `${end.line + 1}G${endCol}|`;
    } else {
      move_cmd += `${end.line + 1}G${endCol + 1}|`;
    }
    col = await nvim.eval(`virtcol([${start.line + 1}, ${col}])`);
    move_cmd += `o${start.line + 1}G${col + 1}|o`;
    nvim.pauseNotification();
    if (ve != "onemore") {
      resetVirtualEdit = true;
      nvim.setOption("virtualedit", "onemore", true);
    }
    nvim.command(`noa call cursor(${start.line + 1},${col + (move_cmd == "a" ? 0 : 1)})`, true);
    nvim.command(`normal! ${move_cmd}`, true);
    if (resetVirtualEdit)
      nvim.setOption("virtualedit", ve, true);
    if (this.isVim)
      nvim.command("redraw", true);
    await nvim.resumeNotification();
  }
  async showLocations(locations) {
    let items = await Promise.all(locations.map((loc) => this.getQuickfixItem(loc)));
    let {nvim} = this;
    const preferences = this.getConfiguration("coc.preferences");
    if (preferences.get("useQuickfixForLocations", false)) {
      let openCommand = await nvim.getVar("coc_quickfix_open_command");
      if (typeof openCommand != "string") {
        openCommand = items.length < 10 ? `copen ${items.length}` : "copen";
      }
      nvim.pauseNotification();
      nvim.call("setqflist", [items], true);
      nvim.command(openCommand, true);
      nvim.resumeNotification(false, true);
    } else {
      await nvim.setVar("coc_jump_locations", items);
      if (this.env.locationlist) {
        nvim.command("CocList --normal --auto-preview location", true);
      } else {
        nvim.call("coc#util#do_autocmd", ["CocLocationsChange"], true);
      }
    }
  }
  async getLine(uri, line) {
    let document3 = this.getDocument(uri);
    if (document3)
      return document3.getline(line) || "";
    if (!uri.startsWith("file:"))
      return "";
    let fsPath = URI.parse(uri).fsPath;
    if (!fs_extra4.default.existsSync(fsPath))
      return "";
    return await readFileLine(fsPath, line);
  }
  getWorkspaceFolder(uri) {
    this.workspaceFolders.sort((a, b) => b.uri.length - a.uri.length);
    let filepath = URI.parse(uri).fsPath;
    return this.workspaceFolders.find((folder) => isParentFolder(URI.parse(folder.uri).fsPath, filepath, true));
  }
  async readFile(uri) {
    let document3 = this.getDocument(uri);
    if (document3) {
      await document3.patchChange();
      return document3.content;
    }
    let u = URI.parse(uri);
    if (u.scheme != "file")
      return "";
    let lines = await this.nvim.call("readfile", [u.fsPath]);
    return lines.join("\n") + "\n";
  }
  get document() {
    return new Promise((resolve3, reject) => {
      this.nvim.buffer.then((buf) => {
        let bufnr = buf.id;
        this.bufnr = bufnr;
        if (this.buffers.has(bufnr)) {
          resolve3(this.buffers.get(bufnr));
          return;
        }
        this.onBufCreate(bufnr).catch(reject);
        let disposable = this.onDidOpenTextDocument((doc) => {
          disposable.dispose();
          resolve3(this.getDocument(doc.uri));
        });
      }, reject);
    });
  }
  async getCurrentState() {
    let document3 = await this.document;
    let position15 = await window_default.getCursorPosition();
    return {
      document: document3.textDocument,
      position: position15
    };
  }
  async getFormatOptions(uri) {
    let doc;
    if (uri)
      doc = this.getDocument(uri);
    let bufnr = doc ? doc.bufnr : 0;
    let [tabSize, insertSpaces] = await this.nvim.call("coc#util#get_format_opts", [bufnr]);
    return {
      tabSize,
      insertSpaces: insertSpaces == 1
    };
  }
  async jumpTo(uri, position15, openCommand) {
    const preferences = this.getConfiguration("coc.preferences");
    let jumpCommand = openCommand || preferences.get("jumpCommand", "edit");
    let {nvim} = this;
    let doc = this.getDocument(uri);
    let bufnr = doc ? doc.bufnr : -1;
    if (bufnr != -1 && jumpCommand == "edit") {
      nvim.pauseNotification();
      nvim.command(`silent! normal! m'`, true);
      nvim.command(`buffer ${bufnr}`, true);
      if (position15) {
        let line = doc.getline(position15.line);
        let col = byteLength(line.slice(0, position15.character)) + 1;
        nvim.call("cursor", [position15.line + 1, col], true);
      }
      if (this.isVim)
        nvim.command("redraw", true);
      await nvim.resumeNotification();
    } else {
      let {fsPath, scheme} = URI.parse(uri);
      let pos = position15 == null ? null : [position15.line, position15.character];
      if (scheme == "file") {
        let bufname = fixDriver(path21.default.normalize(fsPath));
        await this.nvim.call("coc#util#jump", [jumpCommand, bufname, pos]);
      } else {
        if (os7.default.platform() == "win32") {
          uri = uri.replace(/\/?/, "?");
        }
        await this.nvim.call("coc#util#jump", [jumpCommand, uri, pos]);
      }
    }
  }
  async createFile(filepath, opts = {}) {
    let stat = await statAsync(filepath);
    if (stat && !opts.overwrite && !opts.ignoreIfExists) {
      window_default.showMessage(`${filepath} already exists!`, "error");
      return;
    }
    if (!stat || opts.overwrite) {
      if (filepath.endsWith("/")) {
        try {
          filepath = this.expand(filepath);
          await fs_extra4.default.mkdirp(filepath);
        } catch (e) {
          window_default.showMessage(`Can't create ${filepath}: ${e.message}`, "error");
        }
      } else {
        let uri = URI.file(filepath).toString();
        let doc = this.getDocument(uri);
        if (doc)
          return;
        if (!fs_extra4.default.existsSync(path21.default.dirname(filepath))) {
          fs_extra4.default.mkdirpSync(path21.default.dirname(filepath));
        }
        fs_extra4.default.writeFileSync(filepath, "", "utf8");
        await this.loadFile(uri);
      }
    }
  }
  async loadFile(uri) {
    let doc = this.getDocument(uri);
    if (doc)
      return doc;
    let {nvim} = this;
    let filepath = uri.startsWith("file") ? URI.parse(uri).fsPath : uri;
    nvim.call("coc#util#open_files", [[filepath]], true);
    return await new Promise((resolve3, reject) => {
      let disposable = this.onDidOpenTextDocument((textDocument) => {
        let fsPath = URI.parse(textDocument.uri).fsPath;
        if (textDocument.uri == uri || fsPath == filepath) {
          clearTimeout(timer);
          disposable.dispose();
          resolve3(this.getDocument(uri));
        }
      });
      let timer = setTimeout(() => {
        disposable.dispose();
        reject(new Error(`Create document ${uri} timeout after 1s.`));
      }, 1e3);
    });
  }
  async loadFiles(uris) {
    uris = uris.filter((uri) => this.getDocument(uri) == null);
    if (!uris.length)
      return;
    let bufnrs = await this.nvim.call("coc#util#open_files", [uris.map((u) => URI.parse(u).fsPath)]);
    let create = bufnrs.filter((bufnr) => this.getDocument(bufnr) == null);
    if (!create.length)
      return;
    return new Promise((resolve3, reject) => {
      let timer = setTimeout(() => {
        disposable.dispose();
        reject(new Error(`Create document timeout after 2s.`));
      }, 2e3);
      let disposable = this.onDidOpenTextDocument(() => {
        if (uris.every((uri) => this.getDocument(uri) != null)) {
          clearTimeout(timer);
          disposable.dispose();
          resolve3();
        }
      });
    });
  }
  async renameFile(oldPath, newPath, opts = {}) {
    let {overwrite, ignoreIfExists} = opts;
    let {nvim} = this;
    try {
      let stat = await statAsync(newPath);
      if (stat && !overwrite && !ignoreIfExists) {
        throw new Error(`${newPath} already exists`);
      }
      if (!stat || overwrite) {
        let uri = URI.file(oldPath).toString();
        let newUri = URI.file(newPath).toString();
        let doc = this.getDocument(uri);
        let isCurrent = doc.bufnr == this.bufnr;
        let newDoc = this.getDocument(newUri);
        if (newDoc)
          await this.nvim.command(`silent ${newDoc.bufnr}bwipeout!`);
        if (doc != null) {
          let content = doc.getDocumentContent();
          let encoding = await doc.buffer.getOption("fileencoding");
          await fs_extra4.default.writeFile(newPath, content, {encoding});
          if (!isCurrent) {
            await nvim.call("coc#util#open_files", [[newPath]]);
            await nvim.command(`silent ${doc.bufnr}bwipeout!`);
          } else {
            let view = await nvim.call("winsaveview");
            nvim.pauseNotification();
            nvim.call("coc#util#open_file", ["keepalt edit", newPath], true);
            nvim.command(`silent ${doc.bufnr}bwipeout!`, true);
            nvim.call("winrestview", [view], true);
            await nvim.resumeNotification();
          }
          await fs_extra4.default.unlink(oldPath);
        } else {
          await renameAsync(oldPath, newPath);
        }
      }
    } catch (e) {
      window_default.showMessage(`Rename error: ${e.message}`, "error");
    }
  }
  async deleteFile(filepath, opts = {}) {
    let {ignoreIfNotExists, recursive} = opts;
    let stat = await statAsync(filepath.replace(/\/$/, ""));
    let isDir = stat && stat.isDirectory();
    if (filepath.endsWith("/") && !isDir) {
      window_default.showMessage(`${filepath} is not directory`, "error");
      return;
    }
    if (!stat && !ignoreIfNotExists) {
      window_default.showMessage(`${filepath} not exists`, "error");
      return;
    }
    if (stat == null)
      return;
    if (isDir && !recursive) {
      window_default.showMessage(`Can't remove directory, recursive not set`, "error");
      return;
    }
    try {
      if (isDir && recursive) {
        await fs_extra4.default.remove(filepath);
      } else if (isDir) {
        await fs_extra4.default.rmdir(filepath);
      } else {
        await fs_extra4.default.unlink(filepath);
      }
      if (!isDir) {
        let uri = URI.file(filepath).toString();
        let doc = this.getDocument(uri);
        if (doc)
          await this.nvim.command(`silent! bwipeout! ${doc.bufnr}`);
      }
    } catch (e) {
      window_default.showMessage(`Error on delete ${filepath}: ${e.message}`, "error");
    }
  }
  async openResource(uri) {
    let {nvim} = this;
    if (uri.startsWith("http")) {
      await nvim.call("coc#util#open_url", uri);
      return;
    }
    let wildignore = await nvim.getOption("wildignore");
    await nvim.setOption("wildignore", "");
    await this.jumpTo(uri);
    await nvim.setOption("wildignore", wildignore);
  }
  async resolveModule(name2) {
    return await this.resolver.resolveModule(name2);
  }
  async runCommand(cmd, cwd, timeout) {
    cwd = cwd || this.cwd;
    return runCommand(cmd, {cwd}, timeout);
  }
  expand(filepath) {
    if (!filepath)
      return filepath;
    if (filepath.startsWith("~")) {
      filepath = os7.default.homedir() + filepath.slice(1);
    }
    if (filepath.includes("$")) {
      let doc = this.getDocument(this.bufnr);
      let fsPath = doc ? URI.parse(doc.uri).fsPath : "";
      filepath = filepath.replace(/\$\{(.*?)\}/g, (match3, name2) => {
        if (name2.startsWith("env:")) {
          let key = name2.split(":")[1];
          let val = key ? process.env[key] : "";
          return val;
        }
        switch (name2) {
          case "workspace":
          case "workspaceRoot":
          case "workspaceFolder":
            return this.root;
          case "workspaceFolderBasename":
            return path21.default.dirname(this.root);
          case "cwd":
            return this.cwd;
          case "file":
            return fsPath;
          case "fileDirname":
            return fsPath ? path21.default.dirname(fsPath) : "";
          case "fileExtname":
            return fsPath ? path21.default.extname(fsPath) : "";
          case "fileBasename":
            return fsPath ? path21.default.basename(fsPath) : "";
          case "fileBasenameNoExtension": {
            let basename = fsPath ? path21.default.basename(fsPath) : "";
            return basename ? basename.slice(0, basename.length - path21.default.extname(basename).length) : "";
          }
          default:
            return match3;
        }
      });
      filepath = filepath.replace(/\$[\w]+/g, (match3) => {
        if (match3 == "$HOME")
          return os7.default.homedir();
        return process.env[match3.slice(1)] || match3;
      });
    }
    return filepath;
  }
  async createTerminal(opts) {
    let cmd = opts.shellPath;
    let args = opts.shellArgs;
    if (!cmd)
      cmd = await this.nvim.getOption("shell");
    let terminal2 = new terminal_default(cmd, args || [], this.nvim, opts.name);
    await terminal2.start(opts.cwd || this.cwd, opts.env);
    this.terminals.set(terminal2.bufnr, terminal2);
    this._onDidOpenTerminal.fire(terminal2);
    return terminal2;
  }
  async callAsync(method, args) {
    if (this.isNvim)
      return await this.nvim.call(method, args);
    return await this.nvim.callAsync("coc#util#with_callback", [method, args]);
  }
  registerTextDocumentContentProvider(scheme, provider) {
    this.schemeProviderMap.set(scheme, provider);
    this.setupDynamicAutocmd();
    let disposables = [];
    if (provider.onDidChange) {
      provider.onDidChange(async (uri) => {
        let doc = this.getDocument(uri.toString());
        if (doc) {
          let {buffer: buffer4} = doc;
          let tokenSource = new vscode_languageserver_protocol13.CancellationTokenSource();
          let content = await Promise.resolve(provider.provideTextDocumentContent(uri, tokenSource.token));
          await buffer4.setLines(content.split("\n"), {
            start: 0,
            end: -1,
            strictIndexing: false
          });
        }
      }, null, disposables);
    }
    return vscode_languageserver_protocol13.Disposable.create(() => {
      this.schemeProviderMap.delete(scheme);
      disposeAll(disposables);
      this.setupDynamicAutocmd();
    });
  }
  registerKeymap(modes, key, fn, opts = {}) {
    if (!key)
      throw new Error(`Invalid key ${key} of registerKeymap`);
    if (this.keymaps.has(key))
      throw new Error(`${key} already exists.`);
    opts = Object.assign({sync: true, cancel: true, silent: true, repeat: false}, opts);
    let {nvim} = this;
    this.keymaps.set(key, [fn, !!opts.repeat]);
    let method = opts.sync ? "request" : "notify";
    let silent = opts.silent ? "<silent>" : "";
    for (let m of modes) {
      if (m == "i") {
        nvim.command(`inoremap ${silent}<expr> <Plug>(coc-${key}) coc#_insert_key('${method}', '${key}', ${opts.cancel ? 1 : 0})`, true);
      } else {
        let modify2 = getKeymapModifier(m);
        nvim.command(`${m}noremap ${silent} <Plug>(coc-${key}) :${modify2}call coc#rpc#${method}('doKeymap', ['${key}'])<cr>`, true);
      }
    }
    return vscode_languageserver_protocol13.Disposable.create(() => {
      this.keymaps.delete(key);
      for (let m of modes) {
        nvim.command(`${m}unmap <Plug>(coc-${key})`, true);
      }
    });
  }
  registerExprKeymap(mode, key, fn, buffer4 = false) {
    if (!key)
      return;
    let id = `${mode}${global.Buffer.from(key).toString("base64")}${buffer4 ? "1" : "0"}`;
    let {nvim} = this;
    this.keymaps.set(id, [fn, false]);
    if (mode == "i") {
      nvim.command(`inoremap <silent><expr>${buffer4 ? "<nowait><buffer>" : ""} ${key} coc#_insert_key('request', '${id}')`, true);
    } else {
      nvim.command(`${mode}noremap <silent><expr>${buffer4 ? "<nowait><buffer>" : ""} ${key} coc#rpc#request('doKeymap', ['${id}'])`, true);
    }
    return vscode_languageserver_protocol13.Disposable.create(() => {
      this.keymaps.delete(id);
      nvim.command(`${mode}unmap ${buffer4 ? "<buffer>" : ""} ${key}`, true);
    });
  }
  registerLocalKeymap(mode, key, fn, notify = false) {
    let id = v1_default();
    let {nvim} = this;
    this.keymaps.set(id, [fn, false]);
    let buf = this.nvim.createBuffer(this.bufnr);
    let method = notify ? "notify" : "request";
    let modify2 = getKeymapModifier(mode);
    let escaped = key.startsWith("<") && key.endsWith(">") ? `{${key.slice(1, -1)}}` : key;
    if (this.isNvim && !global.hasOwnProperty("__TEST__")) {
      buf.notify("nvim_buf_set_keymap", [mode, key, `:${modify2}call coc#rpc#${method}('doKeymap', ['${id}', '', '${escaped}'])<CR>`, {
        silent: true,
        nowait: true
      }]);
    } else {
      let cmd = `${mode}noremap <silent><nowait><buffer> ${key} :${modify2}call coc#rpc#${method}('doKeymap', ['${id}', '', '${escaped}'])<CR>`;
      nvim.command(cmd, true);
    }
    return vscode_languageserver_protocol13.Disposable.create(() => {
      this.keymaps.delete(id);
      nvim.call("coc#compat#buf_del_keymap", [buf.id, mode, key], true);
    });
  }
  createDatabase(name2) {
    let root;
    if (global.hasOwnProperty("__TEST__")) {
      root = path21.default.join(os7.default.tmpdir(), `coc-${process.pid}`);
      fs_extra4.default.mkdirpSync(root);
    } else {
      root = path21.default.dirname(this.env.extensionRoot);
    }
    let filepath = path21.default.join(root, name2 + ".json");
    return new db_default(filepath);
  }
  createTask(id) {
    return new task_default(this.nvim, id);
  }
  registerBufferSync(create) {
    return new bufferSync_default(create, this);
  }
  setupDynamicAutocmd(initialize = false) {
    if (!initialize && !this._dynAutocmd)
      return;
    this._dynAutocmd = true;
    let schemes = this.schemeProviderMap.keys();
    let cmds = [];
    for (let scheme of schemes) {
      cmds.push(`autocmd BufReadCmd,FileReadCmd,SourceCmd ${scheme}://* call coc#rpc#request('CocAutocmd', ['BufReadCmd','${scheme}', expand('<amatch>')])`);
    }
    for (let [id, autocmd] of this.autocmds.entries()) {
      let args = autocmd.arglist && autocmd.arglist.length ? ", " + autocmd.arglist.join(", ") : "";
      let event = Array.isArray(autocmd.event) ? autocmd.event.join(",") : autocmd.event;
      let pattern = autocmd.pattern != null ? autocmd.pattern : "*";
      if (/\buser\b/i.test(event)) {
        pattern = "";
      }
      cmds.push(`autocmd ${event} ${pattern} call coc#rpc#${autocmd.request ? "request" : "notify"}('doAutocmd', [${id}${args}])`);
    }
    for (let key of this.watchedOptions) {
      cmds.push(`autocmd OptionSet ${key} call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])`);
    }
    let content = `
augroup coc_dynamic_autocmd
  autocmd!
  ${cmds.join("\n  ")}
augroup end`;
    try {
      let dir = path21.default.join(process.env.TMPDIR, `coc.nvim-${process.pid}`);
      if (!fs_extra4.default.existsSync(dir))
        fs_extra4.default.mkdirpSync(dir);
      let filepath = path21.default.join(dir, `coc-${process.pid}.vim`);
      fs_extra4.default.writeFileSync(filepath, content, "utf8");
      let cmd = `source ${filepath}`;
      if (this.env.isCygwin && platform_exports.isWindows) {
        cmd = `execute "source" . substitute(system('cygpath ${filepath.replace(/\\/g, "/")}'), '\\n', '', 'g')`;
      }
      this.nvim.command(cmd).logError();
    } catch (e) {
      window_default.showMessage(`Can't create tmp file: ${e.message}`, "error");
    }
  }
  async onBufReadCmd(scheme, uri) {
    let provider = this.schemeProviderMap.get(scheme);
    if (!provider) {
      window_default.showMessage(`Provider for ${scheme} not found`, "error");
      return;
    }
    let tokenSource = new vscode_languageserver_protocol13.CancellationTokenSource();
    let content = await Promise.resolve(provider.provideTextDocumentContent(URI.parse(uri), tokenSource.token));
    let buf = await this.nvim.buffer;
    await buf.setLines(content.split("\n"), {
      start: 0,
      end: -1,
      strictIndexing: false
    });
    setTimeout(async () => {
      await events_default.fire("BufCreate", [buf.id]);
    }, 30);
  }
  async attach() {
    if (this._attached)
      return;
    this._attached = true;
    let [bufs, bufnr, winid] = await this.nvim.eval(`[map(getbufinfo({'bufloaded': 1}),'v:val["bufnr"]'),bufnr('%'),win_getid()]`);
    this.bufnr = bufnr;
    await Promise.all(bufs.map((buf) => this.onBufCreate(buf)));
    if (!this._initialized) {
      this._onDidWorkspaceInitialized.fire(void 0);
      this._initialized = true;
    }
    await events_default.fire("BufEnter", [bufnr]);
    await events_default.fire("BufWinEnter", [bufnr, winid]);
  }
  getChangedUris(documentChanges) {
    let uris = new Set();
    let createUris = new Set();
    for (let change of documentChanges) {
      if (vscode_languageserver_protocol13.TextDocumentEdit.is(change)) {
        let {textDocument} = change;
        let {uri, version: version2} = textDocument;
        uris.add(uri);
        if (version2 != null && version2 > 0) {
          let doc = this.getDocument(uri);
          if (!doc) {
            throw new Error(`${uri} not loaded`);
          }
          if (doc.version != version2) {
            throw new Error(`${uri} changed before apply edit`);
          }
        }
      } else if (vscode_languageserver_protocol13.CreateFile.is(change) || vscode_languageserver_protocol13.DeleteFile.is(change)) {
        if (!isFile(change.uri)) {
          throw new Error(`change of scheme ${change.uri} not supported`);
        }
        createUris.add(change.uri);
        uris.add(change.uri);
      } else if (vscode_languageserver_protocol13.RenameFile.is(change)) {
        if (!isFile(change.oldUri) || !isFile(change.newUri)) {
          throw new Error(`change of scheme ${change.oldUri} not supported`);
        }
        let newFile = URI.parse(change.newUri).fsPath;
        if (fs_extra4.default.existsSync(newFile)) {
          throw new Error(`file "${newFile}" already exists for rename`);
        }
        uris.add(change.oldUri);
      } else {
        throw new Error(`Invalid document change: ${JSON.stringify(change, null, 2)}`);
      }
    }
    return Array.from(uris);
  }
  createConfigurations() {
    let home = path21.default.normalize(process.env.COC_VIMCONFIG) || path21.default.join(os7.default.homedir(), ".vim");
    let userConfigFile = path21.default.join(home, CONFIG_FILE_NAME);
    return new configuration_default(userConfigFile, new shape_default(this));
  }
  attachChangedEvents() {
    if (this.isVim) {
      const onChange = (bufnr) => {
        let doc = this.getDocument(bufnr);
        if (doc && doc.attached)
          doc.fetchContent();
      };
      events_default.on("TextChangedI", onChange, null, this.disposables);
      events_default.on("TextChanged", onChange, null, this.disposables);
    }
  }
  async onBufCreate(buf) {
    let buffer4 = typeof buf === "number" ? this.nvim.createBuffer(buf) : buf;
    let bufnr = buffer4.id;
    if (this.creatingSources.has(bufnr))
      return;
    let document3 = this.getDocument(bufnr);
    let source3 = new vscode_languageserver_protocol13.CancellationTokenSource();
    try {
      if (document3)
        this.onBufUnload(bufnr, true);
      document3 = new document_default(buffer4, this._env, this.maxFileSize);
      let token = source3.token;
      this.creatingSources.set(bufnr, source3);
      let created = await document3.init(this.nvim, token);
      if (!created)
        document3 = null;
    } catch (e) {
      logger24.error("Error on create buffer:", e);
      document3 = null;
    }
    if (this.creatingSources.get(bufnr) == source3) {
      source3.dispose();
      this.creatingSources.delete(bufnr);
    }
    if (!document3 || !document3.textDocument)
      return;
    this.buffers.set(bufnr, document3);
    if (document3.attached) {
      document3.onDocumentDetach((bufnr2) => {
        let doc = this.getDocument(bufnr2);
        if (doc)
          this.onBufUnload(doc.bufnr);
      });
    }
    if (document3.buftype == "" && document3.schema == "file") {
      this.configurations.checkFolderConfiguration(document3.uri);
      let config = this.getConfiguration("workspace");
      let filetypes = config.get("ignoredFiletypes", []);
      if (!filetypes.includes(document3.filetype)) {
        let root = this.resolveRoot(document3);
        if (root) {
          this.addWorkspaceFolder(root);
          if (this.bufnr == buffer4.id) {
            this._root = root;
          }
        }
      }
    }
    if (document3.enabled) {
      let textDocument = Object.assign(document3.textDocument, {bufnr});
      this._onDidOpenDocument.fire(textDocument);
      document3.onDocumentChange((e) => this._onDidChangeDocument.fire(e));
    }
    logger24.debug("buffer created", buffer4.id);
  }
  onBufEnter(bufnr) {
    this.bufnr = bufnr;
    let doc = this.getDocument(bufnr);
    if (doc) {
      this.configurations.setFolderConfiguration(doc.uri);
      let workspaceFolder = this.getWorkspaceFolder(doc.uri);
      if (workspaceFolder)
        this._root = URI.parse(workspaceFolder.uri).fsPath;
    }
  }
  async checkCurrentBuffer(bufnr) {
    this.bufnr = bufnr;
    await this.checkBuffer(bufnr);
  }
  onBufWritePost(bufnr) {
    let doc = this.buffers.get(bufnr);
    if (!doc)
      return;
    this._onDidSaveDocument.fire(doc.textDocument);
  }
  onBufUnload(bufnr, recreate = false) {
    logger24.debug("buffer unload", bufnr);
    if (!recreate) {
      let source3 = this.creatingSources.get(bufnr);
      if (source3) {
        source3.cancel();
        this.creatingSources.delete(bufnr);
      }
    }
    if (this.terminals.has(bufnr)) {
      let terminal2 = this.terminals.get(bufnr);
      this._onDidCloseTerminal.fire(terminal2);
      this.terminals.delete(bufnr);
    }
    let doc = this.buffers.get(bufnr);
    if (doc) {
      let textDocument = Object.assign(doc.textDocument, {bufnr});
      this._onDidCloseDocument.fire(textDocument);
      this.buffers.delete(bufnr);
      doc.detach();
    }
  }
  async onBufWritePre(bufnr) {
    let doc = this.buffers.get(bufnr);
    if (!doc || !doc.attached)
      return;
    await doc.checkDocument();
    let firing = true;
    let thenables = [];
    let event = {
      document: doc.textDocument,
      reason: vscode_languageserver_protocol13.TextDocumentSaveReason.Manual,
      waitUntil: (thenable) => {
        if (!firing) {
          logger24.error(`Can't call waitUntil in async manner:`, Error().stack);
          window_default.showMessage(`waitUntil can't be used in async manner, check log for details`, "error");
        } else {
          thenables.push(thenable);
        }
      }
    };
    this._onWillSaveDocument.fire(event);
    firing = false;
    let total = thenables.length;
    if (total) {
      let promise = new Promise((resolve3) => {
        let timer = setTimeout(() => {
          window_default.showMessage("Will save handler timeout after 0.5s", "warning");
          resolve3(void 0);
        }, 500);
        let i = 0;
        let called = false;
        for (let p of thenables) {
          let cb = (res) => {
            if (called)
              return;
            called = true;
            clearTimeout(timer);
            resolve3(res);
          };
          p.then((res) => {
            if (Array.isArray(res) && res.length && vscode_languageserver_protocol13.TextEdit.is(res[0])) {
              return cb(res);
            }
            i = i + 1;
            if (i == total)
              cb(void 0);
          }, () => {
            i = i + 1;
            if (i == total)
              cb(void 0);
          });
        }
      });
      let edits = await promise;
      if (edits)
        await doc.applyEdits(edits);
    }
  }
  onDirChanged(cwd) {
    if (cwd == this._cwd)
      return;
    this._cwd = cwd;
  }
  onFileTypeChange(filetype, bufnr) {
    let doc = this.getDocument(bufnr);
    if (!doc)
      return;
    let converted = doc.convertFiletype(filetype);
    if (converted == doc.filetype)
      return;
    let textDocument = Object.assign(doc.textDocument, {bufnr});
    this._onDidCloseDocument.fire(textDocument);
    doc.setFiletype(filetype);
    this._onDidOpenDocument.fire(textDocument);
  }
  async checkBuffer(bufnr) {
    if (this._disposed || !bufnr)
      return;
    let doc = this.getDocument(bufnr);
    if (!doc && !this.creatingSources.has(bufnr))
      await this.onBufCreate(bufnr);
  }
  resolveRoot(document3) {
    let types11 = [PatternType.Buffer, PatternType.LanguageServer, PatternType.Global];
    let u = URI.parse(document3.uri);
    let dir = path21.default.dirname(u.fsPath);
    let {cwd} = this;
    for (let patternType of types11) {
      let patterns = this.getRootPatterns(document3, patternType);
      if (patterns && patterns.length) {
        let root = resolveRoot(dir, patterns, cwd);
        if (root)
          return root;
      }
    }
    if (this.cwd != os7.default.homedir() && isParentFolder(this.cwd, dir, true))
      return this.cwd;
    return null;
  }
  getRootPatterns(document3, patternType) {
    let {uri} = document3;
    if (patternType == PatternType.Buffer)
      return document3.getVar("root_patterns", []) || [];
    if (patternType == PatternType.LanguageServer)
      return this.getServerRootPatterns(document3.filetype);
    const preferences = this.getConfiguration("coc.preferences", uri);
    return preferences.get("rootPatterns", [".git", ".hg", ".projections.json"]).slice();
  }
  async renameCurrent() {
    let {nvim} = this;
    let bufnr = await nvim.call("bufnr", "%");
    let cwd = await nvim.call("getcwd");
    let doc = this.getDocument(bufnr);
    if (!doc || doc.buftype != "" || doc.schema != "file") {
      nvim.errWriteLine("current buffer is not file.");
      return;
    }
    let oldPath = URI.parse(doc.uri).fsPath;
    let newPath = await nvim.callAsync("coc#util#with_callback", ["input", ["New path: ", oldPath, "file"]]);
    newPath = newPath ? newPath.trim() : null;
    if (newPath == oldPath || !newPath)
      return;
    let lines = await doc.buffer.lines;
    let exists = fs_extra4.default.existsSync(oldPath);
    if (exists) {
      let modified = await nvim.eval("&modified");
      if (modified)
        await nvim.command("noa w");
      if (oldPath.toLowerCase() != newPath.toLowerCase() && fs_extra4.default.existsSync(newPath)) {
        let overwrite = await window_default.showPrompt(`${newPath} exists, overwrite?`);
        if (!overwrite)
          return;
        fs_extra4.default.unlinkSync(newPath);
      }
      fs_extra4.default.renameSync(oldPath, newPath);
    }
    let filepath = isParentFolder(cwd, newPath) ? path21.default.relative(cwd, newPath) : newPath;
    let view = await nvim.call("winsaveview");
    nvim.pauseNotification();
    if (oldPath.toLowerCase() == newPath.toLowerCase()) {
      nvim.command(`keepalt ${bufnr}bwipeout!`, true);
      nvim.call("coc#util#open_file", ["keepalt edit", filepath], true);
    } else {
      nvim.call("coc#util#open_file", ["keepalt edit", filepath], true);
      nvim.command(`${bufnr}bwipeout!`, true);
    }
    if (!exists && lines.join("\n") != "\n") {
      nvim.call("append", [0, lines], true);
      nvim.command("normal! Gdd", true);
    }
    nvim.call("winrestview", [view], true);
    await nvim.resumeNotification();
  }
  get folderPaths() {
    return this.workspaceFolders.map((f) => URI.parse(f.uri).fsPath);
  }
  get floatSupported() {
    let {env: env2} = this;
    return env2.floating || env2.textprop;
  }
  removeWorkspaceFolder(fsPath) {
    let idx = this._workspaceFolders.findIndex((f) => URI.parse(f.uri).fsPath == fsPath);
    if (idx != -1) {
      let folder = this._workspaceFolders[idx];
      this._workspaceFolders.splice(idx, 1);
      this._onDidChangeWorkspaceFolders.fire({
        removed: [folder],
        added: []
      });
    }
  }
  renameWorkspaceFolder(oldPath, newPath) {
    let idx = this._workspaceFolders.findIndex((f) => URI.parse(f.uri).fsPath == oldPath);
    if (idx == -1)
      return;
    let removed = this._workspaceFolders[idx];
    let added = {
      uri: URI.file(newPath).toString(),
      name: path21.default.dirname(newPath)
    };
    this._workspaceFolders.splice(idx, 1);
    this._workspaceFolders.push(added);
    this._onDidChangeWorkspaceFolders.fire({
      removed: [removed],
      added: [added]
    });
  }
  addRootPattern(filetype, rootPatterns) {
    let patterns = this.rootPatterns.get(filetype) || [];
    for (let p of rootPatterns) {
      if (!patterns.includes(p)) {
        patterns.push(p);
      }
    }
    this.rootPatterns.set(filetype, patterns);
  }
  get insertMode() {
    return this._insertMode;
  }
  async detach() {
    if (!this._attached)
      return;
    this._attached = false;
    channels_default.dispose();
    for (let bufnr of this.buffers.keys()) {
      await events_default.fire("BufUnload", [bufnr]);
    }
  }
  dispose() {
    this._disposed = true;
    for (let doc of this.documents) {
      doc.detach();
    }
    disposeAll(this.disposables);
    watchman_default.dispose();
    this.configurations.dispose();
    this.buffers.clear();
  }
  addWorkspaceFolder(rootPath) {
    if (rootPath == os7.default.homedir())
      return;
    let {_workspaceFolders} = this;
    let uri = URI.file(rootPath).toString();
    let workspaceFolder = {uri, name: path21.default.basename(rootPath)};
    if (_workspaceFolders.findIndex((o) => o.uri == uri) == -1) {
      _workspaceFolders.push(workspaceFolder);
      if (this._initialized) {
        this._onDidChangeWorkspaceFolders.fire({
          added: [workspaceFolder],
          removed: []
        });
      }
    }
    return workspaceFolder;
  }
  getServerRootPatterns(filetype) {
    let lspConfig = this.getConfiguration().get("languageserver", {});
    let patterns = [];
    for (let key of Object.keys(lspConfig)) {
      let config = lspConfig[key];
      let {filetypes, rootPatterns} = config;
      if (filetypes && rootPatterns && filetypes.includes(filetype)) {
        patterns.push(...rootPatterns);
      }
    }
    patterns = patterns.concat(this.rootPatterns.get(filetype) || []);
    return patterns.length ? distinct(patterns) : null;
  }
};
var workspace_default = new Workspace();

// src/window.ts
var logger25 = require_logger2()("window");
var Window = class {
  constructor() {
    this.mutex = new Mutex();
  }
  get nvim() {
    return workspace_default.nvim;
  }
  dispose() {
    var _a2;
    (_a2 = this.statusLine) == null ? void 0 : _a2.dispose();
  }
  showMessage(msg, messageType = "more") {
    if (this.mutex.busy || !this.nvim)
      return;
    let {messageLevel} = this;
    let method = process.env.VIM_NODE_RPC == "1" ? "callTimer" : "call";
    if (global.hasOwnProperty("__TEST__"))
      logger25.info(msg);
    let hl = "Error";
    let level = MessageLevel.Error;
    switch (messageType) {
      case "more":
        level = MessageLevel.More;
        hl = "MoreMsg";
        break;
      case "warning":
        level = MessageLevel.Warning;
        hl = "WarningMsg";
        break;
    }
    if (level >= messageLevel) {
      this.nvim[method]("coc#util#echo_messages", [hl, ("[coc.nvim] " + msg).split("\n")], true);
    }
  }
  async runTerminalCommand(cmd, cwd, keepfocus = false) {
    cwd = cwd || workspace_default.cwd;
    return await this.nvim.callAsync("coc#util#run_terminal", {cmd, cwd, keepfocus: keepfocus ? 1 : 0});
  }
  async openTerminal(cmd, opts = {}) {
    let bufnr = await this.nvim.call("coc#util#open_terminal", {cmd, ...opts});
    return bufnr;
  }
  async showQuickpick(items, placeholder = "Choose by number") {
    let release = await this.mutex.acquire();
    try {
      let title = placeholder + ":";
      items = items.map((s, idx) => `${idx + 1}. ${s}`);
      let res = await this.nvim.callAsync("coc#util#quickpick", [title, items.map((s) => s.trim())]);
      release();
      let n = parseInt(res, 10);
      if (isNaN(n) || n <= 0 || n > items.length)
        return -1;
      return n - 1;
    } catch (e) {
      release();
      return -1;
    }
  }
  async showMenuPicker(items, title, token) {
    if (workspace_default.env.dialog) {
      let release = await this.mutex.acquire();
      if (token && token.isCancellationRequested) {
        release();
        return void 0;
      }
      try {
        let menu2 = new menu_default(this.nvim, {items: items.map((s) => s.trim()), title}, token);
        let promise = new Promise((resolve3) => {
          menu2.onDidClose((selected) => {
            resolve3(selected);
          });
        });
        await menu2.show(this.dialogPreference);
        let res = await promise;
        release();
        return res;
      } catch (e) {
        logger25.error(`Error on showMenuPicker:`, e);
        release();
      }
    }
    return await this.showQuickpick(items);
  }
  async openLocalConfig() {
    let {root} = workspace_default;
    if (root == os9.default.homedir()) {
      this.showMessage(`Can't create local config in home directory`, "warning");
      return;
    }
    let dir = path23.default.join(root, ".vim");
    if (!fs17.default.existsSync(dir)) {
      let res = await this.showPrompt(`Would you like to create folder'${root}/.vim'?`);
      if (!res)
        return;
      fs17.default.mkdirSync(dir);
    }
    await workspace_default.jumpTo(URI.file(path23.default.join(dir, CONFIG_FILE_NAME)).toString());
  }
  async showPrompt(title) {
    let release = await this.mutex.acquire();
    try {
      let res = await this.nvim.callAsync("coc#float#prompt_confirm", [title]);
      release();
      return res == 1;
    } catch (e) {
      release();
      return false;
    }
  }
  async showDialog(config) {
    if (!this.checkDialog())
      return null;
    let dialog2 = new dialog_default(this.nvim, config);
    await dialog2.show(this.dialogPreference);
    return dialog2;
  }
  async requestInput(title, defaultValue) {
    let {nvim} = this;
    const preferences = workspace_default.getConfiguration("coc.preferences");
    if (workspace_default.env.dialog && preferences.get("promptInput", true)) {
      let release = await this.mutex.acquire();
      let preferences2 = this.dialogPreference;
      try {
        let opts = {};
        if (preferences2.floatHighlight)
          opts.highlight = preferences2.floatHighlight;
        if (preferences2.floatBorderHighlight)
          opts.borderhighlight = preferences2.floatBorderHighlight;
        let arr = await nvim.call("coc#float#create_prompt_win", [title, defaultValue || "", opts]);
        let [bufnr, winid] = arr;
        let res = await new Promise((resolve3) => {
          let disposables = [];
          events_default.on("BufWinLeave", (nr) => {
            if (nr == bufnr) {
              disposeAll(disposables);
              resolve3(null);
            }
          }, null, disposables);
          events_default.on("PromptInsert", async (value) => {
            disposeAll(disposables);
            await nvim.call("coc#float#close", [winid]);
            if (!value) {
              this.showMessage("Empty word, canceled", "warning");
              resolve3(null);
            } else {
              resolve3(value);
            }
          }, null, disposables);
        });
        release();
        return res;
      } catch (e) {
        logger25.error("Error on requestInput:", e);
        release();
      }
    } else {
      let res = await workspace_default.callAsync("input", [title + ": ", defaultValue || ""]);
      nvim.command("normal! :<C-u>", true);
      if (!res) {
        this.showMessage("Empty word, canceled", "warning");
        return null;
      }
      return res;
    }
  }
  createStatusBarItem(priority = 0, option = {}) {
    if (!workspace_default.env) {
      let fn = () => {
      };
      return {text: "", show: fn, dispose: fn, hide: fn, priority: 0, isProgress: false};
    }
    if (!this.statusLine) {
      this.statusLine = new status_default(this.nvim);
    }
    return this.statusLine.createStatusBarItem(priority, option.progress || false);
  }
  createOutputChannel(name2) {
    return channels_default.create(name2, this.nvim);
  }
  showOutputChannel(name2, preserveFocus) {
    channels_default.show(name2, preserveFocus);
  }
  async echoLines(lines, truncate = false) {
    let {nvim} = this;
    let cmdHeight = workspace_default.env.cmdheight;
    if (lines.length > cmdHeight && truncate) {
      lines = lines.slice(0, cmdHeight);
    }
    let maxLen = workspace_default.env.columns - 12;
    lines = lines.map((line) => {
      line = line.replace(/\n/g, " ");
      if (truncate)
        line = line.slice(0, maxLen);
      return line;
    });
    if (truncate && lines.length == cmdHeight) {
      let last = lines[lines.length - 1];
      lines[cmdHeight - 1] = `${last.length == maxLen ? last.slice(0, -4) : last} ...`;
    }
    await nvim.call("coc#util#echo_lines", [lines]);
  }
  async getCursorPosition() {
    let [line, content] = await this.nvim.eval(`[line('.')-1, strpart(getline('.'), 0, col('.') - 1)]`);
    return vscode_languageserver_protocol14.Position.create(line, content.length);
  }
  async moveTo(position15) {
    await this.nvim.call("coc#util#jumpTo", [position15.line, position15.character]);
    if (workspace_default.env.isVim)
      this.nvim.command("redraw", true);
  }
  async getOffset() {
    return await this.nvim.call("coc#util#get_offset");
  }
  async getCursorScreenPosition() {
    let [row, col] = await this.nvim.call("coc#util#cursor_pos");
    return {row, col};
  }
  async showPickerDialog(items, title, token) {
    if (!this.checkDialog())
      return void 0;
    let release = await this.mutex.acquire();
    if (token && token.isCancellationRequested) {
      release();
      return void 0;
    }
    try {
      let useString = typeof items[0] === "string";
      let picker2 = new picker_default(this.nvim, {
        title,
        items: useString ? items.map((s) => {
          return {label: s};
        }) : items
      }, token);
      let promise = new Promise((resolve3) => {
        picker2.onDidClose((selected) => {
          resolve3(selected);
        });
      });
      await picker2.show(this.dialogPreference);
      let picked = await promise;
      let res = picked == void 0 ? void 0 : items.filter((_, i) => picked.includes(i));
      release();
      return res;
    } catch (e) {
      logger25.error(`Error on showPickerDialog:`, e);
      release();
    }
  }
  async showInformationMessage(message, ...items) {
    if (!this.enableMessageDialog)
      return await this.showConfirm(message, items, "Info");
    let texts = typeof items[0] === "string" ? items : items.map((s) => s.title);
    let idx = await this.createNotification("CocInfoFloat", message, texts);
    return idx == -1 ? void 0 : items[idx];
  }
  async showWarningMessage(message, ...items) {
    if (!this.enableMessageDialog)
      return await this.showConfirm(message, items, "Warning");
    let texts = typeof items[0] === "string" ? items : items.map((s) => s.title);
    let idx = await this.createNotification("CocWarningFloat", message, texts);
    return idx == -1 ? void 0 : items[idx];
  }
  async showErrorMessage(message, ...items) {
    if (!this.enableMessageDialog)
      return await this.showConfirm(message, items, "Error");
    let texts = typeof items[0] === "string" ? items : items.map((s) => s.title);
    let idx = await this.createNotification("CocErrorFloat", message, texts);
    return idx == -1 ? void 0 : items[idx];
  }
  async showNotification(config) {
    if (!this.checkDialog())
      return false;
    let notification3 = new notification_default(this.nvim, config);
    return await notification3.show(this.notificationPreference);
  }
  async showConfirm(message, items, kind) {
    if (!items || items.length == 0) {
      let msgType = kind == "Info" ? "more" : kind == "Error" ? "error" : "warning";
      this.showMessage(message, msgType);
      return void 0;
    }
    let choices = typeof items[0] === "string" ? items.slice() : items.map((o) => o.title);
    let res = await this.nvim.callAsync("coc#util#with_callback", ["confirm", [message, choices.join("\n"), 0, kind]]);
    return items[res - 1];
  }
  async withProgress(options, task2) {
    if (!this.checkDialog())
      return void 0;
    let progress3 = new progress_default(this.nvim, {
      task: task2,
      title: options.title,
      cancellable: options.cancellable
    });
    return await progress3.show(this.notificationPreference);
  }
  createNotification(borderhighlight, message, items) {
    return new Promise((resolve3) => {
      let config = {
        content: message,
        borderhighlight,
        close: true,
        buttons: items.map((s, index) => {
          return {text: s, index};
        }),
        callback: (idx) => {
          resolve3(idx);
        }
      };
      let notification3 = new notification_default(this.nvim, config);
      notification3.show(this.notificationPreference).then((shown) => {
        if (!shown) {
          logger25.error("Unable to open notification window");
          resolve3(-1);
        }
        if (!items.length)
          resolve3(-1);
      }, (e) => {
        logger25.error("Unable to open notification window", e);
        resolve3(-1);
      });
    });
  }
  get dialogPreference() {
    let config = workspace_default.getConfiguration("dialog");
    return {
      maxWidth: config.get("maxWidth"),
      maxHeight: config.get("maxHeight"),
      floatHighlight: config.get("floatHighlight"),
      floatBorderHighlight: config.get("floatBorderHighlight"),
      pickerButtons: config.get("pickerButtons"),
      pickerButtonShortcut: config.get("pickerButtonShortcut"),
      confirmKey: config.get("confirmKey")
    };
  }
  get notificationPreference() {
    let config = workspace_default.getConfiguration("notification");
    return {
      top: config.get("marginTop"),
      right: config.get("marginRight"),
      maxWidth: config.get("maxWidth"),
      maxHeight: config.get("maxHeight"),
      highlight: config.get("highlightGroup"),
      minProgressWidth: config.get("minProgressWidth")
    };
  }
  checkDialog() {
    if (workspace_default.env.dialog)
      return true;
    this.showMessage("Dialog requires vim >= 8.2.0750 or neovim >= 0.4.0, please upgrade your vim", "warning");
    return false;
  }
  get enableMessageDialog() {
    if (!workspace_default.env.dialog)
      return false;
    let config = workspace_default.getConfiguration("coc.preferences");
    return config.get("enableMessageDialog", false);
  }
  get messageLevel() {
    let config = workspace_default.getConfiguration("coc.preferences");
    let level = config.get("messageLevel", "more");
    switch (level) {
      case "error":
        return MessageLevel.Error;
      case "warning":
        return MessageLevel.Warning;
      default:
        return MessageLevel.More;
    }
  }
};
var window_default = new Window();

// src/diagnostic/buffer.ts
var debounce7 = __toModule(require_debounce());
var vscode_languageserver_protocol16 = __toModule(require_main3());

// src/diagnostic/util.ts
var vscode_languageserver_protocol15 = __toModule(require_main3());
function getSeverityName(severity) {
  switch (severity) {
    case vscode_languageserver_protocol15.DiagnosticSeverity.Error:
      return "Error";
    case vscode_languageserver_protocol15.DiagnosticSeverity.Warning:
      return "Warning";
    case vscode_languageserver_protocol15.DiagnosticSeverity.Information:
      return "Information";
    case vscode_languageserver_protocol15.DiagnosticSeverity.Hint:
      return "Hint";
    default:
      return "Error";
  }
}
function getSeverityType(severity) {
  switch (severity) {
    case vscode_languageserver_protocol15.DiagnosticSeverity.Error:
      return "E";
    case vscode_languageserver_protocol15.DiagnosticSeverity.Warning:
      return "W";
    case vscode_languageserver_protocol15.DiagnosticSeverity.Information:
      return "I";
    case vscode_languageserver_protocol15.DiagnosticSeverity.Hint:
      return "I";
    default:
      return "Error";
  }
}
function severityLevel(level) {
  switch (level) {
    case "hint":
      return vscode_languageserver_protocol15.DiagnosticSeverity.Hint;
    case "information":
      return vscode_languageserver_protocol15.DiagnosticSeverity.Information;
    case "warning":
      return vscode_languageserver_protocol15.DiagnosticSeverity.Warning;
    case "error":
      return vscode_languageserver_protocol15.DiagnosticSeverity.Error;
    default:
      return vscode_languageserver_protocol15.DiagnosticSeverity.Hint;
  }
}
function getNameFromSeverity(severity) {
  switch (severity) {
    case vscode_languageserver_protocol15.DiagnosticSeverity.Error:
      return "CocError";
    case vscode_languageserver_protocol15.DiagnosticSeverity.Warning:
      return "CocWarning";
    case vscode_languageserver_protocol15.DiagnosticSeverity.Information:
      return "CocInfo";
    case vscode_languageserver_protocol15.DiagnosticSeverity.Hint:
      return "CocHint";
    default:
      return "CocError";
  }
}
function getLocationListItem(bufnr, diagnostic) {
  let {start} = diagnostic.range;
  let owner = diagnostic.source || "coc.nvim";
  let msg = diagnostic.message.split("\n")[0];
  let type = getSeverityName(diagnostic.severity).slice(0, 1).toUpperCase();
  return {
    bufnr,
    lnum: start.line + 1,
    col: start.character + 1,
    text: `[${owner}${diagnostic.code ? " " + diagnostic.code : ""}] ${msg} [${type}]`,
    type
  };
}

// src/diagnostic/buffer.ts
var logger26 = require_logger2()("diagnostic-buffer");
var signGroup = "CocDiagnostic";
var DiagnosticBuffer = class {
  constructor(nvim, bufnr, uri, config, onRefresh) {
    this.nvim = nvim;
    this.bufnr = bufnr;
    this.uri = uri;
    this.config = config;
    this.onRefresh = onRefresh;
    this.diagnostics = [];
    this._disposed = false;
    this.refresh = debounce7.default((diagnostics2) => {
      this._refresh(diagnostics2).logError();
    }, 300);
  }
  get displayByAle() {
    return this.config.displayByAle;
  }
  onChange() {
    this.refresh.clear();
  }
  forceRefresh(diagnostics2) {
    this.refresh.clear();
    this._refresh(diagnostics2).logError();
  }
  refreshAle(diagnostics2) {
    let collections = getCollections(this.diagnostics);
    this.diagnostics = diagnostics2;
    let map = new Map();
    diagnostics2.forEach((o) => {
      let exists = map.get(o.collection) || [];
      exists.push(o);
      map.set(o.collection, exists);
    });
    for (let name2 of collections) {
      if (!map.has(name2)) {
        map.set(name2, []);
      }
    }
    this.nvim.pauseNotification();
    for (let [collection2, diagnostics3] of map.entries()) {
      let aleItems = diagnostics3.map((o) => {
        let range2 = o.range || vscode_languageserver_protocol16.Range.create(0, 0, 1, 0);
        return {
          text: o.message,
          code: o.code,
          lnum: range2.start.line + 1,
          col: range2.start.character + 1,
          end_lnum: range2.end.line + 1,
          end_col: range2.end.character,
          type: getSeverityType(o.severity)
        };
      });
      let method = global.hasOwnProperty("__TEST__") ? "MockAleResults" : "ale#other_source#ShowResults";
      this.nvim.call(method, [this.bufnr, collection2, aleItems], true);
    }
    this.nvim.resumeNotification().then((res) => {
      if (Array.isArray(res) && res[1] != null) {
        logger26.error(`Error on displayByAle:`, res[1][2]);
      }
    }).logError();
  }
  async _refresh(diagnostics2) {
    if (equals(this.diagnostics, diagnostics2))
      return;
    let {refreshOnInsertMode} = this.config;
    let {nvim} = this;
    let arr = await nvim.eval(`[coc#util#check_refresh(${this.bufnr}),mode(),line("."),getloclist(bufwinid(${this.bufnr}),{'title':1})]`);
    if (arr[0] == 0 || this._disposed)
      return;
    let mode = arr[1];
    if (!refreshOnInsertMode && mode.startsWith("i") && diagnostics2.length)
      return;
    if (this.displayByAle) {
      this.refreshAle(diagnostics2);
    } else {
      this.diagnostics = diagnostics2;
      let lnum = arr[2];
      nvim.pauseNotification();
      this.setDiagnosticInfo(diagnostics2);
      this.addSigns(diagnostics2);
      this.addHighlight(diagnostics2);
      this.updateLocationList(arr[3], diagnostics2);
      this.showVirtualText(diagnostics2, lnum);
      if (workspace_default.isVim)
        this.nvim.command("redraw", true);
      let res = await this.nvim.resumeNotification();
      if (Array.isArray(res) && res[1])
        throw new Error(res[1]);
    }
    this.onRefresh(diagnostics2);
  }
  updateLocationList(curr, diagnostics2) {
    if (!this.config.locationlistUpdate)
      return;
    if (!curr || curr.title !== "Diagnostics of coc")
      return;
    let items = [];
    for (let diagnostic of diagnostics2) {
      let item = getLocationListItem(this.bufnr, diagnostic);
      items.push(item);
    }
    this.nvim.call("setloclist", [0, [], "r", {title: "Diagnostics of coc", items}], true);
  }
  addSigns(diagnostics2) {
    if (!this.config.enableSign)
      return;
    this.clearSigns();
    let {nvim, bufnr} = this;
    for (let diagnostic of diagnostics2) {
      let {range: range2, severity} = diagnostic;
      let line = range2.start.line;
      let name2 = getNameFromSeverity(severity);
      nvim.call("sign_place", [0, signGroup, name2, bufnr, {lnum: line + 1, priority: 14 - severity}], true);
    }
  }
  clearSigns() {
    let {nvim, bufnr} = this;
    nvim.call("sign_unplace", [signGroup, {buffer: bufnr}], true);
  }
  setDiagnosticInfo(diagnostics2) {
    let lnums = [0, 0, 0, 0];
    let info = {error: 0, warning: 0, information: 0, hint: 0, lnums};
    for (let diagnostic of diagnostics2) {
      switch (diagnostic.severity) {
        case vscode_languageserver_protocol16.DiagnosticSeverity.Warning:
          info.warning = info.warning + 1;
          lnums[1] = lnums[1] || diagnostic.range.start.line + 1;
          break;
        case vscode_languageserver_protocol16.DiagnosticSeverity.Information:
          info.information = info.information + 1;
          lnums[2] = lnums[2] || diagnostic.range.start.line + 1;
          break;
        case vscode_languageserver_protocol16.DiagnosticSeverity.Hint:
          info.hint = info.hint + 1;
          lnums[3] = lnums[3] || diagnostic.range.start.line + 1;
          break;
        default:
          lnums[0] = lnums[0] || diagnostic.range.start.line + 1;
          info.error = info.error + 1;
      }
    }
    this.nvim.call("coc#util#set_buf_var", [this.bufnr, "coc_diagnostic_info", info], true);
    this.nvim.call("coc#util#do_autocmd", ["CocDiagnosticChange"], true);
  }
  showVirtualText(diagnostics2, lnum) {
    let {buffer: buffer4, config} = this;
    if (!config.virtualText)
      return;
    let srcId = this.config.virtualTextSrcId;
    let prefix = this.config.virtualTextPrefix;
    if (this.config.virtualTextCurrentLineOnly) {
      diagnostics2 = diagnostics2.filter((d) => {
        let {start, end} = d.range;
        return start.line <= lnum - 1 && end.line >= lnum - 1;
      });
    }
    buffer4.clearNamespace(srcId);
    for (let diagnostic of diagnostics2) {
      let {line} = diagnostic.range.start;
      let highlight = getNameFromSeverity(diagnostic.severity) + "VirtualText";
      let msg = diagnostic.message.split(/\n/).map((l) => l.trim()).filter((l) => l.length > 0).slice(0, this.config.virtualTextLines).join(this.config.virtualTextLineSeparator);
      buffer4.setVirtualText(srcId, line, [[prefix + msg, highlight]], {}).logError();
    }
  }
  addHighlight(diagnostics2) {
    if (workspace_default.isVim && !workspace_default.env.textprop)
      return;
    this.clearHighlight();
    if (diagnostics2.length == 0)
      return;
    const highlights2 = new Map();
    for (let diagnostic of diagnostics2) {
      let {range: range2, severity} = diagnostic;
      let ranges = highlights2.get(severity) || [];
      ranges.push(range2);
      highlights2.set(severity, ranges);
    }
    for (let severity of [vscode_languageserver_protocol16.DiagnosticSeverity.Hint, vscode_languageserver_protocol16.DiagnosticSeverity.Information, vscode_languageserver_protocol16.DiagnosticSeverity.Warning, vscode_languageserver_protocol16.DiagnosticSeverity.Error]) {
      let ranges = highlights2.get(severity) || [];
      let hlGroup = getNameFromSeverity(severity) + "Highlight";
      this.buffer.highlightRanges("diagnostic", hlGroup, ranges);
    }
  }
  clearHighlight() {
    this.buffer.clearNamespace("diagnostic");
  }
  get buffer() {
    return this.nvim.createBuffer(this.bufnr);
  }
  clear() {
    this.refresh.clear();
    let {nvim} = this;
    if (this.displayByAle) {
      let collections = getCollections(this.diagnostics);
      this.diagnostics = [];
      if (collections.size > 0) {
        for (let collection2 of collections) {
          let method = global.hasOwnProperty("__TEST__") ? "MockAleResults" : "ale#other_source#ShowResults";
          this.nvim.call(method, [this.bufnr, collection2, []], true);
        }
      }
    } else {
      this.diagnostics = [];
      nvim.pauseNotification();
      this.clearHighlight();
      if (this.config.enableSign) {
        this.clearSigns();
      }
      if (this.config.virtualText) {
        this.buffer.clearNamespace(this.config.virtualTextSrcId);
      }
      this.setDiagnosticInfo([]);
      nvim.resumeNotification(false, true);
    }
  }
  dispose() {
    this._disposed = true;
    this.clear();
  }
};
function getCollections(diagnostics2) {
  let res = new Set();
  diagnostics2.forEach((o) => {
    res.add(o.collection);
  });
  return res;
}

// src/diagnostic/collection.ts
var vscode_languageserver_protocol17 = __toModule(require_main3());
var logger27 = require_logger2()("diagnostic-collection");
var Collection = class {
  constructor(owner) {
    this.diagnosticsMap = new Map();
    this._onDispose = new vscode_languageserver_protocol17.Emitter();
    this._onDidDiagnosticsChange = new vscode_languageserver_protocol17.Emitter();
    this._onDidDiagnosticsClear = new vscode_languageserver_protocol17.Emitter();
    this.onDispose = this._onDispose.event;
    this.onDidDiagnosticsChange = this._onDidDiagnosticsChange.event;
    this.onDidDiagnosticsClear = this._onDidDiagnosticsClear.event;
    this.name = owner;
  }
  set(entries, diagnostics2) {
    let diagnosticsPerFile = new Map();
    if (!Array.isArray(entries)) {
      let doc = workspace_default.getDocument(entries);
      let uri = doc ? doc.uri : entries;
      diagnosticsPerFile.set(uri, diagnostics2 || []);
    } else {
      for (let item of entries) {
        let [uri, diagnostics3] = item;
        let doc = workspace_default.getDocument(uri);
        uri = doc ? doc.uri : uri;
        if (diagnostics3 == null) {
          diagnostics3 = [];
        } else {
          diagnostics3 = (diagnosticsPerFile.get(uri) || []).concat(diagnostics3);
        }
        diagnosticsPerFile.set(uri, diagnostics3);
      }
    }
    for (let item of diagnosticsPerFile) {
      let [uri, diagnostics3] = item;
      uri = URI.parse(uri).toString();
      diagnostics3.forEach((o) => {
        o.range = o.range || vscode_languageserver_protocol17.Range.create(0, 0, 1, 0);
        o.message = o.message || "Empty error message";
        if (emptyRange(o.range)) {
          o.range.end = {
            line: o.range.end.line,
            character: o.range.end.character + 1
          };
        }
        let {start, end} = o.range;
        if (end.character == 0 && end.line - start.line == 1 && start.character > 0) {
          let doc = workspace_default.getDocument(uri);
          if (doc) {
            let line = doc.getline(start.line);
            if (start.character == line.length) {
              o.range.start.character = start.character - 1;
            }
          }
        }
        o.source = o.source || this.name;
      });
      this.diagnosticsMap.set(uri, diagnostics3);
      this._onDidDiagnosticsChange.fire(uri);
    }
    return;
  }
  delete(uri) {
    this.diagnosticsMap.delete(uri);
  }
  clear() {
    let uris = Array.from(this.diagnosticsMap.keys());
    this.diagnosticsMap.clear();
    this._onDidDiagnosticsClear.fire(uris);
  }
  forEach(callback, thisArg) {
    for (let uri of this.diagnosticsMap.keys()) {
      let diagnostics2 = this.diagnosticsMap.get(uri);
      callback.call(thisArg, uri, diagnostics2, this);
    }
  }
  get(uri) {
    let arr = this.diagnosticsMap.get(uri);
    return arr == null ? [] : arr;
  }
  has(uri) {
    return this.diagnosticsMap.has(uri);
  }
  dispose() {
    this.clear();
    this._onDispose.fire(void 0);
    this._onDispose.dispose();
    this._onDidDiagnosticsClear.dispose();
    this._onDidDiagnosticsChange.dispose();
  }
};
var collection_default = Collection;

// src/diagnostic/manager.ts
var logger28 = require_logger2()("diagnostic-manager");
var DiagnosticManager = class {
  constructor() {
    this.enabled = true;
    this._onDidRefresh = new vscode_languageserver_protocol18.Emitter();
    this.onDidRefresh = this._onDidRefresh.event;
    this.lastMessage = "";
    this.collections = [];
    this.disposables = [];
  }
  init() {
    this.setConfiguration();
    workspace_default.onDidChangeConfiguration((e) => {
      this.setConfiguration(e);
    }, null, this.disposables);
    this.floatFactory = new floatFactory_default(this.nvim);
    this.buffers = workspace_default.registerBufferSync((doc) => {
      if (doc.buftype !== "")
        return void 0;
      let buf = new DiagnosticBuffer(this.nvim, doc.bufnr, doc.uri, this.config, (diagnostics3) => {
        this._onDidRefresh.fire({diagnostics: diagnostics3, uri: buf.uri, bufnr: buf.bufnr});
        if (["never", "jump"].includes(this.config.enableMessage)) {
          return;
        }
        this.echoMessage(true).logError();
      });
      let diagnostics2 = this.getDiagnostics(doc.uri);
      if (this.enabled)
        buf.forceRefresh(diagnostics2);
      return buf;
    });
    events_default.on("CursorMoved", (bufnr) => {
      if (this.config.enableMessage != "always")
        return;
      if (this.timer)
        clearTimeout(this.timer);
      if (bufnr == this.floatFactory.bufnr)
        return;
      this.timer = setTimeout(async () => {
        await this.echoMessage(true);
      }, this.config.messageDelay);
    }, null, this.disposables);
    let fn = debounce9.default((bufnr, cursor) => {
      if (!this.config.virtualText || !this.config.virtualTextCurrentLineOnly) {
        return;
      }
      let buf = this.buffers.getItem(bufnr);
      if (buf) {
        let diagnostics2 = this.getDiagnostics(buf.uri);
        buf.showVirtualText(diagnostics2, cursor[0]);
      }
    }, 100);
    events_default.on("CursorMoved", fn, null, this.disposables);
    this.disposables.push(vscode_languageserver_protocol18.Disposable.create(() => {
      fn.clear();
    }));
    events_default.on("InsertLeave", async (bufnr) => {
      if (!this.config.refreshOnInsertMode) {
        this.refreshBuffer(bufnr);
      }
    }, null, this.disposables);
    events_default.on("BufEnter", async () => {
      if (this.timer)
        clearTimeout(this.timer);
    }, null, this.disposables);
    this.setConfigurationErrors(true);
    workspace_default.configurations.onError(() => {
      this.setConfigurationErrors();
    }, null, this.disposables);
  }
  defineSigns() {
    let {nvim} = this;
    let {enableHighlightLineNumber, enableSign} = this.config;
    if (!enableSign)
      return;
    nvim.pauseNotification();
    for (let kind of ["Error", "Warning", "Info", "Hint"]) {
      let signText = this.config[kind.toLowerCase() + "Sign"];
      let cmd = `sign define Coc${kind} linehl=Coc${kind}Line`;
      if (signText)
        cmd += ` texthl=Coc${kind}Sign text=${signText}`;
      if (enableHighlightLineNumber)
        cmd += ` numhl=Coc${kind}Sign`;
      nvim.command(cmd, true);
    }
    nvim.resumeNotification(false, true);
  }
  async setLocationlist(bufnr) {
    let buf = this.buffers.getItem(bufnr);
    let diagnostics2 = buf ? this.getDiagnostics(buf.uri) : [];
    let items = [];
    for (let diagnostic of diagnostics2) {
      let item = getLocationListItem(bufnr, diagnostic);
      items.push(item);
    }
    let curr = await this.nvim.call("getloclist", [0, {title: 1}]);
    let action = curr.title && curr.title.indexOf("Diagnostics of coc") != -1 ? "r" : " ";
    await this.nvim.call("setloclist", [0, [], action, {title: "Diagnostics of coc", items}]);
  }
  setConfigurationErrors(init) {
    let collections = this.collections;
    let collection2 = collections.find((o) => o.name == "config");
    if (!collection2) {
      collection2 = this.create("config");
    } else {
      collection2.clear();
    }
    let {errorItems} = workspace_default.configurations;
    if (errorItems && errorItems.length) {
      if (init)
        window_default.showMessage(`settings file parse error, run ':CocList diagnostics'`, "error");
      let entries = new Map();
      for (let item of errorItems) {
        let {uri} = item.location;
        let diagnostics2 = entries.get(uri) || [];
        diagnostics2.push(vscode_languageserver_protocol18.Diagnostic.create(item.location.range, item.message, vscode_languageserver_protocol18.DiagnosticSeverity.Error));
        entries.set(uri, diagnostics2);
      }
      collection2.set(Array.from(entries));
    }
  }
  create(name2) {
    let collection2 = this.getCollectionByName(name2);
    if (collection2)
      return collection2;
    collection2 = new collection_default(name2);
    this.collections.push(collection2);
    collection2.onDidDiagnosticsChange((uri) => {
      this.refreshBuffer(uri);
    });
    collection2.onDidDiagnosticsClear((uris) => {
      for (let uri of uris) {
        this.refreshBuffer(uri, true);
      }
    });
    collection2.onDispose(() => {
      let idx = this.collections.findIndex((o) => o == collection2);
      if (idx !== -1)
        this.collections.splice(idx, 1);
    });
    return collection2;
  }
  getSortedRanges(uri, severity) {
    let collections = this.getCollections(uri);
    let res = [];
    let level = severity ? severityLevel(severity) : 0;
    for (let collection2 of collections) {
      let diagnostics2 = collection2.get(uri);
      if (level)
        diagnostics2 = diagnostics2.filter((o) => o.severity == level);
      let ranges = diagnostics2.map((o) => o.range);
      res.push(...ranges);
    }
    res.sort((a, b) => {
      if (a.start.line != b.start.line) {
        return a.start.line - b.start.line;
      }
      return a.start.character - b.start.character;
    });
    return res;
  }
  getDiagnostics(uri) {
    let collections = this.getCollections(uri);
    let {level, showUnused, showDeprecated} = this.config;
    let res = [];
    for (let collection2 of collections) {
      let items = collection2.get(uri);
      if (!items)
        continue;
      items = items.filter((d) => {
        var _a2, _b;
        if (level && level < vscode_languageserver_protocol18.DiagnosticSeverity.Hint && d.severity && d.severity > level) {
          return false;
        }
        if (!showUnused && ((_a2 = d.tags) == null ? void 0 : _a2.includes(vscode_languageserver_protocol18.DiagnosticTag.Unnecessary))) {
          return false;
        }
        if (!showDeprecated && ((_b = d.tags) == null ? void 0 : _b.includes(vscode_languageserver_protocol18.DiagnosticTag.Deprecated))) {
          return false;
        }
        return true;
      });
      items.forEach((item) => {
        res.push(Object.assign({collection: collection2.name}, item));
      });
    }
    res.sort((a, b) => {
      if (a.severity == b.severity) {
        let d = comparePosition(a.range.start, b.range.start);
        if (d != 0)
          return d;
        if (a.source == b.source)
          return a.message > b.message ? 1 : -1;
        return a.source > b.source ? 1 : -1;
      }
      return a.severity - b.severity;
    });
    return res;
  }
  getDiagnosticsInRange(document3, range2) {
    let collections = this.getCollections(document3.uri);
    let res = [];
    for (let collection2 of collections) {
      let items = collection2.get(document3.uri);
      if (!items)
        continue;
      for (let item of items) {
        if (rangeIntersect(item.range, range2)) {
          res.push(item);
        }
      }
    }
    return res;
  }
  async preview() {
    let [bufnr, cursor] = await this.nvim.eval('[bufnr("%"),coc#util#cursor()]');
    let {nvim} = this;
    let diagnostics2 = this.getDiagnosticsAt(bufnr, cursor);
    if (diagnostics2.length == 0) {
      nvim.command("pclose", true);
      window_default.showMessage(`Empty diagnostics`, "warning");
      return;
    }
    let lines = [];
    for (let diagnostic of diagnostics2) {
      let {source: source3, code, severity, message} = diagnostic;
      let s = getSeverityName(severity)[0];
      lines.push(`[${source3}${code ? " " + code : ""}] [${s}]`);
      lines.push(...message.split(/\r?\n/));
      lines.push("");
    }
    lines = lines.slice(0, -1);
    nvim.call("coc#util#preview_info", [lines, "txt"], true);
  }
  async jumpPrevious(severity) {
    let buffer4 = await this.nvim.buffer;
    let document3 = workspace_default.getDocument(buffer4.id);
    if (!document3)
      return;
    let curpos = await window_default.getCursorPosition();
    let ranges = this.getSortedRanges(document3.uri, severity);
    if (ranges.length == 0) {
      window_default.showMessage("Empty diagnostics", "warning");
      return;
    }
    let pos;
    for (let i = ranges.length - 1; i >= 0; i--) {
      let end = ranges[i].end;
      if (comparePosition(end, curpos) < 0) {
        pos = ranges[i].start;
        break;
      } else if (i == 0) {
        let wrapscan = await this.nvim.getOption("wrapscan");
        if (wrapscan)
          pos = ranges[ranges.length - 1].start;
      }
    }
    if (pos) {
      await window_default.moveTo(pos);
      if (this.config.enableMessage == "never")
        return;
      await this.echoMessage(false);
    }
  }
  async jumpNext(severity) {
    let buffer4 = await this.nvim.buffer;
    let document3 = workspace_default.getDocument(buffer4.id);
    let curpos = await window_default.getCursorPosition();
    let ranges = this.getSortedRanges(document3.uri, severity);
    if (ranges.length == 0) {
      window_default.showMessage("Empty diagnostics", "warning");
      return;
    }
    let pos;
    for (let i = 0; i <= ranges.length - 1; i++) {
      let start = ranges[i].start;
      if (comparePosition(start, curpos) > 0) {
        pos = ranges[i].start;
        break;
      } else if (i == ranges.length - 1) {
        let wrapscan = await this.nvim.getOption("wrapscan");
        if (wrapscan)
          pos = ranges[0].start;
      }
    }
    if (pos) {
      await window_default.moveTo(pos);
      if (this.config.enableMessage == "never")
        return;
      await this.echoMessage(false);
    }
  }
  getDiagnosticList() {
    let res = [];
    const {level, showUnused, showDeprecated} = this.config;
    for (let collection2 of this.collections) {
      collection2.forEach((uri, diagnostics2) => {
        var _a2, _b;
        let file = URI.parse(uri).fsPath;
        for (let diagnostic of diagnostics2) {
          if (diagnostic.severity && diagnostic.severity > level) {
            continue;
          }
          if (!showUnused && ((_a2 = diagnostic.tags) == null ? void 0 : _a2.includes(vscode_languageserver_protocol18.DiagnosticTag.Unnecessary))) {
            continue;
          }
          if (!showDeprecated && ((_b = diagnostic.tags) == null ? void 0 : _b.includes(vscode_languageserver_protocol18.DiagnosticTag.Deprecated))) {
            continue;
          }
          let {start} = diagnostic.range;
          let o = {
            file,
            lnum: start.line + 1,
            col: start.character + 1,
            code: diagnostic.code,
            source: diagnostic.source || collection2.name,
            message: diagnostic.message,
            severity: getSeverityName(diagnostic.severity),
            level: diagnostic.severity || 0,
            location: vscode_languageserver_protocol18.Location.create(uri, diagnostic.range)
          };
          res.push(o);
        }
      });
    }
    res.sort((a, b) => {
      if (a.level !== b.level) {
        return a.level - b.level;
      }
      if (a.file !== b.file) {
        return a.file > b.file ? 1 : -1;
      } else {
        if (a.lnum != b.lnum) {
          return a.lnum - b.lnum;
        }
        return a.col - b.col;
      }
    });
    return res;
  }
  getDiagnosticsAt(bufnr, cursor) {
    let pos = vscode_languageserver_protocol18.Position.create(cursor[0], cursor[1]);
    let buffer4 = this.buffers.getItem(bufnr);
    if (!buffer4)
      return [];
    let diagnostics2 = this.getDiagnostics(buffer4.uri);
    let {checkCurrentLine} = this.config;
    if (checkCurrentLine) {
      diagnostics2 = diagnostics2.filter((o) => lineInRange(pos.line, o.range));
    } else {
      diagnostics2 = diagnostics2.filter((o) => positionInRange(pos, o.range) == 0);
    }
    diagnostics2.sort((a, b) => a.severity - b.severity);
    return diagnostics2;
  }
  async getCurrentDiagnostics() {
    let [bufnr, cursor] = await this.nvim.eval('[bufnr("%"),coc#util#cursor()]');
    return this.getDiagnosticsAt(bufnr, cursor);
  }
  async echoMessage(truncate = false) {
    const config = this.config;
    if (!this.enabled || config.displayByAle)
      return;
    if (this.timer)
      clearTimeout(this.timer);
    let useFloat = config.messageTarget == "float";
    let [bufnr, cursor, filetype, mode] = await this.nvim.eval('[bufnr("%"),coc#util#cursor(),&filetype,mode()]');
    if (mode != "n")
      return;
    let diagnostics2 = this.getDiagnosticsAt(bufnr, cursor);
    if (diagnostics2.length == 0) {
      if (useFloat) {
        this.floatFactory.close();
      } else {
        let echoLine = await this.nvim.call("coc#util#echo_line");
        if (this.lastMessage && echoLine.startsWith(this.lastMessage)) {
          this.nvim.command('echo ""', true);
        }
      }
      return;
    }
    if (truncate && workspace_default.insertMode)
      return;
    let docs = [];
    let ft = "";
    if (Object.keys(config.filetypeMap).length > 0) {
      const defaultFiletype = config.filetypeMap["default"] || "";
      ft = config.filetypeMap[filetype] || (defaultFiletype == "bufferType" ? filetype : defaultFiletype);
    }
    diagnostics2.forEach((diagnostic) => {
      let {source: source3, code, severity, message} = diagnostic;
      let s = getSeverityName(severity)[0];
      const codeStr = code ? " " + code : "";
      const str = config.format.replace("%source", source3).replace("%code", codeStr).replace("%severity", s).replace("%message", message);
      let filetype2 = "Error";
      if (ft === "") {
        switch (severity) {
          case vscode_languageserver_protocol18.DiagnosticSeverity.Hint:
            filetype2 = "Hint";
            break;
          case vscode_languageserver_protocol18.DiagnosticSeverity.Warning:
            filetype2 = "Warning";
            break;
          case vscode_languageserver_protocol18.DiagnosticSeverity.Information:
            filetype2 = "Info";
            break;
        }
      } else {
        filetype2 = ft;
      }
      docs.push({filetype: filetype2, content: str});
    });
    if (useFloat) {
      let {maxWindowHeight, maxWindowWidth} = this.config;
      await this.floatFactory.show(docs, {maxWidth: maxWindowWidth, maxHeight: maxWindowHeight, modes: ["n"]});
    } else {
      let lines = docs.map((d) => d.content).join("\n").split(/\r?\n/);
      if (lines.length) {
        await this.nvim.command('echo ""');
        this.lastMessage = lines[0].slice(0, 30);
        await window_default.echoLines(lines, truncate);
      }
    }
  }
  async jumpRelated() {
    let diagnostics2 = await this.getCurrentDiagnostics();
    if (!diagnostics2)
      return;
    let diagnostic = diagnostics2.find((o) => o.relatedInformation != null);
    if (!diagnostic)
      return;
    let locations = diagnostic.relatedInformation.map((o) => o.location);
    if (locations.length == 1) {
      await workspace_default.jumpTo(locations[0].uri, locations[0].range.start);
    } else if (locations.length > 1) {
      await workspace_default.showLocations(locations);
    }
  }
  reset() {
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.buffers.reset();
    for (let collection2 of this.collections) {
      collection2.dispose();
    }
    this.collections = [];
  }
  dispose() {
    var _a2;
    this.buffers.dispose();
    if (this.timer) {
      clearTimeout(this.timer);
    }
    for (let collection2 of this.collections) {
      collection2.dispose();
    }
    (_a2 = this.floatFactory) == null ? void 0 : _a2.close();
    this.collections = [];
    disposeAll(this.disposables);
  }
  get nvim() {
    return workspace_default.nvim;
  }
  setConfiguration(event) {
    if (event && !event.affectsConfiguration("diagnostic"))
      return;
    let config = workspace_default.getConfiguration("diagnostic");
    let messageTarget = config.get("messageTarget", "float");
    if (messageTarget == "float" && !workspace_default.env.floating && !workspace_default.env.textprop) {
      messageTarget = "echo";
    }
    let enableHighlightLineNumber = config.get("enableHighlightLineNumber", true);
    if (!workspace_default.isNvim || semver.default.lt(workspace_default.env.version, "v0.3.2")) {
      enableHighlightLineNumber = false;
    }
    this.config = {
      messageTarget,
      enableHighlightLineNumber,
      virtualTextSrcId: workspace_default.createNameSpace("diagnostic-virtualText"),
      checkCurrentLine: config.get("checkCurrentLine", false),
      enableSign: workspace_default.env.sign && config.get("enableSign", true),
      locationlistUpdate: config.get("locationlistUpdate", true),
      maxWindowHeight: config.get("maxWindowHeight", 10),
      maxWindowWidth: config.get("maxWindowWidth", 80),
      enableMessage: config.get("enableMessage", "always"),
      messageDelay: config.get("messageDelay", 200),
      virtualText: config.get("virtualText", false) && this.nvim.hasFunction("nvim_buf_set_virtual_text"),
      virtualTextCurrentLineOnly: config.get("virtualTextCurrentLineOnly", true),
      virtualTextPrefix: config.get("virtualTextPrefix", " "),
      virtualTextLineSeparator: config.get("virtualTextLineSeparator", " \\ "),
      virtualTextLines: config.get("virtualTextLines", 3),
      displayByAle: config.get("displayByAle", false),
      level: severityLevel(config.get("level", "hint")),
      signPriority: config.get("signPriority", 10),
      errorSign: config.get("errorSign", ">>"),
      warningSign: config.get("warningSign", ">>"),
      infoSign: config.get("infoSign", ">>"),
      hintSign: config.get("hintSign", ">>"),
      refreshOnInsertMode: config.get("refreshOnInsertMode", false),
      filetypeMap: config.get("filetypeMap", {}),
      showUnused: config.get("showUnused", true),
      showDeprecated: config.get("showDeprecated", true),
      format: config.get("format", "[%source%code] [%severity] %message")
    };
    this.enabled = config.get("enable", true);
    this.defineSigns();
  }
  getCollectionByName(name2) {
    return this.collections.find((o) => o.name == name2);
  }
  getCollections(uri) {
    return this.collections.filter((c) => c.has(uri));
  }
  toggleDiagnostic() {
    let {enabled} = this;
    this.enabled = !enabled;
    for (let buf of this.buffers.items) {
      if (this.enabled) {
        let diagnostics2 = this.getDiagnostics(buf.uri);
        buf.forceRefresh(diagnostics2);
      } else {
        buf.clear();
      }
    }
  }
  refreshBuffer(uri, force = false) {
    if (!this.enabled)
      return false;
    let buf = this.buffers.getItem(uri);
    if (!buf)
      return false;
    let diagnostics2 = this.getDiagnostics(buf.uri);
    if (force) {
      buf.forceRefresh(diagnostics2);
    } else {
      buf.refresh(diagnostics2);
    }
    return true;
  }
};
var manager_default = new DiagnosticManager();

// src/util/charCode.ts
var CharCode;
(function(CharCode2) {
  CharCode2[CharCode2["Null"] = 0] = "Null";
  CharCode2[CharCode2["Backspace"] = 8] = "Backspace";
  CharCode2[CharCode2["Tab"] = 9] = "Tab";
  CharCode2[CharCode2["LineFeed"] = 10] = "LineFeed";
  CharCode2[CharCode2["CarriageReturn"] = 13] = "CarriageReturn";
  CharCode2[CharCode2["Space"] = 32] = "Space";
  CharCode2[CharCode2["ExclamationMark"] = 33] = "ExclamationMark";
  CharCode2[CharCode2["DoubleQuote"] = 34] = "DoubleQuote";
  CharCode2[CharCode2["Hash"] = 35] = "Hash";
  CharCode2[CharCode2["DollarSign"] = 36] = "DollarSign";
  CharCode2[CharCode2["PercentSign"] = 37] = "PercentSign";
  CharCode2[CharCode2["Ampersand"] = 38] = "Ampersand";
  CharCode2[CharCode2["SingleQuote"] = 39] = "SingleQuote";
  CharCode2[CharCode2["OpenParen"] = 40] = "OpenParen";
  CharCode2[CharCode2["CloseParen"] = 41] = "CloseParen";
  CharCode2[CharCode2["Asterisk"] = 42] = "Asterisk";
  CharCode2[CharCode2["Plus"] = 43] = "Plus";
  CharCode2[CharCode2["Comma"] = 44] = "Comma";
  CharCode2[CharCode2["Dash"] = 45] = "Dash";
  CharCode2[CharCode2["Period"] = 46] = "Period";
  CharCode2[CharCode2["Slash"] = 47] = "Slash";
  CharCode2[CharCode2["Digit0"] = 48] = "Digit0";
  CharCode2[CharCode2["Digit1"] = 49] = "Digit1";
  CharCode2[CharCode2["Digit2"] = 50] = "Digit2";
  CharCode2[CharCode2["Digit3"] = 51] = "Digit3";
  CharCode2[CharCode2["Digit4"] = 52] = "Digit4";
  CharCode2[CharCode2["Digit5"] = 53] = "Digit5";
  CharCode2[CharCode2["Digit6"] = 54] = "Digit6";
  CharCode2[CharCode2["Digit7"] = 55] = "Digit7";
  CharCode2[CharCode2["Digit8"] = 56] = "Digit8";
  CharCode2[CharCode2["Digit9"] = 57] = "Digit9";
  CharCode2[CharCode2["Colon"] = 58] = "Colon";
  CharCode2[CharCode2["Semicolon"] = 59] = "Semicolon";
  CharCode2[CharCode2["LessThan"] = 60] = "LessThan";
  CharCode2[CharCode2["Equals"] = 61] = "Equals";
  CharCode2[CharCode2["GreaterThan"] = 62] = "GreaterThan";
  CharCode2[CharCode2["QuestionMark"] = 63] = "QuestionMark";
  CharCode2[CharCode2["AtSign"] = 64] = "AtSign";
  CharCode2[CharCode2["A"] = 65] = "A";
  CharCode2[CharCode2["B"] = 66] = "B";
  CharCode2[CharCode2["C"] = 67] = "C";
  CharCode2[CharCode2["D"] = 68] = "D";
  CharCode2[CharCode2["E"] = 69] = "E";
  CharCode2[CharCode2["F"] = 70] = "F";
  CharCode2[CharCode2["G"] = 71] = "G";
  CharCode2[CharCode2["H"] = 72] = "H";
  CharCode2[CharCode2["I"] = 73] = "I";
  CharCode2[CharCode2["J"] = 74] = "J";
  CharCode2[CharCode2["K"] = 75] = "K";
  CharCode2[CharCode2["L"] = 76] = "L";
  CharCode2[CharCode2["M"] = 77] = "M";
  CharCode2[CharCode2["N"] = 78] = "N";
  CharCode2[CharCode2["O"] = 79] = "O";
  CharCode2[CharCode2["P"] = 80] = "P";
  CharCode2[CharCode2["Q"] = 81] = "Q";
  CharCode2[CharCode2["R"] = 82] = "R";
  CharCode2[CharCode2["S"] = 83] = "S";
  CharCode2[CharCode2["T"] = 84] = "T";
  CharCode2[CharCode2["U"] = 85] = "U";
  CharCode2[CharCode2["V"] = 86] = "V";
  CharCode2[CharCode2["W"] = 87] = "W";
  CharCode2[CharCode2["X"] = 88] = "X";
  CharCode2[CharCode2["Y"] = 89] = "Y";
  CharCode2[CharCode2["Z"] = 90] = "Z";
  CharCode2[CharCode2["OpenSquareBracket"] = 91] = "OpenSquareBracket";
  CharCode2[CharCode2["Backslash"] = 92] = "Backslash";
  CharCode2[CharCode2["CloseSquareBracket"] = 93] = "CloseSquareBracket";
  CharCode2[CharCode2["Caret"] = 94] = "Caret";
  CharCode2[CharCode2["Underline"] = 95] = "Underline";
  CharCode2[CharCode2["BackTick"] = 96] = "BackTick";
  CharCode2[CharCode2["a"] = 97] = "a";
  CharCode2[CharCode2["b"] = 98] = "b";
  CharCode2[CharCode2["c"] = 99] = "c";
  CharCode2[CharCode2["d"] = 100] = "d";
  CharCode2[CharCode2["e"] = 101] = "e";
  CharCode2[CharCode2["f"] = 102] = "f";
  CharCode2[CharCode2["g"] = 103] = "g";
  CharCode2[CharCode2["h"] = 104] = "h";
  CharCode2[CharCode2["i"] = 105] = "i";
  CharCode2[CharCode2["j"] = 106] = "j";
  CharCode2[CharCode2["k"] = 107] = "k";
  CharCode2[CharCode2["l"] = 108] = "l";
  CharCode2[CharCode2["m"] = 109] = "m";
  CharCode2[CharCode2["n"] = 110] = "n";
  CharCode2[CharCode2["o"] = 111] = "o";
  CharCode2[CharCode2["p"] = 112] = "p";
  CharCode2[CharCode2["q"] = 113] = "q";
  CharCode2[CharCode2["r"] = 114] = "r";
  CharCode2[CharCode2["s"] = 115] = "s";
  CharCode2[CharCode2["t"] = 116] = "t";
  CharCode2[CharCode2["u"] = 117] = "u";
  CharCode2[CharCode2["v"] = 118] = "v";
  CharCode2[CharCode2["w"] = 119] = "w";
  CharCode2[CharCode2["x"] = 120] = "x";
  CharCode2[CharCode2["y"] = 121] = "y";
  CharCode2[CharCode2["z"] = 122] = "z";
  CharCode2[CharCode2["OpenCurlyBrace"] = 123] = "OpenCurlyBrace";
  CharCode2[CharCode2["Pipe"] = 124] = "Pipe";
  CharCode2[CharCode2["CloseCurlyBrace"] = 125] = "CloseCurlyBrace";
  CharCode2[CharCode2["Tilde"] = 126] = "Tilde";
  CharCode2[CharCode2["U_Combining_Grave_Accent"] = 768] = "U_Combining_Grave_Accent";
  CharCode2[CharCode2["U_Combining_Acute_Accent"] = 769] = "U_Combining_Acute_Accent";
  CharCode2[CharCode2["U_Combining_Circumflex_Accent"] = 770] = "U_Combining_Circumflex_Accent";
  CharCode2[CharCode2["U_Combining_Tilde"] = 771] = "U_Combining_Tilde";
  CharCode2[CharCode2["U_Combining_Macron"] = 772] = "U_Combining_Macron";
  CharCode2[CharCode2["U_Combining_Overline"] = 773] = "U_Combining_Overline";
  CharCode2[CharCode2["U_Combining_Breve"] = 774] = "U_Combining_Breve";
  CharCode2[CharCode2["U_Combining_Dot_Above"] = 775] = "U_Combining_Dot_Above";
  CharCode2[CharCode2["U_Combining_Diaeresis"] = 776] = "U_Combining_Diaeresis";
  CharCode2[CharCode2["U_Combining_Hook_Above"] = 777] = "U_Combining_Hook_Above";
  CharCode2[CharCode2["U_Combining_Ring_Above"] = 778] = "U_Combining_Ring_Above";
  CharCode2[CharCode2["U_Combining_Double_Acute_Accent"] = 779] = "U_Combining_Double_Acute_Accent";
  CharCode2[CharCode2["U_Combining_Caron"] = 780] = "U_Combining_Caron";
  CharCode2[CharCode2["U_Combining_Vertical_Line_Above"] = 781] = "U_Combining_Vertical_Line_Above";
  CharCode2[CharCode2["U_Combining_Double_Vertical_Line_Above"] = 782] = "U_Combining_Double_Vertical_Line_Above";
  CharCode2[CharCode2["U_Combining_Double_Grave_Accent"] = 783] = "U_Combining_Double_Grave_Accent";
  CharCode2[CharCode2["U_Combining_Candrabindu"] = 784] = "U_Combining_Candrabindu";
  CharCode2[CharCode2["U_Combining_Inverted_Breve"] = 785] = "U_Combining_Inverted_Breve";
  CharCode2[CharCode2["U_Combining_Turned_Comma_Above"] = 786] = "U_Combining_Turned_Comma_Above";
  CharCode2[CharCode2["U_Combining_Comma_Above"] = 787] = "U_Combining_Comma_Above";
  CharCode2[CharCode2["U_Combining_Reversed_Comma_Above"] = 788] = "U_Combining_Reversed_Comma_Above";
  CharCode2[CharCode2["U_Combining_Comma_Above_Right"] = 789] = "U_Combining_Comma_Above_Right";
  CharCode2[CharCode2["U_Combining_Grave_Accent_Below"] = 790] = "U_Combining_Grave_Accent_Below";
  CharCode2[CharCode2["U_Combining_Acute_Accent_Below"] = 791] = "U_Combining_Acute_Accent_Below";
  CharCode2[CharCode2["U_Combining_Left_Tack_Below"] = 792] = "U_Combining_Left_Tack_Below";
  CharCode2[CharCode2["U_Combining_Right_Tack_Below"] = 793] = "U_Combining_Right_Tack_Below";
  CharCode2[CharCode2["U_Combining_Left_Angle_Above"] = 794] = "U_Combining_Left_Angle_Above";
  CharCode2[CharCode2["U_Combining_Horn"] = 795] = "U_Combining_Horn";
  CharCode2[CharCode2["U_Combining_Left_Half_Ring_Below"] = 796] = "U_Combining_Left_Half_Ring_Below";
  CharCode2[CharCode2["U_Combining_Up_Tack_Below"] = 797] = "U_Combining_Up_Tack_Below";
  CharCode2[CharCode2["U_Combining_Down_Tack_Below"] = 798] = "U_Combining_Down_Tack_Below";
  CharCode2[CharCode2["U_Combining_Plus_Sign_Below"] = 799] = "U_Combining_Plus_Sign_Below";
  CharCode2[CharCode2["U_Combining_Minus_Sign_Below"] = 800] = "U_Combining_Minus_Sign_Below";
  CharCode2[CharCode2["U_Combining_Palatalized_Hook_Below"] = 801] = "U_Combining_Palatalized_Hook_Below";
  CharCode2[CharCode2["U_Combining_Retroflex_Hook_Below"] = 802] = "U_Combining_Retroflex_Hook_Below";
  CharCode2[CharCode2["U_Combining_Dot_Below"] = 803] = "U_Combining_Dot_Below";
  CharCode2[CharCode2["U_Combining_Diaeresis_Below"] = 804] = "U_Combining_Diaeresis_Below";
  CharCode2[CharCode2["U_Combining_Ring_Below"] = 805] = "U_Combining_Ring_Below";
  CharCode2[CharCode2["U_Combining_Comma_Below"] = 806] = "U_Combining_Comma_Below";
  CharCode2[CharCode2["U_Combining_Cedilla"] = 807] = "U_Combining_Cedilla";
  CharCode2[CharCode2["U_Combining_Ogonek"] = 808] = "U_Combining_Ogonek";
  CharCode2[CharCode2["U_Combining_Vertical_Line_Below"] = 809] = "U_Combining_Vertical_Line_Below";
  CharCode2[CharCode2["U_Combining_Bridge_Below"] = 810] = "U_Combining_Bridge_Below";
  CharCode2[CharCode2["U_Combining_Inverted_Double_Arch_Below"] = 811] = "U_Combining_Inverted_Double_Arch_Below";
  CharCode2[CharCode2["U_Combining_Caron_Below"] = 812] = "U_Combining_Caron_Below";
  CharCode2[CharCode2["U_Combining_Circumflex_Accent_Below"] = 813] = "U_Combining_Circumflex_Accent_Below";
  CharCode2[CharCode2["U_Combining_Breve_Below"] = 814] = "U_Combining_Breve_Below";
  CharCode2[CharCode2["U_Combining_Inverted_Breve_Below"] = 815] = "U_Combining_Inverted_Breve_Below";
  CharCode2[CharCode2["U_Combining_Tilde_Below"] = 816] = "U_Combining_Tilde_Below";
  CharCode2[CharCode2["U_Combining_Macron_Below"] = 817] = "U_Combining_Macron_Below";
  CharCode2[CharCode2["U_Combining_Low_Line"] = 818] = "U_Combining_Low_Line";
  CharCode2[CharCode2["U_Combining_Double_Low_Line"] = 819] = "U_Combining_Double_Low_Line";
  CharCode2[CharCode2["U_Combining_Tilde_Overlay"] = 820] = "U_Combining_Tilde_Overlay";
  CharCode2[CharCode2["U_Combining_Short_Stroke_Overlay"] = 821] = "U_Combining_Short_Stroke_Overlay";
  CharCode2[CharCode2["U_Combining_Long_Stroke_Overlay"] = 822] = "U_Combining_Long_Stroke_Overlay";
  CharCode2[CharCode2["U_Combining_Short_Solidus_Overlay"] = 823] = "U_Combining_Short_Solidus_Overlay";
  CharCode2[CharCode2["U_Combining_Long_Solidus_Overlay"] = 824] = "U_Combining_Long_Solidus_Overlay";
  CharCode2[CharCode2["U_Combining_Right_Half_Ring_Below"] = 825] = "U_Combining_Right_Half_Ring_Below";
  CharCode2[CharCode2["U_Combining_Inverted_Bridge_Below"] = 826] = "U_Combining_Inverted_Bridge_Below";
  CharCode2[CharCode2["U_Combining_Square_Below"] = 827] = "U_Combining_Square_Below";
  CharCode2[CharCode2["U_Combining_Seagull_Below"] = 828] = "U_Combining_Seagull_Below";
  CharCode2[CharCode2["U_Combining_X_Above"] = 829] = "U_Combining_X_Above";
  CharCode2[CharCode2["U_Combining_Vertical_Tilde"] = 830] = "U_Combining_Vertical_Tilde";
  CharCode2[CharCode2["U_Combining_Double_Overline"] = 831] = "U_Combining_Double_Overline";
  CharCode2[CharCode2["U_Combining_Grave_Tone_Mark"] = 832] = "U_Combining_Grave_Tone_Mark";
  CharCode2[CharCode2["U_Combining_Acute_Tone_Mark"] = 833] = "U_Combining_Acute_Tone_Mark";
  CharCode2[CharCode2["U_Combining_Greek_Perispomeni"] = 834] = "U_Combining_Greek_Perispomeni";
  CharCode2[CharCode2["U_Combining_Greek_Koronis"] = 835] = "U_Combining_Greek_Koronis";
  CharCode2[CharCode2["U_Combining_Greek_Dialytika_Tonos"] = 836] = "U_Combining_Greek_Dialytika_Tonos";
  CharCode2[CharCode2["U_Combining_Greek_Ypogegrammeni"] = 837] = "U_Combining_Greek_Ypogegrammeni";
  CharCode2[CharCode2["U_Combining_Bridge_Above"] = 838] = "U_Combining_Bridge_Above";
  CharCode2[CharCode2["U_Combining_Equals_Sign_Below"] = 839] = "U_Combining_Equals_Sign_Below";
  CharCode2[CharCode2["U_Combining_Double_Vertical_Line_Below"] = 840] = "U_Combining_Double_Vertical_Line_Below";
  CharCode2[CharCode2["U_Combining_Left_Angle_Below"] = 841] = "U_Combining_Left_Angle_Below";
  CharCode2[CharCode2["U_Combining_Not_Tilde_Above"] = 842] = "U_Combining_Not_Tilde_Above";
  CharCode2[CharCode2["U_Combining_Homothetic_Above"] = 843] = "U_Combining_Homothetic_Above";
  CharCode2[CharCode2["U_Combining_Almost_Equal_To_Above"] = 844] = "U_Combining_Almost_Equal_To_Above";
  CharCode2[CharCode2["U_Combining_Left_Right_Arrow_Below"] = 845] = "U_Combining_Left_Right_Arrow_Below";
  CharCode2[CharCode2["U_Combining_Upwards_Arrow_Below"] = 846] = "U_Combining_Upwards_Arrow_Below";
  CharCode2[CharCode2["U_Combining_Grapheme_Joiner"] = 847] = "U_Combining_Grapheme_Joiner";
  CharCode2[CharCode2["U_Combining_Right_Arrowhead_Above"] = 848] = "U_Combining_Right_Arrowhead_Above";
  CharCode2[CharCode2["U_Combining_Left_Half_Ring_Above"] = 849] = "U_Combining_Left_Half_Ring_Above";
  CharCode2[CharCode2["U_Combining_Fermata"] = 850] = "U_Combining_Fermata";
  CharCode2[CharCode2["U_Combining_X_Below"] = 851] = "U_Combining_X_Below";
  CharCode2[CharCode2["U_Combining_Left_Arrowhead_Below"] = 852] = "U_Combining_Left_Arrowhead_Below";
  CharCode2[CharCode2["U_Combining_Right_Arrowhead_Below"] = 853] = "U_Combining_Right_Arrowhead_Below";
  CharCode2[CharCode2["U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below"] = 854] = "U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below";
  CharCode2[CharCode2["U_Combining_Right_Half_Ring_Above"] = 855] = "U_Combining_Right_Half_Ring_Above";
  CharCode2[CharCode2["U_Combining_Dot_Above_Right"] = 856] = "U_Combining_Dot_Above_Right";
  CharCode2[CharCode2["U_Combining_Asterisk_Below"] = 857] = "U_Combining_Asterisk_Below";
  CharCode2[CharCode2["U_Combining_Double_Ring_Below"] = 858] = "U_Combining_Double_Ring_Below";
  CharCode2[CharCode2["U_Combining_Zigzag_Above"] = 859] = "U_Combining_Zigzag_Above";
  CharCode2[CharCode2["U_Combining_Double_Breve_Below"] = 860] = "U_Combining_Double_Breve_Below";
  CharCode2[CharCode2["U_Combining_Double_Breve"] = 861] = "U_Combining_Double_Breve";
  CharCode2[CharCode2["U_Combining_Double_Macron"] = 862] = "U_Combining_Double_Macron";
  CharCode2[CharCode2["U_Combining_Double_Macron_Below"] = 863] = "U_Combining_Double_Macron_Below";
  CharCode2[CharCode2["U_Combining_Double_Tilde"] = 864] = "U_Combining_Double_Tilde";
  CharCode2[CharCode2["U_Combining_Double_Inverted_Breve"] = 865] = "U_Combining_Double_Inverted_Breve";
  CharCode2[CharCode2["U_Combining_Double_Rightwards_Arrow_Below"] = 866] = "U_Combining_Double_Rightwards_Arrow_Below";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_A"] = 867] = "U_Combining_Latin_Small_Letter_A";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_E"] = 868] = "U_Combining_Latin_Small_Letter_E";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_I"] = 869] = "U_Combining_Latin_Small_Letter_I";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_O"] = 870] = "U_Combining_Latin_Small_Letter_O";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_U"] = 871] = "U_Combining_Latin_Small_Letter_U";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_C"] = 872] = "U_Combining_Latin_Small_Letter_C";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_D"] = 873] = "U_Combining_Latin_Small_Letter_D";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_H"] = 874] = "U_Combining_Latin_Small_Letter_H";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_M"] = 875] = "U_Combining_Latin_Small_Letter_M";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_R"] = 876] = "U_Combining_Latin_Small_Letter_R";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_T"] = 877] = "U_Combining_Latin_Small_Letter_T";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_V"] = 878] = "U_Combining_Latin_Small_Letter_V";
  CharCode2[CharCode2["U_Combining_Latin_Small_Letter_X"] = 879] = "U_Combining_Latin_Small_Letter_X";
  CharCode2[CharCode2["LINE_SEPARATOR_2028"] = 8232] = "LINE_SEPARATOR_2028";
  CharCode2[CharCode2["U_CIRCUMFLEX"] = 94] = "U_CIRCUMFLEX";
  CharCode2[CharCode2["U_GRAVE_ACCENT"] = 96] = "U_GRAVE_ACCENT";
  CharCode2[CharCode2["U_DIAERESIS"] = 168] = "U_DIAERESIS";
  CharCode2[CharCode2["U_MACRON"] = 175] = "U_MACRON";
  CharCode2[CharCode2["U_ACUTE_ACCENT"] = 180] = "U_ACUTE_ACCENT";
  CharCode2[CharCode2["U_CEDILLA"] = 184] = "U_CEDILLA";
  CharCode2[CharCode2["U_MODIFIER_LETTER_LEFT_ARROWHEAD"] = 706] = "U_MODIFIER_LETTER_LEFT_ARROWHEAD";
  CharCode2[CharCode2["U_MODIFIER_LETTER_RIGHT_ARROWHEAD"] = 707] = "U_MODIFIER_LETTER_RIGHT_ARROWHEAD";
  CharCode2[CharCode2["U_MODIFIER_LETTER_UP_ARROWHEAD"] = 708] = "U_MODIFIER_LETTER_UP_ARROWHEAD";
  CharCode2[CharCode2["U_MODIFIER_LETTER_DOWN_ARROWHEAD"] = 709] = "U_MODIFIER_LETTER_DOWN_ARROWHEAD";
  CharCode2[CharCode2["U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING"] = 722] = "U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING";
  CharCode2[CharCode2["U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING"] = 723] = "U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING";
  CharCode2[CharCode2["U_MODIFIER_LETTER_UP_TACK"] = 724] = "U_MODIFIER_LETTER_UP_TACK";
  CharCode2[CharCode2["U_MODIFIER_LETTER_DOWN_TACK"] = 725] = "U_MODIFIER_LETTER_DOWN_TACK";
  CharCode2[CharCode2["U_MODIFIER_LETTER_PLUS_SIGN"] = 726] = "U_MODIFIER_LETTER_PLUS_SIGN";
  CharCode2[CharCode2["U_MODIFIER_LETTER_MINUS_SIGN"] = 727] = "U_MODIFIER_LETTER_MINUS_SIGN";
  CharCode2[CharCode2["U_BREVE"] = 728] = "U_BREVE";
  CharCode2[CharCode2["U_DOT_ABOVE"] = 729] = "U_DOT_ABOVE";
  CharCode2[CharCode2["U_RING_ABOVE"] = 730] = "U_RING_ABOVE";
  CharCode2[CharCode2["U_OGONEK"] = 731] = "U_OGONEK";
  CharCode2[CharCode2["U_SMALL_TILDE"] = 732] = "U_SMALL_TILDE";
  CharCode2[CharCode2["U_DOUBLE_ACUTE_ACCENT"] = 733] = "U_DOUBLE_ACUTE_ACCENT";
  CharCode2[CharCode2["U_MODIFIER_LETTER_RHOTIC_HOOK"] = 734] = "U_MODIFIER_LETTER_RHOTIC_HOOK";
  CharCode2[CharCode2["U_MODIFIER_LETTER_CROSS_ACCENT"] = 735] = "U_MODIFIER_LETTER_CROSS_ACCENT";
  CharCode2[CharCode2["U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR"] = 741] = "U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR";
  CharCode2[CharCode2["U_MODIFIER_LETTER_HIGH_TONE_BAR"] = 742] = "U_MODIFIER_LETTER_HIGH_TONE_BAR";
  CharCode2[CharCode2["U_MODIFIER_LETTER_MID_TONE_BAR"] = 743] = "U_MODIFIER_LETTER_MID_TONE_BAR";
  CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_TONE_BAR"] = 744] = "U_MODIFIER_LETTER_LOW_TONE_BAR";
  CharCode2[CharCode2["U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR"] = 745] = "U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR";
  CharCode2[CharCode2["U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK"] = 746] = "U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK";
  CharCode2[CharCode2["U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK"] = 747] = "U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK";
  CharCode2[CharCode2["U_MODIFIER_LETTER_UNASPIRATED"] = 749] = "U_MODIFIER_LETTER_UNASPIRATED";
  CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD"] = 751] = "U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD";
  CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_UP_ARROWHEAD"] = 752] = "U_MODIFIER_LETTER_LOW_UP_ARROWHEAD";
  CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD"] = 753] = "U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD";
  CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD"] = 754] = "U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD";
  CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_RING"] = 755] = "U_MODIFIER_LETTER_LOW_RING";
  CharCode2[CharCode2["U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT"] = 756] = "U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT";
  CharCode2[CharCode2["U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT"] = 757] = "U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT";
  CharCode2[CharCode2["U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT"] = 758] = "U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT";
  CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_TILDE"] = 759] = "U_MODIFIER_LETTER_LOW_TILDE";
  CharCode2[CharCode2["U_MODIFIER_LETTER_RAISED_COLON"] = 760] = "U_MODIFIER_LETTER_RAISED_COLON";
  CharCode2[CharCode2["U_MODIFIER_LETTER_BEGIN_HIGH_TONE"] = 761] = "U_MODIFIER_LETTER_BEGIN_HIGH_TONE";
  CharCode2[CharCode2["U_MODIFIER_LETTER_END_HIGH_TONE"] = 762] = "U_MODIFIER_LETTER_END_HIGH_TONE";
  CharCode2[CharCode2["U_MODIFIER_LETTER_BEGIN_LOW_TONE"] = 763] = "U_MODIFIER_LETTER_BEGIN_LOW_TONE";
  CharCode2[CharCode2["U_MODIFIER_LETTER_END_LOW_TONE"] = 764] = "U_MODIFIER_LETTER_END_LOW_TONE";
  CharCode2[CharCode2["U_MODIFIER_LETTER_SHELF"] = 765] = "U_MODIFIER_LETTER_SHELF";
  CharCode2[CharCode2["U_MODIFIER_LETTER_OPEN_SHELF"] = 766] = "U_MODIFIER_LETTER_OPEN_SHELF";
  CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_LEFT_ARROW"] = 767] = "U_MODIFIER_LETTER_LOW_LEFT_ARROW";
  CharCode2[CharCode2["U_GREEK_LOWER_NUMERAL_SIGN"] = 885] = "U_GREEK_LOWER_NUMERAL_SIGN";
  CharCode2[CharCode2["U_GREEK_TONOS"] = 900] = "U_GREEK_TONOS";
  CharCode2[CharCode2["U_GREEK_DIALYTIKA_TONOS"] = 901] = "U_GREEK_DIALYTIKA_TONOS";
  CharCode2[CharCode2["U_GREEK_KORONIS"] = 8125] = "U_GREEK_KORONIS";
  CharCode2[CharCode2["U_GREEK_PSILI"] = 8127] = "U_GREEK_PSILI";
  CharCode2[CharCode2["U_GREEK_PERISPOMENI"] = 8128] = "U_GREEK_PERISPOMENI";
  CharCode2[CharCode2["U_GREEK_DIALYTIKA_AND_PERISPOMENI"] = 8129] = "U_GREEK_DIALYTIKA_AND_PERISPOMENI";
  CharCode2[CharCode2["U_GREEK_PSILI_AND_VARIA"] = 8141] = "U_GREEK_PSILI_AND_VARIA";
  CharCode2[CharCode2["U_GREEK_PSILI_AND_OXIA"] = 8142] = "U_GREEK_PSILI_AND_OXIA";
  CharCode2[CharCode2["U_GREEK_PSILI_AND_PERISPOMENI"] = 8143] = "U_GREEK_PSILI_AND_PERISPOMENI";
  CharCode2[CharCode2["U_GREEK_DASIA_AND_VARIA"] = 8157] = "U_GREEK_DASIA_AND_VARIA";
  CharCode2[CharCode2["U_GREEK_DASIA_AND_OXIA"] = 8158] = "U_GREEK_DASIA_AND_OXIA";
  CharCode2[CharCode2["U_GREEK_DASIA_AND_PERISPOMENI"] = 8159] = "U_GREEK_DASIA_AND_PERISPOMENI";
  CharCode2[CharCode2["U_GREEK_DIALYTIKA_AND_VARIA"] = 8173] = "U_GREEK_DIALYTIKA_AND_VARIA";
  CharCode2[CharCode2["U_GREEK_DIALYTIKA_AND_OXIA"] = 8174] = "U_GREEK_DIALYTIKA_AND_OXIA";
  CharCode2[CharCode2["U_GREEK_VARIA"] = 8175] = "U_GREEK_VARIA";
  CharCode2[CharCode2["U_GREEK_OXIA"] = 8189] = "U_GREEK_OXIA";
  CharCode2[CharCode2["U_GREEK_DASIA"] = 8190] = "U_GREEK_DASIA";
  CharCode2[CharCode2["U_OVERLINE"] = 8254] = "U_OVERLINE";
  CharCode2[CharCode2["UTF8_BOM"] = 65279] = "UTF8_BOM";
})(CharCode || (CharCode = {}));

// src/snippets/parser.ts
var logger29 = require_logger2()("snippets-parser");
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["Dollar"] = 0] = "Dollar";
  TokenType2[TokenType2["Colon"] = 1] = "Colon";
  TokenType2[TokenType2["Comma"] = 2] = "Comma";
  TokenType2[TokenType2["CurlyOpen"] = 3] = "CurlyOpen";
  TokenType2[TokenType2["CurlyClose"] = 4] = "CurlyClose";
  TokenType2[TokenType2["Backslash"] = 5] = "Backslash";
  TokenType2[TokenType2["Forwardslash"] = 6] = "Forwardslash";
  TokenType2[TokenType2["Pipe"] = 7] = "Pipe";
  TokenType2[TokenType2["Int"] = 8] = "Int";
  TokenType2[TokenType2["VariableName"] = 9] = "VariableName";
  TokenType2[TokenType2["Format"] = 10] = "Format";
  TokenType2[TokenType2["Plus"] = 11] = "Plus";
  TokenType2[TokenType2["Dash"] = 12] = "Dash";
  TokenType2[TokenType2["QuestionMark"] = 13] = "QuestionMark";
  TokenType2[TokenType2["EOF"] = 14] = "EOF";
})(TokenType || (TokenType = {}));
var Scanner2 = class {
  static isDigitCharacter(ch) {
    return ch >= CharCode.Digit0 && ch <= CharCode.Digit9;
  }
  static isVariableCharacter(ch) {
    return ch === CharCode.Underline || ch >= CharCode.a && ch <= CharCode.z || ch >= CharCode.A && ch <= CharCode.Z;
  }
  constructor() {
    this.text("");
  }
  text(value) {
    this.value = value;
    this.pos = 0;
  }
  tokenText(token) {
    return this.value.substr(token.pos, token.len);
  }
  next() {
    if (this.pos >= this.value.length) {
      return {type: 14, pos: this.pos, len: 0};
    }
    let pos = this.pos;
    let len = 0;
    let ch = this.value.charCodeAt(pos);
    let type;
    type = Scanner2._table[ch];
    if (typeof type === "number") {
      this.pos += 1;
      return {type, pos, len: 1};
    }
    if (Scanner2.isDigitCharacter(ch)) {
      type = 8;
      do {
        len += 1;
        ch = this.value.charCodeAt(pos + len);
      } while (Scanner2.isDigitCharacter(ch));
      this.pos += len;
      return {type, pos, len};
    }
    if (Scanner2.isVariableCharacter(ch)) {
      type = 9;
      do {
        ch = this.value.charCodeAt(pos + ++len);
      } while (Scanner2.isVariableCharacter(ch) || Scanner2.isDigitCharacter(ch));
      this.pos += len;
      return {type, pos, len};
    }
    type = 10;
    do {
      len += 1;
      ch = this.value.charCodeAt(pos + len);
    } while (!isNaN(ch) && typeof Scanner2._table[ch] === "undefined" && !Scanner2.isDigitCharacter(ch) && !Scanner2.isVariableCharacter(ch));
    this.pos += len;
    return {type, pos, len};
  }
};
var Scanner = Scanner2;
Scanner._table = {
  [CharCode.DollarSign]: 0,
  [CharCode.Colon]: 1,
  [CharCode.Comma]: 2,
  [CharCode.OpenCurlyBrace]: 3,
  [CharCode.CloseCurlyBrace]: 4,
  [CharCode.Backslash]: 5,
  [CharCode.Slash]: 6,
  [CharCode.Pipe]: 7,
  [CharCode.Plus]: 11,
  [CharCode.Dash]: 12,
  [CharCode.QuestionMark]: 13
};
var Marker = class {
  constructor() {
    this._children = [];
  }
  appendChild(child) {
    if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
      this._children[this._children.length - 1].value += child.value;
    } else {
      child.parent = this;
      this._children.push(child);
    }
    return this;
  }
  setOnlyChild(child) {
    child.parent = this;
    this._children = [child];
  }
  replace(child, others) {
    const {parent} = child;
    const idx = parent.children.indexOf(child);
    const newChildren = parent.children.slice(0);
    newChildren.splice(idx, 1, ...others);
    parent._children = newChildren;
    (function _fixParent(children, parent2) {
      for (const child2 of children) {
        child2.parent = parent2;
        _fixParent(child2.children, child2);
      }
    })(others, parent);
  }
  get children() {
    return this._children;
  }
  get snippet() {
    let candidate = this;
    while (true) {
      if (!candidate) {
        return void 0;
      }
      if (candidate instanceof TextmateSnippet) {
        return candidate;
      }
      candidate = candidate.parent;
    }
  }
  toString() {
    return this.children.reduce((prev, cur) => prev + cur.toString(), "");
  }
  len() {
    return 0;
  }
  get next() {
    let {parent} = this;
    let {children} = parent;
    let idx = children.indexOf(this);
    return children[idx + 1];
  }
};
var Text = class extends Marker {
  constructor(value) {
    super();
    this.value = value;
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  toString() {
    return this.value;
  }
  toTextmateString() {
    return Text.escape(this.value);
  }
  len() {
    return this.value.length;
  }
  clone() {
    return new Text(this.value);
  }
};
var TransformableMarker = class extends Marker {
};
var Placeholder = class extends TransformableMarker {
  constructor(index) {
    super();
    this.index = index;
  }
  static compareByIndex(a, b) {
    if (a.index === b.index) {
      return 0;
    } else if (a.isFinalTabstop) {
      return 1;
    } else if (b.isFinalTabstop) {
      return -1;
    } else if (a.index < b.index) {
      return -1;
    } else if (a.index > b.index) {
      return 1;
    } else {
      return 0;
    }
  }
  get isFinalTabstop() {
    return this.index === 0;
  }
  get choice() {
    return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
  }
  toTextmateString() {
    let transformString = "";
    if (this.transform) {
      transformString = this.transform.toTextmateString();
    }
    if (this.children.length === 0 && !this.transform) {
      return `$${this.index}`;
    } else if (this.children.length === 0) {
      return `\${${this.index}${transformString}}`;
    } else if (this.choice) {
      return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
    } else {
      return `\${${this.index}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
    }
  }
  clone() {
    let ret2 = new Placeholder(this.index);
    if (this.transform) {
      ret2.transform = this.transform.clone();
    }
    ret2._children = this.children.map((child) => child.clone());
    return ret2;
  }
};
var Choice = class extends Marker {
  constructor() {
    super(...arguments);
    this.options = [];
  }
  appendChild(marker) {
    if (marker instanceof Text) {
      marker.parent = this;
      this.options.push(marker);
    }
    return this;
  }
  toString() {
    return this.options[0].value;
  }
  toTextmateString() {
    return this.options.map((option) => option.value.replace(/\||,/g, "\\$&")).join(",");
  }
  len() {
    return this.options[0].len();
  }
  clone() {
    let ret2 = new Choice();
    for (let opt of this.options) {
      ret2.appendChild(opt);
    }
    return ret2;
  }
};
var Transform = class extends Marker {
  resolve(value) {
    let didMatch = false;
    let ret2 = value.replace(this.regexp, (...args) => {
      didMatch = true;
      return this._replace(args.slice(0, -2));
    });
    if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
      ret2 = this._replace([]);
    }
    return ret2;
  }
  _replace(groups) {
    let ret2 = "";
    for (const marker of this._children) {
      if (marker instanceof FormatString) {
        let value = groups[marker.index] || "";
        value = marker.resolve(value);
        ret2 += value;
      } else {
        ret2 += marker.toString();
      }
    }
    return ret2;
  }
  toString() {
    return "";
  }
  toTextmateString() {
    return `/${this.regexp.source}/${this.children.map((c) => c.toTextmateString())}/${(this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")}`;
  }
  clone() {
    let ret2 = new Transform();
    ret2.regexp = new RegExp(this.regexp.source, "" + (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
    ret2._children = this.children.map((child) => child.clone());
    return ret2;
  }
};
var FormatString = class extends Marker {
  constructor(index, shorthandName, ifValue, elseValue) {
    super();
    this.index = index;
    this.shorthandName = shorthandName;
    this.ifValue = ifValue;
    this.elseValue = elseValue;
  }
  resolve(value) {
    if (this.shorthandName === "upcase") {
      return !value ? "" : value.toLocaleUpperCase();
    } else if (this.shorthandName === "downcase") {
      return !value ? "" : value.toLocaleLowerCase();
    } else if (this.shorthandName === "capitalize") {
      return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
    } else if (this.shorthandName === "pascalcase") {
      return !value ? "" : this._toPascalCase(value);
    } else if (Boolean(value) && typeof this.ifValue === "string") {
      return this.ifValue;
    } else if (!value && typeof this.elseValue === "string") {
      return this.elseValue;
    } else {
      return value || "";
    }
  }
  _toPascalCase(value) {
    const match3 = value.match(/[a-z]+/gi);
    if (!match3) {
      return value;
    }
    return match3.map((word) => word.charAt(0).toUpperCase() + word.substr(1).toLowerCase()).join("");
  }
  toTextmateString() {
    let value = "${";
    value += this.index;
    if (this.shorthandName) {
      value += `:/${this.shorthandName}`;
    } else if (this.ifValue && this.elseValue) {
      value += `:?${this.ifValue}:${this.elseValue}`;
    } else if (this.ifValue) {
      value += `:+${this.ifValue}`;
    } else if (this.elseValue) {
      value += `:-${this.elseValue}`;
    }
    value += "}";
    return value;
  }
  clone() {
    let ret2 = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
    return ret2;
  }
};
var Variable = class extends TransformableMarker {
  constructor(name2) {
    super();
    this.name = name2;
  }
  async resolve(resolver2) {
    let value = await resolver2.resolve(this);
    if (value && value.includes("\n")) {
      let indent = "";
      this.snippet.walk((m) => {
        if (m == this) {
          return false;
        }
        if (m instanceof Text) {
          let lines2 = m.toString().split(/\r?\n/);
          indent = lines2[lines2.length - 1].match(/^\s*/)[0];
        }
        return true;
      });
      let lines = value.split("\n");
      let indents = lines.filter((s) => s.length > 0).map((s) => s.match(/^\s*/)[0]);
      let minIndent = indents.length == 0 ? "" : indents.reduce((p, c) => p.length < c.length ? p : c);
      let newLines = lines.map((s, i) => i == 0 || s.length == 0 || !s.startsWith(minIndent) ? s : indent + s.slice(minIndent.length));
      value = newLines.join("\n");
    }
    if (this.transform) {
      value = this.transform.resolve(value || "");
    }
    if (value !== void 0) {
      this._children = [new Text(value)];
      return true;
    }
    return false;
  }
  toTextmateString() {
    let transformString = "";
    if (this.transform) {
      transformString = this.transform.toTextmateString();
    }
    if (this.children.length === 0) {
      return `\${${this.name}${transformString}}`;
    } else {
      return `\${${this.name}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
    }
  }
  clone() {
    const ret2 = new Variable(this.name);
    if (this.transform) {
      ret2.transform = this.transform.clone();
    }
    ret2._children = this.children.map((child) => child.clone());
    return ret2;
  }
};
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
var TextmateSnippet = class extends Marker {
  get placeholderInfo() {
    if (!this._placeholders) {
      this._variables = [];
      let all = [];
      let last;
      this.walk((candidate) => {
        if (candidate instanceof Placeholder) {
          all.push(candidate);
          last = !last || last.index < candidate.index ? candidate : last;
        } else if (candidate instanceof Variable) {
          let first = candidate.name.charCodeAt(0);
          if (first < 65 || first > 90) {
            this._variables.push(candidate);
          }
        }
        return true;
      });
      this._placeholders = {all, last};
    }
    return this._placeholders;
  }
  get variables() {
    return this._variables;
  }
  get placeholders() {
    const {all} = this.placeholderInfo;
    return all;
  }
  get maxIndexNumber() {
    let {placeholders} = this;
    return placeholders.reduce((curr, p) => Math.max(curr, p.index), 0);
  }
  get minIndexNumber() {
    let {placeholders} = this;
    let nums = placeholders.map((p) => p.index);
    nums.sort((a, b) => a - b);
    if (nums.length > 1 && nums[0] == 0)
      return nums[1];
    return nums[0] || 0;
  }
  insertSnippet(snippet2, id, range2) {
    let placeholder = this.placeholders[id];
    if (!placeholder)
      return;
    let {index} = placeholder;
    const document3 = TextDocument.create("untitled:/1", "snippet", 0, placeholder.toString());
    snippet2 = TextDocument.applyEdits(document3, [{range: range2, newText: snippet2}]);
    let nested = new SnippetParser().parse(snippet2, true);
    let maxIndexAdded = nested.maxIndexNumber + 1;
    let indexes = [];
    for (let p of nested.placeholders) {
      if (p.isFinalTabstop) {
        p.index = maxIndexAdded + index;
      } else {
        p.index = p.index + index;
      }
      indexes.push(p.index);
    }
    this.walk((m) => {
      if (m instanceof Placeholder && m.index > index) {
        m.index = m.index + maxIndexAdded;
      }
      return true;
    });
    this.replace(placeholder, nested.children);
    return Math.min.apply(null, indexes);
  }
  updatePlaceholder(id, val) {
    const placeholder = this.placeholders[id];
    for (let p of this.placeholders) {
      if (p.index == placeholder.index) {
        let child = p.children[0];
        let newText = p.transform ? p.transform.resolve(val) : val;
        if (child) {
          p.setOnlyChild(new Text(newText));
        } else {
          p.appendChild(new Text(newText));
        }
      }
    }
    this._placeholders = void 0;
  }
  updateVariable(id, val) {
    const find = this.variables[id - this.maxIndexNumber - 1];
    if (find) {
      let variables = this.variables.filter((o) => o.name == find.name);
      for (let variable of variables) {
        let newText = variable.transform ? variable.transform.resolve(val) : val;
        variable.setOnlyChild(new Text(newText));
      }
    }
  }
  getPlaceholderText(id, value) {
    const placeholder = this.placeholders[id];
    if (!placeholder)
      return value;
    return placeholder.transform ? placeholder.transform.resolve(value) : value;
  }
  offset(marker) {
    let pos = 0;
    let found = false;
    this.walk((candidate) => {
      if (candidate === marker) {
        found = true;
        return false;
      }
      pos += candidate.len();
      return true;
    });
    if (!found) {
      return -1;
    }
    return pos;
  }
  fullLen(marker) {
    let ret2 = 0;
    walk([marker], (marker2) => {
      ret2 += marker2.len();
      return true;
    });
    return ret2;
  }
  enclosingPlaceholders(placeholder) {
    let ret2 = [];
    let {parent} = placeholder;
    while (parent) {
      if (parent instanceof Placeholder) {
        ret2.push(parent);
      }
      parent = parent.parent;
    }
    return ret2;
  }
  async resolveVariables(resolver2) {
    let items = [];
    this.walk((candidate) => {
      if (candidate instanceof Variable) {
        items.push(candidate);
      }
      return true;
    });
    await Promise.all(items.map((o) => o.resolve(resolver2)));
  }
  appendChild(child) {
    this._placeholders = void 0;
    return super.appendChild(child);
  }
  replace(child, others) {
    this._placeholders = void 0;
    return super.replace(child, others);
  }
  toTextmateString() {
    return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), "");
  }
  clone() {
    let ret2 = new TextmateSnippet();
    this._children = this.children.map((child) => child.clone());
    return ret2;
  }
  walk(visitor) {
    walk(this.children, visitor);
  }
};
var SnippetParser = class {
  constructor() {
    this._scanner = new Scanner();
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  text(value) {
    return this.parse(value).toString();
  }
  parse(value, insertFinalTabstop) {
    this._scanner.text(value);
    this._token = this._scanner.next();
    const snippet2 = new TextmateSnippet();
    while (this._parse(snippet2)) {
    }
    const placeholderDefaultValues = new Map();
    const incompletePlaceholders = [];
    snippet2.walk((marker) => {
      if (marker instanceof Placeholder) {
        if (marker.isFinalTabstop) {
          placeholderDefaultValues.set(0, void 0);
        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
          placeholderDefaultValues.set(marker.index, marker.children);
        } else {
          incompletePlaceholders.push(marker);
        }
      }
      return true;
    });
    for (const placeholder of incompletePlaceholders) {
      if (placeholderDefaultValues.has(placeholder.index)) {
        const clone = new Placeholder(placeholder.index);
        clone.transform = placeholder.transform;
        for (const child of placeholderDefaultValues.get(placeholder.index)) {
          let marker = child.clone();
          if (clone.transform) {
            if (marker instanceof Text) {
              marker = new Text(clone.transform.resolve(marker.value));
            } else {
              for (let child2 of marker.children) {
                if (child2 instanceof Text) {
                  marker.replace(child2, [new Text(clone.transform.resolve(child2.value))]);
                  break;
                }
              }
            }
          }
          clone.appendChild(marker);
        }
        snippet2.replace(placeholder, [clone]);
      }
    }
    if (!placeholderDefaultValues.has(0) && insertFinalTabstop) {
      snippet2.appendChild(new Placeholder(0));
    }
    return snippet2;
  }
  _accept(type, value) {
    if (type === void 0 || this._token.type === type) {
      let ret2 = !value ? true : this._scanner.tokenText(this._token);
      this._token = this._scanner.next();
      return ret2;
    }
    return false;
  }
  _backTo(token) {
    this._scanner.pos = token.pos + token.len;
    this._token = token;
    return false;
  }
  _until(type) {
    if (this._token.type === 14) {
      return false;
    }
    let start = this._token;
    while (this._token.type !== type) {
      this._token = this._scanner.next();
      if (this._token.type === 14) {
        return false;
      }
    }
    let value = this._scanner.value.substring(start.pos, this._token.pos);
    this._token = this._scanner.next();
    return value;
  }
  _parse(marker) {
    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
  }
  _parseEscaped(marker) {
    let value;
    if (value = this._accept(5, true)) {
      value = this._accept(0, true) || this._accept(4, true) || this._accept(5, true) || value;
      marker.appendChild(new Text(value));
      return true;
    }
    return false;
  }
  _parseTabstopOrVariableName(parent) {
    let value;
    const token = this._token;
    const match3 = this._accept(0) && (value = this._accept(9, true) || this._accept(8, true));
    if (!match3) {
      return this._backTo(token);
    }
    parent.appendChild(/^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));
    return true;
  }
  _parseComplexPlaceholder(parent) {
    let index;
    const token = this._token;
    const match3 = this._accept(0) && this._accept(3) && (index = this._accept(8, true));
    if (!match3) {
      return this._backTo(token);
    }
    const placeholder = new Placeholder(Number(index));
    if (this._accept(1)) {
      while (true) {
        if (this._accept(4)) {
          parent.appendChild(placeholder);
          return true;
        }
        if (this._parse(placeholder)) {
          continue;
        }
        parent.appendChild(new Text("${" + index + ":"));
        placeholder.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (placeholder.index > 0 && this._accept(7)) {
      const choice = new Choice();
      while (true) {
        if (this._parseChoiceElement(choice)) {
          if (this._accept(2)) {
            continue;
          }
          if (this._accept(7)) {
            placeholder.appendChild(choice);
            if (this._accept(4)) {
              parent.appendChild(placeholder);
              return true;
            }
          }
        }
        this._backTo(token);
        return false;
      }
    } else if (this._accept(6)) {
      if (this._parseTransform(placeholder)) {
        parent.appendChild(placeholder);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4)) {
      parent.appendChild(placeholder);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseChoiceElement(parent) {
    const token = this._token;
    const values = [];
    while (true) {
      if (this._token.type === 2 || this._token.type === 7) {
        break;
      }
      let value;
      if (value = this._accept(5, true)) {
        value = this._accept(2, true) || this._accept(7, true) || this._accept(5, true) || value;
      } else {
        value = this._accept(void 0, true);
      }
      if (!value) {
        this._backTo(token);
        return false;
      }
      values.push(value);
    }
    if (values.length === 0) {
      this._backTo(token);
      return false;
    }
    parent.appendChild(new Text(values.join("")));
    return true;
  }
  _parseComplexVariable(parent) {
    let name2;
    const token = this._token;
    const match3 = this._accept(0) && this._accept(3) && (name2 = this._accept(9, true));
    if (!match3) {
      return this._backTo(token);
    }
    const variable = new Variable(name2);
    if (this._accept(1)) {
      while (true) {
        if (this._accept(4)) {
          parent.appendChild(variable);
          return true;
        }
        if (this._parse(variable)) {
          continue;
        }
        parent.appendChild(new Text("${" + name2 + ":"));
        variable.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (this._accept(6)) {
      if (this._parseTransform(variable)) {
        parent.appendChild(variable);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4)) {
      parent.appendChild(variable);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseTransform(parent) {
    let transform = new Transform();
    let regexValue = "";
    let regexOptions = "";
    while (true) {
      if (this._accept(6)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5, true)) {
        escaped = this._accept(6, true) || escaped;
        regexValue += escaped;
        continue;
      }
      if (this._token.type !== 14) {
        regexValue += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(6)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5, true)) {
        escaped = this._accept(6, true) || escaped;
        transform.appendChild(new Text(escaped));
        continue;
      }
      if (this._parseFormatString(transform) || this._parseAnything(transform)) {
        let text = transform.children[0];
        if (text && text.value && text.value.includes("\\n")) {
          text.value = text.value.replace(/\\n/g, "\n");
        }
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(4)) {
        break;
      }
      if (this._token.type !== 14) {
        regexOptions += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    try {
      transform.regexp = new RegExp(regexValue, regexOptions);
    } catch (e) {
      return false;
    }
    parent.transform = transform;
    return true;
  }
  _parseFormatString(parent) {
    const token = this._token;
    if (!this._accept(0)) {
      return false;
    }
    let complex = false;
    if (this._accept(3)) {
      complex = true;
    }
    let index = this._accept(8, true);
    if (!index) {
      this._backTo(token);
      return false;
    } else if (!complex) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (this._accept(4)) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (!this._accept(1)) {
      this._backTo(token);
      return false;
    }
    if (this._accept(6)) {
      let shorthand = this._accept(9, true);
      if (!shorthand || !this._accept(4)) {
        this._backTo(token);
        return false;
      } else {
        parent.appendChild(new FormatString(Number(index), shorthand));
        return true;
      }
    } else if (this._accept(11)) {
      let ifValue = this._until(4);
      if (ifValue) {
        parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
        return true;
      }
    } else if (this._accept(12)) {
      let elseValue = this._until(4);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    } else if (this._accept(13)) {
      let ifValue = this._until(1);
      if (ifValue) {
        let elseValue = this._until(4);
        if (elseValue) {
          parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
          return true;
        }
      }
    } else {
      let elseValue = this._until(4);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    }
    this._backTo(token);
    return false;
  }
  _parseAnything(marker) {
    if (this._token.type !== 14) {
      let text = this._scanner.tokenText(this._token);
      marker.appendChild(new Text(text));
      this._accept(void 0);
      return true;
    }
    return false;
  }
};

// src/snippets/session.ts
var vscode_languageserver_protocol68 = __toModule(require_main3());

// src/completion/index.ts
var vscode_languageserver_protocol66 = __toModule(require_main3());

// src/sources.ts
var fast_diff3 = __toModule(require_diff2());
var fs48 = __toModule(require("fs"));
var path56 = __toModule(require("path"));
var util36 = __toModule(require("util"));
var vscode_languageserver_protocol64 = __toModule(require_main3());

// src/extensions.ts
var debounce17 = __toModule(require_debounce());
var fs_extra9 = __toModule(require_lib7());
var isuri3 = __toModule(require_isuri());
var path54 = __toModule(require("path"));
var semver5 = __toModule(require_semver2());
var vscode_languageserver_protocol63 = __toModule(require_main3());
var which7 = __toModule(require_which());

// src/model/installBuffer.ts
var events12 = __toModule(require("events"));
var logger30 = require_logger2()("model-installBuffer");
var State;
(function(State3) {
  State3[State3["Waiting"] = 0] = "Waiting";
  State3[State3["Faild"] = 1] = "Faild";
  State3[State3["Progressing"] = 2] = "Progressing";
  State3[State3["Success"] = 3] = "Success";
})(State || (State = {}));
var InstallBuffer = class extends events12.EventEmitter {
  constructor(isUpdate = false, isSync = false, channel = void 0) {
    super();
    this.isUpdate = isUpdate;
    this.isSync = isSync;
    this.channel = channel;
    this.statMap = new Map();
    this.messagesMap = new Map();
    this.names = [];
  }
  setExtensions(names) {
    this.statMap.clear();
    this.names = names;
    for (let name2 of names) {
      this.statMap.set(name2, 0);
    }
  }
  addMessage(name2, msg, isProgress = false) {
    if (isProgress && this.channel)
      return;
    let lines = this.messagesMap.get(name2) || [];
    this.messagesMap.set(name2, lines.concat(msg.trim().split(/\r?\n/)));
    if (this.channel)
      this.channel.appendLine(`[${name2}] ${msg}`);
  }
  startProgress(names) {
    for (let name2 of names) {
      this.statMap.set(name2, 2);
    }
  }
  finishProgress(name2, succeed = true) {
    if (this.channel) {
      if (succeed) {
        this.channel.appendLine(`[${name2}] install succeed!`);
      } else {
        this.channel.appendLine(`[${name2}] install failed!`);
      }
    }
    this.statMap.set(name2, succeed ? 3 : 1);
  }
  get remains() {
    let count = 0;
    for (let name2 of this.names) {
      let stat = this.statMap.get(name2);
      if (![3, 1].includes(stat)) {
        count = count + 1;
      }
    }
    return count;
  }
  getLines() {
    let lines = [];
    for (let name2 of this.names) {
      let state = this.statMap.get(name2);
      let processText = "*";
      switch (state) {
        case 2: {
          let d = new Date();
          let idx = Math.floor(d.getMilliseconds() / 100);
          processText = frames[idx];
          break;
        }
        case 1:
          processText = "\u2717";
          break;
        case 3:
          processText = "\u2713";
          break;
      }
      let msgs = this.messagesMap.get(name2) || [];
      lines.push(`- ${processText} ${name2} ${msgs.length ? msgs[msgs.length - 1] : ""}`);
    }
    return lines;
  }
  getMessages(line) {
    if (line <= 1)
      return [];
    let name2 = this.names[line - 2];
    if (!name2)
      return [];
    return this.messagesMap.get(name2);
  }
  draw(nvim, buffer4) {
    let {remains} = this;
    let first = remains == 0 ? `${this.isUpdate ? "Update" : "Install"} finished` : `Installing, ${remains} remains...`;
    let lines = [first, "", ...this.getLines()];
    buffer4.setLines(lines, {start: 0, end: -1, strictIndexing: false}, true);
    if (remains == 0 && this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
    if (process.env.VIM_NODE_RPC) {
      nvim.command("redraw", true);
    }
  }
  highlight(nvim) {
    nvim.call("matchadd", ["CocListFgCyan", "^\\-\\s\\zs\\*"], true);
    nvim.call("matchadd", ["CocListFgGreen", "^\\-\\s\\zs\u2713"], true);
    nvim.call("matchadd", ["CocListFgRed", "^\\-\\s\\zs\u2717"], true);
    nvim.call("matchadd", ["CocListFgYellow", "^-.\\{3\\}\\zs\\S\\+"], true);
  }
  async show(nvim) {
    let {isSync} = this;
    if (this.channel)
      return;
    nvim.pauseNotification();
    nvim.command(isSync ? "enew" : "vs +enew", true);
    nvim.call("bufnr", ["%"], true);
    nvim.command("setl buftype=nofile bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1", true);
    if (!isSync) {
      nvim.command("nnoremap <silent><nowait><buffer> q :q<CR>", true);
    }
    this.highlight(nvim);
    let res = await nvim.resumeNotification();
    let bufnr = res && res[1] == null ? res[0][1] : null;
    if (!bufnr)
      return;
    this.bufnr = bufnr;
    let buffer4 = nvim.createBuffer(bufnr);
    this.interval = setInterval(() => {
      this.draw(nvim, buffer4);
    }, 100);
  }
  dispose() {
    if (this.interval) {
      clearInterval(this.interval);
    }
  }
};
var installBuffer_default = InstallBuffer;

// src/model/installer.ts
var events13 = __toModule(require("events"));
var child_process3 = __toModule(require("child_process"));
var readline3 = __toModule(require("readline"));
var fs_extra6 = __toModule(require_lib7());
var os11 = __toModule(require("os"));
var path27 = __toModule(require("path"));
var rc = __toModule(require_rc());
var semver3 = __toModule(require_semver2());

// src/model/download.ts
var follow_redirects2 = __toModule(require_follow_redirects());
var fs_extra5 = __toModule(require_lib7());
var path25 = __toModule(require("path"));
var tar = __toModule(require_tar());
var unzipper = __toModule(require_unzip2());

// src/model/fetch.ts
var follow_redirects = __toModule(require_follow_redirects());
var url = __toModule(require("url"));
var fs19 = __toModule(require("fs"));
var zlib = __toModule(require("zlib"));
var querystring = __toModule(require("querystring"));
var http_proxy_agent = __toModule(require_dist2());
var https_proxy_agent = __toModule(require_dist3());
var logger31 = require_logger2()("model-fetch");
function getSystemProxyURI(endpoint) {
  let env2;
  if (endpoint.protocol === "http:") {
    env2 = process.env.HTTP_PROXY || process.env.http_proxy || null;
  } else if (endpoint.protocol === "https:") {
    env2 = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
  }
  let noProxy = process.env.NO_PROXY || process.env.no_proxy;
  if (noProxy === "*") {
    env2 = null;
  } else if (noProxy) {
    const hostname = endpoint.hostname.replace(/^\.*/, ".").toLowerCase();
    const port = endpoint.port || endpoint.protocol.startsWith("https") ? "443" : "80";
    const noProxyList = noProxy.split(",");
    for (let i = 0, len = noProxyList.length; i < len; i++) {
      let noProxyItem = noProxyList[i].trim().toLowerCase();
      if (noProxyItem.includes(":")) {
        let noProxyItemParts = noProxyItem.split(":", 2);
        let noProxyHost = noProxyItemParts[0].replace(/^\.*/, ".");
        let noProxyPort = noProxyItemParts[1];
        if (port === noProxyPort && hostname.endsWith(noProxyHost)) {
          env2 = null;
          break;
        }
      } else {
        noProxyItem = noProxyItem.replace(/^\.*/, ".");
        if (hostname.endsWith(noProxyItem)) {
          env2 = null;
          break;
        }
      }
    }
  }
  return env2;
}
function getAgent(endpoint, options) {
  let proxy = options.proxyUrl || getSystemProxyURI(endpoint);
  if (proxy) {
    const proxyEndpoint = url.parse(proxy);
    if (!/^https?:$/.test(proxyEndpoint.protocol)) {
      return null;
    }
    let opts = {
      host: proxyEndpoint.hostname,
      port: proxyEndpoint.port ? Number(proxyEndpoint.port) : proxyEndpoint.protocol === "https" ? "443" : "80",
      auth: proxyEndpoint.auth,
      rejectUnauthorized: typeof options.strictSSL === "boolean" ? options.strictSSL : true
    };
    logger31.info(`Using proxy ${proxy} from ${options.proxyUrl ? "configuration" : "system environment"} for ${endpoint.hostname}:`);
    return endpoint.protocol === "http:" ? http_proxy_agent.default(opts) : https_proxy_agent.default(opts);
  }
  return null;
}
function resolveRequestOptions(url2, options = {}) {
  let config = workspace_default.getConfiguration("http");
  let {data} = options;
  let dataType = getDataType(data);
  let proxyOptions = {
    proxyUrl: config.get("proxy", ""),
    strictSSL: config.get("proxyStrictSSL", true),
    proxyAuthorization: config.get("proxyAuthorization", null),
    proxyCA: config.get("proxyCA", null)
  };
  if (options.query && !url2.includes("?")) {
    url2 = `${url2}?${querystring.stringify(options.query)}`;
  }
  let headers = Object.assign(options.headers || {}, {"Proxy-Authorization": proxyOptions.proxyAuthorization});
  let endpoint = url.parse(url2);
  let agent = getAgent(endpoint, proxyOptions);
  let opts = {
    method: options.method || "GET",
    hostname: endpoint.hostname,
    port: endpoint.port ? parseInt(endpoint.port, 10) : endpoint.protocol === "https:" ? 443 : 80,
    path: endpoint.path,
    agent,
    rejectUnauthorized: proxyOptions.strictSSL,
    maxRedirects: 3,
    headers: Object.assign({
      "User-Agent": "Mozilla/5.0 (X11; Linux x86_64)",
      "Accept-Encoding": "gzip, deflate"
    }, headers)
  };
  if (proxyOptions.proxyCA) {
    opts.ca = fs19.default.readFileSync(proxyOptions.proxyCA);
  }
  if (dataType == "object") {
    opts.headers["Content-Type"] = "application/json";
  } else if (dataType == "string") {
    opts.headers["Content-Type"] = "text/plain";
  }
  if (options.user && options.password) {
    opts.auth = options.user + ":" + options.password;
  }
  if (options.timeout) {
    opts.timeout = options.timeout;
  }
  return opts;
}
function request(url2, data, opts, token) {
  let mod = url2.startsWith("https:") ? follow_redirects.https : follow_redirects.http;
  return new Promise((resolve3, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new Error("request aborted"));
      });
    }
    const req = mod.request(opts, (res) => {
      let readable = res;
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers || {};
        let chunks = [];
        let contentType = headers["content-type"] || "";
        let contentEncoding = headers["content-encoding"] || "";
        if (contentEncoding === "gzip") {
          const unzip2 = zlib.default.createGunzip();
          readable = res.pipe(unzip2);
        } else if (contentEncoding === "deflate") {
          let inflate = zlib.default.createInflate();
          res.pipe(inflate);
          readable = inflate;
        }
        readable.on("data", (chunk) => {
          chunks.push(chunk);
        });
        readable.on("end", () => {
          let buf = Buffer.concat(chunks);
          if (contentType.startsWith("application/json") || contentType.startsWith("text/")) {
            let ms = contentType.match(/charset=(\S+)/);
            let encoding = ms ? ms[1] : "utf8";
            let rawData = buf.toString(encoding);
            if (!contentType.includes("application/json")) {
              resolve3(rawData);
            } else {
              try {
                const parsedData = JSON.parse(rawData);
                resolve3(parsedData);
              } catch (e) {
                reject(new Error(`Parse response error: ${e}`));
              }
            }
          } else {
            resolve3(buf);
          }
        });
        readable.on("error", (err) => {
          reject(new Error(`Unable to connect ${url2}: ${err.message}`));
        });
      } else {
        reject(new Error(`Bad response from ${url2}: ${res.statusCode}`));
      }
    });
    req.on("error", reject);
    req.on("timeout", () => {
      req.destroy(new Error(`Request timeout after ${opts.timeout}ms`));
    });
    if (data) {
      if (typeof data === "string" || Buffer.isBuffer(data)) {
        req.write(data);
      } else {
        req.write(JSON.stringify(data));
      }
    }
    if (opts.timeout) {
      req.setTimeout(opts.timeout);
    }
    req.end();
  });
}
function getDataType(data) {
  if (data === null)
    return "null";
  if (data === void 0)
    return "undefined";
  if (typeof data == "string")
    return "string";
  if (Buffer.isBuffer(data))
    return "buffer";
  if (Array.isArray(data) || objectLiteral(data))
    return "object";
  return "unknown";
}
function fetch(url2, options = {}, token) {
  let opts = resolveRequestOptions(url2, options);
  return request(url2, options.data, opts, token).catch((err) => {
    logger31.error(`Fetch error for ${url2}:`, opts, err);
    if (opts.agent && opts.agent.proxy) {
      let {proxy} = opts.agent;
      throw new Error(`Request failed using proxy ${proxy.host}: ${err.message}`);
    } else {
      throw err;
    }
  });
}

// src/model/download.ts
var content_disposition = __toModule(require_content_disposition());
var logger32 = require_logger2()("model-download");
function download(url2, options, token) {
  let {dest, onProgress, extract} = options;
  if (!dest || !path25.default.isAbsolute(dest)) {
    throw new Error(`Expect absolute file path for dest option.`);
  }
  let stat;
  try {
    stat = fs_extra5.default.statSync(dest);
  } catch (_e) {
    fs_extra5.default.mkdirpSync(dest);
  }
  if (stat && !stat.isDirectory()) {
    throw new Error(`${dest} exists, but not directory!`);
  }
  let mod = url2.startsWith("https") ? follow_redirects2.https : follow_redirects2.http;
  let opts = resolveRequestOptions(url2, options);
  let extname = path25.default.extname(url2);
  return new Promise((resolve3, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new Error("request aborted"));
      });
    }
    const req = mod.request(opts, (res) => {
      var _a2, _b;
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers || {};
        let dispositionHeader = headers["content-disposition"];
        if (!extname && dispositionHeader) {
          let disposition = content_disposition.default.parse(dispositionHeader);
          if ((_a2 = disposition.parameters) == null ? void 0 : _a2.filename) {
            extname = path25.default.extname(disposition.parameters.filename);
          }
        }
        if (extract === true) {
          if (extname === ".zip" || headers["content-type"] == "application/zip") {
            extract = "unzip";
          } else if (extname == ".tgz") {
            extract = "untar";
          } else {
            reject(new Error(`Unable to extract for ${url2}`));
            return;
          }
        }
        let total = Number(headers["content-length"]);
        let cur = 0;
        if (!isNaN(total)) {
          res.on("data", (chunk) => {
            cur += chunk.length;
            let percent = (cur / total * 100).toFixed(1);
            if (onProgress) {
              onProgress(percent);
            } else {
              logger32.info(`Download ${url2} progress ${percent}%`);
            }
          });
        }
        res.on("error", (err) => {
          reject(new Error(`Unable to connect ${url2}: ${err.message}`));
        });
        res.on("end", () => {
          logger32.info("Download completed:", url2);
        });
        let stream;
        if (extract === "untar") {
          stream = res.pipe(tar.default.x({strip: (_b = options.strip) != null ? _b : 1, C: dest}));
        } else if (extract === "unzip") {
          stream = res.pipe(unzipper.default.Extract({path: dest}));
        } else {
          dest = path25.default.join(dest, `${v1_default()}${extname}`);
          stream = res.pipe(fs_extra5.default.createWriteStream(dest));
        }
        stream.on("finish", () => {
          logger32.info(`Downloaded ${url2} => ${dest}`);
          setTimeout(() => {
            resolve3(dest);
          }, 100);
        });
        stream.on("error", reject);
      } else {
        reject(new Error(`Invalid response from ${url2}: ${res.statusCode}`));
      }
    });
    req.on("error", reject);
    req.on("timeout", () => {
      req.destroy(new Error(`request timeout after ${options.timeout}ms`));
    });
    if (options.timeout) {
      req.setTimeout(options.timeout);
    }
    req.end();
  });
}

// src/model/installer.ts
var logger33 = require_logger2()("model-installer");
function registryUrl(scope = "coc.nvim") {
  const result = rc.default("npm", {registry: "https://registry.npmjs.org/"});
  const registry = result[`${scope}:registry`] || result.config_registry || result.registry;
  return registry.endsWith("/") ? registry : registry + "/";
}
var Installer = class extends events13.EventEmitter {
  constructor(root, npm, def) {
    super();
    this.root = root;
    this.npm = npm;
    this.def = def;
    if (!fs_extra6.default.existsSync(root))
      fs_extra6.default.mkdirpSync(root);
    if (/^https?:/.test(def)) {
      this.url = def;
    } else {
      if (def.includes("@")) {
        let [name2, version2] = def.split("@", 2);
        this.name = name2;
        this.version = version2;
      } else {
        this.name = def;
      }
    }
  }
  async install() {
    this.log(`Using npm from: ${this.npm}`);
    let info = await this.getInfo();
    logger33.info(`Fetched info of ${this.def}`, info);
    let {name: name2} = info;
    let required = info["engines.coc"] ? info["engines.coc"].replace(/^\^/, ">=") : "";
    if (required && !semver3.default.satisfies(workspace_default.version, required)) {
      throw new Error(`${name2} ${info.version} requires coc.nvim >= ${required}, please update coc.nvim.`);
    }
    await this.doInstall(info);
    return name2;
  }
  async update(url2) {
    this.url = url2;
    let folder = path27.default.join(this.root, this.name);
    let stat = await fs_extra6.default.lstat(folder);
    if (stat.isSymbolicLink()) {
      this.log(`Skipped update for symbol link`);
      return;
    }
    let version2;
    if (fs_extra6.default.existsSync(path27.default.join(folder, "package.json"))) {
      let content = await fs_extra6.default.readFile(path27.default.join(folder, "package.json"), "utf8");
      version2 = JSON.parse(content).version;
    }
    this.log(`Using npm from: ${this.npm}`);
    let info = await this.getInfo();
    if (version2 && info.version && semver3.default.gte(version2, info.version)) {
      this.log(`Current version ${version2} is up to date.`);
      return;
    }
    let required = info["engines.coc"] ? info["engines.coc"].replace(/^\^/, ">=") : "";
    if (required && !semver3.default.satisfies(workspace_default.version, required)) {
      throw new Error(`${info.version} requires coc.nvim ${required}, please update coc.nvim.`);
    }
    await this.doInstall(info);
    let jsonFile = path27.default.join(this.root, info.name, "package.json");
    if (fs_extra6.default.existsSync(jsonFile)) {
      this.log(`Updated to v${info.version}`);
      return path27.default.dirname(jsonFile);
    } else {
      throw new Error(`Package.json not found: ${jsonFile}`);
    }
  }
  async doInstall(info) {
    let folder = path27.default.join(this.root, info.name);
    if (fs_extra6.default.existsSync(folder)) {
      let stat2 = fs_extra6.default.statSync(folder);
      if (!stat2.isDirectory()) {
        this.log(`${folder} is not directory skipped install`);
        return;
      }
    }
    let tmpFolder = await fs_extra6.default.mkdtemp(path27.default.join(os11.default.tmpdir(), `${info.name}-`));
    let url2 = info["dist.tarball"];
    this.log(`Downloading from ${url2}`);
    await download(url2, {dest: tmpFolder, onProgress: (p) => this.log(`Download progress ${p}%`, true), extract: "untar"});
    this.log(`Extension download at ${tmpFolder}`);
    let content = await fs_extra6.default.readFile(path27.default.join(tmpFolder, "package.json"), "utf8");
    let {dependencies} = JSON.parse(content);
    if (dependencies && Object.keys(dependencies).length) {
      let p = new Promise((resolve3, reject) => {
        let args = ["install", "--ignore-scripts", "--no-lockfile", "--production"];
        if (url2.startsWith("https://github.com")) {
          args = ["install"];
        }
        if (this.npm.endsWith("npm") && !this.npm.endsWith("pnpm")) {
          args.push("--legacy-peer-deps");
        }
        if (this.npm.endsWith("yarn")) {
          args.push("--ignore-engines");
        }
        this.log(`Installing dependencies by: ${this.npm} ${args.join(" ")}.`);
        const child = child_process3.spawn(this.npm, args, {
          cwd: tmpFolder
        });
        const rl = readline3.default.createInterface({
          input: child.stdout
        });
        rl.on("line", (line) => {
          this.log(`[npm] ${line}`, true);
        });
        child.stderr.setEncoding("utf8");
        child.stdout.setEncoding("utf8");
        child.on("error", reject);
        let err = "";
        child.stderr.on("data", (data) => {
          err += data;
        });
        child.on("exit", (code) => {
          if (code) {
            if (err)
              this.log(err);
            reject(new Error(`${this.npm} install exited with ${code}`));
            return;
          }
          resolve3();
        });
      });
      await p;
    }
    let jsonFile = path27.default.resolve(this.root, global.hasOwnProperty("__TEST__") ? "" : "..", "package.json");
    let obj = JSON.parse(fs_extra6.default.readFileSync(jsonFile, "utf8"));
    obj.dependencies = obj.dependencies || {};
    if (this.url) {
      obj.dependencies[info.name] = this.url;
    } else {
      obj.dependencies[info.name] = ">=" + info.version;
    }
    const sortedObj = {dependencies: {}};
    Object.keys(obj.dependencies).sort().forEach((k) => {
      sortedObj.dependencies[k] = obj.dependencies[k];
    });
    let stat = await statAsync(folder);
    if (stat) {
      if (stat.isDirectory()) {
        fs_extra6.default.removeSync(folder);
      } else {
        fs_extra6.default.unlinkSync(folder);
      }
    }
    await fs_extra6.default.move(tmpFolder, folder, {overwrite: true});
    await fs_extra6.default.writeFile(jsonFile, JSON.stringify(sortedObj, null, 2), {encoding: "utf8"});
    this.log(`Update package.json at ${jsonFile}`);
    this.log(`Installed extension ${this.name}@${info.version} at ${folder}`);
  }
  async getInfo() {
    if (this.url)
      return await this.getInfoFromUri();
    let registry = registryUrl();
    this.log(`Get info from ${registry}`);
    let res = await fetch(registry + this.name, {timeout: 1e4});
    if (!this.version)
      this.version = res["dist-tags"]["latest"];
    let obj = res["versions"][this.version];
    if (!obj)
      throw new Error(`${this.def} doesn't exists in ${registry}.`);
    let requiredVersion = obj["engines"] && obj["engines"]["coc"];
    if (!requiredVersion) {
      throw new Error(`${this.def} is not valid coc extension, "engines" field with coc property required.`);
    }
    return {
      "dist.tarball": obj["dist"]["tarball"],
      "engines.coc": requiredVersion,
      version: obj["version"],
      name: res.name
    };
  }
  async getInfoFromUri() {
    let {url: url2} = this;
    if (!url2.includes("github.com")) {
      throw new Error(`"${url2}" is not supported, coc.nvim support github.com only`);
    }
    url2 = url2.replace(/\/$/, "");
    let fileUrl = url2.replace("github.com", "raw.githubusercontent.com") + "/master/package.json";
    this.log(`Get info from ${fileUrl}`);
    let content = await fetch(fileUrl, {timeout: 1e4});
    let obj = typeof content == "string" ? JSON.parse(content) : content;
    this.name = obj.name;
    return {
      "dist.tarball": `${url2}/archive/master.tar.gz`,
      "engines.coc": obj["engines"] ? obj["engines"]["coc"] : null,
      name: obj.name,
      version: obj.version
    };
  }
  log(msg, isProgress = false) {
    logger33.info(msg);
    this.emit("message", msg, isProgress);
  }
};
function createInstallerFactory(npm, root) {
  return (def) => new Installer(root, npm, def);
}

// src/model/memos.ts
var fs24 = __toModule(require("fs"));
var logger34 = require_logger2()("model-memos");
var Memos = class {
  constructor(filepath) {
    this.filepath = filepath;
    if (!fs24.default.existsSync(filepath)) {
      fs24.default.writeFileSync(filepath, "{}", "utf8");
    }
  }
  fetchContent(id, key) {
    try {
      let content = fs24.default.readFileSync(this.filepath, "utf8");
      let res = JSON.parse(content);
      let obj = res[id];
      if (!obj)
        return void 0;
      return obj[key];
    } catch (e) {
      return void 0;
    }
  }
  async update(id, key, value) {
    let {filepath} = this;
    try {
      let content = fs24.default.readFileSync(filepath, "utf8");
      let current = content ? JSON.parse(content) : {};
      current[id] = current[id] || {};
      if (value !== void 0) {
        current[id][key] = deepClone(value);
      } else {
        delete current[id][key];
      }
      content = JSON.stringify(current, null, 2);
      fs24.default.writeFileSync(filepath, content, "utf8");
    } catch (e) {
      logger34.error(`Error on update memos:`, e);
    }
  }
  createMemento(id) {
    return {
      get: (key, defaultValue) => {
        let res = this.fetchContent(id, key);
        return res === void 0 ? defaultValue : res;
      },
      update: async (key, value) => {
        await this.update(id, key, value);
      }
    };
  }
};
var memos_default = Memos;

// src/util/extensions.ts
var logger35 = require_logger2()("extensions");
Promise.prototype.logError = function() {
  this.catch((e) => {
    logger35.error(e);
  });
};

// src/util/factory.ts
var fs44 = __toModule(require("fs"));
var path53 = __toModule(require("path"));
var vm = __toModule(require("vm"));

// src/util/lodash.ts
var objectProto = Object.prototype;
var hasOwnProperty2 = objectProto.hasOwnProperty;
function defaults(obj, ...sources6) {
  obj = Object(obj);
  sources6.forEach((source3) => {
    if (source3 != null) {
      source3 = Object(source3);
      for (const key in source3) {
        const value = obj[key];
        if (value === void 0 || value === objectProto[key] && !hasOwnProperty2.call(obj, key)) {
          obj[key] = source3[key];
        }
      }
    }
  });
  return obj;
}
function omit(obj, properties) {
  let o = {};
  for (let key of Object.keys(obj)) {
    if (!properties.includes(key)) {
      o[key] = obj[key];
    }
  }
  return o;
}

// src/util/factory.ts
var createLogger = require_logger2();
var logger64 = createLogger("util-factoroy");
var Module = require("module");
var REMOVED_GLOBALS = [
  "reallyExit",
  "abort",
  "umask",
  "setuid",
  "setgid",
  "setgroups",
  "_fatalException",
  "exit",
  "kill"
];
function removedGlobalStub(name2) {
  return () => {
    throw new Error(`process.${name2}() is not allowed in extension sandbox`);
  };
}

// src/languages.ts
var vscode_languageserver_protocol41 = __toModule(require_main3());

// src/provider/codeActionmanager.ts
var vscode_languageserver_protocol20 = __toModule(require_main3());

// src/provider/manager.ts
var vscode_languageserver_protocol19 = __toModule(require_main3());
var logger36 = require_logger2()("provider-manager");
var Manager = class {
  constructor() {
    this.providers = new Set();
  }
  hasProvider(document3) {
    return this.getProvider(document3) != null;
  }
  getProvider(document3) {
    let currScore = 0;
    let providerItem;
    for (let item of this.providers) {
      let {selector, priority} = item;
      let score6 = workspace_default.match(selector, document3);
      if (score6 == 0)
        continue;
      if (typeof priority == "number") {
        score6 = priority;
      }
      if (score6 < currScore)
        continue;
      currScore = score6;
      providerItem = item;
    }
    return providerItem;
  }
  poviderById(id) {
    let item = Array.from(this.providers).find((o) => o.id == id);
    return item ? item.provider : null;
  }
  getProviders(document3) {
    let items = Array.from(this.providers);
    items = items.filter((item) => workspace_default.match(item.selector, document3) > 0);
    return items.sort((a, b) => workspace_default.match(b.selector, document3) - workspace_default.match(a.selector, document3));
  }
  mergeDefinitions(arr) {
    let res = [];
    for (let def of arr) {
      if (!def)
        continue;
      if (vscode_languageserver_protocol19.Location.is(def)) {
        let {uri, range: range2} = def;
        let idx = res.findIndex((l) => l.uri == uri && l.range.start.line == range2.start.line);
        if (idx == -1) {
          res.push(def);
        }
      } else if (Array.isArray(def)) {
        for (let d of def) {
          if (vscode_languageserver_protocol19.Location.is(d)) {
            let {uri, range: range2} = d;
            let idx = res.findIndex((l) => l.uri == uri && l.range.start.line == range2.start.line);
            if (idx == -1) {
              res.push(d);
            }
          } else if (vscode_languageserver_protocol19.LocationLink.is(d)) {
            let {targetUri, targetSelectionRange} = d;
            let idx = res.findIndex((l) => l.uri === targetUri && l.range.start.line === targetSelectionRange.start.line);
            if (idx === -1) {
              res.push(vscode_languageserver_protocol19.Location.create(targetUri, targetSelectionRange));
            }
          }
        }
      } else {
        window_default.showMessage(`Bad definition ${JSON.stringify(def)}`, "error");
      }
    }
    return res;
  }
};
var manager_default2 = Manager;

// src/provider/codeActionmanager.ts
var logger37 = require_logger2()("codeActionManager");
var CodeActionManager = class extends manager_default2 {
  register(selector, provider, clientId, codeActionKinds) {
    let item = {
      id: v4_default(),
      selector,
      provider,
      kinds: codeActionKinds,
      clientId
    };
    this.providers.add(item);
    return vscode_languageserver_protocol20.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideCodeActions(document3, range2, context, token) {
    let providers = this.getProviders(document3);
    if (!providers.length)
      return null;
    if (context.only) {
      let {only} = context;
      providers = providers.filter((p) => {
        if (p.kinds && !p.kinds.some((kind) => only.includes(kind))) {
          return false;
        }
        return true;
      });
    }
    let res = [];
    await Promise.all(providers.map((item) => {
      let {provider, clientId} = item;
      return Promise.resolve(provider.provideCodeActions(document3, range2, context, token)).then((actions) => {
        if (!actions || actions.length == 0)
          return;
        for (let action of actions) {
          if (vscode_languageserver_protocol20.Command.is(action)) {
            let codeAction = {
              title: action.title,
              command: action,
              clientId
            };
            res.push(codeAction);
          } else {
            if (context.only) {
              if (!action.kind)
                continue;
              let {only} = context;
              if (intersect(only, [vscode_languageserver_protocol20.CodeActionKind.Source, vscode_languageserver_protocol20.CodeActionKind.Refactor])) {
                if (!only.includes(action.kind.split(".", 2)[0])) {
                  continue;
                }
              } else if (!context.only.includes(action.kind)) {
                continue;
              }
            }
            let idx = res.findIndex((o) => o.title == action.title);
            if (idx == -1)
              res.push(Object.assign({clientId}, action));
          }
        }
      });
    }));
    return res;
  }
  dispose() {
    this.providers = new Set();
  }
};
var codeActionmanager_default = CodeActionManager;

// src/provider/codeLensManager.ts
var vscode_languageserver_protocol21 = __toModule(require_main3());
var CodeLensManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol21.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideCodeLenses(document3, token) {
    let providers = this.getProviders(document3);
    if (!providers.length)
      return null;
    let arr = await Promise.all(providers.map((item) => {
      let {provider, id} = item;
      return Promise.resolve(provider.provideCodeLenses(document3, token)).then((res) => {
        if (Array.isArray(res)) {
          for (let item2 of res) {
            item2.source = id;
          }
        }
        return res || [];
      });
    }));
    return [].concat(...arr);
  }
  async resolveCodeLens(codeLens, token) {
    if (codeLens.command)
      return codeLens;
    let {source: source3} = codeLens;
    let provider = this.poviderById(source3);
    if (!provider || typeof provider.resolveCodeLens != "function") {
      return codeLens;
    }
    let res = await Promise.resolve(provider.resolveCodeLens(omit(codeLens, ["source"]), token));
    Object.assign(codeLens, res);
    return codeLens;
  }
  dispose() {
    this.providers = new Set();
  }
};
var codeLensManager_default = CodeLensManager;

// src/provider/declarationManager.ts
var vscode_languageserver_protocol22 = __toModule(require_main3());
var logger38 = require_logger2()("definitionManager");
var DeclarationManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol22.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideDeclaration(document3, position15, token) {
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let {provider} = item;
    return await Promise.resolve(provider.provideDeclaration(document3, position15, token));
  }
  dispose() {
    this.providers = new Set();
  }
};
var declarationManager_default = DeclarationManager;

// src/provider/definitionManager.ts
var vscode_languageserver_protocol23 = __toModule(require_main3());
var logger39 = require_logger2()("definitionManager");
var DefinitionManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol23.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideDefinition(document3, position15, token) {
    let providers = this.getProviders(document3);
    if (!providers.length)
      return null;
    let arr = await Promise.all(providers.map((item) => {
      let {provider} = item;
      return Promise.resolve(provider.provideDefinition(document3, position15, token));
    }));
    return this.mergeDefinitions(arr);
  }
  dispose() {
    this.providers = new Set();
  }
};
var definitionManager_default = DefinitionManager;

// src/provider/documentColorManager.ts
var vscode_languageserver_protocol24 = __toModule(require_main3());
var DocumentColorManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol24.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideDocumentColors(document3, token) {
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let {provider} = item;
    let res = await Promise.resolve(provider.provideDocumentColors(document3, token));
    return res;
  }
  async provideColorPresentations(colorInformation, document3, token) {
    let {range: range2, color} = colorInformation;
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let {provider} = item;
    let res = await Promise.resolve(provider.provideColorPresentations(color, {document: document3, range: range2}, token));
    return res;
  }
  dispose() {
    this.providers = new Set();
  }
};
var documentColorManager_default = DocumentColorManager;

// src/provider/documentHighlightManager.ts
var vscode_languageserver_protocol25 = __toModule(require_main3());
var DocumentHighlightManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol25.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideDocumentHighlights(document3, position15, token) {
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let {provider} = item;
    return await Promise.resolve(provider.provideDocumentHighlights(document3, position15, token));
  }
  dispose() {
    this.providers = new Set();
  }
};
var documentHighlightManager_default = DocumentHighlightManager;

// src/provider/documentLinkManager.ts
var vscode_languageserver_protocol26 = __toModule(require_main3());
var DocumentLinkManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol26.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async _provideDocumentLinks(item, document3, token) {
    let {provider, id} = item;
    let items = await Promise.resolve(provider.provideDocumentLinks(document3, token));
    if (!items || !items.length)
      return [];
    items.forEach((item2) => {
      item2.data = item2.data || {};
      item2.data.source = id;
    });
    return items;
  }
  async provideDocumentLinks(document3, token) {
    let items = this.getProviders(document3);
    if (items.length == 0)
      return [];
    const arr = await Promise.all(items.map((item) => this._provideDocumentLinks(item, document3, token)));
    return [].concat(...arr);
  }
  async resolveDocumentLink(link, token) {
    let {data} = link;
    if (!data || !data.source)
      return null;
    for (let item of this.providers) {
      if (item.id == data.source) {
        let {provider} = item;
        link = await Promise.resolve(provider.resolveDocumentLink(link, token));
        return link;
      }
    }
    return null;
  }
  dispose() {
    this.providers = new Set();
  }
};
var documentLinkManager_default = DocumentLinkManager;

// src/provider/documentSymbolManager.ts
var vscode_languageserver_protocol27 = __toModule(require_main3());
var DocumentSymbolManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol27.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideDocumentSymbols(document3, token) {
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let {provider} = item;
    return await Promise.resolve(provider.provideDocumentSymbols(document3, token)) || [];
  }
  dispose() {
    this.providers = new Set();
  }
};
var documentSymbolManager_default = DocumentSymbolManager;

// src/provider/foldingRangeManager.ts
var vscode_languageserver_protocol28 = __toModule(require_main3());
var FoldingRangeManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol28.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideFoldingRanges(document3, context, token) {
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let {provider} = item;
    return await Promise.resolve(provider.provideFoldingRanges(document3, context, token)) || [];
  }
  dispose() {
    this.providers = new Set();
  }
};
var foldingRangeManager_default = FoldingRangeManager;

// src/provider/formatManager.ts
var vscode_languageserver_protocol29 = __toModule(require_main3());
var FormatManager = class extends manager_default2 {
  register(selector, provider, priority = 0) {
    let item = {
      id: v4_default(),
      selector,
      priority,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol29.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  handles(doc) {
    return this.getProvider(doc) != null;
  }
  async provideDocumentFormattingEdits(document3, options, token) {
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let {provider} = item;
    return await Promise.resolve(provider.provideDocumentFormattingEdits(document3, options, token));
  }
  dispose() {
    this.providers = new Set();
  }
};
var formatManager_default = FormatManager;

// src/provider/formatRangeManager.ts
var vscode_languageserver_protocol30 = __toModule(require_main3());
var FormatRangeManager = class extends manager_default2 {
  register(selector, provider, priority = 0) {
    let item = {
      id: v4_default(),
      selector,
      provider,
      priority
    };
    this.providers.add(item);
    return vscode_languageserver_protocol30.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideDocumentRangeFormattingEdits(document3, range2, options, token) {
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let {provider} = item;
    return await Promise.resolve(provider.provideDocumentRangeFormattingEdits(document3, range2, options, token));
  }
  dispose() {
    this.providers = new Set();
  }
};
var formatRangeManager_default = FormatRangeManager;

// src/provider/hoverManager.ts
var vscode_languageserver_protocol31 = __toModule(require_main3());
var HoverManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol31.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideHover(document3, position15, token) {
    let items = this.getProviders(document3);
    if (items.length === 0)
      return null;
    let res = [];
    for (let i = 0, len = items.length; i < len; i += 1) {
      const item = items[i];
      let hover = await Promise.resolve(item.provider.provideHover(document3, position15, token));
      if (hover && hover.contents != "")
        res.push(hover);
    }
    return res;
  }
  dispose() {
    this.providers = new Set();
  }
};
var hoverManager_default = HoverManager;

// src/provider/implementationManager.ts
var vscode_languageserver_protocol32 = __toModule(require_main3());
var ImplementationManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol32.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideReferences(document3, position15, token) {
    let providers = this.getProviders(document3);
    if (!providers.length)
      return null;
    let arr = await Promise.all(providers.map((item) => {
      let {provider} = item;
      return Promise.resolve(provider.provideImplementation(document3, position15, token));
    }));
    return this.mergeDefinitions(arr);
  }
  dispose() {
    this.providers = new Set();
  }
};
var implementationManager_default = ImplementationManager;

// src/provider/onTypeFormatManager.ts
var vscode_languageserver_protocol33 = __toModule(require_main3());
var logger40 = require_logger2()("onTypeFormatManager");
var OnTypeFormatManager = class {
  constructor() {
    this.providers = new Set();
  }
  register(selector, provider, triggerCharacters) {
    let item = {
      triggerCharacters,
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol33.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  hasProvider(document3) {
    for (let o of this.providers) {
      let {selector} = o;
      if (workspace_default.match(selector, document3) > 0) {
        return true;
      }
    }
    return false;
  }
  getProvider(document3, triggerCharacter) {
    for (let o of this.providers) {
      let {triggerCharacters, selector} = o;
      if (workspace_default.match(selector, document3) > 0 && triggerCharacters.includes(triggerCharacter)) {
        return o.provider;
      }
    }
    return null;
  }
  async onCharacterType(character, document3, position15, token) {
    let provider = this.getProvider(document3, character);
    if (!provider)
      return;
    let formatOpts = await workspace_default.getFormatOptions(document3.uri);
    return await Promise.resolve(provider.provideOnTypeFormattingEdits(document3, position15, character, formatOpts, token));
  }
  dispose() {
    this.providers = new Set();
  }
};
var onTypeFormatManager_default = OnTypeFormatManager;

// src/provider/selectionRangeManager.ts
var vscode_languageserver_protocol34 = __toModule(require_main3());
var SelectionRangeManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol34.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideSelectionRanges(document3, positions2, token) {
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let {provider} = item;
    return await Promise.resolve(provider.provideSelectionRanges(document3, positions2, token)) || [];
  }
  dispose() {
    this.providers = new Set();
  }
};
var selectionRangeManager_default = SelectionRangeManager;

// src/provider/referenceManager.ts
var vscode_languageserver_protocol35 = __toModule(require_main3());
var ReferenceManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol35.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideReferences(document3, position15, context, token) {
    let providers = this.getProviders(document3);
    if (!providers.length)
      return null;
    let arr = await Promise.all(providers.map((item) => {
      let {provider} = item;
      return Promise.resolve(provider.provideReferences(document3, position15, context, token));
    }));
    return this.mergeDefinitions(arr);
  }
  dispose() {
    this.providers = new Set();
  }
};
var referenceManager_default = ReferenceManager;

// src/provider/renameManager.ts
var vscode_languageserver_protocol36 = __toModule(require_main3());
var RenameManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol36.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideRenameEdits(document3, position15, newName, token) {
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let {provider} = item;
    return await Promise.resolve(provider.provideRenameEdits(document3, position15, newName, token));
  }
  async prepareRename(document3, position15, token) {
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let {provider} = item;
    if (provider.prepareRename == null)
      return null;
    let res = await Promise.resolve(provider.prepareRename(document3, position15, token));
    if (res == null)
      return false;
    return res;
  }
  dispose() {
    this.providers = new Set();
  }
};
var renameManager_default = RenameManager;

// src/provider/signatureManager.ts
var vscode_languageserver_protocol37 = __toModule(require_main3());
var SignatureManager = class extends manager_default2 {
  register(selector, provider, triggerCharacters) {
    let characters = triggerCharacters.reduce((p, c) => p.concat(c.split(/\s*/g)), []);
    let item = {
      id: v4_default(),
      selector,
      provider,
      triggerCharacters: characters
    };
    this.providers.add(item);
    return vscode_languageserver_protocol37.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  shouldTrigger(document3, triggerCharacter) {
    let item = this.getProvider(document3);
    if (!item)
      return false;
    let {triggerCharacters} = item;
    return triggerCharacters && triggerCharacters.indexOf(triggerCharacter) != -1;
  }
  async provideSignatureHelp(document3, position15, token, context) {
    let item = this.getProvider(document3);
    if (!item)
      return null;
    let res = await Promise.resolve(item.provider.provideSignatureHelp(document3, position15, token, context));
    if (res && res.signatures && res.signatures.length)
      return res;
    return null;
  }
  dispose() {
    this.providers = new Set();
  }
};
var signatureManager_default = SignatureManager;

// src/provider/typeDefinitionManager.ts
var vscode_languageserver_protocol38 = __toModule(require_main3());
var TypeDefinitionManager = class extends manager_default2 {
  register(selector, provider) {
    let item = {
      id: v4_default(),
      selector,
      provider
    };
    this.providers.add(item);
    return vscode_languageserver_protocol38.Disposable.create(() => {
      this.providers.delete(item);
    });
  }
  async provideTypeDefinition(document3, position15, token) {
    let providers = this.getProviders(document3);
    if (!providers.length)
      return null;
    let arr = await Promise.all(providers.map((item) => {
      let {provider} = item;
      return Promise.resolve(provider.provideTypeDefinition(document3, position15, token));
    }));
    return this.mergeDefinitions(arr);
  }
  dispose() {
    this.providers = new Set();
  }
};
var typeDefinitionManager_default = TypeDefinitionManager;

// src/provider/workspaceSymbolsManager.ts
var vscode_languageserver_protocol39 = __toModule(require_main3());
var WorkspaceSymbolManager = class {
  constructor() {
    this.providers = new Map();
  }
  register(provider) {
    let id = v4_default();
    this.providers.set(id, provider);
    return vscode_languageserver_protocol39.Disposable.create(() => {
      this.providers.delete(id);
    });
  }
  async provideWorkspaceSymbols(query, token) {
    let entries = Array.from(this.providers.entries());
    if (!entries.length)
      return [];
    let res = [];
    await Promise.all(entries.map((o) => {
      let [id, p] = o;
      return Promise.resolve(p.provideWorkspaceSymbols(query, token)).then((item) => {
        if (item) {
          item.source = id;
          res.push(...item);
        }
      });
    }));
    return res;
  }
  async resolveWorkspaceSymbol(symbolInfo, token) {
    let provider = this.providers.get(symbolInfo.source);
    if (!provider)
      return;
    if (typeof provider.resolveWorkspaceSymbol != "function") {
      return Promise.resolve(symbolInfo);
    }
    return await Promise.resolve(provider.resolveWorkspaceSymbol(symbolInfo, token));
  }
  hasProvider() {
    return this.providers.size > 0;
  }
  dispose() {
    this.providers = new Map();
  }
};
var workspaceSymbolsManager_default = WorkspaceSymbolManager;

// src/util/complete.ts
var vscode_languageserver_protocol40 = __toModule(require_main3());
var logger41 = require_logger2()("util-complete");
function getPosition(opt) {
  let {line, linenr, colnr} = opt;
  let part = byteSlice(line, 0, colnr - 1);
  return {
    line: linenr - 1,
    character: part.length
  };
}
function getWord(item, opt, invalidInsertCharacters) {
  let {label, data, insertTextFormat, insertText, textEdit} = item;
  let word;
  let newText;
  if (data && typeof data.word === "string")
    return data.word;
  if (textEdit) {
    let {range: range2} = textEdit;
    newText = textEdit.newText;
    if (range2 && range2.start.line == range2.end.line) {
      let {line, col, colnr} = opt;
      let character = characterIndex(line, col);
      if (range2.start.character > character) {
        let before = line.slice(character - range2.start.character);
        newText = before + newText;
      } else {
        let start = line.slice(range2.start.character, character);
        if (start.length && newText.startsWith(start)) {
          newText = newText.slice(start.length);
        }
      }
      character = characterIndex(line, colnr - 1);
      if (range2.end.character > character) {
        let end = line.slice(character, range2.end.character);
        if (newText.endsWith(end)) {
          newText = newText.slice(0, -end.length);
        }
      }
    }
  } else {
    newText = insertText;
  }
  if (insertTextFormat == vscode_languageserver_protocol40.InsertTextFormat.Snippet && newText && newText.includes("$")) {
    let parser4 = new SnippetParser();
    let text = parser4.text(newText);
    word = text ? getValidWord(text, invalidInsertCharacters) : label;
  } else {
    word = getValidWord(newText, invalidInsertCharacters) || label;
  }
  return word || "";
}
function completionKindString(kind, map, defaultValue = "") {
  return map.get(kind) || defaultValue;
}
function getValidWord(text, invalidChars) {
  if (!text)
    return "";
  for (let i = 0; i < text.length; i++) {
    let c = text[i];
    if (invalidChars.includes(c)) {
      return text.slice(0, i);
    }
  }
  return text;
}

// src/languages.ts
var logger42 = require_logger2()("languages");
var Languages = class {
  constructor() {
    this.onTypeFormatManager = new onTypeFormatManager_default();
    this.documentLinkManager = new documentLinkManager_default();
    this.documentColorManager = new documentColorManager_default();
    this.foldingRangeManager = new foldingRangeManager_default();
    this.renameManager = new renameManager_default();
    this.formatManager = new formatManager_default();
    this.codeActionManager = new codeActionmanager_default();
    this.workspaceSymbolsManager = new workspaceSymbolsManager_default();
    this.formatRangeManager = new formatRangeManager_default();
    this.hoverManager = new hoverManager_default();
    this.signatureManager = new signatureManager_default();
    this.documentSymbolManager = new documentSymbolManager_default();
    this.documentHighlightManager = new documentHighlightManager_default();
    this.definitionManager = new definitionManager_default();
    this.declarationManager = new declarationManager_default();
    this.typeDefinitionManager = new typeDefinitionManager_default();
    this.referenceManager = new referenceManager_default();
    this.implementationManager = new implementationManager_default();
    this.codeLensManager = new codeLensManager_default();
    this.selectionRangeManager = new selectionRangeManager_default();
    this.cancelTokenSource = new vscode_languageserver_protocol41.CancellationTokenSource();
  }
  init() {
    this.loadCompleteConfig();
    workspace_default.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("suggest")) {
        this.loadCompleteConfig();
      }
    }, this);
  }
  get nvim() {
    return workspace_default.nvim;
  }
  get detailField() {
    let {detailField, floatEnable} = this.completeConfig;
    if (detailField == "preview" && (!floatEnable || !workspace_default.floatSupported)) {
      return "menu";
    }
    return "preview";
  }
  loadCompleteConfig() {
    let suggest = workspace_default.getConfiguration("suggest");
    let labels = suggest.get("completionItemKindLabels", {});
    this.completionItemKindMap = new Map([
      [vscode_languageserver_protocol41.CompletionItemKind.Text, labels["text"] || "v"],
      [vscode_languageserver_protocol41.CompletionItemKind.Method, labels["method"] || "f"],
      [vscode_languageserver_protocol41.CompletionItemKind.Function, labels["function"] || "f"],
      [vscode_languageserver_protocol41.CompletionItemKind.Constructor, typeof labels["constructor"] == "function" ? "f" : labels["constructor"]],
      [vscode_languageserver_protocol41.CompletionItemKind.Field, labels["field"] || "m"],
      [vscode_languageserver_protocol41.CompletionItemKind.Variable, labels["variable"] || "v"],
      [vscode_languageserver_protocol41.CompletionItemKind.Class, labels["class"] || "C"],
      [vscode_languageserver_protocol41.CompletionItemKind.Interface, labels["interface"] || "I"],
      [vscode_languageserver_protocol41.CompletionItemKind.Module, labels["module"] || "M"],
      [vscode_languageserver_protocol41.CompletionItemKind.Property, labels["property"] || "m"],
      [vscode_languageserver_protocol41.CompletionItemKind.Unit, labels["unit"] || "U"],
      [vscode_languageserver_protocol41.CompletionItemKind.Value, labels["value"] || "v"],
      [vscode_languageserver_protocol41.CompletionItemKind.Enum, labels["enum"] || "E"],
      [vscode_languageserver_protocol41.CompletionItemKind.Keyword, labels["keyword"] || "k"],
      [vscode_languageserver_protocol41.CompletionItemKind.Snippet, labels["snippet"] || "S"],
      [vscode_languageserver_protocol41.CompletionItemKind.Color, labels["color"] || "v"],
      [vscode_languageserver_protocol41.CompletionItemKind.File, labels["file"] || "F"],
      [vscode_languageserver_protocol41.CompletionItemKind.Reference, labels["reference"] || "r"],
      [vscode_languageserver_protocol41.CompletionItemKind.Folder, labels["folder"] || "F"],
      [vscode_languageserver_protocol41.CompletionItemKind.EnumMember, labels["enumMember"] || "m"],
      [vscode_languageserver_protocol41.CompletionItemKind.Constant, labels["constant"] || "v"],
      [vscode_languageserver_protocol41.CompletionItemKind.Struct, labels["struct"] || "S"],
      [vscode_languageserver_protocol41.CompletionItemKind.Event, labels["event"] || "E"],
      [vscode_languageserver_protocol41.CompletionItemKind.Operator, labels["operator"] || "O"],
      [vscode_languageserver_protocol41.CompletionItemKind.TypeParameter, labels["typeParameter"] || "T"]
    ]);
    this.completeConfig = {
      defaultKindText: labels["default"] || "",
      priority: suggest.get("languageSourcePriority", 99),
      echodocSupport: suggest.get("echodocSupport", false),
      detailField: suggest.get("detailField", "preview"),
      detailMaxLength: suggest.get("detailMaxLength", 100),
      floatEnable: suggest.get("floatEnable", true),
      invalidInsertCharacters: suggest.get("invalidInsertCharacters", ["(", "<", "{", "[", "\r", "\n"])
    };
  }
  hasFormatProvider(doc) {
    if (this.formatManager.hasProvider(doc)) {
      return true;
    }
    if (this.formatRangeManager.hasProvider(doc)) {
      return true;
    }
    return false;
  }
  registerOnTypeFormattingEditProvider(selector, provider, triggerCharacters) {
    return this.onTypeFormatManager.register(selector, provider, triggerCharacters);
  }
  registerCompletionItemProvider(name2, shortcut, languageIds, provider, triggerCharacters = [], priority, allCommitCharacters) {
    languageIds = typeof languageIds == "string" ? [languageIds] : languageIds;
    let source3 = this.createCompleteSource(name2, shortcut, provider, languageIds, triggerCharacters, allCommitCharacters || [], priority);
    sources_default.addSource(source3);
    logger42.debug("created service source", name2);
    return {
      dispose: () => {
        sources_default.removeSource(source3);
      }
    };
  }
  registerCodeActionProvider(selector, provider, clientId, codeActionKinds) {
    return this.codeActionManager.register(selector, provider, clientId, codeActionKinds);
  }
  registerHoverProvider(selector, provider) {
    return this.hoverManager.register(selector, provider);
  }
  registerSelectionRangeProvider(selector, provider) {
    return this.selectionRangeManager.register(selector, provider);
  }
  registerSignatureHelpProvider(selector, provider, triggerCharacters) {
    return this.signatureManager.register(selector, provider, triggerCharacters);
  }
  registerDocumentSymbolProvider(selector, provider) {
    return this.documentSymbolManager.register(selector, provider);
  }
  registerFoldingRangeProvider(selector, provider) {
    return this.foldingRangeManager.register(selector, provider);
  }
  registerDocumentHighlightProvider(selector, provider) {
    return this.documentHighlightManager.register(selector, provider);
  }
  registerCodeLensProvider(selector, provider) {
    return this.codeLensManager.register(selector, provider);
  }
  registerDocumentLinkProvider(selector, provider) {
    return this.documentLinkManager.register(selector, provider);
  }
  registerDocumentColorProvider(selector, provider) {
    return this.documentColorManager.register(selector, provider);
  }
  registerDefinitionProvider(selector, provider) {
    return this.definitionManager.register(selector, provider);
  }
  registerDeclarationProvider(selector, provider) {
    return this.declarationManager.register(selector, provider);
  }
  registerTypeDefinitionProvider(selector, provider) {
    return this.typeDefinitionManager.register(selector, provider);
  }
  registerImplementationProvider(selector, provider) {
    return this.implementationManager.register(selector, provider);
  }
  registerReferencesProvider(selector, provider) {
    return this.referenceManager.register(selector, provider);
  }
  registerRenameProvider(selector, provider) {
    return this.renameManager.register(selector, provider);
  }
  registerWorkspaceSymbolProvider(provider) {
    if (arguments.length > 1 && typeof arguments[1].provideWorkspaceSymbols === "function") {
      provider = arguments[1];
    }
    return this.workspaceSymbolsManager.register(provider);
  }
  registerDocumentFormatProvider(selector, provider, priority = 0) {
    return this.formatManager.register(selector, provider, priority);
  }
  registerDocumentRangeFormatProvider(selector, provider, priority = 0) {
    return this.formatRangeManager.register(selector, provider, priority);
  }
  shouldTriggerSignatureHelp(document3, triggerCharacter) {
    return this.signatureManager.shouldTrigger(document3, triggerCharacter);
  }
  async getHover(document3, position15, token) {
    return await this.hoverManager.provideHover(document3, position15, token);
  }
  async getSignatureHelp(document3, position15, token, context) {
    return await this.signatureManager.provideSignatureHelp(document3, position15, token, context);
  }
  async getDefinition(document3, position15, token) {
    if (!this.definitionManager.hasProvider(document3))
      return null;
    return await this.definitionManager.provideDefinition(document3, position15, token);
  }
  async getDeclaration(document3, position15, token) {
    if (!this.declarationManager.hasProvider(document3))
      return null;
    return await this.declarationManager.provideDeclaration(document3, position15, token);
  }
  async getTypeDefinition(document3, position15, token) {
    if (!this.typeDefinitionManager.hasProvider(document3))
      return null;
    return await this.typeDefinitionManager.provideTypeDefinition(document3, position15, token);
  }
  async getImplementation(document3, position15, token) {
    if (!this.implementationManager.hasProvider(document3))
      return null;
    return await this.implementationManager.provideReferences(document3, position15, token);
  }
  async getReferences(document3, context, position15, token) {
    if (!this.referenceManager.hasProvider(document3))
      return null;
    return await this.referenceManager.provideReferences(document3, position15, context, token);
  }
  async getDocumentSymbol(document3, token) {
    return await this.documentSymbolManager.provideDocumentSymbols(document3, token);
  }
  async getSelectionRanges(document3, positions2, token) {
    return await this.selectionRangeManager.provideSelectionRanges(document3, positions2, token);
  }
  async getWorkspaceSymbols(query, token) {
    query = query || "";
    return await this.workspaceSymbolsManager.provideWorkspaceSymbols(query, token);
  }
  async resolveWorkspaceSymbol(symbol, token) {
    return await this.workspaceSymbolsManager.resolveWorkspaceSymbol(symbol, token);
  }
  async prepareRename(document3, position15, token) {
    return await this.renameManager.prepareRename(document3, position15, token);
  }
  async provideRenameEdits(document3, position15, newName, token) {
    return await this.renameManager.provideRenameEdits(document3, position15, newName, token);
  }
  async provideDocumentFormattingEdits(document3, options, token) {
    if (!this.formatManager.hasProvider(document3)) {
      let hasRangeFormater = this.formatRangeManager.hasProvider(document3);
      if (!hasRangeFormater)
        return null;
      let end = document3.positionAt(document3.getText().length);
      let range2 = vscode_languageserver_protocol41.Range.create(vscode_languageserver_protocol41.Position.create(0, 0), end);
      return await this.provideDocumentRangeFormattingEdits(document3, range2, options, token);
    }
    return await this.formatManager.provideDocumentFormattingEdits(document3, options, token);
  }
  async provideDocumentRangeFormattingEdits(document3, range2, options, token) {
    if (!this.formatRangeManager.hasProvider(document3))
      return null;
    return await this.formatRangeManager.provideDocumentRangeFormattingEdits(document3, range2, options, token);
  }
  async getCodeActions(document3, range2, context, token) {
    return await this.codeActionManager.provideCodeActions(document3, range2, context, token);
  }
  async getDocumentHighLight(document3, position15, token) {
    return await this.documentHighlightManager.provideDocumentHighlights(document3, position15, token);
  }
  async getDocumentLinks(document3, token) {
    if (!this.documentLinkManager.hasProvider(document3)) {
      return null;
    }
    return await this.documentLinkManager.provideDocumentLinks(document3, token) || [];
  }
  async resolveDocumentLink(link) {
    return await this.documentLinkManager.resolveDocumentLink(link, this.token);
  }
  async provideDocumentColors(document3, token) {
    return await this.documentColorManager.provideDocumentColors(document3, token);
  }
  async provideFoldingRanges(document3, context, token) {
    if (!this.foldingRangeManager.hasProvider(document3)) {
      return null;
    }
    return await this.foldingRangeManager.provideFoldingRanges(document3, context, token);
  }
  async provideColorPresentations(color, document3, token) {
    return await this.documentColorManager.provideColorPresentations(color, document3, token);
  }
  async getCodeLens(document3, token) {
    return await this.codeLensManager.provideCodeLenses(document3, token);
  }
  async resolveCodeLens(codeLens, token) {
    return await this.codeLensManager.resolveCodeLens(codeLens, token);
  }
  async provideDocumentOnTypeEdits(character, document3, position15, token) {
    return this.onTypeFormatManager.onCharacterType(character, document3, position15, token);
  }
  hasOnTypeProvider(character, document3) {
    return this.onTypeFormatManager.getProvider(document3, character) != null;
  }
  hasProvider(id, document3) {
    switch (id) {
      case "rename":
        return this.renameManager.hasProvider(document3);
      case "onTypeEdit":
        return this.onTypeFormatManager.hasProvider(document3);
      case "documentLink":
        return this.documentLinkManager.hasProvider(document3);
      case "documentColor":
        return this.documentColorManager.hasProvider(document3);
      case "foldingRange":
        return this.foldingRangeManager.hasProvider(document3);
      case "format":
        return this.formatManager.hasProvider(document3);
      case "codeAction":
        return this.codeActionManager.hasProvider(document3);
      case "workspaceSymbols":
        return this.workspaceSymbolsManager.hasProvider();
      case "formatRange":
        return this.formatRangeManager.hasProvider(document3);
      case "hover":
        return this.hoverManager.hasProvider(document3);
      case "signature":
        return this.signatureManager.hasProvider(document3);
      case "documentSymbol":
        return this.documentSymbolManager.hasProvider(document3);
      case "documentHighlight":
        return this.documentHighlightManager.hasProvider(document3);
      case "definition":
        return this.definitionManager.hasProvider(document3);
      case "declaration":
        return this.declarationManager.hasProvider(document3);
      case "typeDefinition":
        return this.typeDefinitionManager.hasProvider(document3);
      case "reference":
        return this.referenceManager.hasProvider(document3);
      case "implementation":
        return this.implementationManager.hasProvider(document3);
      case "codeLens":
        return this.codeLensManager.hasProvider(document3);
      case "selectionRange":
        return this.selectionRangeManager.hasProvider(document3);
      default:
        throw new Error(`${id} not supported.`);
    }
  }
  dispose() {
  }
  createDiagnosticCollection(owner) {
    return manager_default.create(owner);
  }
  createCompleteSource(name2, shortcut, provider, languageIds, triggerCharacters, allCommitCharacters, priority) {
    let completeItems = [];
    let hasResolve = typeof provider.resolveCompletionItem === "function";
    priority = priority == null ? this.completeConfig.priority : priority;
    let resolvedIndexes = new Set();
    let source3 = {
      name: name2,
      priority,
      shortcut,
      enable: true,
      sourceType: SourceType.Service,
      filetypes: languageIds,
      triggerCharacters: triggerCharacters || [],
      toggle: () => {
        source3.enable = !source3.enable;
      },
      doComplete: async (opt, token) => {
        let {triggerCharacter, bufnr} = opt;
        resolvedIndexes = new Set();
        let isTrigger = triggerCharacters && triggerCharacters.includes(triggerCharacter);
        let triggerKind = vscode_languageserver_protocol41.CompletionTriggerKind.Invoked;
        if (opt.triggerForInComplete) {
          triggerKind = vscode_languageserver_protocol41.CompletionTriggerKind.TriggerForIncompleteCompletions;
        } else if (isTrigger) {
          triggerKind = vscode_languageserver_protocol41.CompletionTriggerKind.TriggerCharacter;
        }
        if (token.isCancellationRequested)
          return null;
        let position15 = getPosition(opt);
        let context = {triggerKind, option: opt};
        if (isTrigger)
          context.triggerCharacter = triggerCharacter;
        let result;
        try {
          let doc = workspace_default.getDocument(bufnr);
          result = await Promise.resolve(provider.provideCompletionItems(doc.textDocument, position15, token, context));
        } catch (e) {
          logger42.error(`Complete "${name2}" error:`, e);
          return null;
        }
        if (!result || token.isCancellationRequested)
          return null;
        completeItems = Array.isArray(result) ? result : result.items;
        if (!completeItems || completeItems.length == 0)
          return null;
        let startcol = this.getStartColumn(opt.line, completeItems);
        let option = Object.assign({}, opt);
        let prefix;
        if (startcol != null) {
          if (startcol < option.col) {
            prefix = byteSlice(opt.line, startcol, option.col);
          }
          option.col = startcol;
        }
        let items = completeItems.map((o, index) => {
          let item = this.convertVimCompleteItem(o, shortcut, option, prefix);
          item.index = index;
          return item;
        });
        return {
          startcol,
          isIncomplete: !!result.isIncomplete,
          items
        };
      },
      onCompleteResolve: async (item, token) => {
        let resolving = completeItems[item.index];
        if (!resolving)
          return;
        if (hasResolve && !resolvedIndexes.has(item.index)) {
          let resolved = await Promise.resolve(provider.resolveCompletionItem(resolving, token));
          if (token.isCancellationRequested)
            return;
          resolvedIndexes.add(item.index);
          if (resolved)
            Object.assign(resolving, resolved);
        }
        if (item.documentation == null) {
          let {documentation, detail} = resolving;
          if (!documentation && !detail)
            return;
          let docs = [];
          if (detail && !item.detailShown && detail != item.word) {
            detail = detail.replace(/\n\s*/g, " ");
            if (detail.length) {
              let isText = /^[\w-\s.,\t]+$/.test(detail);
              let filetype = isText ? "txt" : await workspace_default.nvim.eval("&filetype");
              docs.push({filetype: isText ? "txt" : filetype, content: detail});
            }
          }
          if (documentation) {
            if (typeof documentation == "string") {
              docs.push({
                filetype: "markdown",
                content: documentation
              });
            } else if (documentation.value) {
              docs.push({
                filetype: documentation.kind == "markdown" ? "markdown" : "txt",
                content: documentation.value
              });
            }
          }
          item.documentation = docs;
        }
      },
      onCompleteDone: async (vimItem, opt) => {
        let item = completeItems[vimItem.index];
        if (!item)
          return;
        let line = opt.linenr - 1;
        if (item.insertText != null && !item.textEdit) {
          item.textEdit = {
            range: vscode_languageserver_protocol41.Range.create(line, opt.col, line, opt.colnr - 1),
            newText: item.insertText
          };
        }
        if (vimItem.line)
          Object.assign(opt, {line: vimItem.line});
        try {
          let isSnippet = await this.applyTextEdit(item, opt);
          let {additionalTextEdits} = item;
          if (additionalTextEdits && item.textEdit) {
            let r = item.textEdit.range;
            additionalTextEdits = additionalTextEdits.filter((edit2) => {
              if (rangeOverlap(r, edit2.range)) {
                logger42.error("Filtered overlap additionalTextEdit:", edit2);
                return false;
              }
              return true;
            });
          }
          await this.applyAdditionalEdits(additionalTextEdits, opt.bufnr, isSnippet);
          if (isSnippet)
            await manager_default3.selectCurrentPlaceholder();
          if (item.command)
            commands_default.execute(item.command);
        } catch (e) {
          logger42.error("Error on CompleteDone:", e);
        }
      },
      shouldCommit: (item, character) => {
        let completeItem = completeItems[item.index];
        if (!completeItem)
          return false;
        let commitCharacters = completeItem.commitCharacters || allCommitCharacters;
        return commitCharacters.includes(character);
      }
    };
    return source3;
  }
  get token() {
    this.cancelTokenSource = new vscode_languageserver_protocol41.CancellationTokenSource();
    return this.cancelTokenSource.token;
  }
  async applyTextEdit(item, option) {
    let {nvim} = this;
    let {textEdit} = item;
    if (!textEdit)
      return false;
    let {line, bufnr, linenr} = option;
    let doc = workspace_default.getDocument(bufnr);
    if (!doc)
      return false;
    let {range: range2, newText} = textEdit;
    let isSnippet = item.insertTextFormat === vscode_languageserver_protocol41.InsertTextFormat.Snippet;
    let start = line.substr(0, range2.start.character);
    let end = line.substr(range2.end.character);
    if (isSnippet) {
      let currline = doc.getline(linenr - 1);
      let endCharacter = currline.length - end.length;
      let r = vscode_languageserver_protocol41.Range.create(linenr - 1, range2.start.character, linenr - 1, endCharacter);
      return await manager_default3.insertSnippet(newText, false, r);
    }
    let newLines = `${start}${newText}${end}`.split("\n");
    if (newLines.length == 1) {
      await nvim.call("coc#util#setline", [linenr, newLines[0]]);
      await window_default.moveTo(vscode_languageserver_protocol41.Position.create(linenr - 1, (start + newText).length));
    } else {
      let buffer4 = nvim.createBuffer(bufnr);
      await buffer4.setLines(newLines, {
        start: linenr - 1,
        end: linenr,
        strictIndexing: false
      });
      let line2 = linenr - 1 + newLines.length - 1;
      let character = newLines[newLines.length - 1].length - end.length;
      await window_default.moveTo({line: line2, character});
    }
    return false;
  }
  async applyAdditionalEdits(textEdits, bufnr, snippet2) {
    if (!textEdits || textEdits.length == 0)
      return;
    let document3 = workspace_default.getDocument(bufnr);
    if (!document3)
      return;
    await document3.patchChange(true);
    let changed = null;
    let pos = await window_default.getCursorPosition();
    if (!snippet2)
      changed = getChangedFromEdits(pos, textEdits);
    await document3.applyEdits(textEdits);
    if (changed)
      await window_default.moveTo(vscode_languageserver_protocol41.Position.create(pos.line + changed.line, pos.character + changed.character));
  }
  getStartColumn(line, items) {
    let first = items[0];
    if (!first.textEdit)
      return null;
    let {range: range2, newText} = first.textEdit;
    let {character} = range2.start;
    if (newText.length < range2.end.character - character) {
      return null;
    }
    for (let i = 0; i < 10; i++) {
      let o = items[i];
      if (!o)
        break;
      if (!o.textEdit)
        return null;
      if (o.textEdit.range.start.character !== character)
        return null;
    }
    return byteIndex(line, character);
  }
  convertVimCompleteItem(item, shortcut, opt, prefix) {
    let {echodocSupport, detailMaxLength, invalidInsertCharacters} = this.completeConfig;
    let {detailField} = this;
    let hasAdditionalEdit = item.additionalTextEdits && item.additionalTextEdits.length > 0;
    let isSnippet = item.insertTextFormat === vscode_languageserver_protocol41.InsertTextFormat.Snippet || hasAdditionalEdit;
    let label = item.label.trim();
    let obj = {
      word: getWord(item, opt, invalidInsertCharacters),
      abbr: label,
      menu: `[${shortcut}]`,
      kind: completionKindString(item.kind, this.completionItemKindMap, this.completeConfig.defaultKindText),
      sortText: item.sortText || null,
      sourceScore: item["score"] || null,
      filterText: item.filterText || label,
      isSnippet,
      dup: item.data && item.data.dup == 0 ? 0 : 1
    };
    if (prefix) {
      if (!obj.filterText.startsWith(prefix)) {
        if (item.textEdit && item.textEdit.newText.startsWith(prefix)) {
          obj.filterText = item.textEdit.newText.split(/\n/)[0];
        } else {
          obj.filterText = `${prefix}${obj.filterText}`;
        }
      }
      if (!item.textEdit && !obj.word.startsWith(prefix)) {
        obj.word = `${prefix}${obj.word}`;
      }
    }
    if (item && item.detail && detailField != "preview") {
      let detail = item.detail.replace(/\n\s*/g, " ");
      if (byteLength(detail) < detailMaxLength) {
        if (detailField == "menu") {
          obj.menu = `${detail} ${obj.menu}`;
        } else if (detailField == "abbr") {
          obj.abbr = `${obj.abbr} - ${detail}`;
        }
        obj.detailShown = 1;
      }
    }
    if (item.documentation) {
      obj.info = typeof item.documentation == "string" ? item.documentation : item.documentation.value;
    } else {
      obj.info = "";
    }
    if (obj.word == "")
      obj.empty = 1;
    if (item.textEdit)
      obj.line = opt.line;
    if (item.kind == vscode_languageserver_protocol41.CompletionItemKind.Folder && !obj.abbr.endsWith("/")) {
      obj.abbr = obj.abbr + "/";
    }
    if (echodocSupport && item.kind >= 2 && item.kind <= 4) {
      let fields = [item.detail || "", obj.abbr, obj.word];
      for (let s of fields) {
        if (s.includes("(")) {
          obj.signature = s;
          break;
        }
      }
    }
    if (item.preselect)
      obj.preselect = true;
    item.data = item.data || {};
    if (item.data.optional)
      obj.abbr = obj.abbr + "?";
    return obj;
  }
};
var languages_default = new Languages();

// src/model/highligher.ts
var Highlighter = class {
  constructor(srcId = -1) {
    this.srcId = srcId;
    this.lines = [];
    this.highlights = [];
  }
  addLine(line, hlGroup) {
    if (line.includes("\n")) {
      for (let content of line.split(/\r?\n/)) {
        this.addLine(content, hlGroup);
      }
      return;
    }
    if (hlGroup) {
      this.highlights.push({
        line: this.lines.length,
        colStart: line.match(/^\s*/)[0].length,
        colEnd: byteLength(line),
        hlGroup
      });
    }
    if (line.includes("")) {
      let res = parseAnsiHighlights(line);
      for (let hl of res.highlights) {
        let {span, hlGroup: hlGroup2} = hl;
        if (span[0] != span[1]) {
          this.highlights.push({
            line: this.lines.length,
            colStart: span[0],
            colEnd: span[1],
            hlGroup: hlGroup2
          });
        }
      }
      this.lines.push(res.line);
    } else {
      this.lines.push(line);
    }
  }
  addLines(lines) {
    this.lines.push(...lines);
  }
  addText(text, hlGroup) {
    let {lines} = this;
    let pre = lines[lines.length - 1] || "";
    if (hlGroup) {
      let colStart = byteLength(pre);
      this.highlights.push({
        line: lines.length ? lines.length - 1 : 0,
        colStart,
        colEnd: colStart + byteLength(text),
        hlGroup
      });
    }
    if (lines.length) {
      lines[lines.length - 1] = `${pre}${text}`;
    } else {
      lines.push(text);
    }
  }
  get length() {
    return this.lines.length;
  }
  getline(line) {
    return this.lines[line] || "";
  }
  render(buffer4, start = 0, end = -1) {
    buffer4.setLines(this.lines, {start, end, strictIndexing: false}, true);
    for (let item of this.highlights) {
      buffer4.addHighlight({
        hlGroup: item.hlGroup,
        colStart: item.colStart,
        colEnd: item.colEnd == null ? -1 : item.colEnd,
        line: start + item.line,
        srcId: this.srcId
      }).logError();
    }
  }
};
var highligher_default = Highlighter;

// src/services.ts
var events14 = __toModule(require("events"));
var fs31 = __toModule(require("fs"));
var net3 = __toModule(require("net"));
var vscode_languageserver_protocol54 = __toModule(require_main3());

// src/language-client/index.ts
var child_process4 = __toModule(require("child_process"));
var fs29 = __toModule(require("fs"));
var path32 = __toModule(require("path"));
var vscode_languageserver_protocol53 = __toModule(require_main3());

// src/util/processes.ts
var cp = __toModule(require("child_process"));
var path29 = __toModule(require("path"));
var fs26 = __toModule(require("fs"));
var isWindows3 = process.platform === "win32";
var isMacintosh2 = process.platform === "darwin";
var isLinux2 = process.platform === "linux";
var pluginRoot2 = path29.dirname(__dirname);
function terminate(process2, cwd) {
  if (process2.killed)
    return;
  if (isWindows3) {
    try {
      let options = {
        stdio: ["pipe", "pipe", "ignore"]
      };
      if (cwd) {
        options.cwd = cwd;
      }
      cp.execFileSync("taskkill", ["/T", "/F", "/PID", process2.pid.toString()], options);
      return true;
    } catch (err) {
      return false;
    }
  } else if (isLinux2 || isMacintosh2) {
    try {
      let filepath = path29.join(pluginRoot2, "bin/terminateProcess.sh");
      if (!fs26.default.existsSync(filepath)) {
        console.error(`"${filepath}" not found`);
        return false;
      }
      let result = cp.spawnSync(filepath, [process2.pid.toString()]);
      return result.error ? false : true;
    } catch (err) {
      return false;
    }
  } else {
    process2.kill("SIGKILL");
    return true;
  }
}

// src/language-client/client.ts
var path30 = __toModule(require("path"));
var vscode_languageserver_protocol43 = __toModule(require_main3());

// src/language-client/progressPart.ts
var vscode_languageserver_protocol42 = __toModule(require_main3());
"use strict";
var logger43 = require_logger2()("language-client-progressPart");
var ProgressPart = class {
  constructor(client8, token, done) {
    this.client = client8;
    this.token = token;
    this.disposables = [];
    this._cancelled = false;
    this.statusBarItem = window_default.createStatusBarItem(99, {progress: true});
    this.disposables.push(client8.onProgress(vscode_languageserver_protocol42.WorkDoneProgress.type, this.token, (value) => {
      switch (value.kind) {
        case "begin":
          this.begin(value);
          break;
        case "report":
          this.report(value);
          break;
        case "end":
          this.done(value.message);
          done && done(this);
          break;
      }
    }));
  }
  begin(params) {
    if (typeof this.title === "string")
      return;
    this.title = params.title;
    this.report(params);
  }
  report(params) {
    let statusBarItem = this.statusBarItem;
    let parts = [];
    if (this.title)
      parts.push(this.title);
    if (typeof params.percentage == "number")
      parts.push(params.percentage.toFixed(0) + "%");
    if (params.message)
      parts.push(params.message);
    statusBarItem.text = parts.join(" ");
    statusBarItem.show();
  }
  cancel() {
    if (this._cancelled)
      return;
    this._cancelled = true;
    disposeAll(this.disposables);
  }
  done(message) {
    if (this._cancelled)
      return;
    const statusBarItem = this.statusBarItem;
    statusBarItem.text = `${this.title} ${message || "finished"}`;
    setTimeout(() => {
      statusBarItem.dispose();
    }, 300);
    this.cancel();
  }
};

// src/language-client/utils/async.ts
var Delayer = class {
  constructor(defaultDelay) {
    this.defaultDelay = defaultDelay;
    this.timeout = null;
    this.completionPromise = null;
    this.doResolve = null;
    this.task = null;
  }
  trigger(task2, delay = this.defaultDelay) {
    this.task = task2;
    this.cancelTimeout();
    if (!this.completionPromise) {
      this.completionPromise = new Promise((c, e) => {
        this.doResolve = c;
        this.doReject = e;
      }).then(() => {
        this.completionPromise = null;
        this.doResolve = null;
        const task3 = this.task;
        this.task = null;
        return task3();
      });
    }
    this.timeout = setTimeout(() => {
      this.timeout = null;
      this.doResolve(null);
    }, delay);
    return this.completionPromise;
  }
  isTriggered() {
    return this.timeout !== null;
  }
  cancel() {
    this.cancelTimeout();
    if (this.completionPromise) {
      this.doReject(new Error("Canceled"));
      this.completionPromise = null;
    }
  }
  cancelTimeout() {
    if (this.timeout !== null) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
  }
  dispose() {
    this.cancelTimeout();
  }
};

// src/language-client/utils/converter.ts
function asLanguageIds(documentSelector) {
  let res = documentSelector.map((filter) => {
    if (typeof filter == "string") {
      return filter;
    }
    return filter.language;
  });
  res = res.filter((s) => s != null);
  return res.length == 0 ? null : res;
}
function convertToTextDocumentItem(document3) {
  return {
    uri: document3.uri,
    languageId: document3.languageId,
    version: document3.version,
    text: document3.getText()
  };
}
function asCloseTextDocumentParams(document3) {
  return {
    textDocument: {
      uri: document3.uri
    }
  };
}
function asChangeTextDocumentParams(document3) {
  let result = {
    textDocument: {
      uri: document3.uri,
      version: document3.version
    },
    contentChanges: [{text: document3.getText()}]
  };
  return result;
}
function asWillSaveTextDocumentParams(event) {
  return {
    textDocument: asVersionedTextDocumentIdentifier(event.document),
    reason: event.reason
  };
}
function asVersionedTextDocumentIdentifier(textDocument) {
  return {
    uri: textDocument.uri,
    version: textDocument.version
  };
}
function asSaveTextDocumentParams(document3, includeText) {
  let result = {
    textDocument: asVersionedTextDocumentIdentifier(document3)
  };
  if (includeText) {
    result.text = document3.getText();
  }
  return result;
}
function asUri(resource) {
  return resource.toString();
}
function asCompletionParams(textDocument, position15, context) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position: position15,
    context: omit(context, ["option"])
  };
}
function asTextDocumentPositionParams(textDocument, position15) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position: position15
  };
}
function asSignatureHelpParams(textDocument, position15, context) {
  return {
    textDocument: asTextDocumentIdentifier(textDocument),
    position: position15,
    context
  };
}
function asTextDocumentIdentifier(textDocument) {
  return {
    uri: textDocument.uri
  };
}
function asReferenceParams(textDocument, position15, options) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position: position15,
    context: {includeDeclaration: options.includeDeclaration}
  };
}
function asDocumentSymbolParams(textDocument) {
  return {
    textDocument: {
      uri: textDocument.uri
    }
  };
}
function asCodeLensParams(textDocument) {
  return {
    textDocument: {
      uri: textDocument.uri
    }
  };
}

// src/language-client/utils/uuid.ts
function generateUuid() {
  return v4_default();
}

// src/language-client/client.ts
var logger44 = require_logger2()("language-client-client");
var ConsoleLogger = class {
  error(message) {
    logger44.error(message);
  }
  warn(message) {
    logger44.warn(message);
  }
  info(message) {
    logger44.info(message);
  }
  log(message) {
    logger44.log(message);
  }
};
var NullLogger = class {
  error(_message) {
  }
  warn(_message) {
  }
  info(_message) {
  }
  log(_message) {
  }
};
function createConnection(input, output, errorHandler, closeHandler) {
  let logger93 = new ConsoleLogger();
  let connection = vscode_languageserver_protocol43.createProtocolConnection(input, output, logger93);
  connection.onError((data) => {
    errorHandler(data[0], data[1], data[2]);
  });
  connection.onClose(closeHandler);
  let result = {
    listen: () => connection.listen(),
    sendRequest: (type, ...params) => connection.sendRequest(string(type) ? type : type.method, ...params),
    onRequest: (type, handler2) => connection.onRequest(string(type) ? type : type.method, handler2),
    sendNotification: (type, params) => connection.sendNotification(string(type) ? type : type.method, params),
    onNotification: (type, handler2) => connection.onNotification(string(type) ? type : type.method, handler2),
    onProgress: connection.onProgress,
    sendProgress: connection.sendProgress,
    trace: (value, tracer, sendNotificationOrTraceOptions) => {
      const defaultTraceOptions = {
        sendNotification: false,
        traceFormat: vscode_languageserver_protocol43.TraceFormat.Text
      };
      if (sendNotificationOrTraceOptions === void 0) {
        connection.trace(value, tracer, defaultTraceOptions);
      } else if (boolean(sendNotificationOrTraceOptions)) {
        connection.trace(value, tracer, sendNotificationOrTraceOptions);
      } else {
        connection.trace(value, tracer, sendNotificationOrTraceOptions);
      }
    },
    initialize: (params) => connection.sendRequest(vscode_languageserver_protocol43.InitializeRequest.type, params),
    shutdown: () => connection.sendRequest(vscode_languageserver_protocol43.ShutdownRequest.type, void 0),
    exit: () => connection.sendNotification(vscode_languageserver_protocol43.ExitNotification.type),
    onLogMessage: (handler2) => connection.onNotification(vscode_languageserver_protocol43.LogMessageNotification.type, handler2),
    onShowMessage: (handler2) => connection.onNotification(vscode_languageserver_protocol43.ShowMessageNotification.type, handler2),
    onTelemetry: (handler2) => connection.onNotification(vscode_languageserver_protocol43.TelemetryEventNotification.type, handler2),
    didChangeConfiguration: (params) => connection.sendNotification(vscode_languageserver_protocol43.DidChangeConfigurationNotification.type, params),
    didChangeWatchedFiles: (params) => connection.sendNotification(vscode_languageserver_protocol43.DidChangeWatchedFilesNotification.type, params),
    didOpenTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol43.DidOpenTextDocumentNotification.type, params),
    didChangeTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol43.DidChangeTextDocumentNotification.type, params),
    didCloseTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol43.DidCloseTextDocumentNotification.type, params),
    didSaveTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol43.DidSaveTextDocumentNotification.type, params),
    onDiagnostics: (handler2) => connection.onNotification(vscode_languageserver_protocol43.PublishDiagnosticsNotification.type, handler2),
    dispose: () => connection.dispose()
  };
  return result;
}
var ErrorAction;
(function(ErrorAction2) {
  ErrorAction2[ErrorAction2["Continue"] = 1] = "Continue";
  ErrorAction2[ErrorAction2["Shutdown"] = 2] = "Shutdown";
})(ErrorAction || (ErrorAction = {}));
var CloseAction;
(function(CloseAction2) {
  CloseAction2[CloseAction2["DoNotRestart"] = 1] = "DoNotRestart";
  CloseAction2[CloseAction2["Restart"] = 2] = "Restart";
})(CloseAction || (CloseAction = {}));
var DefaultErrorHandler = class {
  constructor(name2) {
    this.name = name2;
    this.restarts = [];
  }
  error(_error, _message, count) {
    if (count && count <= 3) {
      return 1;
    }
    return 2;
  }
  closed() {
    this.restarts.push(Date.now());
    if (this.restarts.length < 5) {
      return 2;
    } else {
      let diff3 = this.restarts[this.restarts.length - 1] - this.restarts[0];
      if (diff3 <= 3 * 60 * 1e3) {
        window_default.showMessage(`The "${this.name}" server crashed 5 times in the last 3 minutes. The server will not be restarted.`, "error");
        return 1;
      } else {
        this.restarts.shift();
        return 2;
      }
    }
  }
};
var RevealOutputChannelOn;
(function(RevealOutputChannelOn2) {
  RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
  RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
  RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
  RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
})(RevealOutputChannelOn || (RevealOutputChannelOn = {}));
var State2;
(function(State3) {
  State3[State3["Stopped"] = 1] = "Stopped";
  State3[State3["Running"] = 2] = "Running";
  State3[State3["Starting"] = 3] = "Starting";
})(State2 || (State2 = {}));
var ClientState;
(function(ClientState2) {
  ClientState2[ClientState2["Initial"] = 0] = "Initial";
  ClientState2[ClientState2["Starting"] = 1] = "Starting";
  ClientState2[ClientState2["StartFailed"] = 2] = "StartFailed";
  ClientState2[ClientState2["Running"] = 3] = "Running";
  ClientState2[ClientState2["Stopping"] = 4] = "Stopping";
  ClientState2[ClientState2["Stopped"] = 5] = "Stopped";
})(ClientState || (ClientState = {}));
var SupportedSymbolKinds = [
  vscode_languageserver_protocol43.SymbolKind.File,
  vscode_languageserver_protocol43.SymbolKind.Module,
  vscode_languageserver_protocol43.SymbolKind.Namespace,
  vscode_languageserver_protocol43.SymbolKind.Package,
  vscode_languageserver_protocol43.SymbolKind.Class,
  vscode_languageserver_protocol43.SymbolKind.Method,
  vscode_languageserver_protocol43.SymbolKind.Property,
  vscode_languageserver_protocol43.SymbolKind.Field,
  vscode_languageserver_protocol43.SymbolKind.Constructor,
  vscode_languageserver_protocol43.SymbolKind.Enum,
  vscode_languageserver_protocol43.SymbolKind.Interface,
  vscode_languageserver_protocol43.SymbolKind.Function,
  vscode_languageserver_protocol43.SymbolKind.Variable,
  vscode_languageserver_protocol43.SymbolKind.Constant,
  vscode_languageserver_protocol43.SymbolKind.String,
  vscode_languageserver_protocol43.SymbolKind.Number,
  vscode_languageserver_protocol43.SymbolKind.Boolean,
  vscode_languageserver_protocol43.SymbolKind.Array,
  vscode_languageserver_protocol43.SymbolKind.Object,
  vscode_languageserver_protocol43.SymbolKind.Key,
  vscode_languageserver_protocol43.SymbolKind.Null,
  vscode_languageserver_protocol43.SymbolKind.EnumMember,
  vscode_languageserver_protocol43.SymbolKind.Struct,
  vscode_languageserver_protocol43.SymbolKind.Event,
  vscode_languageserver_protocol43.SymbolKind.Operator,
  vscode_languageserver_protocol43.SymbolKind.TypeParameter
];
var SupportedCompletionItemKinds = [
  vscode_languageserver_protocol43.CompletionItemKind.Text,
  vscode_languageserver_protocol43.CompletionItemKind.Method,
  vscode_languageserver_protocol43.CompletionItemKind.Function,
  vscode_languageserver_protocol43.CompletionItemKind.Constructor,
  vscode_languageserver_protocol43.CompletionItemKind.Field,
  vscode_languageserver_protocol43.CompletionItemKind.Variable,
  vscode_languageserver_protocol43.CompletionItemKind.Class,
  vscode_languageserver_protocol43.CompletionItemKind.Interface,
  vscode_languageserver_protocol43.CompletionItemKind.Module,
  vscode_languageserver_protocol43.CompletionItemKind.Property,
  vscode_languageserver_protocol43.CompletionItemKind.Unit,
  vscode_languageserver_protocol43.CompletionItemKind.Value,
  vscode_languageserver_protocol43.CompletionItemKind.Enum,
  vscode_languageserver_protocol43.CompletionItemKind.Keyword,
  vscode_languageserver_protocol43.CompletionItemKind.Snippet,
  vscode_languageserver_protocol43.CompletionItemKind.Color,
  vscode_languageserver_protocol43.CompletionItemKind.File,
  vscode_languageserver_protocol43.CompletionItemKind.Reference,
  vscode_languageserver_protocol43.CompletionItemKind.Folder,
  vscode_languageserver_protocol43.CompletionItemKind.EnumMember,
  vscode_languageserver_protocol43.CompletionItemKind.Constant,
  vscode_languageserver_protocol43.CompletionItemKind.Struct,
  vscode_languageserver_protocol43.CompletionItemKind.Event,
  vscode_languageserver_protocol43.CompletionItemKind.Operator,
  vscode_languageserver_protocol43.CompletionItemKind.TypeParameter
];
var SupportedSymbolTags = [
  vscode_languageserver_protocol43.SymbolTag.Deprecated
];
function ensure(target, key) {
  if (target[key] == null) {
    target[key] = {};
  }
  return target[key];
}
var DynamicFeature;
(function(DynamicFeature3) {
  function is6(value) {
    let candidate = value;
    return candidate && func(candidate.register) && func(candidate.unregister) && func(candidate.dispose) && candidate.messages !== void 0;
  }
  DynamicFeature3.is = is6;
})(DynamicFeature || (DynamicFeature = {}));
var DocumentNotifiactions = class {
  constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {
    this._client = _client;
    this._event = _event;
    this._type = _type;
    this._middleware = _middleware;
    this._createParams = _createParams;
    this._selectorFilter = _selectorFilter;
    this._selectors = new Map();
  }
  static textDocumentFilter(selectors, textDocument) {
    for (const selector of selectors) {
      if (workspace_default.match(selector, textDocument) > 0) {
        return true;
      }
    }
    return false;
  }
  register(_message, data) {
    if (!data.registerOptions.documentSelector) {
      return;
    }
    if (!this._listener) {
      this._listener = this._event(this.callback, this);
    }
    this._selectors.set(data.id, data.registerOptions.documentSelector);
  }
  callback(data) {
    if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
      if (this._middleware) {
        this._middleware(data, (data2) => this._client.sendNotification(this._type, this._createParams(data2)));
      } else {
        this._client.sendNotification(this._type, this._createParams(data));
      }
      this.notificationSent(data);
    }
  }
  notificationSent(_data) {
  }
  unregister(id) {
    this._selectors.delete(id);
    if (this._selectors.size === 0 && this._listener) {
      this._listener.dispose();
      this._listener = void 0;
    }
  }
  dispose() {
    this._selectors.clear();
    if (this._listener) {
      this._listener.dispose();
      this._listener = void 0;
    }
  }
  getProvider(document3) {
    for (const selector of this._selectors.values()) {
      if (workspace_default.match(selector, document3)) {
        return {
          send: (data) => {
            this.callback(data);
          }
        };
      }
    }
    throw new Error(`No provider available for the given text document`);
  }
};
var DidOpenTextDocumentFeature = class extends DocumentNotifiactions {
  constructor(client8, _syncedDocuments) {
    super(client8, workspace_default.onDidOpenTextDocument, vscode_languageserver_protocol43.DidOpenTextDocumentNotification.type, client8.clientOptions.middleware.didOpen, (textDocument) => {
      return {textDocument: convertToTextDocumentItem(textDocument)};
    }, DocumentNotifiactions.textDocumentFilter);
    this._syncedDocuments = _syncedDocuments;
  }
  get messages() {
    return vscode_languageserver_protocol43.DidOpenTextDocumentNotification.type;
  }
  fillClientCapabilities(capabilities) {
    ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
    if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
      this.register(this.messages, {
        id: generateUuid(),
        registerOptions: {documentSelector}
      });
    }
  }
  register(message, data) {
    super.register(message, data);
    if (!data.registerOptions.documentSelector) {
      return;
    }
    let documentSelector = data.registerOptions.documentSelector;
    workspace_default.textDocuments.forEach((textDocument) => {
      let uri = textDocument.uri.toString();
      if (this._syncedDocuments.has(uri)) {
        return;
      }
      if (workspace_default.match(documentSelector, textDocument) > 0) {
        let middleware = this._client.clientOptions.middleware;
        let didOpen = (textDocument2) => {
          this._client.sendNotification(this._type, this._createParams(textDocument2));
        };
        if (middleware.didOpen) {
          middleware.didOpen(textDocument, didOpen);
        } else {
          didOpen(textDocument);
        }
        this._syncedDocuments.set(uri, textDocument);
      }
    });
  }
  notificationSent(textDocument) {
    super.notificationSent(textDocument);
    this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
  }
};
var DidCloseTextDocumentFeature = class extends DocumentNotifiactions {
  constructor(client8, _syncedDocuments) {
    super(client8, workspace_default.onDidCloseTextDocument, vscode_languageserver_protocol43.DidCloseTextDocumentNotification.type, client8.clientOptions.middleware.didClose, (textDocument) => asCloseTextDocumentParams(textDocument), DocumentNotifiactions.textDocumentFilter);
    this._syncedDocuments = _syncedDocuments;
  }
  get messages() {
    return vscode_languageserver_protocol43.DidCloseTextDocumentNotification.type;
  }
  fillClientCapabilities(capabilities) {
    ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
    if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
      this.register(this.messages, {
        id: generateUuid(),
        registerOptions: {documentSelector}
      });
    }
  }
  notificationSent(textDocument) {
    super.notificationSent(textDocument);
    this._syncedDocuments.delete(textDocument.uri.toString());
  }
  unregister(id) {
    let selector = this._selectors.get(id);
    super.unregister(id);
    let selectors = this._selectors.values();
    this._syncedDocuments.forEach((textDocument) => {
      if (workspace_default.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument)) {
        let middleware = this._client.clientOptions.middleware;
        let didClose = (textDocument2) => {
          this._client.sendNotification(this._type, this._createParams(textDocument2));
        };
        this._syncedDocuments.delete(textDocument.uri.toString());
        if (middleware.didClose) {
          middleware.didClose(textDocument, didClose);
        } else {
          didClose(textDocument);
        }
      }
    });
  }
};
var DidChangeTextDocumentFeature = class {
  constructor(_client) {
    this._client = _client;
    this._changeData = new Map();
  }
  get messages() {
    return vscode_languageserver_protocol43.DidChangeTextDocumentNotification.type;
  }
  fillClientCapabilities(capabilities) {
    ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
    if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol43.TextDocumentSyncKind.None) {
      this.register(this.messages, {
        id: generateUuid(),
        registerOptions: Object.assign({}, {documentSelector}, {syncKind: textDocumentSyncOptions.change})
      });
    }
  }
  register(_message, data) {
    if (!data.registerOptions.documentSelector) {
      return;
    }
    if (!this._listener) {
      this._listener = workspace_default.onDidChangeTextDocument(this.callback, this);
    }
    this._changeData.set(data.id, {
      documentSelector: data.registerOptions.documentSelector,
      syncKind: data.registerOptions.syncKind
    });
  }
  callback(event) {
    if (event.contentChanges.length === 0) {
      return;
    }
    let doc = workspace_default.getDocument(event.textDocument.uri);
    if (!doc)
      return;
    let {textDocument} = doc;
    for (const changeData of this._changeData.values()) {
      if (workspace_default.match(changeData.documentSelector, textDocument) > 0) {
        let middleware = this._client.clientOptions.middleware;
        if (changeData.syncKind === vscode_languageserver_protocol43.TextDocumentSyncKind.Incremental) {
          if (middleware.didChange) {
            middleware.didChange(event, () => this._client.sendNotification(vscode_languageserver_protocol43.DidChangeTextDocumentNotification.type, omit(event, ["bufnr", "original"])));
          } else {
            this._client.sendNotification(vscode_languageserver_protocol43.DidChangeTextDocumentNotification.type, omit(event, ["bufnr", "original"]));
          }
        } else if (changeData.syncKind === vscode_languageserver_protocol43.TextDocumentSyncKind.Full) {
          let didChange = (event2) => {
            let {textDocument: textDocument2} = workspace_default.getDocument(event2.textDocument.uri);
            this._client.sendNotification(vscode_languageserver_protocol43.DidChangeTextDocumentNotification.type, asChangeTextDocumentParams(textDocument2));
          };
          if (middleware.didChange) {
            middleware.didChange(event, didChange);
          } else {
            didChange(event);
          }
        }
      }
    }
  }
  unregister(id) {
    this._changeData.delete(id);
    if (this._changeData.size === 0 && this._listener) {
      this._listener.dispose();
      this._listener = void 0;
    }
  }
  dispose() {
    this._changeData.clear();
    if (this._listener) {
      this._listener.dispose();
      this._listener = void 0;
    }
  }
  getProvider(document3) {
    for (const changeData of this._changeData.values()) {
      if (workspace_default.match(changeData.documentSelector, document3)) {
        return {
          send: (event) => {
            this.callback(event);
          }
        };
      }
    }
    throw new Error(`No provider available for the given text document`);
  }
};
var WillSaveFeature = class extends DocumentNotifiactions {
  constructor(client8) {
    super(client8, workspace_default.onWillSaveTextDocument, vscode_languageserver_protocol43.WillSaveTextDocumentNotification.type, client8.clientOptions.middleware.willSave, (willSaveEvent) => asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifiactions.textDocumentFilter(selectors, willSaveEvent.document));
  }
  get messages() {
    return vscode_languageserver_protocol43.WillSaveTextDocumentNotification.type;
  }
  fillClientCapabilities(capabilities) {
    let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
    value.willSave = true;
  }
  initialize(capabilities, documentSelector) {
    let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
    if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
      this.register(this.messages, {
        id: generateUuid(),
        registerOptions: {documentSelector}
      });
    }
  }
};
var WillSaveWaitUntilFeature = class {
  constructor(_client) {
    this._client = _client;
    this._selectors = new Map();
  }
  get messages() {
    return vscode_languageserver_protocol43.WillSaveTextDocumentWaitUntilRequest.type;
  }
  fillClientCapabilities(capabilities) {
    let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
    value.willSaveWaitUntil = true;
  }
  initialize(capabilities, documentSelector) {
    let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
    if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
      this.register(this.messages, {
        id: generateUuid(),
        registerOptions: {documentSelector}
      });
    }
  }
  register(_message, data) {
    if (!data.registerOptions.documentSelector) {
      return;
    }
    if (!this._listener) {
      this._listener = workspace_default.onWillSaveTextDocument(this.callback, this);
    }
    this._selectors.set(data.id, data.registerOptions.documentSelector);
  }
  callback(event) {
    if (DocumentNotifiactions.textDocumentFilter(this._selectors.values(), event.document)) {
      let middleware = this._client.clientOptions.middleware;
      let willSaveWaitUntil = (event2) => {
        return this._client.sendRequest(vscode_languageserver_protocol43.WillSaveTextDocumentWaitUntilRequest.type, asWillSaveTextDocumentParams(event2)).then((edits) => {
          return edits ? edits : [];
        }, (e) => {
          window_default.showMessage(`Error on willSaveWaitUntil: ${e}`, "error");
          logger44.error(e);
          return [];
        });
      };
      event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
    }
  }
  unregister(id) {
    this._selectors.delete(id);
    if (this._selectors.size === 0 && this._listener) {
      this._listener.dispose();
      this._listener = void 0;
    }
  }
  dispose() {
    this._selectors.clear();
    if (this._listener) {
      this._listener.dispose();
      this._listener = void 0;
    }
  }
};
var DidSaveTextDocumentFeature = class extends DocumentNotifiactions {
  constructor(client8) {
    super(client8, workspace_default.onDidSaveTextDocument, vscode_languageserver_protocol43.DidSaveTextDocumentNotification.type, client8.clientOptions.middleware.didSave, (textDocument) => asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifiactions.textDocumentFilter);
  }
  get messages() {
    return vscode_languageserver_protocol43.DidSaveTextDocumentNotification.type;
  }
  fillClientCapabilities(capabilities) {
    ensure(ensure(capabilities, "textDocument"), "synchronization").didSave = true;
  }
  initialize(capabilities, documentSelector) {
    let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
    if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
      this.register(this.messages, {
        id: generateUuid(),
        registerOptions: Object.assign({}, {documentSelector}, {includeText: !!textDocumentSyncOptions.save.includeText})
      });
    }
  }
  register(method, data) {
    this._includeText = !!data.registerOptions.includeText;
    super.register(method, data);
  }
};
var FileSystemWatcherFeature = class {
  constructor(_client, _notifyFileEvent) {
    this._notifyFileEvent = _notifyFileEvent;
    this._watchers = new Map();
  }
  get messages() {
    return vscode_languageserver_protocol43.DidChangeWatchedFilesNotification.type;
  }
  fillClientCapabilities(capabilities) {
    ensure(ensure(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
  }
  initialize(_capabilities, _documentSelector) {
  }
  register(_method, data) {
    if (!Array.isArray(data.registerOptions.watchers)) {
      return;
    }
    let disposables = [];
    for (let watcher of data.registerOptions.watchers) {
      if (!string(watcher.globPattern)) {
        continue;
      }
      let watchCreate = true, watchChange = true, watchDelete = true;
      if (watcher.kind != null) {
        watchCreate = (watcher.kind & vscode_languageserver_protocol43.WatchKind.Create) !== 0;
        watchChange = (watcher.kind & vscode_languageserver_protocol43.WatchKind.Change) != 0;
        watchDelete = (watcher.kind & vscode_languageserver_protocol43.WatchKind.Delete) != 0;
      }
      let fileSystemWatcher2 = workspace_default.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);
      this.hookListeners(fileSystemWatcher2, watchCreate, watchChange, watchDelete, disposables);
      disposables.push(fileSystemWatcher2);
    }
    this._watchers.set(data.id, disposables);
  }
  registerRaw(id, fileSystemWatchers) {
    let disposables = [];
    for (let fileSystemWatcher2 of fileSystemWatchers) {
      disposables.push(fileSystemWatcher2);
      this.hookListeners(fileSystemWatcher2, true, true, true, disposables);
    }
    this._watchers.set(id, disposables);
  }
  hookListeners(fileSystemWatcher2, watchCreate, watchChange, watchDelete, listeners) {
    if (watchCreate) {
      fileSystemWatcher2.onDidCreate((resource) => this._notifyFileEvent({
        uri: asUri(resource),
        type: vscode_languageserver_protocol43.FileChangeType.Created
      }), null, listeners);
    }
    if (watchChange) {
      fileSystemWatcher2.onDidChange((resource) => this._notifyFileEvent({
        uri: asUri(resource),
        type: vscode_languageserver_protocol43.FileChangeType.Changed
      }), null, listeners);
    }
    if (watchDelete) {
      fileSystemWatcher2.onDidDelete((resource) => this._notifyFileEvent({
        uri: asUri(resource),
        type: vscode_languageserver_protocol43.FileChangeType.Deleted
      }), null, listeners);
    }
  }
  unregister(id) {
    let disposables = this._watchers.get(id);
    if (disposables) {
      for (let disposable of disposables) {
        disposable.dispose();
      }
    }
  }
  dispose() {
    this._watchers.forEach((disposables) => {
      for (let disposable of disposables) {
        disposable.dispose();
      }
    });
    this._watchers.clear();
  }
};
var TextDocumentFeature = class {
  constructor(_client, _message) {
    this._client = _client;
    this._message = _message;
    this._registrations = new Map();
  }
  get messages() {
    return this._message;
  }
  register(message, data) {
    if (message.method !== this.messages.method) {
      throw new Error(`Register called on wrong feature. Requested ${message.method} but reached feature ${this.messages.method}`);
    }
    if (!data.registerOptions.documentSelector) {
      return;
    }
    let registration = this.registerLanguageProvider(data.registerOptions);
    this._registrations.set(data.id, {disposable: registration[0], data, provider: registration[1]});
  }
  unregister(id) {
    let registration = this._registrations.get(id);
    if (registration) {
      registration.disposable.dispose();
    }
  }
  dispose() {
    this._registrations.forEach((value) => {
      value.disposable.dispose();
    });
    this._registrations.clear();
  }
  getRegistration(documentSelector, capability) {
    if (!capability) {
      return [void 0, void 0];
    } else if (vscode_languageserver_protocol43.TextDocumentRegistrationOptions.is(capability)) {
      const id = vscode_languageserver_protocol43.StaticRegistrationOptions.hasId(capability) ? capability.id : generateUuid();
      const selector = capability.documentSelector || documentSelector;
      if (selector) {
        return [id, Object.assign({}, capability, {documentSelector: selector})];
      }
    } else if (boolean(capability) && capability === true || vscode_languageserver_protocol43.WorkDoneProgressOptions.is(capability)) {
      if (!documentSelector) {
        return [void 0, void 0];
      }
      let options = boolean(capability) && capability === true ? {documentSelector} : Object.assign({}, capability, {documentSelector});
      return [generateUuid(), options];
    }
    return [void 0, void 0];
  }
  getRegistrationOptions(documentSelector, capability) {
    if (!documentSelector || !capability) {
      return void 0;
    }
    return boolean(capability) && capability === true ? {documentSelector} : Object.assign({}, capability, {documentSelector});
  }
  getProvider(textDocument) {
    for (const registration of this._registrations.values()) {
      let selector = registration.data.registerOptions.documentSelector;
      if (selector !== null && workspace_default.match(selector, textDocument) > 0) {
        return registration.provider;
      }
    }
    throw new Error(`The feature has no registration for the provided text document ${textDocument.uri.toString()}`);
  }
};
var WorkspaceFeature = class {
  constructor(_client, _message) {
    this._client = _client;
    this._message = _message;
    this._registrations = new Map();
  }
  get messages() {
    return this._message;
  }
  register(message, data) {
    if (message.method !== this.messages.method) {
      throw new Error(`Register called on wrong feature. Requested ${message.method} but reached feature ${this.messages.method}`);
    }
    const registration = this.registerLanguageProvider(data.registerOptions);
    this._registrations.set(data.id, registration);
  }
  unregister(id) {
    const registration = this._registrations.get(id);
    if (registration)
      registration.dispose();
  }
  dispose() {
    this._registrations.forEach((value) => {
      value.dispose();
    });
    this._registrations.clear();
  }
};
var CompletionItemFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.CompletionRequest.type);
  }
  fillClientCapabilities(capabilites) {
    let snippetSupport = this._client.clientOptions.disableSnippetCompletion !== true;
    let completion3 = ensure(ensure(capabilites, "textDocument"), "completion");
    completion3.dynamicRegistration = true;
    completion3.contextSupport = true;
    completion3.completionItem = {
      snippetSupport,
      commitCharactersSupport: true,
      documentationFormat: this._client.supporedMarkupKind,
      deprecatedSupport: true,
      preselectSupport: true,
      tagSupport: {valueSet: [vscode_languageserver_protocol43.CompletionItemTag.Deprecated]}
    };
    completion3.completionItemKind = {valueSet: SupportedCompletionItemKinds};
  }
  initialize(capabilities, documentSelector) {
    this.index = 0;
    const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    let triggerCharacters = options.triggerCharacters || [];
    let allCommitCharacters = options.allCommitCharacters || [];
    let priority = options.priority;
    this.index = this.index + 1;
    const provider = {
      provideCompletionItems: (document3, position15, token, context) => {
        const client8 = this._client;
        const middleware = this._client.clientOptions.middleware;
        const provideCompletionItems = (document4, position16, context2, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.CompletionRequest.type, asCompletionParams(document4, position16, context2), token2).then((result) => result, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.CompletionRequest.type, error);
            return Promise.resolve([]);
          });
        };
        return middleware.provideCompletionItem ? middleware.provideCompletionItem(document3, position15, context, token, provideCompletionItems) : provideCompletionItems(document3, position15, context, token);
      },
      resolveCompletionItem: options.resolveProvider ? (item, token) => {
        const client8 = this._client;
        const middleware = this._client.clientOptions.middleware;
        const resolveCompletionItem = (item2, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.CompletionResolveRequest.type, item2, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.CompletionResolveRequest.type, error);
            return Promise.resolve(item2);
          });
        };
        return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
      } : void 0
    };
    const languageIds = asLanguageIds(options.documentSelector);
    const disposable = languages_default.registerCompletionItemProvider(this._client.id + "-" + this.index, "LS", languageIds, provider, triggerCharacters, priority, allCommitCharacters);
    return [disposable, provider];
  }
};
var HoverFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.HoverRequest.type);
  }
  fillClientCapabilities(capabilites) {
    const hoverCapability = ensure(ensure(capabilites, "textDocument"), "hover");
    hoverCapability.dynamicRegistration = true;
    hoverCapability.contentFormat = this._client.supporedMarkupKind;
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideHover: (document3, position15, token) => {
        const client8 = this._client;
        const provideHover = (document4, position16, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.HoverRequest.type, asTextDocumentPositionParams(document4, position16), token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.HoverRequest.type, error);
            return Promise.resolve(null);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideHover ? middleware.provideHover(document3, position15, token, provideHover) : provideHover(document3, position15, token);
      }
    };
    return [languages_default.registerHoverProvider(options.documentSelector, provider), provider];
  }
};
var SignatureHelpFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.SignatureHelpRequest.type);
  }
  fillClientCapabilities(capabilites) {
    let config = ensure(ensure(capabilites, "textDocument"), "signatureHelp");
    config.dynamicRegistration = true;
    config.contextSupport = true;
    config.signatureInformation = {
      documentationFormat: this._client.supporedMarkupKind,
      activeParameterSupport: true,
      parameterInformation: {
        labelOffsetSupport: true
      }
    };
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideSignatureHelp: (document3, position15, token, context) => {
        const client8 = this._client;
        const providerSignatureHelp = (document4, position16, context2, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.SignatureHelpRequest.type, asSignatureHelpParams(document4, position16, context2), token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.SignatureHelpRequest.type, error);
            return Promise.resolve(null);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document3, position15, context, token, providerSignatureHelp) : providerSignatureHelp(document3, position15, context, token);
      }
    };
    const triggerCharacters = options.triggerCharacters || [];
    const disposable = languages_default.registerSignatureHelpProvider(options.documentSelector, provider, triggerCharacters);
    return [disposable, provider];
  }
};
var DefinitionFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.DefinitionRequest.type);
  }
  fillClientCapabilities(capabilites) {
    let definitionSupport = ensure(ensure(capabilites, "textDocument"), "definition");
    definitionSupport.dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideDefinition: (document3, position15, token) => {
        const client8 = this._client;
        const provideDefinition = (document4, position16, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.DefinitionRequest.type, asTextDocumentPositionParams(document4, position16), token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.DefinitionRequest.type, error);
            return Promise.resolve(null);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideDefinition ? middleware.provideDefinition(document3, position15, token, provideDefinition) : provideDefinition(document3, position15, token);
      }
    };
    return [languages_default.registerDefinitionProvider(options.documentSelector, provider), provider];
  }
};
var ReferencesFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.ReferencesRequest.type);
  }
  fillClientCapabilities(capabilites) {
    ensure(ensure(capabilites, "textDocument"), "references").dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideReferences: (document3, position15, options2, token) => {
        const client8 = this._client;
        const _providerReferences = (document4, position16, options3, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.ReferencesRequest.type, asReferenceParams(document4, position16, options3), token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.ReferencesRequest.type, error);
            return Promise.resolve([]);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideReferences ? middleware.provideReferences(document3, position15, options2, token, _providerReferences) : _providerReferences(document3, position15, options2, token);
      }
    };
    return [languages_default.registerReferencesProvider(options.documentSelector, provider), provider];
  }
};
var DocumentHighlightFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.DocumentHighlightRequest.type);
  }
  fillClientCapabilities(capabilites) {
    ensure(ensure(capabilites, "textDocument"), "documentHighlight").dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideDocumentHighlights: (document3, position15, token) => {
        const client8 = this._client;
        const _provideDocumentHighlights = (document4, position16, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.DocumentHighlightRequest.type, asTextDocumentPositionParams(document4, position16), token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.DocumentHighlightRequest.type, error);
            return Promise.resolve([]);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document3, position15, token, _provideDocumentHighlights) : _provideDocumentHighlights(document3, position15, token);
      }
    };
    return [languages_default.registerDocumentHighlightProvider(options.documentSelector, provider), provider];
  }
};
var DocumentSymbolFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.DocumentSymbolRequest.type);
  }
  fillClientCapabilities(capabilites) {
    let symbolCapabilities = ensure(ensure(capabilites, "textDocument"), "documentSymbol");
    symbolCapabilities.dynamicRegistration = true;
    symbolCapabilities.symbolKind = {
      valueSet: SupportedSymbolKinds
    };
    symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
    symbolCapabilities.tagSupport = {
      valueSet: SupportedSymbolTags
    };
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideDocumentSymbols: (document3, token) => {
        const client8 = this._client;
        const _provideDocumentSymbols = (document4, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.DocumentSymbolRequest.type, asDocumentSymbolParams(document4), token2).then((data) => {
            if (data === null) {
              return void 0;
            }
            if (data.length === 0) {
              return [];
            } else {
              let element = data[0];
              if (vscode_languageserver_protocol43.DocumentSymbol.is(element)) {
                return data;
              } else {
                return data;
              }
            }
          }, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.DocumentSymbolRequest.type, error);
            return Promise.resolve([]);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document3, token, _provideDocumentSymbols) : _provideDocumentSymbols(document3, token);
      }
    };
    return [languages_default.registerDocumentSymbolProvider(options.documentSelector, provider), provider];
  }
};
var WorkspaceSymbolFeature = class extends WorkspaceFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.WorkspaceSymbolRequest.type);
  }
  fillClientCapabilities(capabilites) {
    let symbolCapabilities = ensure(ensure(capabilites, "workspace"), "symbol");
    symbolCapabilities.dynamicRegistration = true;
    symbolCapabilities.symbolKind = {
      valueSet: SupportedSymbolKinds
    };
    symbolCapabilities.tagSupport = {
      valueSet: SupportedSymbolTags
    };
  }
  initialize(capabilities) {
    if (!capabilities.workspaceSymbolProvider) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: capabilities.workspaceSymbolProvider === true ? {workDoneProgress: false} : capabilities.workspaceSymbolProvider
    });
  }
  registerLanguageProvider(_options) {
    const provider = {
      provideWorkspaceSymbols: (query, token) => {
        const client8 = this._client;
        const provideWorkspaceSymbols = (query2, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.WorkspaceSymbolRequest.type, {query: query2}, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.WorkspaceSymbolRequest.type, error);
            return Promise.resolve([]);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
      }
    };
    return languages_default.registerWorkspaceSymbolProvider(provider);
  }
};
var CodeActionFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.CodeActionRequest.type);
  }
  fillClientCapabilities(capabilites) {
    const cap = ensure(ensure(capabilites, "textDocument"), "codeAction");
    cap.dynamicRegistration = true;
    cap.isPreferredSupport = true;
    cap.codeActionLiteralSupport = {
      codeActionKind: {
        valueSet: [
          vscode_languageserver_protocol43.CodeActionKind.Empty,
          vscode_languageserver_protocol43.CodeActionKind.QuickFix,
          vscode_languageserver_protocol43.CodeActionKind.Refactor,
          vscode_languageserver_protocol43.CodeActionKind.RefactorExtract,
          vscode_languageserver_protocol43.CodeActionKind.RefactorInline,
          vscode_languageserver_protocol43.CodeActionKind.RefactorRewrite,
          vscode_languageserver_protocol43.CodeActionKind.Source,
          vscode_languageserver_protocol43.CodeActionKind.SourceOrganizeImports
        ]
      }
    };
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideCodeActions: (document3, range2, context, token) => {
        const client8 = this._client;
        const _provideCodeActions = (document4, range3, context2, token2) => {
          const params = {
            textDocument: {
              uri: document4.uri
            },
            range: range3,
            context: context2
          };
          return client8.sendRequest(vscode_languageserver_protocol43.CodeActionRequest.type, params, token2).then((values) => {
            if (values === null) {
              return void 0;
            }
            return values;
          }, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.CodeActionRequest.type, error);
            return Promise.resolve([]);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideCodeActions ? middleware.provideCodeActions(document3, range2, context, token, _provideCodeActions) : _provideCodeActions(document3, range2, context, token);
      }
    };
    return [languages_default.registerCodeActionProvider(options.documentSelector, provider, this._client.id, options.codeActionKinds), provider];
  }
};
var CodeLensFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.CodeLensRequest.type);
  }
  fillClientCapabilities(capabilites) {
    ensure(ensure(capabilites, "textDocument"), "codeLens").dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideCodeLenses: (document3, token) => {
        const client8 = this._client;
        const provideCodeLenses = (document4, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.CodeLensRequest.type, asCodeLensParams(document4), token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.CodeLensRequest.type, error);
            return Promise.resolve([]);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideCodeLenses ? middleware.provideCodeLenses(document3, token, provideCodeLenses) : provideCodeLenses(document3, token);
      },
      resolveCodeLens: options.resolveProvider ? (codeLens, token) => {
        const client8 = this._client;
        const resolveCodeLens = (codeLens2, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.CodeLensResolveRequest.type, codeLens2, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.CodeLensResolveRequest.type, error);
            return codeLens2;
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
      } : void 0
    };
    return [languages_default.registerCodeLensProvider(options.documentSelector, provider), provider];
  }
};
var DocumentFormattingFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.DocumentFormattingRequest.type);
  }
  fillClientCapabilities(capabilites) {
    ensure(ensure(capabilites, "textDocument"), "formatting").dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideDocumentFormattingEdits: (document3, options2, token) => {
        const client8 = this._client;
        const provideDocumentFormattingEdits = (document4, options3, token2) => {
          const params = {
            textDocument: {uri: document4.uri},
            options: options3
          };
          return client8.sendRequest(vscode_languageserver_protocol43.DocumentFormattingRequest.type, params, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.DocumentFormattingRequest.type, error);
            return Promise.resolve([]);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document3, options2, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document3, options2, token);
      }
    };
    return [
      languages_default.registerDocumentFormatProvider(options.documentSelector, provider, this._client.clientOptions.formatterPriority),
      provider
    ];
  }
};
var DocumentRangeFormattingFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.DocumentRangeFormattingRequest.type);
  }
  fillClientCapabilities(capabilites) {
    ensure(ensure(capabilites, "textDocument"), "rangeFormatting").dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideDocumentRangeFormattingEdits: (document3, range2, options2, token) => {
        const client8 = this._client;
        const provideDocumentRangeFormattingEdits = (document4, range3, options3, token2) => {
          const params = {
            textDocument: {uri: document4.uri},
            range: range3,
            options: options3
          };
          return client8.sendRequest(vscode_languageserver_protocol43.DocumentRangeFormattingRequest.type, params, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.DocumentRangeFormattingRequest.type, error);
            return Promise.resolve([]);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document3, range2, options2, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document3, range2, options2, token);
      }
    };
    return [languages_default.registerDocumentRangeFormatProvider(options.documentSelector, provider), provider];
  }
};
var DocumentOnTypeFormattingFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.DocumentOnTypeFormattingRequest.type);
  }
  fillClientCapabilities(capabilites) {
    ensure(ensure(capabilites, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideOnTypeFormattingEdits: (document3, position15, ch, options2, token) => {
        const client8 = this._client;
        const provideOnTypeFormattingEdits = (document4, position16, ch2, options3, token2) => {
          const params = {
            textDocument: asVersionedTextDocumentIdentifier(document4),
            position: position16,
            ch: ch2,
            options: options3
          };
          return client8.sendRequest(vscode_languageserver_protocol43.DocumentOnTypeFormattingRequest.type, params, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.DocumentOnTypeFormattingRequest.type, error);
            return Promise.resolve([]);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document3, position15, ch, options2, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document3, position15, ch, options2, token);
      }
    };
    const moreTriggerCharacter = options.moreTriggerCharacter || [];
    const characters = [options.firstTriggerCharacter, ...moreTriggerCharacter];
    return [languages_default.registerOnTypeFormattingEditProvider(options.documentSelector, provider, characters), provider];
  }
};
var RenameFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.RenameRequest.type);
  }
  fillClientCapabilities(capabilites) {
    let rename = ensure(ensure(capabilites, "textDocument"), "rename");
    rename.dynamicRegistration = true;
    rename.prepareSupport = true;
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
    if (!options) {
      return;
    }
    if (boolean(capabilities.renameProvider)) {
      options.prepareProvider = false;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideRenameEdits: (document3, position15, newName, token) => {
        const client8 = this._client;
        const provideRenameEdits = (document4, position16, newName2, token2) => {
          const params = {
            textDocument: {uri: document4.uri},
            position: position16,
            newName: newName2
          };
          return client8.sendRequest(vscode_languageserver_protocol43.RenameRequest.type, params, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.RenameRequest.type, error);
            return Promise.reject(new Error(error.message));
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideRenameEdits ? middleware.provideRenameEdits(document3, position15, newName, token, provideRenameEdits) : provideRenameEdits(document3, position15, newName, token);
      },
      prepareRename: options.prepareProvider ? (document3, position15, token) => {
        const client8 = this._client;
        const prepareRename = (document4, position16, token2) => {
          const params = {
            textDocument: asTextDocumentIdentifier(document4),
            position: position16
          };
          return client8.sendRequest(vscode_languageserver_protocol43.PrepareRenameRequest.type, params, token2).then((result) => {
            if (vscode_languageserver_protocol43.Range.is(result)) {
              return result;
            } else if (result && vscode_languageserver_protocol43.Range.is(result.range)) {
              return {
                range: result.range,
                placeholder: result.placeholder
              };
            }
            return Promise.reject(new Error(`The element can't be renamed.`));
          }, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.PrepareRenameRequest.type, error);
            return Promise.reject(new Error(error.message));
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.prepareRename ? middleware.prepareRename(document3, position15, token, prepareRename) : prepareRename(document3, position15, token);
      } : void 0
    };
    return [languages_default.registerRenameProvider(options.documentSelector, provider), provider];
  }
};
var DocumentLinkFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol43.DocumentLinkRequest.type);
  }
  fillClientCapabilities(capabilites) {
    const documentLinkCapabilities = ensure(ensure(capabilites, "textDocument"), "documentLink");
    documentLinkCapabilities.dynamicRegistration = true;
    documentLinkCapabilities.tooltipSupport = true;
  }
  initialize(capabilities, documentSelector) {
    const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
    if (!options) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: options
    });
  }
  registerLanguageProvider(options) {
    const provider = {
      provideDocumentLinks: (document3, token) => {
        const client8 = this._client;
        const provideDocumentLinks = (document4, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.DocumentLinkRequest.type, {
            textDocument: {uri: document4.uri}
          }, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.DocumentLinkRequest.type, error);
            return Promise.resolve([]);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document3, token, provideDocumentLinks) : provideDocumentLinks(document3, token);
      },
      resolveDocumentLink: options.resolveProvider ? (link, token) => {
        const client8 = this._client;
        let resolveDocumentLink = (link2, token2) => {
          return client8.sendRequest(vscode_languageserver_protocol43.DocumentLinkResolveRequest.type, link2, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol43.DocumentLinkResolveRequest.type, error);
            return Promise.resolve(link2);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
      } : void 0
    };
    return [languages_default.registerDocumentLinkProvider(options.documentSelector, provider), provider];
  }
};
var ConfigurationFeature = class {
  constructor(_client) {
    this._client = _client;
    this._listeners = new Map();
  }
  get messages() {
    return vscode_languageserver_protocol43.DidChangeConfigurationNotification.type;
  }
  fillClientCapabilities(capabilities) {
    ensure(ensure(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
  }
  initialize() {
    var _a2;
    let section2 = (_a2 = this._client.clientOptions.synchronize) == null ? void 0 : _a2.configurationSection;
    if (section2 !== void 0) {
      this.register(this.messages, {
        id: generateUuid(),
        registerOptions: {
          section: section2
        }
      });
    }
  }
  register(_message, data) {
    let {section: section2} = data.registerOptions;
    let disposable = workspace_default.onDidChangeConfiguration((event) => {
      if (typeof section2 == "string" && !event.affectsConfiguration(section2)) {
        return;
      }
      if (Array.isArray(section2) && !section2.some((v) => event.affectsConfiguration(v))) {
        return;
      }
      if (section2 != null) {
        this.onDidChangeConfiguration(data.registerOptions.section);
      }
    });
    this._listeners.set(data.id, disposable);
    if (string(section2) && section2.endsWith(".settings")) {
      let settings = this.getConfiguredSettings(section2);
      if (!settings || emptyObject(settings))
        return;
    }
    if (section2 != null) {
      this.onDidChangeConfiguration(data.registerOptions.section);
    }
  }
  unregister(id) {
    let disposable = this._listeners.get(id);
    if (disposable) {
      this._listeners.delete(id);
      disposable.dispose();
    }
  }
  dispose() {
    for (let disposable of this._listeners.values()) {
      disposable.dispose();
    }
    this._listeners.clear();
  }
  onDidChangeConfiguration(configurationSection) {
    let isConfigured = typeof configurationSection === "string" && configurationSection.startsWith("languageserver.");
    let sections;
    if (string(configurationSection)) {
      sections = [configurationSection];
    } else {
      sections = configurationSection;
    }
    let didChangeConfiguration = (sections2) => {
      if (sections2 === void 0) {
        this._client.sendNotification(vscode_languageserver_protocol43.DidChangeConfigurationNotification.type, {settings: null});
        return;
      }
      this._client.sendNotification(vscode_languageserver_protocol43.DidChangeConfigurationNotification.type, {
        settings: isConfigured ? this.getConfiguredSettings(sections2[0]) : this.extractSettingsInformation(sections2)
      });
    };
    let middleware = this.getMiddleware();
    middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections);
  }
  getConfiguredSettings(key) {
    let len = ".settings".length;
    let config = workspace_default.getConfiguration(key.slice(0, -len));
    return config.get("settings", {});
  }
  extractSettingsInformation(keys) {
    function ensurePath(config, path66) {
      let current = config;
      for (let i = 0; i < path66.length - 1; i++) {
        let obj = current[path66[i]];
        if (!obj) {
          obj = Object.create(null);
          current[path66[i]] = obj;
        }
        current = obj;
      }
      return current;
    }
    let result = Object.create(null);
    for (let i = 0; i < keys.length; i++) {
      let key = keys[i];
      let index = key.indexOf(".");
      let config = null;
      if (index >= 0) {
        config = workspace_default.getConfiguration(key.substr(0, index)).get(key.substr(index + 1));
      } else {
        config = workspace_default.getConfiguration(key);
      }
      if (config) {
        let path66 = keys[i].split(".");
        ensurePath(result, path66)[path66[path66.length - 1]] = config;
      }
    }
    return result;
  }
  getMiddleware() {
    let middleware = this._client.clientOptions.middleware;
    if (middleware.workspace && middleware.workspace.didChangeConfiguration) {
      return middleware.workspace.didChangeConfiguration;
    } else {
      return void 0;
    }
  }
};
var ExecuteCommandFeature = class {
  constructor(_client) {
    this._client = _client;
    this._commands = new Map();
  }
  get messages() {
    return vscode_languageserver_protocol43.ExecuteCommandRequest.type;
  }
  fillClientCapabilities(capabilities) {
    ensure(ensure(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
  }
  initialize(capabilities) {
    if (!capabilities.executeCommandProvider) {
      return;
    }
    this.register(this.messages, {
      id: generateUuid(),
      registerOptions: Object.assign({}, capabilities.executeCommandProvider)
    });
  }
  register(_message, data) {
    const client8 = this._client;
    const middleware = client8.clientOptions.middleware;
    const executeCommand = (command, args) => {
      const params = {
        command,
        arguments: args
      };
      return client8.sendRequest(vscode_languageserver_protocol43.ExecuteCommandRequest.type, params).then(void 0, (error) => {
        client8.logFailedRequest(vscode_languageserver_protocol43.ExecuteCommandRequest.type, error);
      });
    };
    if (data.registerOptions.commands) {
      let disposables = [];
      for (const command of data.registerOptions.commands) {
        disposables.push(commands_default.registerCommand(command, (...args) => {
          return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
        }, null, true));
      }
      this._commands.set(data.id, disposables);
    }
  }
  unregister(id) {
    let disposables = this._commands.get(id);
    if (disposables) {
      disposables.forEach((disposable) => disposable.dispose());
    }
  }
  dispose() {
    this._commands.forEach((value) => {
      value.forEach((disposable) => disposable.dispose());
    });
    this._commands.clear();
  }
};
var MessageTransports;
(function(MessageTransports2) {
  function is6(value) {
    let candidate = value;
    return candidate && vscode_languageserver_protocol43.MessageReader.is(value.reader) && vscode_languageserver_protocol43.MessageWriter.is(value.writer);
  }
  MessageTransports2.is = is6;
})(MessageTransports || (MessageTransports = {}));
var OnReady = class {
  constructor(_resolve, _reject) {
    this._resolve = _resolve;
    this._reject = _reject;
    this._used = false;
  }
  get isUsed() {
    return this._used;
  }
  resolve() {
    this._used = true;
    this._resolve();
  }
  reject(error) {
    this._used = true;
    this._reject(error);
  }
};
var BaseLanguageClient = class {
  constructor(id, name2, clientOptions) {
    this._features = [];
    this._method2Message = new Map();
    this._dynamicFeatures = new Map();
    this._id = id;
    this._name = name2;
    if (clientOptions.outputChannel) {
      this._outputChannel = clientOptions.outputChannel;
    } else {
      this._outputChannel = void 0;
    }
    this._clientOptions = {
      disableWorkspaceFolders: clientOptions.disableWorkspaceFolders,
      disableSnippetCompletion: clientOptions.disableSnippetCompletion,
      disableDynamicRegister: clientOptions.disableDynamicRegister,
      disableDiagnostics: clientOptions.disableDiagnostics,
      disableCompletion: clientOptions.disableCompletion,
      formatterPriority: clientOptions.formatterPriority,
      ignoredRootPaths: clientOptions.ignoredRootPaths,
      documentSelector: clientOptions.documentSelector || [],
      synchronize: clientOptions.synchronize || {},
      diagnosticCollectionName: clientOptions.diagnosticCollectionName,
      outputChannelName: clientOptions.outputChannelName || this._id,
      revealOutputChannelOn: clientOptions.revealOutputChannelOn || 4,
      stdioEncoding: clientOptions.stdioEncoding || "utf8",
      initializationOptions: clientOptions.initializationOptions,
      initializationFailedHandler: clientOptions.initializationFailedHandler,
      progressOnInitialization: !!clientOptions.progressOnInitialization,
      errorHandler: clientOptions.errorHandler || new DefaultErrorHandler(this._id),
      middleware: clientOptions.middleware || {},
      workspaceFolder: clientOptions.workspaceFolder
    };
    this.state = 0;
    this._connectionPromise = void 0;
    this._resolvedConnection = void 0;
    this._initializeResult = void 0;
    this._listeners = void 0;
    this._providers = void 0;
    this._diagnostics = void 0;
    this._fileEvents = [];
    this._fileEventDelayer = new Delayer(250);
    this._onReady = new Promise((resolve3, reject) => {
      this._onReadyCallbacks = new OnReady(resolve3, reject);
    });
    this._onStop = void 0;
    this._stateChangeEmitter = new vscode_languageserver_protocol43.Emitter();
    this._tracer = {
      log: (messageOrDataObject, data) => {
        if (string(messageOrDataObject)) {
          this.logTrace(messageOrDataObject, data);
        } else {
          this.logObjectTrace(messageOrDataObject);
        }
      }
    };
    this._syncedDocuments = new Map();
    let preferences = workspace_default.getConfiguration("coc.preferences");
    this._markdownSupport = preferences.get("enableMarkdown", true);
    this.registerBuiltinFeatures();
  }
  get supporedMarkupKind() {
    if (this._markdownSupport)
      return [vscode_languageserver_protocol43.MarkupKind.Markdown, vscode_languageserver_protocol43.MarkupKind.PlainText];
    return [vscode_languageserver_protocol43.MarkupKind.PlainText];
  }
  get state() {
    return this._state;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  set state(value) {
    let oldState = this.getPublicState();
    this._state = value;
    let newState = this.getPublicState();
    if (newState !== oldState) {
      this._stateChangeEmitter.fire({oldState, newState});
    }
  }
  getPublicState() {
    if (this.state === 3) {
      return 2;
    } else if (this.state === 1) {
      return 3;
    } else {
      return 1;
    }
  }
  get initializeResult() {
    return this._initializeResult;
  }
  async sendRequest(type, ...params) {
    if (!this.isConnectionActive()) {
      throw new Error("Language client is not ready yet");
    }
    try {
      return this._resolvedConnection.sendRequest(type, ...params);
    } catch (error) {
      this.error(`Sending request ${string(type) ? type : type.method} failed.`, error);
      throw error;
    }
  }
  onRequest(type, handler2) {
    if (!this.isConnectionActive()) {
      throw new Error("Language client is not ready yet");
    }
    try {
      this._resolvedConnection.onRequest(type, handler2);
    } catch (error) {
      this.error(`Registering request handler ${string(type) ? type : type.method} failed.`, error);
      throw error;
    }
  }
  sendNotification(type, params) {
    if (!this.isConnectionActive()) {
      throw new Error("Language client is not ready yet");
    }
    try {
      this._resolvedConnection.sendNotification(type, params);
    } catch (error) {
      this.error(`Sending notification ${string(type) ? type : type.method} failed.`, error);
      throw error;
    }
  }
  onNotification(type, handler2) {
    if (!this.isConnectionActive()) {
      throw new Error("Language client is not ready yet");
    }
    try {
      this._resolvedConnection.onNotification(type, handler2);
    } catch (error) {
      this.error(`Registering notification handler ${string(type) ? type : type.method} failed.`, error);
      throw error;
    }
  }
  onProgress(type, token, handler2) {
    if (!this.isConnectionActive()) {
      throw new Error("Language client is not ready yet");
    }
    try {
      if (type == vscode_languageserver_protocol43.WorkDoneProgress.type) {
        const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;
        if (handleWorkDoneProgress !== void 0) {
          return this._resolvedConnection.onProgress(type, token, (params) => {
            handleWorkDoneProgress(token, params, () => handler2(params));
          });
        }
      }
      return this._resolvedConnection.onProgress(type, token, handler2);
    } catch (error) {
      this.error(`Registering progress handler for token ${token} failed.`, error);
      throw error;
    }
  }
  sendProgress(type, token, value) {
    if (!this.isConnectionActive()) {
      throw new Error("Language client is not ready yet");
    }
    try {
      this._resolvedConnection.sendProgress(type, token, value);
    } catch (error) {
      this.error(`Sending progress for token ${token} failed.`, error);
      throw error;
    }
  }
  get clientOptions() {
    return this._clientOptions;
  }
  get onDidChangeState() {
    return this._stateChangeEmitter.event;
  }
  get outputChannel() {
    if (!this._outputChannel) {
      let {outputChannelName} = this._clientOptions;
      this._outputChannel = window_default.createOutputChannel(outputChannelName ? outputChannelName : this._name);
    }
    return this._outputChannel;
  }
  get diagnostics() {
    return this._diagnostics;
  }
  createDefaultErrorHandler() {
    return new DefaultErrorHandler(this._id);
  }
  set trace(value) {
    this._trace = value;
    this.onReady().then(() => {
      this.resolveConnection().then((connection) => {
        connection.trace(this._trace, this._tracer, {
          sendNotification: false,
          traceFormat: this._traceFormat
        });
      });
    }, () => {
    });
  }
  logObjectTrace(data) {
    if (data.isLSPMessage && data.type) {
      this.outputChannel.append(`[LSP   - ${new Date().toLocaleTimeString()}] `);
    } else {
      this.outputChannel.append(`[Trace - ${new Date().toLocaleTimeString()}] `);
    }
    if (data) {
      this.outputChannel.appendLine(`${JSON.stringify(data)}`);
    }
  }
  data2String(data) {
    if (data instanceof vscode_languageserver_protocol43.ResponseError) {
      const responseError = data;
      return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
    }
    if (data instanceof Error) {
      if (string(data.stack)) {
        return data.stack;
      }
      return data.message;
    }
    if (string(data)) {
      return data;
    }
    return data.toString();
  }
  _appendOutput(type, message, data) {
    let level = 3;
    switch (type) {
      case "Info":
        level = 1;
        break;
      case "Warn":
        level = 2;
        break;
    }
    this.outputChannel.appendLine(`[${type}  - ${new Date().toLocaleTimeString()}] ${message}`);
    let dataString;
    if (data) {
      dataString = this.data2String(data);
      this.outputChannel.appendLine(dataString);
    }
    if (this._clientOptions.revealOutputChannelOn <= level) {
      this.outputChannel.show(true);
    }
  }
  info(message, data) {
    this._appendOutput("Info", message, data);
  }
  warn(message, data) {
    this._appendOutput("Warn", message, data);
  }
  error(message, data) {
    this._appendOutput("Error", message, data);
  }
  logTrace(message, data) {
    this.outputChannel.appendLine(`[Trace - ${new Date().toLocaleTimeString()}] ${message}`);
    if (data) {
      this.outputChannel.appendLine(this.data2String(data));
    }
  }
  needsStart() {
    return this.state === 0 || this.state === 4 || this.state === 5;
  }
  needsStop() {
    return this.state === 1 || this.state === 3;
  }
  onReady() {
    return this._onReady;
  }
  get started() {
    return this.state != 0;
  }
  isConnectionActive() {
    return this.state === 3 && !!this._resolvedConnection;
  }
  start() {
    if (this._onReadyCallbacks.isUsed) {
      this._onReady = new Promise((resolve3, reject) => {
        this._onReadyCallbacks = new OnReady(resolve3, reject);
      });
    }
    this._listeners = [];
    this._providers = [];
    if (!this._diagnostics) {
      let opts = this._clientOptions;
      let name2 = opts.diagnosticCollectionName ? opts.diagnosticCollectionName : this._id;
      this._diagnostics = languages_default.createDiagnosticCollection(name2);
    }
    this.state = 1;
    this.resolveConnection().then((connection) => {
      connection.onLogMessage((message) => {
        let kind;
        switch (message.type) {
          case vscode_languageserver_protocol43.MessageType.Error:
            kind = "error";
            this.error(message.message);
            break;
          case vscode_languageserver_protocol43.MessageType.Warning:
            kind = "warning";
            this.warn(message.message);
            break;
          case vscode_languageserver_protocol43.MessageType.Info:
            kind = "info";
            this.info(message.message);
            break;
          default:
            kind = "log";
            this.outputChannel.appendLine(message.message);
        }
        if (global.hasOwnProperty("__TEST__")) {
          console.log(`[${kind}] ${message.message}`);
          return;
        }
      });
      connection.onShowMessage((message) => {
        switch (message.type) {
          case vscode_languageserver_protocol43.MessageType.Error:
            window_default.showErrorMessage(message.message);
            break;
          case vscode_languageserver_protocol43.MessageType.Warning:
            window_default.showWarningMessage(message.message);
            break;
          case vscode_languageserver_protocol43.MessageType.Info:
            window_default.showInformationMessage(message.message);
            break;
          default:
            window_default.showInformationMessage(message.message);
        }
      });
      connection.onRequest(vscode_languageserver_protocol43.ShowMessageRequest.type, (params) => {
        let messageFunc;
        switch (params.type) {
          case vscode_languageserver_protocol43.MessageType.Error:
            messageFunc = window_default.showErrorMessage.bind(window_default);
            break;
          case vscode_languageserver_protocol43.MessageType.Warning:
            messageFunc = window_default.showWarningMessage.bind(window_default);
            break;
          case vscode_languageserver_protocol43.MessageType.Info:
            messageFunc = window_default.showInformationMessage.bind(window_default);
            break;
          default:
            messageFunc = window_default.showInformationMessage.bind(window_default);
        }
        let actions = params.actions || [];
        return messageFunc(params.message, ...actions);
      });
      connection.onTelemetry((_data) => {
      });
      connection.listen();
      return this.initialize(connection);
    }).then(void 0, (error) => {
      this.state = 2;
      this._onReadyCallbacks.reject(error);
      this.error("Starting client failed ", error);
    });
    return vscode_languageserver_protocol43.Disposable.create(() => {
      if (this.needsStop()) {
        this.stop();
      }
    });
  }
  resolveConnection() {
    if (!this._connectionPromise) {
      this._connectionPromise = this.createConnection();
    }
    return this._connectionPromise;
  }
  resolveRootPath() {
    if (this._clientOptions.workspaceFolder) {
      return URI.parse(this._clientOptions.workspaceFolder.uri).fsPath;
    }
    let {ignoredRootPaths} = this._clientOptions;
    let config = workspace_default.getConfiguration(this.id);
    let rootPatterns = config.get("rootPatterns", []);
    let required = config.get("requireRootPattern", false);
    let resolved;
    if (rootPatterns && rootPatterns.length) {
      let doc = workspace_default.getDocument(workspace_default.bufnr);
      if (doc && doc.schema == "file") {
        let dir = path30.default.dirname(URI.parse(doc.uri).fsPath);
        resolved = resolveRoot(dir, rootPatterns, workspace_default.cwd);
      }
    }
    if (required && !resolved)
      return null;
    let rootPath = resolved || workspace_default.rootPath || workspace_default.cwd;
    if (ignoredRootPaths && ignoredRootPaths.indexOf(rootPath) !== -1) {
      window_default.showMessage(`Ignored rootPath ${rootPath} of client "${this._id}"`, "warning");
      return null;
    }
    return rootPath;
  }
  initialize(connection) {
    this.refreshTrace(connection, false);
    let {initializationOptions, progressOnInitialization} = this._clientOptions;
    let rootPath = this.resolveRootPath();
    if (!rootPath)
      return;
    let initParams = {
      processId: process.pid,
      rootPath: rootPath ? rootPath : null,
      rootUri: rootPath ? asUri(URI.file(rootPath)) : null,
      capabilities: this.computeClientCapabilities(),
      initializationOptions: func(initializationOptions) ? initializationOptions() : initializationOptions,
      trace: vscode_languageserver_protocol43.Trace.toString(this._trace),
      workspaceFolders: null,
      clientInfo: {
        name: "coc.nvim",
        version: workspace_default.version
      }
    };
    this.fillInitializeParams(initParams);
    if (progressOnInitialization) {
      const token = generateUuid();
      initParams.workDoneToken = token;
      const part = new ProgressPart(connection, token);
      part.begin({title: `initializing ${this.id}`, kind: "begin"});
      return this.doInitialize(connection, initParams).then((result) => {
        part.done();
        return result;
      }, (error) => {
        part.cancel();
        throw error;
      });
    } else {
      return this.doInitialize(connection, initParams);
    }
  }
  doInitialize(connection, initParams) {
    return connection.initialize(initParams).then((result) => {
      this._resolvedConnection = connection;
      this._initializeResult = result;
      this.state = 3;
      let textDocumentSyncOptions = void 0;
      if (number(result.capabilities.textDocumentSync)) {
        if (result.capabilities.textDocumentSync === vscode_languageserver_protocol43.TextDocumentSyncKind.None) {
          textDocumentSyncOptions = {
            openClose: false,
            change: vscode_languageserver_protocol43.TextDocumentSyncKind.None,
            save: void 0
          };
        } else {
          textDocumentSyncOptions = {
            openClose: true,
            change: result.capabilities.textDocumentSync,
            save: {
              includeText: false
            }
          };
        }
      } else if (result.capabilities.textDocumentSync != null) {
        textDocumentSyncOptions = result.capabilities.textDocumentSync;
      }
      this._capabilities = Object.assign({}, result.capabilities, {
        resolvedTextDocumentSync: textDocumentSyncOptions
      });
      if (!this._clientOptions.disableDiagnostics) {
        connection.onDiagnostics((params) => this.handleDiagnostics(params));
      }
      connection.onRequest(vscode_languageserver_protocol43.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
      connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
      connection.onRequest(vscode_languageserver_protocol43.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
      connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
      connection.onRequest(vscode_languageserver_protocol43.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
      connection.sendNotification(vscode_languageserver_protocol43.InitializedNotification.type, {});
      this.hookFileEvents(connection);
      this.hookConfigurationChanged(connection);
      this.initializeFeatures(connection);
      this._onReadyCallbacks.resolve();
      return result;
    }).then(void 0, (error) => {
      if (this._clientOptions.initializationFailedHandler) {
        if (this._clientOptions.initializationFailedHandler(error)) {
          this.initialize(connection);
        } else {
          this.stop();
          this._onReadyCallbacks.reject(error);
        }
      } else if (error instanceof vscode_languageserver_protocol43.ResponseError && error.data && error.data.retry) {
        window_default.showPrompt(error.message + " Retry?").then((confirmed) => {
          if (confirmed) {
            this.initialize(connection);
          } else {
            this.stop();
            this._onReadyCallbacks.reject(error);
          }
        });
      } else {
        if (error && error.message) {
          window_default.showMessage(error.message, "error");
        }
        this.error("Server initialization failed.", error);
        this.stop();
        this._onReadyCallbacks.reject(error);
      }
      throw error;
    });
  }
  stop() {
    this._initializeResult = void 0;
    if (!this._connectionPromise) {
      this.state = 5;
      return Promise.resolve();
    }
    if (this.state === 4 && this._onStop) {
      return this._onStop;
    }
    this.state = 4;
    this.cleanUp();
    return this._onStop = this.resolveConnection().then((connection) => {
      return connection.shutdown().then(() => {
        connection.exit();
        connection.dispose();
        this.state = 5;
        this.cleanUpChannel();
        this._onStop = void 0;
        this._connectionPromise = void 0;
        this._resolvedConnection = void 0;
      });
    }).catch((e) => {
      logger44.error("Error on stop languageserver:", e);
      this.state = 5;
      this.cleanUpChannel();
      this._onStop = void 0;
      this._connectionPromise = void 0;
      this._resolvedConnection = void 0;
    });
  }
  cleanUp(channel = true, diagnostics2 = true) {
    if (this._listeners) {
      this._listeners.forEach((listener) => listener.dispose());
      this._listeners = void 0;
    }
    if (this._providers) {
      this._providers.forEach((provider) => provider.dispose());
      this._providers = void 0;
    }
    for (let feature of this._features.values()) {
      if (typeof feature.dispose === "function") {
        feature.dispose();
      } else {
        logger44.error(`Feature can't be disposed`, feature);
      }
    }
    if (this._syncedDocuments) {
      this._syncedDocuments.clear();
    }
    if (channel) {
      this.cleanUpChannel();
    }
    if (this._diagnostics) {
      if (diagnostics2) {
        this._diagnostics.dispose();
        this._diagnostics = void 0;
      } else {
        this._diagnostics.clear();
      }
    }
  }
  cleanUpChannel() {
    if (this._outputChannel) {
      this._outputChannel.dispose();
      this._outputChannel = void 0;
    }
  }
  notifyFileEvent(event) {
    var _a2;
    const client8 = this;
    function didChangeWatchedFile(event2) {
      client8._fileEvents.push(event2);
      client8._fileEventDelayer.trigger(() => {
        client8.onReady().then(() => {
          client8.resolveConnection().then((connection) => {
            if (client8.isConnectionActive()) {
              connection.didChangeWatchedFiles({changes: client8._fileEvents});
            }
            client8._fileEvents = [];
          });
        }, (error) => {
          client8.error(`Notify file events failed.`, error);
        });
      });
    }
    const workSpaceMiddleware = (_a2 = this.clientOptions.middleware) == null ? void 0 : _a2.workspace;
    (workSpaceMiddleware == null ? void 0 : workSpaceMiddleware.didChangeWatchedFile) ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event);
  }
  handleDiagnostics(params) {
    if (!this._diagnostics) {
      return;
    }
    let {uri, diagnostics: diagnostics2} = params;
    let middleware = this.clientOptions.middleware.handleDiagnostics;
    if (middleware) {
      middleware(uri, diagnostics2, (uri2, diagnostics3) => this.setDiagnostics(uri2, diagnostics3));
    } else {
      this.setDiagnostics(uri, diagnostics2);
    }
  }
  setDiagnostics(uri, diagnostics2) {
    var _a2;
    if (!this._diagnostics) {
      return;
    }
    const separate = workspace_default.getConfiguration("diagnostic").get("separateRelatedInformationAsDiagnostics");
    if (separate && diagnostics2.length > 0) {
      const entries = new Map();
      entries.set(uri, diagnostics2);
      for (const diagnostic of diagnostics2) {
        if ((_a2 = diagnostic.relatedInformation) == null ? void 0 : _a2.length) {
          let message = `${diagnostic.message}

Related diagnostics:
`;
          for (const info of diagnostic.relatedInformation) {
            const basename = path30.default.basename(URI.parse(info.location.uri).fsPath);
            const ln = info.location.range.start.line;
            message = `${message}
${basename}(line ${ln + 1}): ${info.message}`;
            const diags = entries.get(info.location.uri) || [];
            diags.push(vscode_languageserver_protocol43.Diagnostic.create(info.location.range, info.message, vscode_languageserver_protocol43.DiagnosticSeverity.Hint, diagnostic.code, diagnostic.source));
            entries.set(info.location.uri, diags);
          }
          diagnostic.message = message;
        }
        this._diagnostics.set(Array.from(entries));
      }
    } else {
      this._diagnostics.set(uri, diagnostics2);
    }
  }
  createConnection() {
    let errorHandler = (error, message, count) => {
      logger44.error("connection error:", error, message);
      this.handleConnectionError(error, message, count);
    };
    let closeHandler = () => {
      this.handleConnectionClosed();
    };
    return this.createMessageTransports(this._clientOptions.stdioEncoding || "utf8").then((transports) => {
      return createConnection(transports.reader, transports.writer, errorHandler, closeHandler);
    });
  }
  handleConnectionClosed() {
    if (this.state === 4 || this.state === 5) {
      return;
    }
    try {
      if (this._resolvedConnection) {
        this._resolvedConnection.dispose();
      }
    } catch (error) {
    }
    let action = 1;
    try {
      action = this._clientOptions.errorHandler.closed();
    } catch (error) {
    }
    this._connectionPromise = void 0;
    this._resolvedConnection = void 0;
    if (action === 1) {
      this.error("Connection to server got closed. Server will not be restarted.");
      this.state = 5;
      this.cleanUp(false, true);
    } else if (action === 2) {
      this.info("Connection to server got closed. Server will restart.");
      this.cleanUp(false, true);
      this.state = 0;
      this.start();
    }
  }
  restart() {
    this.cleanUp(true, false);
    this.start();
  }
  handleConnectionError(error, message, count) {
    let action = this._clientOptions.errorHandler.error(error, message, count);
    if (action === 2) {
      this.error("Connection to server is erroring. Shutting down server.");
      this.stop();
    }
  }
  hookConfigurationChanged(connection) {
    workspace_default.onDidChangeConfiguration(() => {
      this.refreshTrace(connection, true);
    });
  }
  refreshTrace(connection, sendNotification = false) {
    let config = workspace_default.getConfiguration(this._id);
    let trace = vscode_languageserver_protocol43.Trace.Off;
    let traceFormat = vscode_languageserver_protocol43.TraceFormat.Text;
    if (config) {
      const traceConfig = config.get("trace.server", "off");
      if (typeof traceConfig === "string") {
        trace = vscode_languageserver_protocol43.Trace.fromString(traceConfig);
      } else {
        trace = vscode_languageserver_protocol43.Trace.fromString(config.get("trace.server.verbosity", "off"));
        traceFormat = vscode_languageserver_protocol43.TraceFormat.fromString(config.get("trace.server.format", "text"));
      }
    }
    this._trace = trace;
    this._traceFormat = traceFormat;
    connection.trace(this._trace, this._tracer, {
      sendNotification,
      traceFormat: this._traceFormat
    });
  }
  hookFileEvents(_connection) {
    let fileEvents = this._clientOptions.synchronize.fileEvents;
    if (!fileEvents)
      return;
    let watchers;
    if (Array.isArray(fileEvents)) {
      watchers = fileEvents;
    } else {
      watchers = [fileEvents];
    }
    if (!watchers) {
      return;
    }
    this._dynamicFeatures.get(vscode_languageserver_protocol43.DidChangeWatchedFilesNotification.type.method).registerRaw(generateUuid(), watchers);
  }
  registerFeatures(features) {
    for (let feature of features) {
      this.registerFeature(feature);
    }
  }
  registerFeature(feature) {
    this._features.push(feature);
    if (DynamicFeature.is(feature)) {
      let messages = feature.messages;
      if (Array.isArray(messages)) {
        for (let message of messages) {
          this._method2Message.set(message.method, message);
          this._dynamicFeatures.set(message.method, feature);
        }
      } else {
        this._method2Message.set(messages.method, messages);
        this._dynamicFeatures.set(messages.method, feature);
      }
    }
  }
  getFeature(request2) {
    return this._dynamicFeatures.get(request2);
  }
  registerBuiltinFeatures() {
    this.registerFeature(new ConfigurationFeature(this));
    this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));
    this.registerFeature(new DidChangeTextDocumentFeature(this));
    this.registerFeature(new WillSaveFeature(this));
    this.registerFeature(new WillSaveWaitUntilFeature(this));
    this.registerFeature(new DidSaveTextDocumentFeature(this));
    this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));
    this.registerFeature(new FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
    if (!this._clientOptions.disableCompletion) {
      this.registerFeature(new CompletionItemFeature(this));
    }
    this.registerFeature(new HoverFeature(this));
    this.registerFeature(new SignatureHelpFeature(this));
    this.registerFeature(new DefinitionFeature(this));
    this.registerFeature(new ReferencesFeature(this));
    this.registerFeature(new DocumentHighlightFeature(this));
    this.registerFeature(new DocumentSymbolFeature(this));
    this.registerFeature(new WorkspaceSymbolFeature(this));
    this.registerFeature(new CodeActionFeature(this));
    this.registerFeature(new CodeLensFeature(this));
    this.registerFeature(new DocumentFormattingFeature(this));
    this.registerFeature(new DocumentRangeFormattingFeature(this));
    this.registerFeature(new DocumentOnTypeFormattingFeature(this));
    this.registerFeature(new RenameFeature(this));
    this.registerFeature(new DocumentLinkFeature(this));
    this.registerFeature(new ExecuteCommandFeature(this));
  }
  fillInitializeParams(params) {
    for (let feature of this._features) {
      if (func(feature.fillInitializeParams)) {
        feature.fillInitializeParams(params);
      }
    }
  }
  computeClientCapabilities() {
    let result = {};
    ensure(result, "workspace").applyEdit = true;
    let workspaceEdit = ensure(ensure(result, "workspace"), "workspaceEdit");
    workspaceEdit.documentChanges = true;
    workspaceEdit.resourceOperations = [vscode_languageserver_protocol43.ResourceOperationKind.Create, vscode_languageserver_protocol43.ResourceOperationKind.Rename, vscode_languageserver_protocol43.ResourceOperationKind.Delete];
    workspaceEdit.failureHandling = vscode_languageserver_protocol43.FailureHandlingKind.TextOnlyTransactional;
    const diagnostics2 = ensure(ensure(result, "textDocument"), "publishDiagnostics");
    diagnostics2.relatedInformation = true;
    diagnostics2.versionSupport = false;
    diagnostics2.tagSupport = {valueSet: [vscode_languageserver_protocol43.DiagnosticTag.Unnecessary, vscode_languageserver_protocol43.DiagnosticTag.Deprecated]};
    for (let feature of this._features) {
      feature.fillClientCapabilities(result);
    }
    return result;
  }
  initializeFeatures(_connection) {
    let documentSelector = this._clientOptions.documentSelector;
    for (let feature of this._features) {
      feature.initialize(this._capabilities, documentSelector);
    }
  }
  handleRegistrationRequest(params) {
    if (this.clientOptions.disableDynamicRegister)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      for (let registration of params.registrations) {
        const feature = this._dynamicFeatures.get(registration.method);
        if (!feature) {
          reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
          return;
        }
        const options = registration.registerOptions || {};
        options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;
        const data = {
          id: registration.id,
          registerOptions: options
        };
        feature.register(this._method2Message.get(registration.method), data);
      }
      resolve3();
    });
  }
  handleUnregistrationRequest(params) {
    return new Promise((resolve3, reject) => {
      for (let unregistration of params.unregisterations) {
        const feature = this._dynamicFeatures.get(unregistration.method);
        if (!feature) {
          reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
          return;
        }
        feature.unregister(unregistration.id);
      }
      resolve3();
    });
  }
  handleApplyWorkspaceEdit(params) {
    let workspaceEdit = params.edit;
    let openTextDocuments = new Map();
    workspace_default.textDocuments.forEach((document3) => openTextDocuments.set(document3.uri.toString(), document3));
    let versionMismatch = false;
    if (workspaceEdit.documentChanges) {
      for (const change of workspaceEdit.documentChanges) {
        if (vscode_languageserver_protocol43.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
          let textDocument = openTextDocuments.get(change.textDocument.uri);
          if (textDocument && textDocument.version !== change.textDocument.version) {
            versionMismatch = true;
            break;
          }
        }
      }
    }
    if (versionMismatch) {
      return Promise.resolve({applied: false});
    }
    return workspace_default.applyEdit(params.edit).then((value) => {
      return {applied: value};
    });
  }
  logFailedRequest(type, error) {
    if (error instanceof vscode_languageserver_protocol43.ResponseError && error.code === vscode_languageserver_protocol43.ErrorCodes.RequestCancelled) {
      return;
    }
    this.error(`Request ${type.method} failed.`, error);
  }
};

// src/language-client/colorProvider.ts
var vscode_languageserver_protocol44 = __toModule(require_main3());
"use strict";
function ensure2(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var ColorProviderFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol44.DocumentColorRequest.type);
  }
  fillClientCapabilities(capabilites) {
    ensure2(ensure2(capabilites, "textDocument"), "colorProvider").dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
    if (!id || !options) {
      return;
    }
    this.register(this.messages, {id, registerOptions: options});
  }
  registerLanguageProvider(options) {
    const provider = {
      provideColorPresentations: (color, context, token) => {
        const client8 = this._client;
        const provideColorPresentations = (color2, context2, token2) => {
          const requestParams = {
            color: color2,
            textDocument: {uri: context2.document.uri},
            range: context2.range
          };
          return client8.sendRequest(vscode_languageserver_protocol44.ColorPresentationRequest.type, requestParams, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol44.ColorPresentationRequest.type, error);
            return Promise.resolve(null);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
      },
      provideDocumentColors: (document3, token) => {
        const client8 = this._client;
        const provideDocumentColors = (document4, token2) => {
          const requestParams = {
            textDocument: {uri: document4.uri}
          };
          return client8.sendRequest(vscode_languageserver_protocol44.DocumentColorRequest.type, requestParams, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol44.ColorPresentationRequest.type, error);
            return Promise.resolve(null);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideDocumentColors ? middleware.provideDocumentColors(document3, token, provideDocumentColors) : provideDocumentColors(document3, token);
      }
    };
    return [languages_default.registerDocumentColorProvider(options.documentSelector, provider), provider];
  }
};

// src/language-client/configuration.ts
var vscode_languageserver_protocol45 = __toModule(require_main3());
var logger45 = require_logger2()("languageclient-configuration");
var ConfigurationFeature2 = class {
  constructor(_client) {
    this._client = _client;
    var _a2;
    let section2 = (_a2 = this._client.clientOptions.synchronize) == null ? void 0 : _a2.configurationSection;
    if (typeof section2 === "string" && section2.startsWith("languageserver.")) {
      this.languageserverSection = section2;
    }
  }
  fillClientCapabilities(capabilities) {
    capabilities.workspace = capabilities.workspace || {};
    capabilities.workspace.configuration = true;
  }
  initialize() {
    let client8 = this._client;
    client8.onRequest(vscode_languageserver_protocol45.ConfigurationRequest.type, (params, token) => {
      let configuration7 = (params2) => {
        let result = [];
        for (let item of params2.items) {
          result.push(this.getConfiguration(item.scopeUri, item.section));
        }
        return result;
      };
      let middleware = client8.clientOptions.middleware.workspace;
      return middleware && middleware.configuration ? middleware.configuration(params, token, configuration7) : configuration7(params, token);
    });
  }
  getConfiguration(resource, section2) {
    let result = null;
    if (section2) {
      if (this.languageserverSection) {
        section2 = `${this.languageserverSection}.${section2}`;
      }
      let index = section2.lastIndexOf(".");
      if (index === -1) {
        result = workspace_default.getConfiguration(void 0, resource).get(section2, {});
      } else {
        let config = workspace_default.getConfiguration(section2.substr(0, index), resource);
        if (config) {
          result = config.get(section2.substr(index + 1));
        }
      }
    } else {
      let config = workspace_default.getConfiguration(this.languageserverSection, resource);
      result = {};
      for (let key of Object.keys(config)) {
        if (config.has(key)) {
          result[key] = toJSONObject(config.get(key));
        }
      }
    }
    return result;
  }
  dispose() {
  }
};
function toJSONObject(obj) {
  if (obj) {
    if (Array.isArray(obj)) {
      return obj.map(toJSONObject);
    } else if (typeof obj === "object") {
      const res = Object.create(null);
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          res[key] = toJSONObject(obj[key]);
        }
      }
      return res;
    }
  }
  return obj;
}

// src/language-client/declaration.ts
var vscode_languageserver_protocol46 = __toModule(require_main3());
"use strict";
function ensure3(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var DeclarationFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol46.DeclarationRequest.type);
  }
  fillClientCapabilities(capabilites) {
    let declarationSupport = ensure3(ensure3(capabilites, "textDocument"), "declaration");
    declarationSupport.dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
    if (!id || !options) {
      return;
    }
    this.register(this.messages, {id, registerOptions: options});
  }
  registerLanguageProvider(options) {
    const provider = {
      provideDeclaration: (document3, position15, token) => {
        const client8 = this._client;
        const provideDeclaration = (document4, position16, token2) => client8.sendRequest(vscode_languageserver_protocol46.DeclarationRequest.type, asTextDocumentPositionParams(document4, position16), token2).then((res) => res, (error) => {
          client8.logFailedRequest(vscode_languageserver_protocol46.DeclarationRequest.type, error);
          return Promise.resolve(null);
        });
        const middleware = client8.clientOptions.middleware;
        return middleware.provideDeclaration ? middleware.provideDeclaration(document3, position15, token, provideDeclaration) : provideDeclaration(document3, position15, token);
      }
    };
    return [languages_default.registerDeclarationProvider(options.documentSelector, provider), provider];
  }
};

// src/language-client/foldingRange.ts
var vscode_languageserver_protocol47 = __toModule(require_main3());
"use strict";
function ensure4(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var FoldingRangeFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol47.FoldingRangeRequest.type);
  }
  fillClientCapabilities(capabilites) {
    let capability = ensure4(ensure4(capabilites, "textDocument"), "foldingRange");
    capability.dynamicRegistration = true;
    capability.rangeLimit = 5e3;
    capability.lineFoldingOnly = true;
  }
  initialize(capabilities, documentSelector) {
    const [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
    if (!id || !options) {
      return;
    }
    this.register(this.messages, {id, registerOptions: options});
  }
  registerLanguageProvider(options) {
    const provider = {
      provideFoldingRanges: (document3, context, token) => {
        const client8 = this._client;
        const provideFoldingRanges = (document4, _, token2) => {
          const requestParams = {
            textDocument: {uri: document4.uri}
          };
          return client8.sendRequest(vscode_languageserver_protocol47.FoldingRangeRequest.type, requestParams, token2).then((res) => res, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol47.FoldingRangeRequest.type, error);
            return Promise.resolve(null);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document3, context, token, provideFoldingRanges) : provideFoldingRanges(document3, context, token);
      }
    };
    return [languages_default.registerFoldingRangeProvider(options.documentSelector, provider), provider];
  }
};

// src/language-client/implementation.ts
var vscode_languageserver_protocol48 = __toModule(require_main3());
function ensure5(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var ImplementationFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol48.ImplementationRequest.type);
  }
  fillClientCapabilities(capabilites) {
    const implementationSupport = ensure5(ensure5(capabilites, "textDocument"), "implementation");
    implementationSupport.dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    const [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
    if (!id || !options) {
      return;
    }
    this.register(this.messages, {id, registerOptions: options});
  }
  registerLanguageProvider(options) {
    const provider = {
      provideImplementation: (document3, position15, token) => {
        const client8 = this._client;
        const provideImplementation = (document4, position16, token2) => client8.sendRequest(vscode_languageserver_protocol48.ImplementationRequest.type, asTextDocumentPositionParams(document4, position16), token2).then((res) => res, (error) => {
          client8.logFailedRequest(vscode_languageserver_protocol48.ImplementationRequest.type, error);
          return Promise.resolve(null);
        });
        const middleware = client8.clientOptions.middleware;
        return middleware.provideImplementation ? middleware.provideImplementation(document3, position15, token, provideImplementation) : provideImplementation(document3, position15, token);
      }
    };
    return [languages_default.registerImplementationProvider(options.documentSelector, provider), provider];
  }
};

// src/language-client/progress.ts
var vscode_languageserver_protocol49 = __toModule(require_main3());
"use strict";
function ensure6(target, key) {
  if (target[key] === void 0) {
    target[key] = Object.create(null);
  }
  return target[key];
}
var ProgressFeature = class {
  constructor(_client) {
    this._client = _client;
    this.activeParts = new Set();
  }
  fillClientCapabilities(capabilities) {
    ensure6(capabilities, "window").workDoneProgress = true;
  }
  initialize() {
    let client8 = this._client;
    const deleteHandler = (part) => {
      this.activeParts.delete(part);
    };
    const createHandler = (params) => {
      this.activeParts.add(new ProgressPart(this._client, params.token, deleteHandler));
    };
    client8.onRequest(vscode_languageserver_protocol49.WorkDoneProgressCreateRequest.type, createHandler);
  }
  dispose() {
    for (const part of this.activeParts) {
      part.done();
    }
    this.activeParts.clear();
  }
};

// src/language-client/typeDefinition.ts
var vscode_languageserver_protocol50 = __toModule(require_main3());
function ensure7(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var TypeDefinitionFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol50.TypeDefinitionRequest.type);
  }
  fillClientCapabilities(capabilites) {
    const typeDefinitionSupport = ensure7(ensure7(capabilites, "textDocument"), "typeDefinition");
    typeDefinitionSupport.dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    const [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
    if (!id || !options) {
      return;
    }
    this.register(this.messages, {id, registerOptions: options});
  }
  registerLanguageProvider(options) {
    const provider = {
      provideTypeDefinition: (document3, position15, token) => {
        const client8 = this._client;
        const provideTypeDefinition = (document4, position16, token2) => client8.sendRequest(vscode_languageserver_protocol50.TypeDefinitionRequest.type, asTextDocumentPositionParams(document4, position16), token2).then((res) => res, (error) => {
          client8.logFailedRequest(vscode_languageserver_protocol50.TypeDefinitionRequest.type, error);
          return Promise.resolve(null);
        });
        const middleware = client8.clientOptions.middleware;
        return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document3, position15, token, provideTypeDefinition) : provideTypeDefinition(document3, position15, token);
      }
    };
    return [languages_default.registerTypeDefinitionProvider(options.documentSelector, provider), provider];
  }
};

// src/language-client/workspaceFolders.ts
var vscode_languageserver_protocol51 = __toModule(require_main3());
"use strict";
var logger46 = require_logger2()("language-client-workspaceFolder");
function access(target, key) {
  if (target === void 0) {
    return void 0;
  }
  return target[key];
}
function arrayDiff(left, right) {
  return left.filter((element) => !right.includes(element));
}
var WorkspaceFoldersFeature = class {
  constructor(_client) {
    this._client = _client;
    this._listeners = new Map();
  }
  get messages() {
    return vscode_languageserver_protocol51.DidChangeWorkspaceFoldersNotification.type;
  }
  asProtocol(workspaceFolder) {
    if (workspaceFolder === void 0) {
      return null;
    }
    return {uri: workspaceFolder.uri, name: workspaceFolder.name};
  }
  fillInitializeParams(params) {
    const folders2 = workspace_default.workspaceFolders;
    this._initialFolders = folders2;
    if (folders2 === void 0) {
      params.workspaceFolders = null;
    } else {
      params.workspaceFolders = folders2.map((folder) => this.asProtocol(folder));
    }
    params.workspaceFolders = workspace_default.workspaceFolders;
  }
  fillClientCapabilities(capabilities) {
    capabilities.workspace = capabilities.workspace || {};
    capabilities.workspace.workspaceFolders = true;
  }
  initialize(capabilities) {
    let client8 = this._client;
    client8.onRequest(vscode_languageserver_protocol51.WorkspaceFoldersRequest.type, (token) => {
      let workspaceFolders2 = () => {
        let folders2 = workspace_default.workspaceFolders;
        if (folders2 === void 0) {
          return null;
        }
        let result = folders2.map((folder) => this.asProtocol(folder));
        return result;
      };
      let middleware = client8.clientOptions.middleware.workspace;
      return middleware && middleware.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders2) : workspaceFolders2(token);
    });
    let value = access(access(access(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
    let id;
    if (typeof value === "string") {
      id = value;
    } else if (value === true) {
      id = generateUuid();
    }
    if (id) {
      this.register(this.messages, {
        id,
        registerOptions: void 0
      });
    }
  }
  doSendEvent(addedFolders, removedFolders) {
    let params = {
      event: {
        added: addedFolders.map((folder) => this.asProtocol(folder)),
        removed: removedFolders.map((folder) => this.asProtocol(folder))
      }
    };
    this._client.sendNotification(vscode_languageserver_protocol51.DidChangeWorkspaceFoldersNotification.type, params);
  }
  sendInitialEvent(currentWorkspaceFolders) {
    if (this._initialFolders && currentWorkspaceFolders) {
      const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
      const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
      if (added.length > 0 || removed.length > 0) {
        this.doSendEvent(added, removed);
      }
    } else if (this._initialFolders) {
      this.doSendEvent([], this._initialFolders);
    } else if (currentWorkspaceFolders) {
      this.doSendEvent(currentWorkspaceFolders, []);
    }
  }
  register(_message, data) {
    let id = data.id;
    let client8 = this._client;
    let disposable = workspace_default.onDidChangeWorkspaceFolders((event) => {
      let didChangeWorkspaceFolders = (event2) => {
        this.doSendEvent(event2.added, event2.removed);
      };
      let middleware = client8.clientOptions.middleware.workspace;
      middleware && middleware.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
    });
    this._listeners.set(id, disposable);
    this.sendInitialEvent(workspace_default.workspaceFolders);
  }
  unregister(id) {
    let disposable = this._listeners.get(id);
    if (disposable === void 0) {
      return;
    }
    this._listeners.delete(id);
    disposable.dispose();
  }
  dispose() {
    for (let disposable of this._listeners.values()) {
      disposable.dispose();
    }
    this._listeners.clear();
  }
};

// src/language-client/selectionRange.ts
var vscode_languageserver_protocol52 = __toModule(require_main3());
"use strict";
function ensure8(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var SelectionRangeFeature = class extends TextDocumentFeature {
  constructor(client8) {
    super(client8, vscode_languageserver_protocol52.SelectionRangeRequest.type);
  }
  fillClientCapabilities(capabilites) {
    let capability = ensure8(ensure8(capabilites, "textDocument"), "selectionRange");
    capability.dynamicRegistration = true;
  }
  initialize(capabilities, documentSelector) {
    let [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
    if (!id || !options) {
      return;
    }
    this.register(this.messages, {id, registerOptions: options});
  }
  registerLanguageProvider(options) {
    const provider = {
      provideSelectionRanges: (document3, positions2, token) => {
        const client8 = this._client;
        const provideSelectionRanges = (document4, positions3, token2) => {
          const requestParams = {
            textDocument: {uri: document4.uri},
            positions: positions3
          };
          return client8.sendRequest(vscode_languageserver_protocol52.SelectionRangeRequest.type, requestParams, token2).then((ranges) => ranges, (error) => {
            client8.logFailedRequest(vscode_languageserver_protocol52.SelectionRangeRequest.type, error);
            return Promise.resolve(null);
          });
        };
        const middleware = client8.clientOptions.middleware;
        return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document3, positions2, token, provideSelectionRanges) : provideSelectionRanges(document3, positions2, token);
      }
    };
    return [languages_default.registerSelectionRangeProvider(options.documentSelector, provider), provider];
  }
};

// src/language-client/index.ts
var ChildProcess2 = child_process4.default.ChildProcess;
var logger47 = require_logger2()("language-client-index");
var Executable;
(function(Executable3) {
  function is6(value) {
    return string(value.command);
  }
  Executable3.is = is6;
})(Executable || (Executable = {}));
var TransportKind;
(function(TransportKind2) {
  TransportKind2[TransportKind2["stdio"] = 0] = "stdio";
  TransportKind2[TransportKind2["ipc"] = 1] = "ipc";
  TransportKind2[TransportKind2["pipe"] = 2] = "pipe";
  TransportKind2[TransportKind2["socket"] = 3] = "socket";
})(TransportKind || (TransportKind = {}));
var Transport;
(function(Transport3) {
  function isSocket(value) {
    let candidate = value;
    return candidate && candidate.kind === 3 && number(candidate.port);
  }
  Transport3.isSocket = isSocket;
})(Transport || (Transport = {}));
var NodeModule;
(function(NodeModule2) {
  function is6(value) {
    return string(value.module);
  }
  NodeModule2.is = is6;
})(NodeModule || (NodeModule = {}));
var StreamInfo;
(function(StreamInfo2) {
  function is6(value) {
    let candidate = value;
    return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
  }
  StreamInfo2.is = is6;
})(StreamInfo || (StreamInfo = {}));
var ChildProcessInfo;
(function(ChildProcessInfo2) {
  function is6(value) {
    let candidate = value;
    return candidate && candidate.process !== void 0 && typeof candidate.detached === "boolean";
  }
  ChildProcessInfo2.is = is6;
})(ChildProcessInfo || (ChildProcessInfo = {}));
var LanguageClient = class extends BaseLanguageClient {
  constructor(arg1, arg2, arg3, arg4, arg5) {
    let id;
    let name2;
    let serverOptions;
    let clientOptions;
    let forceDebug;
    if (string(arg2)) {
      id = arg1;
      name2 = arg2;
      serverOptions = arg3;
      clientOptions = arg4;
      forceDebug = !!arg5;
    } else {
      id = arg1.toLowerCase();
      name2 = arg1;
      serverOptions = arg2;
      clientOptions = arg3;
      forceDebug = arg4;
    }
    if (forceDebug === void 0) {
      forceDebug = false;
    }
    super(id, name2, clientOptions);
    this._serverOptions = serverOptions;
    this._forceDebug = forceDebug;
    this.registerProposedFeatures();
  }
  stop() {
    return super.stop().then(() => {
      if (this._serverProcess) {
        let toCheck = this._serverProcess;
        this._serverProcess = void 0;
        if (this._isDetached === void 0 || !this._isDetached) {
          this.checkProcessDied(toCheck);
        }
        this._isDetached = void 0;
      }
    });
  }
  get serviceState() {
    let state = this._state;
    switch (state) {
      case ClientState.Initial:
        return ServiceStat.Initial;
      case ClientState.Running:
        return ServiceStat.Running;
      case ClientState.StartFailed:
        return ServiceStat.StartFailed;
      case ClientState.Starting:
        return ServiceStat.Starting;
      case ClientState.Stopped:
        return ServiceStat.Stopped;
      case ClientState.Stopping:
        return ServiceStat.Stopping;
      default:
        logger47.error(`Unknown state: ${state}`);
        return ServiceStat.Stopped;
    }
  }
  static stateName(state) {
    switch (state) {
      case ClientState.Initial:
        return "Initial";
      case ClientState.Running:
        return "Running";
      case ClientState.StartFailed:
        return "StartFailed";
      case ClientState.Starting:
        return "Starting";
      case ClientState.Stopped:
        return "Stopped";
      case ClientState.Stopping:
        return "Stopping";
      default:
        return "Unknonw";
    }
  }
  checkProcessDied(childProcess) {
    if (!childProcess || global.hasOwnProperty("__TEST__"))
      return;
    if (global.hasOwnProperty("__TEST__")) {
      process.kill(childProcess.pid, 0);
      return;
    }
    setTimeout(() => {
      try {
        process.kill(childProcess.pid, 0);
        terminate(childProcess);
      } catch (error) {
      }
    }, 2e3);
  }
  handleConnectionClosed() {
    this._serverProcess = void 0;
    super.handleConnectionClosed();
  }
  createMessageTransports(encoding) {
    function getEnvironment(env2) {
      if (!env2)
        return process.env;
      return Object.assign({}, process.env, env2);
    }
    function startedInDebugMode() {
      let args = process.execArgv;
      if (args) {
        return args.some((arg) => /^--debug=?/.test(arg) || /^--debug-brk=?/.test(arg) || /^--inspect=?/.test(arg) || /^--inspect-brk=?/.test(arg));
      }
      return false;
    }
    let server = this._serverOptions;
    if (func(server)) {
      return server().then((result) => {
        if (MessageTransports.is(result)) {
          this._isDetached = !!result.detached;
          return result;
        } else if (StreamInfo.is(result)) {
          this._isDetached = !!result.detached;
          return {
            reader: new vscode_languageserver_protocol53.StreamMessageReader(result.reader),
            writer: new vscode_languageserver_protocol53.StreamMessageWriter(result.writer)
          };
        } else {
          let cp3;
          if (ChildProcessInfo.is(result)) {
            cp3 = result.process;
            this._isDetached = result.detached;
          } else {
            cp3 = result;
            this._isDetached = false;
          }
          cp3.stderr.on("data", (data) => this.appendOutput(data, encoding));
          return {
            reader: new vscode_languageserver_protocol53.StreamMessageReader(cp3.stdout),
            writer: new vscode_languageserver_protocol53.StreamMessageWriter(cp3.stdin)
          };
        }
      });
    }
    let json = server;
    let runDebug = server;
    if (runDebug.run || runDebug.debug) {
      if (typeof v8debug === "object" || this._forceDebug || startedInDebugMode()) {
        json = runDebug.debug;
      } else {
        json = runDebug.run;
      }
    } else {
      json = server;
    }
    return this._getServerWorkingDir(json.options).then((serverWorkingDir) => {
      if (NodeModule.is(json) && json.module) {
        let node = json;
        let transport = node.transport || 0;
        let args = [];
        let options = node.options || Object.create(null);
        let runtime = node.runtime || process.execPath;
        if (options.execArgv)
          options.execArgv.forEach((element) => args.push(element));
        if (transport != 1)
          args.push(node.module);
        if (node.args)
          node.args.forEach((element) => args.push(element));
        let execOptions = Object.create(null);
        execOptions.cwd = serverWorkingDir;
        execOptions.env = getEnvironment(options.env);
        let pipeName;
        if (transport === 1) {
          execOptions.stdio = [null, null, null];
          args.push("--node-ipc");
        } else if (transport === 0) {
          args.push("--stdio");
        } else if (transport === 2) {
          pipeName = vscode_languageserver_protocol53.generateRandomPipeName();
          args.push(`--pipe=${pipeName}`);
        } else if (Transport.isSocket(transport)) {
          args.push(`--socket=${transport.port}`);
        }
        args.push(`--clientProcessId=${process.pid.toString()}`);
        if (transport === 1) {
          let forkOptions = {
            cwd: serverWorkingDir,
            env: getEnvironment(options.env),
            stdio: [null, null, null, "ipc"],
            execPath: runtime,
            execArgv: options.execArgv || []
          };
          let serverProcess = child_process4.default.fork(node.module, args, forkOptions);
          if (!serverProcess || !serverProcess.pid) {
            return Promise.reject(`Launching server module "${node.module}" failed.`);
          }
          serverProcess.on("error", (e) => {
            logger47.error(e);
          });
          logger47.info(`${this.id} started with ${serverProcess.pid}`);
          this._serverProcess = serverProcess;
          serverProcess.stdout.on("data", (data) => this.appendOutput(data, encoding));
          serverProcess.stderr.on("data", (data) => this.appendOutput(data, encoding));
          return {
            reader: new vscode_languageserver_protocol53.IPCMessageReader(serverProcess),
            writer: new vscode_languageserver_protocol53.IPCMessageWriter(serverProcess)
          };
        } else if (transport === 0) {
          let serverProcess = child_process4.default.spawn(runtime, args, execOptions);
          if (!serverProcess || !serverProcess.pid) {
            return Promise.reject(`Launching server module "${node.module}" failed.`);
          }
          logger47.info(`${this.id} started with ${serverProcess.pid}`);
          serverProcess.on("error", (e) => {
            logger47.error(`Process ${runtime} error: `, e);
          });
          this._serverProcess = serverProcess;
          serverProcess.stderr.on("data", (data) => this.appendOutput(data, encoding));
          return {
            reader: new vscode_languageserver_protocol53.StreamMessageReader(serverProcess.stdout),
            writer: new vscode_languageserver_protocol53.StreamMessageWriter(serverProcess.stdin)
          };
        } else if (transport == 2) {
          return Promise.resolve(vscode_languageserver_protocol53.createClientPipeTransport(pipeName)).then((transport2) => {
            let process2 = child_process4.default.spawn(runtime, args, execOptions);
            if (!process2 || !process2.pid) {
              return Promise.reject(`Launching server module "${node.module}" failed.`);
            }
            logger47.info(`Language server ${this.id} started with ${process2.pid}`);
            this._serverProcess = process2;
            process2.stderr.on("data", (data) => this.appendOutput(data, encoding));
            process2.stdout.on("data", (data) => this.appendOutput(data, encoding));
            return Promise.resolve(transport2.onConnected()).then((protocol) => ({reader: protocol[0], writer: protocol[1]}));
          });
        } else if (Transport.isSocket(node.transport)) {
          return Promise.resolve(vscode_languageserver_protocol53.createClientSocketTransport(node.transport.port)).then((transport2) => {
            let process2 = child_process4.default.spawn(runtime, args, execOptions);
            if (!process2 || !process2.pid) {
              return Promise.reject(`Launching server ${node.module} failed.`);
            }
            process2.on("exit", (code) => {
              if (code != 0)
                this.error(`command "${runtime} ${args.join(" ")}" exited with code: ${code}`);
            });
            logger47.info(`Language server ${this.id} started with ${process2.pid}`);
            this._serverProcess = process2;
            process2.stderr.on("data", (data) => this.appendOutput(data, encoding));
            process2.stdout.on("data", (data) => this.appendOutput(data, encoding));
            return Promise.resolve(transport2.onConnected()).then((protocol) => ({reader: protocol[0], writer: protocol[1]}));
          });
        }
      } else if (Executable.is(json) && json.command) {
        let command = json;
        let args = command.args || [];
        let options = Object.assign({}, command.options);
        options.env = options.env ? Object.assign({}, process.env, options.env) : process.env;
        options.cwd = serverWorkingDir;
        let cmd = workspace_default.expand(json.command);
        let serverProcess = child_process4.default.spawn(cmd, args, options);
        serverProcess.on("error", (e) => {
          logger47.error(e);
        });
        if (!serverProcess || !serverProcess.pid) {
          return Promise.reject(`Launching server "${this.id}" using command ${command.command} failed.`);
        }
        logger47.info(`Language server "${this.id}" started with ${serverProcess.pid}`);
        serverProcess.on("exit", (code) => {
          if (code != 0)
            this.error(`${command.command} exited with code: ${code}`);
        });
        serverProcess.stderr.on("data", (data) => this.appendOutput(data, encoding));
        this._serverProcess = serverProcess;
        this._isDetached = !!options.detached;
        return {
          reader: new vscode_languageserver_protocol53.StreamMessageReader(serverProcess.stdout),
          writer: new vscode_languageserver_protocol53.StreamMessageWriter(serverProcess.stdin)
        };
      }
      return Promise.reject(`Unsupported server configuration ${JSON.stringify(server, null, 2)}`);
    });
  }
  registerProposedFeatures() {
    this.registerFeatures(ProposedFeatures.createAll(this));
  }
  registerBuiltinFeatures() {
    super.registerBuiltinFeatures();
    this.registerFeature(new ConfigurationFeature2(this));
    this.registerFeature(new TypeDefinitionFeature(this));
    this.registerFeature(new ImplementationFeature(this));
    this.registerFeature(new DeclarationFeature(this));
    this.registerFeature(new ColorProviderFeature(this));
    this.registerFeature(new FoldingRangeFeature(this));
    this.registerFeature(new SelectionRangeFeature(this));
    this.registerFeature(new ProgressFeature(this));
    if (!this.clientOptions.disableWorkspaceFolders) {
      this.registerFeature(new WorkspaceFoldersFeature(this));
    }
  }
  _getServerWorkingDir(options) {
    let cwd = options && options.cwd;
    if (cwd && !path32.default.isAbsolute(cwd))
      cwd = path32.default.join(workspace_default.cwd, cwd);
    if (!cwd)
      cwd = workspace_default.cwd;
    if (cwd) {
      return new Promise((s) => {
        fs29.default.lstat(cwd, (err, stats) => {
          s(!err && stats.isDirectory() ? cwd : void 0);
        });
      });
    }
    return Promise.resolve(void 0);
  }
  appendOutput(data, encoding) {
    let msg = string(data) ? data : data.toString(encoding);
    this.outputChannel.append(msg.endsWith("\n") ? msg : msg + "\n");
  }
};
var SettingMonitor = class {
  constructor(_client, _setting) {
    this._client = _client;
    this._setting = _setting;
    this._listeners = [];
  }
  start() {
    workspace_default.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(this._setting)) {
        this.onDidChangeConfiguration();
      }
    }, null, this._listeners);
    this.onDidChangeConfiguration();
    return {
      dispose: () => {
        disposeAll(this._listeners);
        if (this._client.needsStop()) {
          this._client.stop();
        }
      }
    };
  }
  onDidChangeConfiguration() {
    let index = this._setting.indexOf(".");
    let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
    let rest = index >= 0 ? this._setting.substr(index + 1) : void 0;
    let enabled = rest ? workspace_default.getConfiguration(primary).get(rest, true) : workspace_default.getConfiguration(primary);
    if (enabled && this._client.needsStart()) {
      this._client.start();
    } else if (!enabled && this._client.needsStop()) {
      this._client.stop();
    }
  }
};
var ProposedFeatures;
(function(ProposedFeatures2) {
  function createAll(_client) {
    let result = [];
    return result;
  }
  ProposedFeatures2.createAll = createAll;
})(ProposedFeatures || (ProposedFeatures = {}));

// src/services.ts
var logger48 = require_logger2()("services");
function getStateName(state) {
  switch (state) {
    case ServiceStat.Initial:
      return "init";
    case ServiceStat.Running:
      return "running";
    case ServiceStat.Starting:
      return "starting";
    case ServiceStat.StartFailed:
      return "startFailed";
    case ServiceStat.Stopping:
      return "stopping";
    case ServiceStat.Stopped:
      return "stopped";
    default:
      return "unknown";
  }
}
var ServiceManager = class extends events14.EventEmitter {
  constructor() {
    super(...arguments);
    this.registered = new Map();
    this.disposables = [];
  }
  init() {
    workspace_default.onDidOpenTextDocument((document3) => {
      this.start(document3);
    }, null, this.disposables);
    workspace_default.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("languageserver")) {
        this.createCustomServices();
      }
    }, null, this.disposables);
    this.createCustomServices();
  }
  dispose() {
    this.removeAllListeners();
    disposeAll(this.disposables);
    for (let service of this.registered.values()) {
      service.dispose();
    }
  }
  regist(service) {
    let {id} = service;
    if (!id)
      logger48.error("invalid service configuration. ", service.name);
    if (this.registered.get(id))
      return;
    this.registered.set(id, service);
    logger48.info(`registered service "${id}"`);
    if (this.shouldStart(service)) {
      service.start();
    }
    if (service.state == ServiceStat.Running) {
      this.emit("ready", id);
    }
    service.onServiceReady(() => {
      logger48.info(`service ${id} started`);
      this.emit("ready", id);
    }, null, this.disposables);
    return vscode_languageserver_protocol54.Disposable.create(() => {
      service.stop();
      service.dispose();
      this.registered.delete(id);
    });
  }
  getService(id) {
    let service = this.registered.get(id);
    if (!service)
      service = this.registered.get(`languageserver.${id}`);
    return service;
  }
  shouldStart(service) {
    if (service.state != ServiceStat.Initial) {
      return false;
    }
    let selector = service.selector;
    for (let doc of workspace_default.documents) {
      if (workspace_default.match(selector, doc.textDocument)) {
        return true;
      }
    }
    return false;
  }
  start(document3) {
    let services5 = this.getServices(document3);
    for (let service of services5) {
      if (service.state == ServiceStat.Initial) {
        service.start();
      }
    }
  }
  getServices(document3) {
    let res = [];
    for (let service of this.registered.values()) {
      if (workspace_default.match(service.selector, document3) > 0) {
        res.push(service);
      }
    }
    return res;
  }
  stop(id) {
    let service = this.registered.get(id);
    if (!service) {
      window_default.showMessage(`Service ${id} not found`, "error");
      return;
    }
    return Promise.resolve(service.stop());
  }
  stopAll() {
    for (let service of this.registered.values()) {
      service.stop();
    }
  }
  async toggle(id) {
    let service = this.registered.get(id);
    if (!service) {
      window_default.showMessage(`Service ${id} not found`, "error");
      return;
    }
    let {state} = service;
    try {
      if (state == ServiceStat.Running) {
        await Promise.resolve(service.stop());
      } else if (state == ServiceStat.Initial) {
        await service.start();
      } else if (state == ServiceStat.Stopped) {
        await service.restart();
      }
    } catch (e) {
      window_default.showMessage(`Service error: ${e.message}`, "error");
    }
  }
  getServiceStats() {
    let res = [];
    for (let [id, service] of this.registered) {
      res.push({
        id,
        languageIds: documentSelectorToLanguageIds(service.selector),
        state: getStateName(service.state)
      });
    }
    return res;
  }
  createCustomServices() {
    let lspConfig = workspace_default.getConfiguration().get("languageserver", {});
    for (let key of Object.keys(lspConfig)) {
      let config = lspConfig[key];
      this.registLanguageClient(key, config);
    }
  }
  waitClient(id) {
    let service = this.getService(id);
    if (service && service.state == ServiceStat.Running)
      return Promise.resolve();
    if (service)
      return new Promise((resolve3) => {
        service.onServiceReady(() => {
          resolve3();
        });
      });
    return new Promise((resolve3) => {
      let listener = (clientId) => {
        if (clientId == id || clientId == `languageserver.${id}`) {
          this.off("ready", listener);
          resolve3();
        }
      };
      this.on("ready", listener);
    });
  }
  async registNotification(id, method) {
    await this.waitClient(id);
    let service = this.getService(id);
    if (!service.client) {
      window_default.showMessage(`Not a language client: ${id}`, "error");
      return;
    }
    let client8 = service.client;
    client8.onNotification(method, async (result) => {
      await workspace_default.nvim.call("coc#do_notify", [id, method, result]);
    });
  }
  async sendNotification(id, method, params) {
    if (!method)
      throw new Error(`method required for ontification`);
    let service = this.getService(id);
    if (!service || !service.client)
      throw new Error(`Language server ${id} not found`);
    if (service.state == ServiceStat.Starting) {
      await service.client.onReady();
    }
    if (service.state != ServiceStat.Running) {
      throw new Error(`Language server ${id} not running`);
    }
    await Promise.resolve(service.client.sendNotification(method, params));
  }
  async sendRequest(id, method, params, token) {
    if (!method)
      throw new Error(`method required for sendRequest`);
    let service = this.getService(id);
    if (!service)
      await wait(100);
    service = this.getService(id);
    if (!service || !service.client) {
      throw new Error(`Language server ${id} not found`);
    }
    if (service.state == ServiceStat.Starting) {
      await service.client.onReady();
    }
    if (service.state != ServiceStat.Running) {
      throw new Error(`Language server ${id} not running`);
    }
    if (!token) {
      let tokenSource = new vscode_languageserver_protocol54.CancellationTokenSource();
      token = tokenSource.token;
    }
    return await Promise.resolve(service.client.sendRequest(method, params, token));
  }
  registLanguageClient(name2, config) {
    let id = typeof name2 === "string" ? `languageserver.${name2}` : name2.id;
    let disposables = [];
    let onDidServiceReady = new vscode_languageserver_protocol54.Emitter();
    let client8 = typeof name2 === "string" ? null : name2;
    if (this.registered.has(id))
      return;
    let created = false;
    let service = {
      id,
      client: client8,
      name: typeof name2 === "string" ? name2 : name2.name,
      selector: typeof name2 === "string" ? getDocumentSelector(config.filetypes, config.additionalSchemes) : name2.clientOptions.documentSelector,
      state: ServiceStat.Initial,
      onServiceReady: onDidServiceReady.event,
      start: () => {
        if (service.state == ServiceStat.Starting || service.state == ServiceStat.Running) {
          return;
        }
        if (client8 && !client8.needsStart()) {
          return;
        }
        if (created && client8) {
          client8.restart();
          return Promise.resolve();
        }
        if (!created) {
          if (typeof name2 == "string" && !client8) {
            let config2 = workspace_default.getConfiguration().get("languageserver", {})[name2];
            if (!config2 || config2.enable === false)
              return;
            let opts = getLanguageServerOptions(id, name2, config2);
            if (!opts)
              return;
            client8 = new LanguageClient(id, name2, opts[1], opts[0]);
            service.selector = opts[0].documentSelector;
            service.client = client8;
          }
          client8.onDidChangeState((changeEvent) => {
            let {oldState, newState} = changeEvent;
            if (newState == State2.Starting) {
              service.state = ServiceStat.Starting;
            } else if (newState == State2.Running) {
              service.state = ServiceStat.Running;
            } else if (newState == State2.Stopped) {
              service.state = ServiceStat.Stopped;
            }
            let oldStr = stateString(oldState);
            let newStr = stateString(newState);
            logger48.info(`${client8.name} state change: ${oldStr} => ${newStr}`);
          }, null, disposables);
          created = true;
        }
        service.state = ServiceStat.Starting;
        logger48.debug(`starting service: ${id}`);
        let disposable = client8.start();
        disposables.push(disposable);
        return new Promise((resolve3) => {
          client8.onReady().then(() => {
            onDidServiceReady.fire(void 0);
            resolve3();
          }, (e) => {
            window_default.showMessage(`Server ${id} failed to start: ${e}`, "error");
            logger48.error(`Server ${id} failed to start:`, e);
            service.state = ServiceStat.StartFailed;
            resolve3();
          });
        });
      },
      dispose: async () => {
        onDidServiceReady.dispose();
        disposeAll(disposables);
      },
      stop: async () => {
        if (!client8 || !client8.needsStop())
          return;
        await Promise.resolve(client8.stop());
      },
      restart: async () => {
        if (client8) {
          service.state = ServiceStat.Starting;
          client8.restart();
        } else {
          await service.start();
        }
      }
    };
    return this.regist(service);
  }
};
function documentSelectorToLanguageIds(documentSelector) {
  let res = documentSelector.map((filter) => {
    if (typeof filter == "string") {
      return filter;
    }
    return filter.language;
  });
  res = res.filter((s) => typeof s == "string");
  return Array.from(new Set(res));
}
function getLanguageServerOptions(id, name2, config) {
  let {command, module: module2, port, args, filetypes} = config;
  args = args || [];
  if (!filetypes) {
    window_default.showMessage(`Wrong configuration of LS "${name2}", filetypes not found`, "error");
    return null;
  }
  if (!command && !module2 && !port) {
    window_default.showMessage(`Wrong configuration of LS "${name2}", no command or module specified.`, "error");
    return null;
  }
  let serverOptions;
  if (module2) {
    module2 = workspace_default.expand(module2);
    if (!fs31.default.existsSync(module2)) {
      window_default.showMessage(`Module file "${module2}" not found for LS "${name2}"`, "error");
      return null;
    }
    serverOptions = {
      module: module2,
      runtime: config.runtime || process.execPath,
      args,
      transport: getTransportKind(config),
      options: getForkOptions(config)
    };
  } else if (command) {
    serverOptions = {
      command,
      args,
      options: getSpawnOptions(config)
    };
  } else if (port) {
    serverOptions = () => new Promise((resolve3, reject) => {
      let client8 = new net3.default.Socket();
      let host = config.host || "127.0.0.1";
      logger48.info(`languageserver "${id}" connecting to ${host}:${port}`);
      client8.connect(port, host, () => {
        resolve3({
          reader: client8,
          writer: client8
        });
      });
      client8.on("error", (e) => {
        reject(new Error(`Connection error for ${id}: ${e.message}`));
      });
    });
  }
  let disableWorkspaceFolders = !!config.disableWorkspaceFolders;
  let disableSnippetCompletion = !!config.disableSnippetCompletion;
  let ignoredRootPaths = config.ignoredRootPaths || [];
  let clientOptions = {
    ignoredRootPaths: ignoredRootPaths.map((s) => workspace_default.expand(s)),
    disableWorkspaceFolders,
    disableSnippetCompletion,
    disableDynamicRegister: !!config.disableDynamicRegister,
    disableCompletion: !!config.disableCompletion,
    disableDiagnostics: !!config.disableDiagnostics,
    formatterPriority: config.formatterPriority || 0,
    documentSelector: getDocumentSelector(config.filetypes, config.additionalSchemes),
    revealOutputChannelOn: getRevealOutputChannelOn(config.revealOutputChannelOn),
    synchronize: {
      configurationSection: `${id}.settings`
    },
    diagnosticCollectionName: name2,
    outputChannelName: id,
    stdioEncoding: config.stdioEncoding || "utf8",
    progressOnInitialization: config.progressOnInitialization !== false,
    initializationOptions: config.initializationOptions || {}
  };
  return [clientOptions, serverOptions];
}
function getRevealOutputChannelOn(revealOn) {
  switch (revealOn) {
    case "info":
      return RevealOutputChannelOn.Info;
    case "warn":
      return RevealOutputChannelOn.Warn;
    case "error":
      return RevealOutputChannelOn.Error;
    case "never":
      return RevealOutputChannelOn.Never;
    default:
      return RevealOutputChannelOn.Never;
  }
}
function getDocumentSelector(filetypes, additionalSchemes) {
  let documentSelector = [];
  let schemes = ["file", "untitled"].concat(additionalSchemes || []);
  if (!filetypes)
    return schemes.map((s) => ({scheme: s}));
  filetypes.forEach((filetype) => {
    documentSelector.push(...schemes.map((scheme) => ({language: filetype, scheme})));
  });
  return documentSelector;
}
function getTransportKind(config) {
  let {transport, transportPort} = config;
  if (!transport || transport == "ipc")
    return TransportKind.ipc;
  if (transport == "stdio")
    return TransportKind.stdio;
  if (transport == "pipe")
    return TransportKind.pipe;
  return {kind: TransportKind.socket, port: transportPort};
}
function getForkOptions(config) {
  return {
    cwd: config.cwd,
    execArgv: config.execArgv || [],
    env: config.env || void 0
  };
}
function getSpawnOptions(config) {
  return {
    cwd: config.cwd,
    detached: !!config.detached,
    shell: !!config.shell,
    env: config.env || void 0
  };
}
function stateString(state) {
  switch (state) {
    case State2.Running:
      return "running";
    case State2.Starting:
      return "starting";
    case State2.Stopped:
      return "stopped";
    default:
      return "unknown";
  }
}
var services_default = new ServiceManager();

// src/list/manager.ts
var debounce15 = __toModule(require_debounce());
var vscode_languageserver_protocol62 = __toModule(require_main3());

// src/list/configuration.ts
var events15 = __toModule(require("events"));
var validKeys = [
  "<esc>",
  "<space>",
  "<tab>",
  "<s-tab>",
  "<bs>",
  "<right>",
  "<left>",
  "<up>",
  "<down>",
  "<home>",
  "<end>",
  "<cr>",
  "<FocusGained>",
  "<ScrollWheelUp>",
  "<ScrollWheelDown>",
  "<LeftMouse>",
  "<LeftDrag>",
  "<LeftRelease>",
  "<2-LeftMouse>",
  "<C-a>",
  "<C-b>",
  "<C-c>",
  "<C-d>",
  "<C-e>",
  "<C-f>",
  "<C-g>",
  "<C-h>",
  "<C-i>",
  "<C-j>",
  "<C-k>",
  "<C-l>",
  "<C-m>",
  "<C-n>",
  "<C-o>",
  "<C-p>",
  "<C-q>",
  "<C-r>",
  "<C-s>",
  "<C-t>",
  "<C-u>",
  "<C-v>",
  "<C-w>",
  "<C-x>",
  "<C-y>",
  "<C-z>",
  "<A-a>",
  "<A-b>",
  "<A-c>",
  "<A-d>",
  "<A-e>",
  "<A-f>",
  "<A-g>",
  "<A-h>",
  "<A-i>",
  "<A-j>",
  "<A-k>",
  "<A-l>",
  "<A-m>",
  "<A-n>",
  "<A-o>",
  "<A-p>",
  "<A-q>",
  "<A-r>",
  "<A-s>",
  "<A-t>",
  "<A-u>",
  "<A-v>",
  "<A-w>",
  "<A-x>",
  "<A-y>",
  "<A-z>"
];
var ListConfiguration = class extends events15.EventEmitter {
  constructor() {
    super();
    this.configuration = workspace_default.getConfiguration("list");
    this.disposable = workspace_default.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("list")) {
        this.configuration = workspace_default.getConfiguration("list");
        this.emit("change");
      }
    });
  }
  get(key, defaultValue) {
    return this.configuration.get(key, defaultValue);
  }
  get previousKey() {
    return this.fixKey(this.configuration.get("previousKeymap", "<C-j>"));
  }
  get nextKey() {
    return this.fixKey(this.configuration.get("nextKeymap", "<C-k>"));
  }
  dispose() {
    this.disposable.dispose();
    this.removeAllListeners();
  }
  fixKey(key) {
    if (validKeys.includes(key))
      return key;
    let find = validKeys.find((s) => s.toLowerCase() == key.toLowerCase());
    if (find)
      return find;
    window_default.showMessage(`Configured key "${key}" not supported.`, "error");
    return null;
  }
};
var configuration_default2 = ListConfiguration;

// src/list/mappings.ts
var logger49 = require_logger2()("list-mappings");
var Mappings = class {
  constructor(manager31, nvim, config) {
    this.manager = manager31;
    this.nvim = nvim;
    this.config = config;
    this.insertMappings = new Map();
    this.normalMappings = new Map();
    this.userInsertMappings = new Map();
    this.userNormalMappings = new Map();
    let {prompt: prompt2} = manager31;
    this.add("insert", "<C-k>", () => {
      prompt2.removeTail();
    });
    this.add("insert", "<C-n>", () => {
      var _a2;
      (_a2 = manager31.session) == null ? void 0 : _a2.history.next();
    });
    this.add("insert", "<C-p>", () => {
      var _a2;
      (_a2 = manager31.session) == null ? void 0 : _a2.history.previous();
    });
    this.add("insert", "<C-v>", async () => {
      await prompt2.paste();
    });
    this.add("insert", "<C-s>", () => manager31.switchMatcher());
    this.add("insert", ["<C-m>", "<cr>"], async () => {
      await manager31.doAction();
    });
    this.add("insert", ["<tab>", "<C-i>", "	"], () => manager31.chooseAction());
    this.add("insert", "<C-o>", () => {
      manager31.toggleMode();
    });
    this.add("insert", "<C-c>", () => {
      manager31.stop();
      return;
    });
    this.add("insert", "<esc>", () => manager31.cancel());
    this.add("insert", "<C-l>", async () => {
      var _a2;
      await ((_a2 = manager31.session) == null ? void 0 : _a2.reloadItems());
    });
    this.add("insert", "<left>", () => {
      prompt2.moveLeft();
    });
    this.add("insert", "<right>", () => {
      prompt2.moveRight();
    });
    this.add("insert", ["<end>", "<C-e>"], () => {
      prompt2.moveToEnd();
    });
    this.add("insert", ["<home>", "<C-a>"], () => {
      prompt2.moveToStart();
    });
    this.add("insert", ["<C-h>", "<bs>", "<backspace>"], () => {
      prompt2.onBackspace();
    });
    this.add("insert", "<C-w>", () => {
      prompt2.removeWord();
    });
    this.add("insert", "<C-u>", () => {
      prompt2.removeAhead();
    });
    this.add("insert", "<C-r>", () => prompt2.insertRegister());
    this.add("insert", "<C-d>", () => manager31.feedkeys("<C-d>", false));
    this.add("insert", "<PageUp>", () => manager31.feedkeys("<PageUp>", false));
    this.add("insert", "<PageDown>", () => manager31.feedkeys("<PageDown>", false));
    this.add("insert", "<down>", () => manager31.normal("j"));
    this.add("insert", "<up>", () => manager31.normal("k"));
    this.add("insert", ["<ScrollWheelUp>"], this.doScroll.bind(this, "<ScrollWheelUp>"));
    this.add("insert", ["<ScrollWheelDown>"], this.doScroll.bind(this, "<ScrollWheelDown>"));
    this.add("insert", ["<C-f>"], this.doScroll.bind(this, "<C-f>"));
    this.add("insert", ["<C-b>"], this.doScroll.bind(this, "<C-b>"));
    this.add("normal", "<C-o>", () => {
    });
    this.add("normal", "t", () => manager31.doAction("tabe"));
    this.add("normal", "s", () => manager31.doAction("split"));
    this.add("normal", "d", () => manager31.doAction("drop"));
    this.add("normal", ["<cr>", "<C-m>", "\r"], () => manager31.doAction());
    this.add("normal", "<C-a>", () => {
      var _a2;
      return (_a2 = manager31.session) == null ? void 0 : _a2.ui.selectAll();
    });
    this.add("normal", " ", () => {
      var _a2;
      return (_a2 = manager31.session) == null ? void 0 : _a2.ui.toggleSelection();
    });
    this.add("normal", "p", () => manager31.togglePreview());
    this.add("normal", ["<tab>", "	", "<C-i>"], () => manager31.chooseAction());
    this.add("normal", "<C-c>", () => {
      manager31.stop();
    });
    this.add("normal", "<esc>", () => manager31.cancel());
    this.add("normal", "<C-l>", () => {
      var _a2;
      return (_a2 = manager31.session) == null ? void 0 : _a2.reloadItems();
    });
    this.add("normal", "<C-o>", () => {
      var _a2;
      return (_a2 = manager31.session) == null ? void 0 : _a2.jumpBack();
    });
    this.add("normal", "<C-e>", () => this.scrollPreview("down"));
    this.add("normal", "<C-y>", () => this.scrollPreview("up"));
    this.add("normal", ["i", "I", "o", "O", "a", "A"], () => manager31.toggleMode());
    this.add("normal", "?", () => {
      var _a2;
      return (_a2 = manager31.session) == null ? void 0 : _a2.showHelp();
    });
    this.add("normal", ":", async () => {
      await manager31.cancel(false);
      await nvim.eval('feedkeys(":")');
    });
    this.add("normal", ["<ScrollWheelUp>"], this.doScroll.bind(this, "<ScrollWheelUp>"));
    this.add("normal", ["<ScrollWheelDown>"], this.doScroll.bind(this, "<ScrollWheelDown>"));
    this.createMappings();
    config.on("change", () => {
      this.createMappings();
    });
  }
  createMappings() {
    let insertMappings = this.config.get("insertMappings", {});
    this.userInsertMappings = this.fixUserMappings(insertMappings);
    let normalMappings = this.config.get("normalMappings", {});
    this.userNormalMappings = this.fixUserMappings(normalMappings);
  }
  fixUserMappings(mappings2) {
    let res = new Map();
    for (let [key, value] of Object.entries(mappings2)) {
      if (key.length == 1) {
        res.set(key, value);
      } else if (key.startsWith("<") && key.endsWith(">")) {
        if (key.toLowerCase() == "<space>") {
          res.set(" ", value);
        } else if (key.toLowerCase() == "<backspace>") {
          res.set("<bs>", value);
        } else if (validKeys.includes(key)) {
          res.set(key, value);
        } else {
          let find = false;
          for (let i = 0; i < validKeys.length; i++) {
            if (validKeys[i].toLowerCase() == key.toLowerCase()) {
              find = true;
              res.set(validKeys[i], value);
              break;
            }
          }
          if (!find)
            window_default.showMessage(`Invalid list mappings key configuration: "${key}"`, "warning");
        }
      } else {
        window_default.showMessage(`Invalid list mappings key configuration: "${key}"`, "warning");
      }
    }
    return res;
  }
  async doInsertKeymap(key) {
    let nextKey = this.config.nextKey;
    let previousKey = this.config.previousKey;
    let {session: session4} = this.manager;
    if (!session4)
      return;
    if (key == nextKey) {
      session4.ui.index = session4.ui.index + 1;
      return true;
    }
    if (key == previousKey) {
      session4.ui.index = session4.ui.index - 1;
      return true;
    }
    let expr = this.userInsertMappings.get(key);
    if (expr) {
      await this.evalExpression(expr, "insert");
      return true;
    }
    if (this.insertMappings.has(key)) {
      let fn = this.insertMappings.get(key);
      await Promise.resolve(fn());
      return true;
    }
    return false;
  }
  async doNormalKeymap(key) {
    let expr = this.userNormalMappings.get(key);
    if (expr) {
      await this.evalExpression(expr, "normal");
      return true;
    }
    if (this.normalMappings.has(key)) {
      let fn = this.normalMappings.get(key);
      await Promise.resolve(fn());
      return true;
    }
    return false;
  }
  add(mode, key, fn) {
    let mappings2 = mode == "insert" ? this.insertMappings : this.normalMappings;
    if (Array.isArray(key)) {
      for (let k of key) {
        mappings2.set(k, fn);
      }
    } else {
      mappings2.set(key, fn);
    }
  }
  async onError(msg) {
    let {nvim} = this;
    await nvim.call("coc#prompt#stop_prompt", ["list"]);
    window_default.showMessage(msg, "error");
    this.manager.prompt.start();
  }
  async evalExpression(expr, _mode) {
    var _a2, _b, _c, _d, _e, _f, _g;
    if (typeof expr != "string" || !expr.includes(":")) {
      await this.onError(`Invalid list mapping expression: ${expr}`);
      return;
    }
    let {manager: manager31} = this;
    let {prompt: prompt2} = manager31;
    let [key, action] = expr.split(":", 2);
    if (key == "do") {
      switch (action.toLowerCase()) {
        case "switch":
          manager31.switchMatcher();
          return;
        case "selectall":
          await ((_a2 = manager31.session) == null ? void 0 : _a2.ui.selectAll());
          return;
        case "help":
          await ((_b = manager31.session) == null ? void 0 : _b.showHelp());
          return;
        case "refresh":
          await ((_c = manager31.session) == null ? void 0 : _c.reloadItems());
          return;
        case "exit":
          await manager31.cancel();
          return;
        case "stop":
          manager31.stop();
          return;
        case "cancel":
          await manager31.cancel(false);
          return;
        case "toggle":
          await ((_d = manager31.session) == null ? void 0 : _d.ui.toggleSelection());
          return;
        case "jumpback":
          (_e = manager31.session) == null ? void 0 : _e.jumpBack();
          return;
        case "previous":
          await manager31.normal("k");
          return;
        case "next":
          await manager31.normal("j");
          return;
        case "defaultaction":
          await manager31.doAction();
          return;
        case "togglemode":
          return manager31.toggleMode();
        case "previewup":
          return this.scrollPreview("up");
        case "previewdown":
          return this.scrollPreview("down");
        default:
          await this.onError(`'${action}' not supported`);
      }
    } else if (key == "prompt") {
      switch (action) {
        case "previous":
          (_f = manager31.session) == null ? void 0 : _f.history.previous();
          return;
        case "next":
          (_g = manager31.session) == null ? void 0 : _g.history.next();
          return;
        case "start":
          return prompt2.moveToStart();
        case "end":
          return prompt2.moveToEnd();
        case "left":
          return prompt2.moveLeft();
        case "right":
          return prompt2.moveRight();
        case "deleteforward":
          return prompt2.onBackspace();
        case "deletebackward":
          return prompt2.removeNext();
        case "removetail":
          return prompt2.removeTail();
        case "removeahead":
          return prompt2.removeAhead();
        case "insertregister":
          prompt2.insertRegister();
          return;
        case "paste":
          await prompt2.paste();
          return;
        default:
          await this.onError(`prompt '${action}' not supported`);
      }
    } else if (key == "eval") {
      await prompt2.eval(action);
    } else if (key == "command") {
      await manager31.command(action);
    } else if (key == "action") {
      await manager31.doAction(action);
    } else if (key == "feedkeys") {
      await manager31.feedkeys(action);
    } else if (key == "normal") {
      await manager31.normal(action, false);
    } else if (key == "normal!") {
      await manager31.normal(action, true);
    } else if (key == "call") {
      await manager31.call(action);
    } else if (key == "expr") {
      let name2 = await manager31.call(action);
      if (name2)
        await manager31.doAction(name2);
    } else {
      await this.onError(`Invalid expression ${expr}`);
    }
  }
  async doScroll(key) {
    await this.manager.feedkeys(key);
  }
  async scrollPreview(dir) {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.call("coc#util#scroll_preview", [dir], true);
    nvim.command("redraw", true);
    await nvim.resumeNotification();
  }
};
var mappings_default = Mappings;

// src/list/prompt.ts
var clipboardy = __toModule(require_clipboardy());
var vscode_languageserver_protocol55 = __toModule(require_main3());
var logger50 = require_logger2()("list-prompt");
var Prompt = class {
  constructor(nvim, config) {
    this.nvim = nvim;
    this.config = config;
    this.cusorIndex = 0;
    this._input = "";
    this._mode = "insert";
    this.interactive = false;
    this.requestInput = false;
    this._onDidChangeInput = new vscode_languageserver_protocol55.Emitter();
    this.onDidChangeInput = this._onDidChangeInput.event;
  }
  get input() {
    return this._input;
  }
  set input(str) {
    if (this._input == str)
      return;
    this.cusorIndex = str.length;
    this._input = str;
    this.drawPrompt();
    this._onDidChangeInput.fire(this._input);
  }
  get mode() {
    return this._mode;
  }
  set mode(val) {
    if (val == this._mode)
      return;
    this._mode = val;
    this.drawPrompt();
  }
  set matcher(val) {
    this._matcher = val;
    this.drawPrompt();
  }
  start(opts) {
    if (opts) {
      this.interactive = opts.interactive;
      this.cusorIndex = opts.input.length;
      this._input = opts.input;
      this._mode = opts.mode;
      this._matcher = opts.interactive ? "" : opts.matcher;
    }
    this.nvim.call("coc#prompt#start_prompt", ["list"], true);
    this.drawPrompt();
  }
  cancel() {
    let {nvim} = this;
    nvim.call("coc#prompt#stop_prompt", ["list"], true);
  }
  reset() {
    this._input = "";
    this.cusorIndex = 0;
  }
  drawPrompt() {
    let indicator = this.config.get("indicator", ">");
    let {cusorIndex, interactive, input, _matcher} = this;
    let cmds = ['echo ""'];
    if (this.mode == "insert") {
      if (interactive) {
        cmds.push(`echohl MoreMsg | echon 'INTERACTIVE ' | echohl None`);
      } else if (_matcher) {
        cmds.push(`echohl MoreMsg | echon '${_matcher.toUpperCase()} ' | echohl None`);
      }
      cmds.push(`echohl Special | echon '${indicator} ' | echohl None`);
      if (cusorIndex == input.length) {
        cmds.push(`echon '${input.replace(/'/g, "''")}'`);
        cmds.push(`echohl Cursor | echon ' ' | echohl None`);
      } else {
        let pre = input.slice(0, cusorIndex);
        if (pre)
          cmds.push(`echon '${pre.replace(/'/g, "''")}'`);
        cmds.push(`echohl Cursor | echon '${input[cusorIndex].replace(/'/, "''")}' | echohl None`);
        let post = input.slice(cusorIndex + 1);
        cmds.push(`echon '${post.replace(/'/g, "''")}'`);
      }
    } else {
      cmds.push(`echohl MoreMsg | echo "" | echohl None`);
    }
    cmds.push("redraw");
    let cmd = cmds.join("|");
    this.nvim.command(cmd, true);
  }
  moveLeft() {
    if (this.cusorIndex == 0)
      return;
    this.cusorIndex = this.cusorIndex - 1;
    this.drawPrompt();
  }
  moveRight() {
    if (this.cusorIndex == this._input.length)
      return;
    this.cusorIndex = this.cusorIndex + 1;
    this.drawPrompt();
  }
  moveToEnd() {
    if (this.cusorIndex == this._input.length)
      return;
    this.cusorIndex = this._input.length;
    this.drawPrompt();
  }
  moveToStart() {
    if (this.cusorIndex == 0)
      return;
    this.cusorIndex = 0;
    this.drawPrompt();
  }
  onBackspace() {
    let {cusorIndex, input} = this;
    if (cusorIndex == 0)
      return;
    let pre = input.slice(0, cusorIndex);
    let post = input.slice(cusorIndex);
    this.cusorIndex = cusorIndex - 1;
    this._input = `${pre.slice(0, pre.length - 1)}${post}`;
    this.drawPrompt();
    this._onDidChangeInput.fire(this._input);
  }
  removeNext() {
    let {cusorIndex, input} = this;
    if (cusorIndex == input.length - 1)
      return;
    let pre = input.slice(0, cusorIndex);
    let post = input.slice(cusorIndex + 1);
    this._input = `${pre}${post}`;
    this.drawPrompt();
    this._onDidChangeInput.fire(this._input);
  }
  removeWord() {
    let {cusorIndex, input} = this;
    if (cusorIndex == 0)
      return;
    let pre = input.slice(0, cusorIndex);
    let post = input.slice(cusorIndex);
    let remain = pre.replace(/[\w$]+([^\w$]+)?$/, "");
    this.cusorIndex = cusorIndex - (pre.length - remain.length);
    this._input = `${remain}${post}`;
    this.drawPrompt();
    this._onDidChangeInput.fire(this._input);
  }
  removeTail() {
    let {cusorIndex, input} = this;
    if (cusorIndex == input.length)
      return;
    let pre = input.slice(0, cusorIndex);
    this._input = pre;
    this.drawPrompt();
    this._onDidChangeInput.fire(this._input);
  }
  removeAhead() {
    let {cusorIndex, input} = this;
    if (cusorIndex == 0)
      return;
    let post = input.slice(cusorIndex);
    this.cusorIndex = 0;
    this._input = post;
    this.drawPrompt();
    this._onDidChangeInput.fire(this._input);
  }
  async acceptCharacter(ch) {
    if (this.requestInput) {
      this.requestInput = false;
      if (/^[0-9a-z"%#*+/:\-.]$/.test(ch)) {
        let text = await this.nvim.call("getreg", ch);
        text = text.replace(/\n/g, " ");
        this.addText(text);
      }
    } else {
      this.addText(ch);
    }
  }
  insertRegister() {
    this.requestInput = true;
  }
  async paste() {
    let text = await clipboardy.default.read();
    text = text.replace(/\n/g, "");
    if (!text)
      return;
    this.addText(text);
  }
  async eval(expression) {
    let text = await this.nvim.call("eval", [expression]);
    text = text.replace(/\n/g, "");
    this.addText(text);
  }
  addText(text) {
    let {cusorIndex, input} = this;
    this.cusorIndex = cusorIndex + text.length;
    let pre = input.slice(0, cusorIndex);
    let post = input.slice(cusorIndex);
    this._input = `${pre}${text}${post}`;
    this.drawPrompt();
    this._onDidChangeInput.fire(this._input);
  }
};
var prompt_default = Prompt;

// src/list/session.ts
var debounce13 = __toModule(require_debounce());
var vscode_languageserver_protocol58 = __toModule(require_main3());

// src/util/fuzzy.ts
function getCharCodes(str) {
  let res = [];
  for (let i = 0, l = str.length; i < l; i++) {
    res.push(str.charCodeAt(i));
  }
  return res;
}
function wordChar(ch) {
  return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
}
function caseMatch(input, code) {
  if (input == code)
    return true;
  if (input >= 97 && input <= 122 && code + 32 === input)
    return true;
  return false;
}
function fuzzyChar(a, b) {
  let ca = a.charCodeAt(0);
  let cb = b.charCodeAt(0);
  if (ca === cb)
    return true;
  if (ca >= 97 && ca <= 122 && cb + 32 === ca)
    return true;
  return false;
}
function fuzzyMatch(needle, text) {
  let totalCount = needle.length;
  if (needle.length > text.length)
    return false;
  let i = 0;
  for (let j = 0; j < text.length; j++) {
    if (i === totalCount)
      break;
    let code = text.charCodeAt(j);
    let m = needle[i];
    if (code === m) {
      i = i + 1;
      continue;
    }
    if (m >= 97 && m <= 122 && code + 32 === m) {
      i = i + 1;
      continue;
    }
  }
  return i === totalCount;
}

// src/list/history.ts
var logger51 = require_logger2()("list-history");
var InputHistory = class {
  constructor(prompt2, name2) {
    this.prompt = prompt2;
    this.name = name2;
    this.index = -1;
    this.loaded = [];
    this.current = [];
    this.db = workspace_default.createDatabase(`list-${name2}-history`);
    this.key = Buffer.from(workspace_default.cwd).toString("base64");
  }
  filter() {
    let {input} = this.prompt;
    if (input == this.curr)
      return;
    this.historyInput = "";
    let codes = getCharCodes(input);
    this.current = this.loaded.filter((s) => fuzzyMatch(codes, s));
    this.index = -1;
  }
  get curr() {
    return this.index == -1 ? null : this.current[this.index];
  }
  load(input) {
    let {db: db3} = this;
    input = input || "";
    let arr = db3.fetch(this.key);
    if (!arr || !Array.isArray(arr)) {
      this.loaded = [];
    } else {
      this.loaded = arr;
    }
    this.index = -1;
    this.current = this.loaded.filter((s) => s.startsWith(input));
  }
  add() {
    let {loaded, db: db3, prompt: prompt2} = this;
    let {input} = prompt2;
    if (!input || input.length < 2 || input == this.historyInput)
      return;
    let idx = loaded.indexOf(input);
    if (idx != -1)
      loaded.splice(idx, 1);
    loaded.push(input);
    if (loaded.length > 200) {
      loaded = loaded.slice(-200);
    }
    db3.push(this.key, loaded);
  }
  previous() {
    let {current, index} = this;
    if (!current || !current.length)
      return;
    if (index <= 0) {
      this.index = current.length - 1;
    } else {
      this.index = index - 1;
    }
    this.historyInput = this.prompt.input = current[this.index] || "";
  }
  next() {
    let {current, index} = this;
    if (!current || !current.length)
      return;
    if (index == current.length - 1) {
      this.index = 0;
    } else {
      this.index = index + 1;
    }
    this.historyInput = this.prompt.input = current[this.index] || "";
  }
};
var history_default = InputHistory;

// src/list/ui.ts
var debounce11 = __toModule(require_debounce());
var vscode_languageserver_protocol56 = __toModule(require_main3());
var logger52 = require_logger2()("list-ui");
var ListUI = class {
  constructor(nvim, name2, listOptions, config) {
    this.nvim = nvim;
    this.name = name2;
    this.listOptions = listOptions;
    this.config = config;
    this.newTab = false;
    this.currIndex = 0;
    this.drawCount = 0;
    this.items = [];
    this.disposables = [];
    this.selected = new Set();
    this.mutex = new Mutex();
    this._onDidChangeLine = new vscode_languageserver_protocol56.Emitter();
    this._onDidOpen = new vscode_languageserver_protocol56.Emitter();
    this._onDidClose = new vscode_languageserver_protocol56.Emitter();
    this._onDidLineChange = new vscode_languageserver_protocol56.Emitter();
    this._onDoubleClick = new vscode_languageserver_protocol56.Emitter();
    this.onDidChangeLine = this._onDidChangeLine.event;
    this.onDidLineChange = this._onDidLineChange.event;
    this.onDidOpen = this._onDidOpen.event;
    this.onDidClose = this._onDidClose.event;
    this.onDidDoubleClick = this._onDoubleClick.event;
    this.signOffset = config.get("signOffset");
    this.matchHighlightGroup = config.get("matchHighlightGroup", "Search");
    this.newTab = listOptions.position == "tab";
    events_default.on("BufWinLeave", async (bufnr) => {
      if (bufnr != this.bufnr || this.window == null)
        return;
      this.window = null;
      this._onDidClose.fire(bufnr);
    }, null, this.disposables);
    events_default.on("CursorMoved", async (bufnr, cursor) => {
      if (bufnr != this.bufnr)
        return;
      this.onLineChange(cursor[0] - 1);
    }, null, this.disposables);
    let debounced = debounce11.default(async (bufnr) => {
      if (bufnr != this.bufnr)
        return;
      let [winid, start, end] = await nvim.eval('[win_getid(),line("w0"),line("w$")]');
      if (end < 300)
        return;
      if (!this.window || winid != this.window.id)
        return;
      nvim.pauseNotification();
      this.doHighlight(start - 1, end);
      nvim.command("redraw", true);
      nvim.resumeNotification(false, true);
    }, 100);
    this.disposables.push({
      dispose: () => {
        debounced.clear();
      }
    });
    events_default.on("CursorMoved", debounced, null, this.disposables);
  }
  get limitLines() {
    return this.config.get("limitLines", 3e4);
  }
  onLineChange(index) {
    if (this.currIndex == index)
      return;
    this.currIndex = index;
    this._onDidChangeLine.fire(index);
  }
  set index(n) {
    if (n < 0 || n >= this.items.length)
      return;
    let {nvim} = this;
    nvim.pauseNotification();
    this.setCursor(n + 1, 0);
    nvim.command("redraw", true);
    nvim.resumeNotification(false, true).logError();
  }
  get index() {
    return this.currIndex;
  }
  get firstItem() {
    return this.items[0];
  }
  get lastItem() {
    return this.items[this.items.length - 1];
  }
  getItem(index) {
    return this.items[index];
  }
  get item() {
    let {window: window36} = this;
    if (!window36)
      return Promise.resolve(null);
    return window36.cursor.then((cursor) => {
      this.currIndex = cursor[0] - 1;
      return this.items[this.currIndex];
    }, (_e) => null);
  }
  async echoMessage(item) {
    if (this.bufnr)
      return;
    let {items} = this;
    let idx = items.indexOf(item);
    let msg = `[${idx + 1}/${items.length}] ${item.label || ""}`;
    this.nvim.callTimer("coc#util#echo_lines", [[msg]], true);
  }
  async updateItem(item, index) {
    if (!this.bufnr || workspace_default.bufnr != this.bufnr)
      return;
    let obj = Object.assign({resolved: true}, item);
    if (index < this.length) {
      this.items[index] = obj;
      let {nvim} = this;
      nvim.pauseNotification();
      nvim.command("setl modifiable", true);
      nvim.call("setline", [index + 1, obj.label], true);
      nvim.command("setl nomodifiable", true);
      await nvim.resumeNotification();
    }
  }
  async getItems() {
    if (this.length == 0 || !this.window)
      return [];
    let mode = await this.nvim.call("mode");
    if (mode == "v" || mode == "V") {
      let [start, end] = await this.getSelectedRange();
      let res = [];
      for (let i = start; i <= end; i++) {
        let item2 = this.items[i - 1];
        if (item2)
          res.push(item2);
      }
      return res;
    }
    let {selectedItems} = this;
    if (selectedItems.length)
      return selectedItems;
    let item = await this.item;
    return item == null ? [] : [item];
  }
  async onMouse(event) {
    let {nvim, window: window36} = this;
    if (!window36)
      return;
    let winid = await nvim.getVvar("mouse_winid");
    let lnum = await nvim.getVvar("mouse_lnum");
    let col = await nvim.getVvar("mouse_col");
    if (event == "mouseDown") {
      this.mouseDown = {winid, lnum, col, current: winid == window36.id};
      return;
    }
    let current = winid == window36.id;
    if (current && event == "doubleClick") {
      this.setCursor(lnum, 0);
      this._onDoubleClick.fire();
    }
    if (!this.mouseDown || this.mouseDown.winid != this.mouseDown.winid)
      return;
    if (current && event == "mouseDrag") {
      await this.selectLines(this.mouseDown.lnum, lnum);
    } else if (current && event == "mouseUp") {
      if (this.mouseDown.lnum == lnum) {
        nvim.pauseNotification();
        this.clearSelection();
        this.setCursor(lnum, 0);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
      } else {
        await this.selectLines(this.mouseDown.lnum, lnum);
      }
    } else if (!current && event == "mouseUp") {
      nvim.pauseNotification();
      nvim.call("win_gotoid", winid, true);
      nvim.call("cursor", [lnum, col], true);
      await nvim.resumeNotification();
    }
  }
  async resume() {
    let {items, selected, nvim, signOffset} = this;
    await this.drawItems(items, this.height, true);
    if (selected.size > 0 && this.bufnr) {
      nvim.pauseNotification();
      for (let lnum of selected) {
        nvim.command(`sign place ${signOffset + lnum} line=${lnum} name=CocSelected buffer=${this.bufnr}`, true);
      }
      await nvim.resumeNotification();
    }
  }
  async toggleSelection() {
    let {nvim, selected, signOffset, bufnr} = this;
    if (workspace_default.bufnr != bufnr)
      return;
    let lnum = await nvim.call("line", ".");
    let mode = await nvim.call("mode");
    if (mode == "v" || mode == "V") {
      let [start, end] = await this.getSelectedRange();
      let exists2 = selected.has(start);
      let reverse = start > end;
      if (reverse)
        [start, end] = [end, start];
      for (let i = start; i <= end; i++) {
        if (!exists2) {
          selected.add(i);
          nvim.command(`sign place ${signOffset + i} line=${i} name=CocSelected buffer=${bufnr}`, true);
        } else {
          selected.delete(i);
          nvim.command(`sign unplace ${signOffset + i} buffer=${bufnr}`, true);
        }
      }
      this.setCursor(end, 0);
      nvim.command("redraw", true);
      await nvim.resumeNotification();
      return;
    }
    let exists = selected.has(lnum);
    nvim.pauseNotification();
    if (exists) {
      selected.delete(lnum);
      nvim.command(`sign unplace ${signOffset + lnum} buffer=${bufnr}`, true);
    } else {
      selected.add(lnum);
      nvim.command(`sign place ${signOffset + lnum} line=${lnum} name=CocSelected buffer=${bufnr}`, true);
    }
    this.setCursor(lnum + 1, 0);
    nvim.command("redraw", true);
    await nvim.resumeNotification();
  }
  async selectLines(start, end) {
    let {nvim, signOffset, bufnr, length} = this;
    this.clearSelection();
    let {selected} = this;
    nvim.pauseNotification();
    let reverse = start > end;
    if (reverse)
      [start, end] = [end, start];
    for (let i = start; i <= end; i++) {
      if (i > length)
        break;
      selected.add(i);
      nvim.command(`sign place ${signOffset + i} line=${i} name=CocSelected buffer=${bufnr}`, true);
    }
    this.setCursor(end, 0);
    nvim.command("redraw", true);
    await nvim.resumeNotification();
  }
  async selectAll() {
    let {length} = this;
    if (length == 0)
      return;
    await this.selectLines(1, length);
  }
  clearSelection() {
    let {selected, nvim, signOffset, bufnr} = this;
    if (!bufnr)
      return;
    if (selected.size > 0) {
      let signIds = [];
      for (let lnum of selected) {
        signIds.push(signOffset + lnum);
      }
      nvim.call("coc#util#unplace_signs", [bufnr, signIds], true);
      this.selected = new Set();
    }
  }
  get shown() {
    return this.window != null;
  }
  get bufnr() {
    var _a2;
    return (_a2 = this.buffer) == null ? void 0 : _a2.id;
  }
  get winid() {
    var _a2;
    return (_a2 = this.window) == null ? void 0 : _a2.id;
  }
  get ready() {
    if (this.window)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      let timeout = setTimeout(() => {
        reject(new Error("window create timeout"));
      }, 3e3);
      let disposable = this.onDidLineChange(() => {
        disposable.dispose();
        clearTimeout(timeout);
        resolve3();
      });
    });
  }
  async drawItems(items, height, reload = false, token) {
    let count = this.drawCount = this.drawCount + 1;
    const {nvim, name: name2, listOptions} = this;
    const release = await this.mutex.acquire();
    this.items = items.length > this.limitLines ? items.slice(0, this.limitLines) : items;
    const create = this.window == null;
    if (create && !(token && token.isCancellationRequested)) {
      try {
        let {position: position15, numberSelect} = listOptions;
        let [bufnr, winid] = await nvim.call("coc#list#create", [position15, height, name2, numberSelect]);
        if (token && token.isCancellationRequested) {
          nvim.call("coc#list#clean_up", [], true);
        } else {
          this.height = height;
          this.buffer = nvim.createBuffer(bufnr);
          this.window = nvim.createWindow(winid);
          this._onDidOpen.fire(this.bufnr);
        }
      } catch (e) {
        nvim.call("coc#prompt#stop_prompt", ["list"], true);
        nvim.call("coc#list#clean_up", [], true);
        release();
        window_default.showMessage(`Error on list create: ${e.message}`, "error");
        return;
      }
    }
    release();
    if (token && token.isCancellationRequested)
      return;
    if (count !== this.drawCount)
      return;
    const lines = this.items.map((item) => item.label);
    this.clearSelection();
    let newIndex = reload ? this.currIndex : 0;
    await this.setLines(lines, false, newIndex);
    this._onDidLineChange.fire(this.currIndex + 1);
  }
  async appendItems(items) {
    if (!this.window)
      return;
    let curr = this.items.length;
    if (curr >= this.limitLines)
      return;
    let max = this.limitLines - curr;
    let append = items.slice(0, max);
    this.items = this.items.concat(append);
    await this.setLines(append.map((item) => item.label), curr > 0, this.currIndex);
  }
  async setLines(lines, append = false, index) {
    let {nvim, buffer: buffer4, window: window36} = this;
    if (!buffer4 || !window36)
      return;
    nvim.pauseNotification();
    if (!append) {
      let statusSegments = this.config.get("statusLineSegments");
      if (statusSegments) {
        window36.notify("nvim_win_set_option", ["statusline", statusSegments.join(" ")]);
      }
      nvim.call("coc#compat#clear_matches", [window36.id], true);
      if (!lines.length) {
        lines = ["No results, press ? on normal mode to get help."];
        nvim.call("coc#compat#matchaddpos", ["Comment", [[1]], 99, this.window.id], true);
      }
    }
    buffer4.setOption("modifiable", true, true);
    if (workspace_default.isVim) {
      nvim.call("coc#list#setlines", [buffer4.id, lines, append], true);
    } else {
      buffer4.setLines(lines, {start: append ? -1 : 0, end: -1, strictIndexing: false}, true);
    }
    buffer4.setOption("modifiable", false, true);
    if (!append && index == 0) {
      this.doHighlight(0, 300);
    } else {
      let height = this.newTab ? workspace_default.env.lines : this.height;
      this.doHighlight(Math.max(0, index - height), Math.min(index + height + 1, this.length - 1));
    }
    if (!append) {
      this.currIndex = index;
      window36.notify("nvim_win_set_cursor", [[index + 1, 0]]);
    }
    nvim.command("redraws", true);
    let res = await nvim.resumeNotification();
    if (Array.isArray(res[1]) && res[1][0] == 0) {
      this.window = null;
    }
  }
  restoreWindow() {
    if (this.newTab)
      return;
    let {winid, height} = this;
    if (winid && height) {
      this.nvim.call("coc#list#restore", [winid, height], true);
    }
  }
  reset() {
    if (this.window) {
      this.window = null;
      this.buffer = null;
    }
  }
  dispose() {
    disposeAll(this.disposables);
    this.window = null;
    this._onDidChangeLine.dispose();
    this._onDidOpen.dispose();
    this._onDidClose.dispose();
    this._onDidLineChange.dispose();
    this._onDoubleClick.dispose();
  }
  get length() {
    return this.items.length;
  }
  get selectedItems() {
    let {selected, items} = this;
    let res = [];
    for (let i of selected) {
      if (items[i - 1])
        res.push(items[i - 1]);
    }
    return res;
  }
  doHighlight(start, end) {
    let {nvim} = workspace_default;
    let {items} = this;
    let groups = [];
    for (let i = start; i <= Math.min(end, items.length - 1); i++) {
      let {ansiHighlights, highlights: highlights2} = items[i];
      if (ansiHighlights) {
        for (let hi of ansiHighlights) {
          let {span, hlGroup} = hi;
          groups.push({hlGroup, priority: 9, pos: [i + 1, span[0] + 1, span[1] - span[0]]});
        }
      }
      if (highlights2 && Array.isArray(highlights2.spans)) {
        let {spans, hlGroup} = highlights2;
        for (let span of spans) {
          groups.push({hlGroup: hlGroup || this.matchHighlightGroup, priority: 11, pos: [i + 1, span[0] + 1, span[1] - span[0]]});
        }
      }
    }
    nvim.call("coc#compat#matchaddgroups", [this.window.id, groups], true);
  }
  setCursor(lnum, col) {
    let {window: window36, items} = this;
    let max = items.length == 0 ? 1 : items.length;
    if (lnum > max)
      return;
    this.onLineChange(lnum - 1);
    if (window36)
      window36.notify("nvim_win_set_cursor", [[lnum, col]]);
  }
  async getSelectedRange() {
    let {nvim} = this;
    await nvim.call("coc#prompt#stop_prompt", ["list"]);
    await nvim.eval('feedkeys("\\<esc>", "in")');
    let [, start] = await nvim.call("getpos", "'<");
    let [, end] = await nvim.call("getpos", "'>");
    if (start > end) {
      [start, end] = [end, start];
    }
    this.nvim.call("coc#prompt#start_prompt", ["list"], true);
    return [start, end];
  }
};
var ui_default = ListUI;

// src/list/worker.ts
var vscode_languageserver_protocol57 = __toModule(require_main3());

// src/util/fzy.ts
var SCORE_MIN = -Infinity;
var SCORE_MAX = Infinity;
var SCORE_GAP_LEADING = -5e-3;
var SCORE_GAP_TRAILING = -5e-3;
var SCORE_GAP_INNER = -0.01;
var SCORE_MATCH_CONSECUTIVE = 1;
var SCORE_MATCH_SLASH = 0.9;
var SCORE_MATCH_WORD = 0.8;
var SCORE_MATCH_CAPITAL = 0.7;
var SCORE_MATCH_DOT = 0.6;
function islower(s) {
  return s.toLowerCase() === s;
}
function isupper(s) {
  return s.toUpperCase() === s;
}
function precompute_bonus(haystack) {
  let m = haystack.length;
  let match_bonus = new Array(m);
  let last_ch = "/";
  for (let i = 0; i < m; i++) {
    let ch = haystack[i];
    if (last_ch === "/") {
      match_bonus[i] = SCORE_MATCH_SLASH;
    } else if (last_ch === "-" || last_ch === "_" || last_ch === " ") {
      match_bonus[i] = SCORE_MATCH_WORD;
    } else if (last_ch === ".") {
      match_bonus[i] = SCORE_MATCH_DOT;
    } else if (islower(last_ch) && isupper(ch)) {
      match_bonus[i] = SCORE_MATCH_CAPITAL;
    } else {
      match_bonus[i] = 0;
    }
    last_ch = ch;
  }
  return match_bonus;
}
function compute(needle, haystack, D, M) {
  let n = needle.length;
  let m = haystack.length;
  let lower_needle = needle.toLowerCase();
  let lower_haystack = haystack.toLowerCase();
  let match_bonus = precompute_bonus(haystack);
  for (let i = 0; i < n; i++) {
    D[i] = new Array(m);
    M[i] = new Array(m);
    let prev_score = SCORE_MIN;
    let gap_score = i === n - 1 ? SCORE_GAP_TRAILING : SCORE_GAP_INNER;
    for (let j = 0; j < m; j++) {
      if (lower_needle[i] === lower_haystack[j]) {
        let score6 = SCORE_MIN;
        if (!i) {
          score6 = j * SCORE_GAP_LEADING + match_bonus[j];
        } else if (j) {
          score6 = Math.max(M[i - 1][j - 1] + match_bonus[j], D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE);
        }
        D[i][j] = score6;
        M[i][j] = prev_score = Math.max(score6, prev_score + gap_score);
      } else {
        D[i][j] = SCORE_MIN;
        M[i][j] = prev_score = prev_score + gap_score;
      }
    }
  }
}
function score2(needle, haystack) {
  let n = needle.length;
  let m = haystack.length;
  if (!n || !m)
    return SCORE_MIN;
  if (n === m) {
    return SCORE_MAX;
  }
  if (m > 1024) {
    return SCORE_MIN;
  }
  let D = new Array(n);
  let M = new Array(n);
  compute(needle, haystack, D, M);
  return M[n - 1][m - 1];
}
function positions(needle, haystack) {
  let n = needle.length;
  let m = haystack.length;
  let positions2 = new Array(n);
  if (!n || !m)
    return positions2;
  if (n === m) {
    for (let i = 0; i < n; i++)
      positions2[i] = i;
    return positions2;
  }
  if (m > 1024) {
    return positions2;
  }
  let D = new Array(n);
  let M = new Array(n);
  compute(needle, haystack, D, M);
  let match_required = false;
  for (let i = n - 1, j = m - 1; i >= 0; i--) {
    for (; j >= 0; j--) {
      if (D[i][j] !== SCORE_MIN && (match_required || D[i][j] === M[i][j])) {
        match_required = i && j && M[i][j] === D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE;
        positions2[i] = j--;
        break;
      }
    }
  }
  return positions2;
}
function hasMatch(needle, haystack) {
  needle = needle.toLowerCase();
  haystack = haystack.toLowerCase();
  let l = needle.length;
  for (let i = 0, j = 0; i < l; i += 1) {
    j = haystack.indexOf(needle[i], j) + 1;
    if (j === 0)
      return false;
  }
  return true;
}

// src/util/score.ts
var path34 = __toModule(require("path"));
function getMatchResult(text, query, filename = "") {
  if (!query)
    return {score: 1};
  let matches = [];
  let codes = getCharCodes(query);
  let filenameIdx = filename ? text.indexOf(filename) : -1;
  let matchBase = filenameIdx != -1 && fuzzyMatch(codes, filename);
  let score6 = 0;
  let c = query[0];
  let idx = 0;
  if (matchBase) {
    if (filename.startsWith(c)) {
      score6 = score6 + 2;
      idx = filenameIdx + 1;
      matches.push(filenameIdx);
    } else if (filename[0].toLowerCase() == c) {
      score6 = score6 + 1.5;
      idx = filenameIdx + 1;
      matches.push(filenameIdx);
    } else {
      for (let i = 1; i < filename.length; i++) {
        if (fuzzyChar(c, filename[i])) {
          score6 = score6 + 1;
          idx = filenameIdx + i + 1;
          matches.push(filenameIdx + i);
          break;
        }
      }
    }
  } else if (text.startsWith(c)) {
    score6 = score6 + 1;
    matches.push(0);
    idx = 1;
  } else {
    for (let i = 1; i < text.length; i++) {
      let pre = text[i - 1];
      if (pre == path34.sep && text[i] == c) {
        score6 = score6 + 1;
        matches.push(i);
        idx = i + 1;
        break;
      }
    }
    if (idx == 0) {
      for (let i = 0; i < text.length; i++) {
        if (fuzzyChar(c, text[i])) {
          score6 = score6 + 0.5;
          matches.push(i);
          idx = i + 1;
          break;
        }
      }
    }
  }
  if (idx == 0)
    return {score: 0};
  if (codes.length == 1)
    return {score: score6, matches};
  return nextResult(codes.slice(1), text, idx, {score: score6, matches});
}
function nextResult(codes, text, idx, curr) {
  let {score: score6, matches} = curr;
  let results = [];
  let c = codes[0];
  let remain = codes.slice(1);
  let result;
  function getRemianResult(index) {
    if (!result)
      return;
    if (remain.length == 0) {
      results.push(result);
    } else if (result) {
      let res = nextResult(remain, text, index, result);
      if (res)
        results.push(res);
    }
  }
  let followed = idx < text.length ? text[idx].charCodeAt(0) : null;
  if (!followed)
    return null;
  if (followed == c) {
    result = {score: score6 + 1, matches: matches.concat([idx])};
    getRemianResult(idx + 1);
  } else if (caseMatch(c, followed)) {
    result = {score: score6 + 0.5, matches: matches.concat([idx])};
    getRemianResult(idx + 1);
  }
  if (idx + 1 < text.length) {
    for (let i = idx + 1; i < text.length; i++) {
      let ch = text[i].charCodeAt(0);
      if (text[i - 1] == path34.sep && caseMatch(c, ch)) {
        let add = c == ch ? 1 : 0.5;
        result = {score: score6 + add, matches: matches.concat([i])};
        getRemianResult(i + 1);
        break;
      }
    }
    for (let i = idx + 1; i < text.length; i++) {
      let ch = text[i].charCodeAt(0);
      if (caseMatch(c, ch)) {
        let add = c == ch ? 0.5 : 0.2;
        result = {score: score6 + add, matches: matches.concat([i])};
        getRemianResult(i + 1);
        break;
      }
    }
  }
  return results.length ? bestResult(results) : null;
}
function bestResult(results) {
  let res = results[0];
  for (let i = 1; i < results.length; i++) {
    if (results[i].score > res.score) {
      res = results[i];
    }
  }
  return res;
}

// src/list/worker.ts
var logger53 = require_logger2()("list-worker");
var controlCode = "";
var Worker = class {
  constructor(nvim, list2, prompt2, listOptions, config) {
    this.nvim = nvim;
    this.list = list2;
    this.prompt = prompt2;
    this.listOptions = listOptions;
    this.config = config;
    this._loading = false;
    this.totalItems = [];
    this._onDidChangeItems = new vscode_languageserver_protocol57.Emitter();
    this._onDidChangeLoading = new vscode_languageserver_protocol57.Emitter();
    this.onDidChangeItems = this._onDidChangeItems.event;
    this.onDidChangeLoading = this._onDidChangeLoading.event;
  }
  set loading(loading) {
    if (this._loading == loading)
      return;
    this._loading = loading;
    this._onDidChangeLoading.fire(loading);
  }
  get isLoading() {
    return this._loading;
  }
  async loadItems(context, reload = false) {
    let {list: list2, listOptions} = this;
    this.loading = true;
    let {interactive} = listOptions;
    this.tokenSource = new vscode_languageserver_protocol57.CancellationTokenSource();
    let token = this.tokenSource.token;
    let items = await list2.loadItems(context, token);
    if (token.isCancellationRequested)
      return;
    if (!items || Array.isArray(items)) {
      this.tokenSource = null;
      items = items || [];
      this.totalItems = items.map((item) => {
        item.label = this.fixLabel(item.label);
        this.parseListItemAnsi(item);
        return item;
      });
      this.loading = false;
      let filtered;
      if (!interactive) {
        filtered = this.filterItems(items);
      } else {
        filtered = this.convertToHighlightItems(items);
      }
      this._onDidChangeItems.fire({
        items: filtered,
        reload,
        finished: true
      });
    } else {
      let task2 = items;
      let totalItems = this.totalItems = [];
      let count = 0;
      let currInput = context.input;
      let timer;
      let lastTs;
      let _onData = (finished) => {
        lastTs = Date.now();
        if (count >= totalItems.length)
          return;
        let inputChanged = this.input != currInput;
        if (interactive && inputChanged)
          return;
        if (count == 0 || inputChanged) {
          currInput = this.input;
          count = totalItems.length;
          let items2;
          if (interactive) {
            items2 = this.convertToHighlightItems(totalItems);
          } else {
            items2 = this.filterItems(totalItems);
          }
          this._onDidChangeItems.fire({items: items2, reload, append: false, finished});
        } else {
          let remain = totalItems.slice(count);
          count = totalItems.length;
          let items2;
          if (!interactive) {
            items2 = this.filterItems(remain);
          } else {
            items2 = this.convertToHighlightItems(remain);
          }
          this._onDidChangeItems.fire({items: items2, append: true, finished});
        }
      };
      task2.on("data", (item) => {
        if (timer)
          clearTimeout(timer);
        if (token.isCancellationRequested)
          return;
        if (interactive && this.input != currInput)
          return;
        item.label = this.fixLabel(item.label);
        this.parseListItemAnsi(item);
        totalItems.push(item);
        if (!lastTs && totalItems.length == 500 || Date.now() - lastTs > 200) {
          _onData();
        } else {
          timer = setTimeout(() => _onData(), 50);
        }
      });
      let onEnd = () => {
        if (task2 == null)
          return;
        this.tokenSource = null;
        task2 = null;
        this.loading = false;
        disposable.dispose();
        if (timer)
          clearTimeout(timer);
        if (totalItems.length == 0) {
          this._onDidChangeItems.fire({items: [], finished: true});
        } else {
          _onData(true);
        }
      };
      let disposable = token.onCancellationRequested(() => {
        if (task2) {
          task2.dispose();
          onEnd();
        }
      });
      task2.on("error", async (error) => {
        if (task2 == null)
          return;
        task2 = null;
        this.tokenSource = null;
        this.loading = false;
        disposable.dispose();
        if (timer)
          clearTimeout(timer);
        this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
        window_default.showMessage(`Task error: ${error.toString()}`, "error");
        logger53.error(error);
      });
      task2.on("end", onEnd);
    }
  }
  drawItems() {
    let {totalItems, listOptions} = this;
    let items;
    if (listOptions.interactive) {
      items = this.convertToHighlightItems(totalItems);
    } else {
      items = this.filterItems(totalItems);
    }
    this._onDidChangeItems.fire({items, finished: true});
  }
  stop() {
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource = null;
    }
    this.loading = false;
  }
  get length() {
    return this.totalItems.length;
  }
  get input() {
    return this.prompt.input;
  }
  convertToHighlightItems(items) {
    let {input} = this;
    if (!input)
      return [];
    return items.map((item) => {
      let filterLabel = getFilterLabel(item);
      if (filterLabel == "")
        return item;
      let res = getMatchResult(filterLabel, input);
      if (!res || !res.score)
        return item;
      let highlights2 = this.getHighlights(filterLabel, res.matches);
      return Object.assign({}, item, {highlights: highlights2});
    });
  }
  filterItems(items) {
    let {input} = this;
    let {sort, matcher, ignorecase} = this.listOptions;
    let inputs = this.config.extendedSearchMode ? parseInput(input) : [input];
    if (input.length == 0 || inputs.length == 0)
      return items;
    if (matcher == "strict") {
      let filtered2 = [];
      for (let item of items) {
        let spans = [];
        let filterLabel = getFilterLabel(item);
        let match3 = true;
        for (let input2 of inputs) {
          let idx2 = ignorecase ? filterLabel.toLowerCase().indexOf(input2.toLowerCase()) : filterLabel.indexOf(input2);
          if (idx2 == -1) {
            match3 = false;
            break;
          }
          spans.push([byteIndex(filterLabel, idx2), byteIndex(filterLabel, idx2 + byteLength(input2))]);
        }
        if (match3) {
          filtered2.push(Object.assign({}, item, {
            highlights: {spans}
          }));
        }
      }
      return filtered2;
    }
    if (matcher == "regex") {
      let filtered2 = [];
      let flags = ignorecase ? "iu" : "u";
      let regexes = inputs.reduce((p, c) => {
        try {
          let regex = new RegExp(c, flags);
          p.push(regex);
        } catch (e) {
        }
        return p;
      }, []);
      for (let item of items) {
        let spans = [];
        let filterLabel = getFilterLabel(item);
        let match3 = true;
        for (let regex of regexes) {
          let ms = filterLabel.match(regex);
          if (ms == null) {
            match3 = false;
            break;
          }
          spans.push([byteIndex(filterLabel, ms.index), byteIndex(filterLabel, ms.index + byteLength(ms[0]))]);
        }
        if (match3) {
          filtered2.push(Object.assign({}, item, {
            highlights: {spans}
          }));
        }
      }
      return filtered2;
    }
    let filtered = [];
    let idx = 0;
    for (let item of items) {
      let filterText = item.filterText || item.label;
      let matchScore2 = 0;
      let matches = [];
      let filterLabel = getFilterLabel(item);
      let match3 = true;
      for (let input2 of inputs) {
        if (!hasMatch(input2, filterText)) {
          match3 = false;
          break;
        }
        matches.push(...positions(input2, filterLabel));
        if (sort)
          matchScore2 += score2(input2, filterText);
      }
      if (!match3)
        continue;
      let obj = Object.assign({}, item, {
        sortText: typeof item.sortText === "string" ? item.sortText : String.fromCharCode(idx),
        score: matchScore2,
        highlights: this.getHighlights(filterLabel, matches)
      });
      filtered.push(obj);
      idx = idx + 1;
    }
    if (sort && filtered.length) {
      filtered.sort((a, b) => {
        if (a.score != b.score)
          return b.score - a.score;
        if (a.sortText > b.sortText)
          return 1;
        return -1;
      });
    }
    return filtered;
  }
  getHighlights(text, matches) {
    let spans = [];
    if (matches && matches.length) {
      let start = matches.shift();
      let next = matches.shift();
      let curr = start;
      while (next) {
        if (next == curr + 1) {
          curr = next;
          next = matches.shift();
          continue;
        }
        spans.push([byteIndex(text, start), byteIndex(text, curr) + 1]);
        start = next;
        curr = start;
        next = matches.shift();
      }
      spans.push([byteIndex(text, start), byteIndex(text, curr) + 1]);
    }
    return {spans};
  }
  parseListItemAnsi(item) {
    let {label} = item;
    if (item.ansiHighlights || !label.includes(controlCode))
      return;
    let {line, highlights: highlights2} = parseAnsiHighlights(label);
    item.label = line;
    item.ansiHighlights = highlights2;
  }
  fixLabel(label) {
    let {columns} = workspace_default.env;
    label = label.split("\n").join(" ");
    return label.slice(0, columns * 2);
  }
  dispose() {
    this.stop();
  }
};
var worker_default = Worker;
function getFilterLabel(item) {
  return item.filterText != null ? patchLine(item.filterText, item.label) : item.label;
}
function parseInput(input) {
  let res = [];
  let startIdx = 0;
  let currIdx = 0;
  let prev = "";
  for (; currIdx < input.length; currIdx++) {
    let ch = input[currIdx];
    if (ch.charCodeAt(0) === 32) {
      if (prev && prev != "\\" && startIdx != currIdx) {
        res.push(input.slice(startIdx, currIdx));
        startIdx = currIdx + 1;
      }
    } else {
    }
    prev = ch;
  }
  if (startIdx != input.length) {
    res.push(input.slice(startIdx, input.length));
  }
  return res.map((s) => s.replace(/\\\s/g, " ").trim()).filter((s) => s.length > 0);
}

// src/list/session.ts
var frames2 = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
var logger54 = require_logger2()("list-session");
var ListSession = class {
  constructor(nvim, prompt2, list2, listOptions, listArgs = [], config) {
    this.nvim = nvim;
    this.prompt = prompt2;
    this.list = list2;
    this.listOptions = listOptions;
    this.listArgs = listArgs;
    this.config = config;
    this.loadingFrame = "";
    this.hidden = false;
    this.disposables = [];
    this.args = [];
    this.ui = new ui_default(nvim, list2.name, listOptions, config);
    this.history = new history_default(prompt2, list2.name);
    this.worker = new worker_default(nvim, list2, prompt2, listOptions, {
      interactiveDebounceTime: config.get("interactiveDebounceTime", 100),
      extendedSearchMode: config.get("extendedSearchMode", true)
    });
    this.interactiveDebounceTime = config.get("interactiveDebounceTime", 100);
    let debouncedChangeLine = debounce13.default(async () => {
      let [previewing, currwin, lnum] = await nvim.eval('[coc#list#has_preview(),win_getid(),line(".")]');
      if (previewing && currwin == this.winid) {
        await this.doPreview(lnum - 1);
      }
    }, 50);
    this.disposables.push({
      dispose: () => {
        debouncedChangeLine.clear();
      }
    });
    this.ui.onDidChangeLine(debouncedChangeLine, null, this.disposables);
    this.ui.onDidChangeLine(this.resolveItem, this, this.disposables);
    this.ui.onDidLineChange(this.resolveItem, this, this.disposables);
    let debounced = debounce13.default(async () => {
      let {autoPreview} = this.listOptions;
      if (!autoPreview) {
        let [previewing, mode] = await nvim.eval("[coc#list#has_preview(),mode()]");
        if (!previewing || mode != "n")
          return;
      }
      await this.doAction("preview");
    }, 50);
    this.disposables.push({
      dispose: () => {
        debounced.clear();
      }
    });
    this.ui.onDidLineChange(debounced, null, this.disposables);
    this.ui.onDidLineChange(() => {
      this.updateStatus();
    }, null, this.disposables);
    this.ui.onDidOpen(async () => {
      if (typeof this.list.doHighlight == "function") {
        this.list.doHighlight();
      }
      if (this.listOptions.first) {
        await this.doAction();
      }
    }, null, this.disposables);
    this.ui.onDidClose(async () => {
      await this.hide();
    }, null, this.disposables);
    this.ui.onDidDoubleClick(async () => {
      await this.doAction();
    }, null, this.disposables);
    this.worker.onDidChangeItems(async ({items, reload, append, finished}) => {
      if (this.hidden)
        return;
      if (append) {
        await this.ui.appendItems(items);
      } else {
        let height = this.config.get("height", 10);
        if (finished && !listOptions.interactive && listOptions.input.length == 0) {
          height = Math.min(items.length, height);
        }
        let tokenSource = this.uiTokenSource = new vscode_languageserver_protocol58.CancellationTokenSource();
        await this.ui.drawItems(items, Math.max(1, height), reload, tokenSource.token);
      }
    }, null, this.disposables);
    this.worker.onDidChangeLoading((loading) => {
      if (this.hidden)
        return;
      if (loading) {
        this.interval = setInterval(() => {
          let idx = Math.floor(new Date().getMilliseconds() / 100);
          this.loadingFrame = frames2[idx];
          this.updateStatus();
        }, 100);
      } else {
        if (this.interval) {
          this.loadingFrame = "";
          clearInterval(this.interval);
          this.interval = null;
        }
        this.updateStatus();
      }
    }, null, this.disposables);
  }
  async start(args) {
    this.args = args;
    this.cwd = workspace_default.cwd;
    this.hidden = false;
    let {listOptions, listArgs} = this;
    let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
    this.listArgs = listArgs;
    this.history.load(listOptions.input || "");
    this.window = this.nvim.createWindow(res[0]);
    this.buffer = this.nvim.createBuffer(res[1]);
    this.savedHeight = res[2];
    await this.worker.loadItems(this.context);
  }
  async reloadItems() {
    if (!this.window)
      return;
    let bufnr = await this.nvim.call("winbufnr", [this.window.id]);
    if (bufnr == -1)
      return;
    this.buffer = this.nvim.createBuffer(bufnr);
    await this.worker.loadItems(this.context, true);
  }
  async call(fname) {
    var _a2, _b;
    await this.nvim.call("coc#prompt#stop_prompt", ["list"]);
    let targets = await this.ui.getItems();
    let context = {
      name: this.name,
      args: this.listArgs,
      input: this.prompt.input,
      winid: (_a2 = this.window) == null ? void 0 : _a2.id,
      bufnr: (_b = this.buffer) == null ? void 0 : _b.id,
      targets
    };
    let res = await this.nvim.call(fname, [context]);
    this.prompt.start();
    return res;
  }
  async chooseAction() {
    let {nvim} = this;
    let {actions, defaultAction} = this.list;
    let names = actions.map((o) => o.name);
    let idx = names.indexOf(defaultAction);
    if (idx != -1) {
      names.splice(idx, 1);
      names.unshift(defaultAction);
    }
    let shortcuts = new Set();
    let choices = [];
    let invalids = [];
    for (let name2 of names) {
      let i = 0;
      for (let ch of name2) {
        if (!shortcuts.has(ch)) {
          shortcuts.add(ch);
          choices.push(`${name2.slice(0, i)}&${name2.slice(i)}`);
          break;
        }
        i++;
      }
      if (i == name2.length) {
        invalids.push(name2);
      }
    }
    if (invalids.length) {
      logger54.error(`Can't create shortcut for actions: ${invalids.join(",")} of "${this.name}" list`);
      names = names.filter((s) => !invalids.includes(s));
    }
    await nvim.call("coc#prompt#stop_prompt", ["list"]);
    let n = await nvim.call("confirm", ["Choose action:", choices.join("\n")]);
    await wait(10);
    this.prompt.start();
    if (n)
      await this.doAction(names[n - 1]);
  }
  async doAction(name2) {
    let {list: list2} = this;
    name2 = name2 || list2.defaultAction;
    let action = list2.actions.find((o) => o.name == name2);
    if (!action) {
      window_default.showMessage(`Action ${name2} not found`, "error");
      return;
    }
    let items;
    if (name2 == "preview") {
      let item = await this.ui.item;
      items = item ? [item] : [];
    } else {
      items = await this.ui.getItems();
    }
    if (items.length)
      await this.doItemAction(items, action);
  }
  async doPreview(index) {
    let item = this.ui.getItem(index);
    let action = this.list.actions.find((o) => o.name == "preview");
    if (!item || !action)
      return;
    await this.doItemAction([item], action);
  }
  async first() {
    await this.doDefaultAction(0);
  }
  async last() {
    await this.doDefaultAction(this.ui.length - 1);
  }
  async previous() {
    await this.doDefaultAction(this.ui.index - 1);
  }
  async next() {
    await this.doDefaultAction(this.ui.index + 1);
  }
  async doDefaultAction(index) {
    let {ui: ui2} = this;
    let item = ui2.getItem(index);
    if (!item)
      return;
    ui2.index = index;
    await this.doItemAction([item], this.defaultAction);
    await ui2.echoMessage(item);
  }
  get name() {
    return this.list.name;
  }
  get winid() {
    return this.ui.winid;
  }
  get length() {
    return this.ui.length;
  }
  get defaultAction() {
    let {defaultAction, actions} = this.list;
    let action = actions.find((o) => o.name == defaultAction);
    if (!action)
      throw new Error(`default action "${defaultAction}" not found`);
    return action;
  }
  async hide() {
    if (this.hidden)
      return;
    if (this.uiTokenSource) {
      this.uiTokenSource.cancel();
      this.uiTokenSource.dispose();
      this.uiTokenSource = null;
    }
    let {nvim, interval} = this;
    if (interval)
      clearInterval(interval);
    this.hidden = true;
    this.worker.stop();
    this.history.add();
    let {winid} = this.ui;
    this.ui.reset();
    if (this.window && winid) {
      await nvim.call("coc#list#hide", [this.window.id, this.savedHeight, winid]);
      if (workspace_default.isVim) {
        nvim.command("redraw", true);
        await wait(10);
      }
    }
    nvim.call("coc#prompt#stop_prompt", ["list"], true);
  }
  toggleMode() {
    let mode = this.prompt.mode == "normal" ? "insert" : "normal";
    this.prompt.mode = mode;
    this.listOptions.mode = mode;
    this.updateStatus();
  }
  stop() {
    this.worker.stop();
  }
  async resolveItem() {
    let index = this.ui.index;
    let item = this.ui.getItem(index);
    if (!item || item.resolved)
      return;
    let {list: list2} = this;
    if (typeof list2.resolveItem == "function") {
      let resolved = await Promise.resolve(list2.resolveItem(item));
      if (resolved && index == this.ui.index) {
        await this.ui.updateItem(resolved, index);
      }
    }
  }
  async showHelp() {
    await this.hide();
    let {list: list2, nvim} = this;
    if (!list2)
      return;
    nvim.pauseNotification();
    nvim.command(`tabe +setl\\ previewwindow [LIST HELP]`, true);
    nvim.command("setl nobuflisted noswapfile buftype=nofile bufhidden=wipe", true);
    await nvim.resumeNotification();
    let hasOptions = list2.options && list2.options.length;
    let buf = await nvim.buffer;
    let highligher4 = new highligher_default();
    highligher4.addLine("NAME", "Label");
    highligher4.addLine(`  ${list2.name} - ${list2.description || ""}
`);
    highligher4.addLine("SYNOPSIS", "Label");
    highligher4.addLine(`  :CocList [LIST OPTIONS] ${list2.name}${hasOptions ? " [ARGUMENTS]" : ""}
`);
    if (list2.detail) {
      highligher4.addLine("DESCRIPTION", "Label");
      let lines = list2.detail.split("\n").map((s) => "  " + s);
      highligher4.addLine(lines.join("\n") + "\n");
    }
    if (hasOptions) {
      highligher4.addLine("ARGUMENTS", "Label");
      highligher4.addLine("");
      for (let opt of list2.options) {
        highligher4.addLine(opt.name, "Special");
        highligher4.addLine(`  ${opt.description}`);
        highligher4.addLine("");
      }
      highligher4.addLine("");
    }
    let config = workspace_default.getConfiguration(`list.source.${list2.name}`);
    if (Object.keys(config).length) {
      highligher4.addLine("CONFIGURATIONS", "Label");
      highligher4.addLine("");
      let props = {};
      extensions_default.all.forEach((extension) => {
        let {packageJSON} = extension;
        let {contributes} = packageJSON;
        if (!contributes)
          return;
        let {configuration: configuration7} = contributes;
        if (configuration7) {
          let {properties} = configuration7;
          if (properties) {
            for (let key of Object.keys(properties)) {
              props[key] = properties[key];
            }
          }
        }
      });
      for (let key of Object.keys(config)) {
        let val = config[key];
        let name2 = `list.source.${list2.name}.${key}`;
        let description = props[name2] && props[name2].description ? props[name2].description : key;
        highligher4.addLine(`  "${name2}"`, "MoreMsg");
        highligher4.addText(` - ${description}, current value: `);
        highligher4.addText(JSON.stringify(val), "Special");
      }
      highligher4.addLine("");
    }
    highligher4.addLine("ACTIONS", "Label");
    highligher4.addLine(`  ${list2.actions.map((o) => o.name).join(", ")}`);
    highligher4.addLine("");
    highligher4.addLine(`see ':h coc-list-options' for available list options.`, "Comment");
    nvim.pauseNotification();
    highligher4.render(buf, 0, -1);
    nvim.command("setl nomod", true);
    nvim.command("setl nomodifiable", true);
    nvim.command("normal! gg", true);
    nvim.command("nnoremap <buffer> q :bd!<CR>", true);
    await nvim.resumeNotification();
  }
  switchMatcher() {
    let {matcher, interactive} = this.listOptions;
    if (interactive)
      return;
    const list2 = ["fuzzy", "strict", "regex"];
    let idx = list2.indexOf(matcher) + 1;
    if (idx >= list2.length)
      idx = 0;
    this.listOptions.matcher = list2[idx];
    this.prompt.matcher = list2[idx];
    this.worker.drawItems();
  }
  updateStatus() {
    let {ui: ui2, list: list2, nvim} = this;
    if (!ui2.winid)
      return;
    let buf = nvim.createBuffer(ui2.bufnr);
    let status3 = {
      mode: this.prompt.mode.toUpperCase(),
      args: this.args.join(" "),
      name: list2.name,
      cwd: this.cwd,
      loading: this.loadingFrame,
      total: this.worker.length
    };
    nvim.pauseNotification();
    buf.setVar("list_status", status3, true);
    nvim.command("redraws", true);
    nvim.resumeNotification(false, true).logError();
  }
  get context() {
    let {winid} = this.ui;
    return {
      options: this.listOptions,
      args: this.listArgs,
      input: this.prompt.input,
      cwd: workspace_default.cwd,
      window: this.window,
      buffer: this.buffer,
      listWindow: winid ? this.nvim.createWindow(winid) : void 0
    };
  }
  redrawItems() {
    this.worker.drawItems();
  }
  onMouseEvent(key) {
    switch (key) {
      case "<LeftMouse>":
        return this.ui.onMouse("mouseDown");
      case "<LeftDrag>":
        return this.ui.onMouse("mouseDrag");
      case "<LeftRelease>":
        return this.ui.onMouse("mouseUp");
      case "<2-LeftMouse>":
        return this.ui.onMouse("doubleClick");
    }
  }
  async doNumberSelect(ch) {
    if (!this.listOptions.numberSelect)
      return false;
    let code = ch.charCodeAt(0);
    if (code >= 48 && code <= 57) {
      let n = Number(ch);
      if (n == 0)
        n = 10;
      if (this.ui.length >= n) {
        this.nvim.pauseNotification();
        this.ui.setCursor(Number(ch), 0);
        await this.nvim.resumeNotification();
        await this.doAction();
      }
      return true;
    }
    return false;
  }
  jumpBack() {
    let {window: window36, nvim} = this;
    if (window36) {
      nvim.pauseNotification();
      nvim.call("coc#prompt#stop_prompt", ["list"], true);
      this.nvim.call("win_gotoid", [window36.id], true);
      nvim.resumeNotification(false, true).logError();
    }
  }
  async resume() {
    if (this.winid)
      await this.hide();
    let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
    this.hidden = false;
    this.window = this.nvim.createWindow(res[0]);
    this.buffer = this.nvim.createBuffer(res[1]);
    this.savedHeight = res[2];
    this.prompt.start();
    await this.ui.resume();
    if (this.listOptions.autoPreview) {
      await this.doAction("preview");
    }
  }
  async doItemAction(items, action) {
    let {noQuit} = this.listOptions;
    let {nvim} = this;
    let persistAction = action.persist === true || action.name == "preview";
    let persist = this.winid && (persistAction || noQuit);
    try {
      if (persist) {
        if (!persistAction) {
          nvim.pauseNotification();
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
          nvim.call("win_gotoid", [this.context.window.id], true);
          await nvim.resumeNotification();
        }
      } else {
        await this.hide();
      }
      if (action.multiple) {
        await Promise.resolve(action.execute(items, this.context));
      } else if (action.parallel) {
        await Promise.all(items.map((item) => Promise.resolve(action.execute(item, this.context))));
      } else {
        for (let item of items) {
          await Promise.resolve(action.execute(item, this.context));
        }
      }
      if (persist) {
        this.ui.restoreWindow();
      }
      if (action.reload && persist)
        await this.worker.loadItems(this.context, true);
    } catch (e) {
      console.error(e);
    }
  }
  onInputChange() {
    if (this.timer)
      clearTimeout(this.timer);
    let len = this.worker.length;
    this.listOptions.input = this.prompt.input;
    if (this.listOptions.interactive) {
      this.worker.stop();
      this.timer = setTimeout(async () => {
        await this.worker.loadItems(this.context);
      }, this.interactiveDebounceTime);
    } else if (len) {
      let wait2 = Math.max(Math.min(Math.floor(len / 200), 300), 50);
      this.timer = setTimeout(() => {
        this.worker.drawItems();
      }, wait2);
    }
  }
  dispose() {
    if (!this.hidden) {
      this.hidden = true;
      if (this.uiTokenSource) {
        this.uiTokenSource.cancel();
        this.uiTokenSource.dispose();
        this.uiTokenSource = null;
      }
      let {winid} = this.ui;
      this.ui.reset();
      if (this.window && winid) {
        this.nvim.call("coc#list#hide", [this.window.id, this.savedHeight, winid], true);
      }
    }
    if (this.interval) {
      clearInterval(this.interval);
    }
    if (this.timer) {
      clearTimeout(this.timer);
    }
    disposeAll(this.disposables);
    this.worker.dispose();
    this.ui.dispose();
  }
};
var session_default = ListSession;

// src/list/basic.ts
var fs33 = __toModule(require("fs"));
var path35 = __toModule(require("path"));
var readline7 = __toModule(require("readline"));
var vscode_languageserver_protocol59 = __toModule(require_main3());

// src/list/commandTask.ts
var child_process5 = __toModule(require("child_process"));
var events17 = __toModule(require("events"));
var readline5 = __toModule(require("readline"));
var logger55 = require_logger2()("list-commandTask");
var CommandTask = class extends events17.EventEmitter {
  constructor(opt) {
    super();
    this.opt = opt;
    this.disposables = [];
    this.start();
  }
  start() {
    let {cmd, args, cwd, onLine} = this.opt;
    let proc = child_process5.spawn(cmd, args, {cwd, windowsHide: true});
    this.disposables.push({
      dispose: () => {
        proc.kill();
      }
    });
    proc.on("error", (e) => {
      this.emit("error", e.message);
    });
    proc.stderr.on("data", (chunk) => {
      logger55.error(`[${cmd} Error]`, chunk.toString("utf8"));
    });
    const rl = readline5.default.createInterface(proc.stdout);
    rl.on("line", (line) => {
      let res = onLine(line);
      if (res)
        this.emit("data", res);
    });
    rl.on("close", () => {
      this.emit("end");
    });
  }
  dispose() {
    disposeAll(this.disposables);
  }
};
var commandTask_default = CommandTask;

// src/list/basic.ts
var logger56 = require_logger2()("list-basic");
var BasicList = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.defaultAction = "open";
    this.actions = [];
    this.options = [];
    this.disposables = [];
    this.config = new configuration_default2();
  }
  get alignColumns() {
    return this.config.get("alignColumns", false);
  }
  get hlGroup() {
    return this.config.get("previewHighlightGroup", "Search");
  }
  get previewHeight() {
    return this.config.get("maxPreviewHeight", 12);
  }
  get splitRight() {
    return this.config.get("previewSplitRight", false);
  }
  parseArguments(args) {
    if (!this.optionMap) {
      this.optionMap = new Map();
      for (let opt of this.options) {
        let parts = opt.name.split(/,\s*/g).map((s) => s.replace(/\s+.*/g, ""));
        let name2 = opt.key ? opt.key : parts[parts.length - 1].replace(/^-/, "");
        for (let p of parts) {
          this.optionMap.set(p, {name: name2, hasValue: opt.hasValue});
        }
      }
    }
    let res = {};
    for (let i = 0; i < args.length; i++) {
      let arg = args[i];
      let def = this.optionMap.get(arg);
      if (!def) {
        logger56.error(`Option "${arg}" of "${this.name}" not found`);
        continue;
      }
      let value = true;
      if (def.hasValue) {
        value = args[i + 1] || "";
        i = i + 1;
      }
      res[def.name] = value;
    }
    return res;
  }
  getConfig() {
    return workspace_default.getConfiguration(`list.source.${this.name}`);
  }
  addAction(name2, fn, options) {
    this.createAction(Object.assign({
      name: name2,
      execute: fn
    }, options || {}));
  }
  addMultipleAction(name2, fn, options) {
    this.createAction(Object.assign({
      name: name2,
      multiple: true,
      execute: fn
    }, options || {}));
  }
  createCommandTask(opt) {
    return new commandTask_default(opt);
  }
  addLocationActions() {
    this.createAction({
      name: "preview",
      execute: async (item, context) => {
        let loc = await this.convertLocation(item.location);
        await this.previewLocation(loc, context);
      }
    });
    let {nvim} = this;
    this.createAction({
      name: "quickfix",
      multiple: true,
      execute: async (items) => {
        let quickfixItems = await Promise.all(items.map((item) => this.convertLocation(item.location).then((loc) => workspace_default.getQuickfixItem(loc))));
        await nvim.call("setqflist", [quickfixItems]);
        let openCommand = await nvim.getVar("coc_quickfix_open_command");
        nvim.command(typeof openCommand === "string" ? openCommand : "copen", true);
      }
    });
    for (let name2 of ["open", "tabe", "drop", "vsplit", "split"]) {
      this.createAction({
        name: name2,
        execute: async (item) => {
          await this.jumpTo(item.location, name2 == "open" ? null : name2);
        }
      });
    }
  }
  async convertLocation(location5) {
    if (typeof location5 == "string")
      return vscode_languageserver_protocol59.Location.create(location5, vscode_languageserver_protocol59.Range.create(0, 0, 0, 0));
    if (vscode_languageserver_protocol59.Location.is(location5))
      return location5;
    let u = URI.parse(location5.uri);
    if (u.scheme != "file")
      return vscode_languageserver_protocol59.Location.create(location5.uri, vscode_languageserver_protocol59.Range.create(0, 0, 0, 0));
    const rl = readline7.default.createInterface({
      input: fs33.default.createReadStream(u.fsPath, {encoding: "utf8"})
    });
    let match3 = location5.line;
    let n = 0;
    let resolved = false;
    let line = await new Promise((resolve3) => {
      rl.on("line", (line2) => {
        if (resolved)
          return;
        if (line2.includes(match3)) {
          rl.removeAllListeners();
          rl.close();
          resolved = true;
          resolve3(line2);
          return;
        }
        n = n + 1;
      });
      rl.on("error", (e) => {
        this.nvim.errWriteLine(`Read ${u.fsPath} error: ${e.message}`);
        resolve3(null);
      });
    });
    if (line != null) {
      let character = location5.text ? line.indexOf(location5.text) : 0;
      if (character == 0)
        character = line.match(/^\s*/)[0].length;
      let end = vscode_languageserver_protocol59.Position.create(n, character + (location5.text ? location5.text.length : 0));
      return vscode_languageserver_protocol59.Location.create(location5.uri, vscode_languageserver_protocol59.Range.create(vscode_languageserver_protocol59.Position.create(n, character), end));
    }
    return vscode_languageserver_protocol59.Location.create(location5.uri, vscode_languageserver_protocol59.Range.create(0, 0, 0, 0));
  }
  async jumpTo(location5, command) {
    if (typeof location5 == "string") {
      await workspace_default.jumpTo(location5, null, command);
      return;
    }
    let {range: range2, uri} = await this.convertLocation(location5);
    let position15 = range2.start;
    if (position15.line == 0 && position15.character == 0 && comparePosition(position15, range2.end) == 0) {
      position15 = null;
    }
    await workspace_default.jumpTo(uri, position15, command);
  }
  createAction(action) {
    let {name: name2} = action;
    let idx = this.actions.findIndex((o) => o.name == name2);
    if (idx !== -1)
      this.actions.splice(idx, 1);
    this.actions.push(action);
  }
  async previewLocation(location5, context) {
    if (!context.listWindow)
      return;
    let {nvim} = this;
    let {uri, range: range2} = location5;
    let doc = workspace_default.getDocument(location5.uri);
    let u = URI.parse(uri);
    let lines = [];
    if (doc) {
      lines = doc.getLines();
    } else if (u.scheme == "file") {
      try {
        let content = await readFile(u.fsPath, "utf8");
        lines = content.split(/\r?\n/);
      } catch (e) {
        [`Error on read file ${u.fsPath}`, e.message];
      }
    }
    let config = {
      winid: context.window.id,
      range: emptyRange(range2) ? null : range2,
      lnum: range2.start.line + 1,
      name: u.scheme == "file" ? u.fsPath : uri,
      filetype: doc ? doc.filetype : this.getFiletype(u.fsPath),
      position: context.options.position,
      maxHeight: this.previewHeight,
      splitRight: this.splitRight,
      hlGroup: this.hlGroup,
      scheme: u.scheme
    };
    await nvim.call("coc#list#preview", [lines, config]);
    if (workspace_default.isVim)
      nvim.command("redraw", true);
  }
  async preview(options, context) {
    let {nvim} = this;
    let {bufname, filetype, range: range2, lines, lnum} = options;
    let config = {
      winid: context.window.id,
      lnum: range2 ? range2.start.line + 1 : lnum || 1,
      filetype: filetype || "txt",
      position: context.options.position,
      maxHeight: this.previewHeight,
      splitRight: this.splitRight,
      hlGroup: this.hlGroup
    };
    if (bufname)
      config.name = bufname;
    if (range2)
      config.range = range2;
    await nvim.call("coc#list#preview", [lines, config]);
    if (workspace_default.isVim)
      nvim.command("redraw", true);
  }
  doHighlight() {
  }
  dispose() {
    disposeAll(this.disposables);
  }
  getFiletype(filepath) {
    let extname = path35.default.extname(filepath);
    if (!extname)
      return "";
    for (let doc of workspace_default.documents) {
      let fsPath = URI.parse(doc.uri).fsPath;
      if (path35.default.extname(fsPath) == extname) {
        let {filetype} = doc;
        if (filetype == "javascriptreact")
          return "javascript";
        if (filetype == "typescriptreact")
          return "typescript";
        if (filetype.indexOf(".") !== -1)
          return filetype.split(".")[0];
        return filetype;
      }
    }
    return "";
  }
};
var basic_default = BasicList;

// src/list/formatting.ts
var path37 = __toModule(require("path"));
function formatListItems(align, list2) {
  if (list2.length === 0) {
    return [];
  }
  let processedList = [];
  if (align) {
    const maxWidths = Array(Math.min(...list2.map((item) => item.label.length))).fill(0);
    for (let item of list2) {
      for (let i = 0; i < maxWidths.length; i++) {
        maxWidths[i] = Math.max(maxWidths[i], item.label[i].length);
      }
    }
    processedList = list2.map((item) => ({
      ...item,
      label: item.label.map((element, idx) => element.padEnd(maxWidths[idx])).join("	")
    }));
  } else {
    processedList = list2.map((item) => ({...item, label: item.label.join("	")}));
  }
  return processedList;
}
function formatPath(format4, pathToFormat) {
  var _a2;
  if (format4 === "hidden") {
    return "";
  } else if (format4 === "full") {
    return pathToFormat;
  } else if (format4 === "short") {
    const segments = pathToFormat.split(path37.default.sep);
    if (segments.length < 2) {
      return pathToFormat;
    }
    const shortenedInit = segments.slice(0, segments.length - 2).filter((seg) => seg.length > 0).map((seg) => seg[0]);
    return [...shortenedInit, segments[segments.length - 1]].join(path37.default.sep);
  } else {
    const segments = pathToFormat.split(path37.default.sep);
    return (_a2 = segments[segments.length - 1]) != null ? _a2 : "";
  }
}

// src/list/source/commands.ts
var CommandsList = class extends basic_default {
  constructor(nvim) {
    super(nvim);
    this.defaultAction = "run";
    this.description = "registered commands of coc.nvim";
    this.name = "commands";
    this.mru = workspace_default.createMru("commands");
    this.addAction("run", async (item) => {
      let {cmd} = item.data;
      await events_default.fire("Command", [cmd]);
      commands_default.executeCommand(cmd).logError();
      await commands_default.addRecent(cmd);
    });
    this.addAction("append", async (item) => {
      let {cmd} = item.data;
      await nvim.feedKeys(`:CocCommand ${cmd} `, "n", false);
    });
  }
  async loadItems(_context) {
    let items = [];
    let list2 = commands_default.commandList;
    let {titles} = commands_default;
    let mruList = await this.mru.load();
    for (const o of list2) {
      const {id} = o;
      items.push({
        label: [id, ...titles.get(id) ? [titles.get(id)] : []],
        filterText: id,
        data: {cmd: id, score: score4(mruList, id)}
      });
    }
    items.sort((a, b) => b.data.score - a.data.score);
    return formatListItems(this.alignColumns, items);
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocCommandsTitle /\\t.*$/ contained containedin=CocCommandsLine", true);
    nvim.command("highlight default link CocCommandsTitle Comment", true);
    nvim.resumeNotification().catch((_e) => {
    });
  }
};
var commands_default2 = CommandsList;
function score4(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}

// src/list/source/diagnostics.ts
var path41 = __toModule(require("path"));

// src/list/source/location.ts
var vscode_languageserver_types = __toModule(require_main2());
var path39 = __toModule(require("path"));
var logger57 = require_logger2()("list-location");
var LocationList = class extends basic_default {
  constructor(nvim) {
    super(nvim);
    this.defaultAction = "open";
    this.description = "show locations saved by g:coc_jump_locations variable";
    this.name = "location";
    this.addLocationActions();
  }
  async loadItems(context, token) {
    let locs = await this.nvim.getVar("coc_jump_locations");
    if (token.isCancellationRequested)
      return [];
    locs = locs || [];
    locs.forEach((loc) => {
      if (!loc.uri) {
        let fullpath = path39.default.isAbsolute(loc.filename) ? loc.filename : path39.default.join(context.cwd, loc.filename);
        loc.uri = URI.file(fullpath).toString();
      }
      if (!loc.bufnr && workspace_default.getDocument(loc.uri) != null) {
        loc.bufnr = workspace_default.getDocument(loc.uri).bufnr;
      }
      if (!loc.range) {
        let {lnum, col} = loc;
        loc.range = vscode_languageserver_types.Range.create(lnum - 1, col - 1, lnum - 1, col - 1);
      } else {
        loc.lnum = loc.lnum || loc.range.start.line + 1;
        loc.col = loc.col || loc.range.start.character + 1;
      }
    });
    let bufnr = await this.nvim.call("bufnr", "%");
    let ignoreFilepath = locs.every((o) => o.bufnr && bufnr && o.bufnr == bufnr);
    let items = locs.map((loc) => {
      let filename = ignoreFilepath ? "" : loc.filename;
      let filterText = `${filename}${loc.text.trim()}`;
      if (path39.default.isAbsolute(filename)) {
        filename = isParentFolder(context.cwd, filename) ? path39.default.relative(context.cwd, filename) : filename;
      }
      let pre = `${filename} |${loc.type ? loc.type + " " : ""}${loc.lnum} col ${loc.col}| `;
      let highlight;
      if (loc.range && loc.range.start.line == loc.range.end.line) {
        let start = byteLength(pre) + byteLength(loc.text.slice(0, loc.range.start.character));
        let end = byteLength(pre) + byteLength(loc.text.slice(0, loc.range.end.character));
        highlight = {hlGroup: "Search", span: [start, end]};
      }
      let label = pre + loc.text;
      return {
        label,
        location: vscode_languageserver_types.Location.create(loc.uri, loc.range),
        filterText,
        ansiHighlights: highlight ? [highlight] : void 0
      };
    });
    return items;
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocLocationName /\\v^[^|]+/ contained containedin=CocLocationLine", true);
    nvim.command("syntax match CocLocationPosition /\\v\\|\\w*\\s?\\d+\\scol\\s\\d+\\|/ contained containedin=CocLocationLine", true);
    nvim.command("syntax match CocLocationError /Error/ contained containedin=CocLocationPosition", true);
    nvim.command("syntax match CocLocationWarning /Warning/ contained containedin=CocLocationPosition", true);
    nvim.command("highlight default link CocLocationName Directory", true);
    nvim.command("highlight default link CocLocationPosition LineNr", true);
    nvim.command("highlight default link CocLocationError Error", true);
    nvim.command("highlight default link CocLocationWarning WarningMsg", true);
    nvim.resumeNotification().catch((_e) => {
    });
  }
};
var location_default = LocationList;

// src/list/source/diagnostics.ts
var logger58 = require_logger2()("list-symbols");
var DiagnosticsList = class extends location_default {
  constructor() {
    super(...arguments);
    this.defaultAction = "open";
    this.description = "diagnostics of current workspace";
    this.name = "diagnostics";
  }
  async loadItems(context) {
    let list2 = manager_default.getDiagnosticList();
    let {cwd} = context;
    const shouldIncludeCode = this.getConfig().get("includeCode", true);
    const pathFormat = this.getConfig().get("pathFormat", "full");
    const unformatted = list2.map((item) => {
      const file = isParentFolder(cwd, item.file) ? path41.default.relative(cwd, item.file) : item.file;
      const formattedPath = formatPath(pathFormat, file);
      const formattedPosition = pathFormat !== "hidden" ? [`${formattedPath}:${item.lnum}`] : [];
      const code = shouldIncludeCode ? [`[${item.source}${item.code ? "" : "]"}`, item.code ? `${item.code}]` : ""] : [];
      return {
        label: [...formattedPosition, ...code, item.severity, item.message],
        location: item.location
      };
    });
    return formatListItems(this.alignColumns, unformatted);
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocDiagnosticsFile /\\v^\\s*\\S+/ contained containedin=CocDiagnosticsLine", true);
    nvim.command("syntax match CocDiagnosticsError /\\tError\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
    nvim.command("syntax match CocDiagnosticsWarning /\\tWarning\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
    nvim.command("syntax match CocDiagnosticsInfo /\\tInformation\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
    nvim.command("syntax match CocDiagnosticsHint /\\tHint\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
    nvim.command("highlight default link CocDiagnosticsFile Comment", true);
    nvim.command("highlight default link CocDiagnosticsError CocErrorSign", true);
    nvim.command("highlight default link CocDiagnosticsWarning CocWarningSign", true);
    nvim.command("highlight default link CocDiagnosticsInfo CocInfoSign", true);
    nvim.command("highlight default link CocDiagnosticsHint CocHintSign", true);
    nvim.resumeNotification().catch((_e) => {
    });
  }
};
var diagnostics_default = DiagnosticsList;

// src/list/source/extensions.ts
var fs_extra7 = __toModule(require_lib7());
var os13 = __toModule(require("os"));
var path43 = __toModule(require("path"));
var logger59 = require_logger2()("list-extensions");
var ExtensionList = class extends basic_default {
  constructor(nvim) {
    super(nvim);
    this.defaultAction = "toggle";
    this.description = "manage coc extensions";
    this.name = "extensions";
    this.addAction("toggle", async (item) => {
      let {id, state} = item.data;
      if (state == "disabled")
        return;
      if (state == "activated") {
        await extensions_default.deactivate(id);
      } else {
        await extensions_default.activate(id);
      }
      await wait(100);
    }, {persist: true, reload: true, parallel: true});
    this.addAction("configuration", async (item) => {
      let {root} = item.data;
      let jsonFile = path43.default.join(root, "package.json");
      if (fs_extra7.default.existsSync(jsonFile)) {
        let lines = fs_extra7.default.readFileSync(jsonFile, "utf8").split(/\r?\n/);
        let idx = lines.findIndex((s) => s.includes('"contributes"'));
        await workspace_default.jumpTo(URI.file(jsonFile).toString(), {line: idx == -1 ? 0 : idx, character: 0});
      }
    });
    this.addAction("open", async (item) => {
      let {root} = item.data;
      if (workspace_default.env.isiTerm) {
        nvim.call("coc#util#iterm_open", [root], true);
      } else {
        nvim.call("coc#util#open_url", [root], true);
      }
    });
    this.addAction("disable", async (item) => {
      let {id, state} = item.data;
      if (state !== "disabled")
        await extensions_default.toggleExtension(id);
    }, {persist: true, reload: true, parallel: true});
    this.addAction("enable", async (item) => {
      let {id, state} = item.data;
      if (state == "disabled")
        await extensions_default.toggleExtension(id);
    }, {persist: true, reload: true, parallel: true});
    this.addAction("lock", async (item) => {
      let {id} = item.data;
      await extensions_default.toggleLock(id);
    }, {persist: true, reload: true});
    this.addAction("help", async (item) => {
      let {root} = item.data;
      let files = await fs_extra7.default.readdir(root);
      let file = files.find((f) => /^readme/i.test(f));
      if (file) {
        let escaped = await nvim.call("fnameescape", [path43.default.join(root, file)]);
        await workspace_default.callAsync("coc#util#execute", [`edit ${escaped}`]);
      }
    });
    this.addAction("reload", async (item) => {
      let {id} = item.data;
      await extensions_default.reloadExtension(id);
    }, {persist: true, reload: true});
    this.addAction("fix", async (item) => {
      let {root, isLocal} = item.data;
      let {npm} = extensions_default;
      if (isLocal) {
        window_default.showMessage(`Can't fix for local extension.`, "warning");
        return;
      }
      if (!npm)
        return;
      let folder = path43.default.join(root, "node_modules");
      if (fs_extra7.default.existsSync(folder)) {
        fs_extra7.default.removeSync(folder);
      }
      let terminal2 = await workspace_default.createTerminal({
        cwd: root
      });
      let shown = await terminal2.show(false);
      if (!shown)
        return;
      workspace_default.nvim.command(`startinsert`, true);
      terminal2.sendText(`${npm} install --production --ignore-scripts --no-lockfile`, true);
    });
    this.addMultipleAction("uninstall", async (items) => {
      let ids = [];
      for (let item of items) {
        if (item.data.isLocal)
          continue;
        ids.push(item.data.id);
      }
      extensions_default.uninstallExtension(ids).catch((e) => {
        logger59.error(e);
      });
    });
  }
  async loadItems(_context) {
    let items = [];
    let list2 = await extensions_default.getExtensionStates();
    let lockedList = await extensions_default.getLockedList();
    for (let stat of list2) {
      let prefix = "+";
      if (stat.state == "disabled") {
        prefix = "-";
      } else if (stat.state == "activated") {
        prefix = "*";
      } else if (stat.state == "unknown") {
        prefix = "?";
      }
      let root = await this.nvim.call("resolve", stat.root);
      let locked = lockedList.includes(stat.id);
      items.push({
        label: [`${prefix} ${stat.id}${locked ? " \uE0A2" : ""}`, ...stat.isLocal ? ["[RTP]"] : [], stat.version, root.replace(os13.default.homedir(), "~")],
        filterText: stat.id,
        data: {
          id: stat.id,
          root,
          state: stat.state,
          isLocal: stat.isLocal,
          priority: getPriority(stat.state)
        }
      });
    }
    items.sort((a, b) => {
      if (a.data.priority != b.data.priority) {
        return b.data.priority - a.data.priority;
      }
      return b.data.id - a.data.id ? 1 : -1;
    });
    return formatListItems(this.alignColumns, items);
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocExtensionsActivited /\\v^\\*/ contained containedin=CocExtensionsLine", true);
    nvim.command("syntax match CocExtensionsLoaded /\\v^\\+/ contained containedin=CocExtensionsLine", true);
    nvim.command("syntax match CocExtensionsDisabled /\\v^-/ contained containedin=CocExtensionsLine", true);
    nvim.command("syntax match CocExtensionsName /\\v%3c\\S+/ contained containedin=CocExtensionsLine", true);
    nvim.command("syntax match CocExtensionsRoot /\\v\\t[^\\t]*$/ contained containedin=CocExtensionsLine", true);
    nvim.command("syntax match CocExtensionsLocal /\\v\\[RTP\\]/ contained containedin=CocExtensionsLine", true);
    nvim.command("highlight default link CocExtensionsActivited Special", true);
    nvim.command("highlight default link CocExtensionsLoaded Normal", true);
    nvim.command("highlight default link CocExtensionsDisabled Comment", true);
    nvim.command("highlight default link CocExtensionsName String", true);
    nvim.command("highlight default link CocExtensionsLocal MoreMsg", true);
    nvim.command("highlight default link CocExtensionsRoot Comment", true);
    nvim.resumeNotification().catch((_e) => {
    });
  }
};
var extensions_default2 = ExtensionList;
function getPriority(stat) {
  switch (stat) {
    case "unknown":
      return 2;
    case "activated":
      return 1;
    case "disabled":
      return -1;
    default:
      return 0;
  }
}

// src/list/source/folders.ts
var path45 = __toModule(require("path"));
var fs_extra8 = __toModule(require_lib7());
var FoldList = class extends basic_default {
  constructor(nvim) {
    super(nvim);
    this.defaultAction = "edit";
    this.description = "list of current workspace folders";
    this.name = "folders";
    this.addAction("edit", async (item) => {
      let newPath = await nvim.call("input", ["Folder: ", item.label, "dir"]);
      let stat = await statAsync(newPath);
      if (!stat || !stat.isDirectory()) {
        window_default.showMessage(`invalid path: ${newPath}`, "error");
        return;
      }
      workspace_default.renameWorkspaceFolder(item.label, newPath);
    });
    this.addAction("delete", async (item) => {
      workspace_default.removeWorkspaceFolder(item.label);
    }, {reload: true, persist: true});
    this.addAction("newfile", async (item) => {
      let file = await window_default.requestInput("File name", item.label + "/");
      let dir = path45.default.dirname(file);
      let stat = await statAsync(dir);
      if (!stat || !stat.isDirectory()) {
        let success = await fs_extra8.default.mkdirp(dir);
        if (!success) {
          window_default.showMessage(`Error creating new directory ${dir}`, "error");
          return;
        }
      }
      await workspace_default.createFile(file, {overwrite: false, ignoreIfExists: true});
      await this.jumpTo(URI.file(file).toString());
    });
  }
  async loadItems(_context) {
    return workspace_default.folderPaths.map((p) => ({label: p}));
  }
};
var folders_default = FoldList;

// src/list/source/links.ts
var path47 = __toModule(require("path"));
var vscode_languageserver_types2 = __toModule(require_main2());
var LinksList = class extends basic_default {
  constructor(nvim) {
    super(nvim);
    this.defaultAction = "open";
    this.description = "links of current buffer";
    this.name = "links";
    this.addAction("open", async (item) => {
      let {target} = item.data;
      let uri = URI.parse(target);
      if (uri.scheme.startsWith("http")) {
        await nvim.call("coc#util#open_url", target);
      } else {
        await workspace_default.jumpTo(target);
      }
    });
    this.addAction("jump", async (item) => {
      let {location: location5} = item.data;
      await workspace_default.jumpTo(location5.uri, location5.range.start);
    });
  }
  async loadItems(context, token) {
    let buf = await context.window.buffer;
    let doc = workspace_default.getDocument(buf.id);
    if (!doc)
      return null;
    let items = [];
    let links3 = await languages_default.getDocumentLinks(doc.textDocument, token);
    if (links3 == null) {
      throw new Error("Links provider not found.");
    }
    let res = [];
    for (let link of links3) {
      if (link.target) {
        items.push({
          label: formatUri(link.target),
          data: {
            target: link.target,
            location: vscode_languageserver_types2.Location.create(doc.uri, link.range)
          }
        });
      } else {
        link = await languages_default.resolveDocumentLink(link);
        if (link.target) {
          items.push({
            label: formatUri(link.target),
            data: {
              target: link.target,
              location: vscode_languageserver_types2.Location.create(doc.uri, link.range)
            }
          });
        }
        res.push(link);
      }
    }
    return items;
  }
};
var links_default = LinksList;
function formatUri(uri) {
  if (!uri.startsWith("file:"))
    return uri;
  let filepath = URI.parse(uri).fsPath;
  return isParentFolder(workspace_default.cwd, filepath) ? path47.default.relative(workspace_default.cwd, filepath) : filepath;
}

// src/list/source/lists.ts
var LinksList2 = class extends basic_default {
  constructor(nvim, listMap) {
    super(nvim);
    this.listMap = listMap;
    this.name = "lists";
    this.defaultAction = "open";
    this.description = "registered lists of coc.nvim";
    this.mru = new mru_default("lists");
    this.addAction("open", async (item) => {
      let {name: name2} = item.data;
      await this.mru.add(name2);
      await nvim.command(`CocList ${name2}`);
    });
  }
  async loadItems(_context) {
    let items = [];
    let mruList = await this.mru.load();
    for (let list2 of this.listMap.values()) {
      if (list2.name == "lists")
        continue;
      items.push({
        label: [list2.name, ...list2.description ? [list2.description] : []],
        data: {
          name: list2.name,
          interactive: list2.interactive,
          score: score5(mruList, list2.name)
        }
      });
    }
    items.sort((a, b) => b.data.score - a.data.score);
    return formatListItems(this.alignColumns, items);
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocListsDesc /\\t.*$/ contained containedin=CocListsLine", true);
    nvim.command("highlight default link CocListsDesc Comment", true);
    nvim.resumeNotification().catch((_e) => {
    });
  }
};
var lists_default = LinksList2;
function score5(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}

// src/list/source/outline.ts
var path49 = __toModule(require("path"));
var vscode_languageserver_types3 = __toModule(require_main2());
var which5 = __toModule(require_which());

// src/util/convert.ts
var vscode_languageserver_protocol60 = __toModule(require_main3());
function getSymbolKind(kind) {
  switch (kind) {
    case vscode_languageserver_protocol60.SymbolKind.File:
      return "File";
    case vscode_languageserver_protocol60.SymbolKind.Module:
      return "Module";
    case vscode_languageserver_protocol60.SymbolKind.Namespace:
      return "Namespace";
    case vscode_languageserver_protocol60.SymbolKind.Package:
      return "Package";
    case vscode_languageserver_protocol60.SymbolKind.Class:
      return "Class";
    case vscode_languageserver_protocol60.SymbolKind.Method:
      return "Method";
    case vscode_languageserver_protocol60.SymbolKind.Property:
      return "Property";
    case vscode_languageserver_protocol60.SymbolKind.Field:
      return "Field";
    case vscode_languageserver_protocol60.SymbolKind.Constructor:
      return "Constructor";
    case vscode_languageserver_protocol60.SymbolKind.Enum:
      return "Enum";
    case vscode_languageserver_protocol60.SymbolKind.Interface:
      return "Interface";
    case vscode_languageserver_protocol60.SymbolKind.Function:
      return "Function";
    case vscode_languageserver_protocol60.SymbolKind.Variable:
      return "Variable";
    case vscode_languageserver_protocol60.SymbolKind.Constant:
      return "Constant";
    case vscode_languageserver_protocol60.SymbolKind.String:
      return "String";
    case vscode_languageserver_protocol60.SymbolKind.Number:
      return "Number";
    case vscode_languageserver_protocol60.SymbolKind.Boolean:
      return "Boolean";
    case vscode_languageserver_protocol60.SymbolKind.Array:
      return "Array";
    case vscode_languageserver_protocol60.SymbolKind.Object:
      return "Object";
    case vscode_languageserver_protocol60.SymbolKind.Key:
      return "Key";
    case vscode_languageserver_protocol60.SymbolKind.Null:
      return "Null";
    case vscode_languageserver_protocol60.SymbolKind.EnumMember:
      return "EnumMember";
    case vscode_languageserver_protocol60.SymbolKind.Struct:
      return "Struct";
    case vscode_languageserver_protocol60.SymbolKind.Event:
      return "Event";
    case vscode_languageserver_protocol60.SymbolKind.Operator:
      return "Operator";
    case vscode_languageserver_protocol60.SymbolKind.TypeParameter:
      return "TypeParameter";
    default:
      return "Unknown";
  }
}

// src/list/source/outline.ts
var logger60 = require_logger2()("list-symbols");
function getFilterText(s, kind) {
  return `${s.name}${kind ? ` ${kind}` : ""}`;
}
var Outline = class extends location_default {
  constructor() {
    super(...arguments);
    this.description = "symbols of current document";
    this.name = "outline";
    this.options = [{
      name: "-k, -kind KIND",
      hasValue: true,
      description: "filters also by kind"
    }];
  }
  async loadItems(context, token) {
    let buf = await context.window.buffer;
    let document3 = workspace_default.getDocument(buf.id);
    if (!document3)
      return null;
    let config = this.getConfig();
    let ctagsFilestypes = config.get("ctagsFilestypes", []);
    let symbols3;
    let args = this.parseArguments(context.args);
    if (!ctagsFilestypes.includes(document3.filetype)) {
      symbols3 = await languages_default.getDocumentSymbol(document3.textDocument, token);
    }
    if (token.isCancellationRequested)
      return [];
    if (!symbols3)
      return await this.loadCtagsSymbols(document3);
    if (symbols3.length == 0)
      return [];
    let filterKind = args.kind ? args.kind.toLowerCase() : null;
    let items = [];
    let isSymbols = !symbols3[0].hasOwnProperty("location");
    if (isSymbols) {
      function addSymbols(symbols4, level = 0) {
        symbols4.sort(sortSymbols);
        for (let s of symbols4) {
          let kind = getSymbolKind(s.kind);
          let location5 = vscode_languageserver_types3.Location.create(document3.uri, s.selectionRange);
          items.push({
            label: [`${"| ".repeat(level)}${s.name}`, `[${kind}]`, `${s.range.start.line + 1}`],
            filterText: getFilterText(s, args.kind == "" ? kind : null),
            location: location5,
            data: {kind}
          });
          if (s.children && s.children.length) {
            addSymbols(s.children, level + 1);
          }
        }
      }
      addSymbols(symbols3);
      if (filterKind) {
        items = items.filter((o) => o.data.kind.toLowerCase().indexOf(filterKind) == 0);
      }
    } else {
      symbols3.sort((a, b) => {
        let sa = a.location.range.start;
        let sb = b.location.range.start;
        let d = sa.line - sb.line;
        return d == 0 ? sa.character - sb.character : d;
      });
      for (let s of symbols3) {
        let kind = getSymbolKind(s.kind);
        if (s.name.endsWith(") callback"))
          continue;
        if (filterKind && !kind.toLowerCase().startsWith(filterKind)) {
          continue;
        }
        if (s.location.uri === void 0) {
          s.location.uri = document3.uri;
        }
        items.push({
          label: [s.name, `[${kind}]`, `${s.location.range.start.line + 1}`],
          filterText: getFilterText(s, args.kind == "" ? kind : null),
          location: s.location
        });
      }
    }
    return formatListItems(this.alignColumns, items);
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocOutlineName /\\v\\s?[^\\t]+\\s/ contained containedin=CocOutlineLine", true);
    nvim.command("syntax match CocOutlineIndentLine /\\v\\|/ contained containedin=CocOutlineLine,CocOutlineName", true);
    nvim.command("syntax match CocOutlineKind /\\[\\w\\+\\]/ contained containedin=CocOutlineLine", true);
    nvim.command("syntax match CocOutlineLine /\\d\\+$/ contained containedin=CocOutlineLine", true);
    nvim.command("highlight default link CocOutlineName Normal", true);
    nvim.command("highlight default link CocOutlineIndentLine Comment", true);
    nvim.command("highlight default link CocOutlineKind Typedef", true);
    nvim.command("highlight default link CocOutlineLine Comment", true);
    nvim.resumeNotification(false, true).logError();
  }
  async loadCtagsSymbols(document3) {
    if (!which5.default.sync("ctags", {nothrow: true})) {
      return [];
    }
    let uri = URI.parse(document3.uri);
    let extname = path49.default.extname(uri.fsPath);
    let content = "";
    let tempname = await this.nvim.call("tempname");
    let filepath = `${tempname}.${extname}`;
    let escaped = await this.nvim.call("fnameescape", filepath);
    await writeFile(escaped, document3.getDocumentContent());
    try {
      content = await runCommand(`ctags -f - --excmd=number --language-force=${document3.filetype} ${escaped}`);
    } catch (e) {
    }
    if (!content.trim().length) {
      content = await runCommand(`ctags -f - --excmd=number ${escaped}`);
    }
    content = content.trim();
    if (!content)
      return [];
    let lines = content.split("\n");
    let items = [];
    for (let line of lines) {
      let parts = line.split("	");
      if (parts.length < 4)
        continue;
      let lnum = Number(parts[2].replace(/;"$/, ""));
      let text = document3.getline(lnum - 1);
      if (!text)
        continue;
      let idx = text.indexOf(parts[0]);
      let start = idx == -1 ? 0 : idx;
      let range2 = vscode_languageserver_types3.Range.create(lnum - 1, start, lnum - 1, start + parts[0].length);
      items.push({
        label: `${parts[0]} [${parts[3]}] ${lnum}`,
        filterText: parts[0],
        location: vscode_languageserver_types3.Location.create(document3.uri, range2),
        data: {line: lnum}
      });
    }
    items.sort((a, b) => a.data.line - b.data.line);
    return items;
  }
};
var outline_default = Outline;
function sortSymbols(a, b) {
  let ra = a.selectionRange;
  let rb = b.selectionRange;
  if (ra.start.line != rb.start.line) {
    return ra.start.line - rb.start.line;
  }
  return ra.start.character - rb.start.character;
}

// src/list/source/services.ts
var ServicesList = class extends basic_default {
  constructor(nvim) {
    super(nvim);
    this.defaultAction = "toggle";
    this.description = "registered services of coc.nvim";
    this.name = "services";
    this.addAction("toggle", async (item) => {
      let {id} = item.data;
      await services_default.toggle(id);
      await wait(100);
    }, {persist: true, reload: true});
  }
  async loadItems(_context) {
    let stats = services_default.getServiceStats();
    stats.sort((a, b) => a.id > b.id ? -1 : 1);
    return formatListItems(this.alignColumns, stats.map((stat) => {
      let prefix = stat.state == "running" ? "*" : " ";
      return {
        label: [prefix, stat.id, `[${stat.state}]`, stat.languageIds.join(", ")],
        data: {id: stat.id}
      };
    }));
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocServicesPrefix /\\v^./ contained containedin=CocServicesLine", true);
    nvim.command("syntax match CocServicesName /\\v%3c\\S+/ contained containedin=CocServicesLine", true);
    nvim.command("syntax match CocServicesStat /\\v\\t\\[\\w+\\]/ contained containedin=CocServicesLine", true);
    nvim.command("syntax match CocServicesLanguages /\\v(\\])@<=.*$/ contained containedin=CocServicesLine", true);
    nvim.command("highlight default link CocServicesPrefix Special", true);
    nvim.command("highlight default link CocServicesName Type", true);
    nvim.command("highlight default link CocServicesStat Statement", true);
    nvim.command("highlight default link CocServicesLanguages Comment", true);
    nvim.resumeNotification().catch((_e) => {
    });
  }
};
var services_default2 = ServicesList;

// src/list/source/sources.ts
var vscode_languageserver_types4 = __toModule(require_main2());
var logger61 = require_logger2()("list-sources");
var SourcesList = class extends basic_default {
  constructor(nvim) {
    super(nvim);
    this.defaultAction = "toggle";
    this.description = "registered completion sources";
    this.name = "sources";
    this.addAction("toggle", async (item) => {
      let {name: name2} = item.data;
      sources_default.toggleSource(name2);
    }, {persist: true, reload: true});
    this.addAction("refresh", async (item) => {
      let {name: name2} = item.data;
      await sources_default.refresh(name2);
    }, {persist: true, reload: true});
    this.addAction("open", async (item) => {
      let {location: location5} = item;
      if (location5)
        await this.jumpTo(location5);
    });
  }
  async loadItems(context) {
    let stats = sources_default.sourceStats();
    let filetype = await context.buffer.getOption("filetype");
    let map = workspace_default.env.disabledSources;
    let disables = map ? map[filetype] || [] : [];
    stats.sort((a, b) => {
      if (a.type != b.type)
        return a.type < b.type ? 1 : -1;
      return a.name > b.name ? -1 : 1;
    });
    return stats.map((stat) => {
      let prefix = stat.disabled ? " " : "*";
      if (disables && disables.includes(stat.name)) {
        prefix = "-";
      }
      let location5;
      if (stat.filepath) {
        location5 = vscode_languageserver_types4.Location.create(URI.file(stat.filepath).toString(), vscode_languageserver_types4.Range.create(0, 0, 0, 0));
      }
      return {
        label: `${prefix} ${fixWidth(stat.name, 22)} ${fixWidth("[" + stat.shortcut + "]", 10)} ${fixWidth(stat.triggerCharacters.join(""), 10)} ${fixWidth(stat.priority.toString(), 3)} ${stat.filetypes.join(",")}`,
        location: location5,
        data: {name: stat.name}
      };
    });
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocSourcesPrefix /\\v^./ contained containedin=CocSourcesLine", true);
    nvim.command("syntax match CocSourcesName /\\v%3c\\S+/ contained containedin=CocSourcesLine", true);
    nvim.command("syntax match CocSourcesType /\\v%25v.*%36v/ contained containedin=CocSourcesLine", true);
    nvim.command("syntax match CocSourcesPriority /\\v%46v.*%50v/ contained containedin=CocSourcesLine", true);
    nvim.command("syntax match CocSourcesFileTypes /\\v\\S+$/ contained containedin=CocSourcesLine", true);
    nvim.command("highlight default link CocSourcesPrefix Special", true);
    nvim.command("highlight default link CocSourcesName Type", true);
    nvim.command("highlight default link CocSourcesPriority Number", true);
    nvim.command("highlight default link CocSourcesFileTypes Comment", true);
    nvim.command("highlight default link CocSourcesType Statement", true);
    nvim.resumeNotification(false, true);
  }
};
var sources_default2 = SourcesList;
function fixWidth(str, width) {
  if (str.length > width) {
    return str.slice(0, width - 1) + ".";
  }
  return str + " ".repeat(width - str.length);
}

// src/list/source/symbols.ts
var path51 = __toModule(require("path"));
var minimatch9 = __toModule(require_minimatch());
var vscode_languageserver_protocol61 = __toModule(require_main3());
var logger62 = require_logger2()("list-symbols");
var Symbols = class extends location_default {
  constructor() {
    super(...arguments);
    this.interactive = true;
    this.description = "search workspace symbols";
    this.detail = "Symbols list is provided by server, it works on interactive mode only.";
    this.name = "symbols";
    this.options = [{
      name: "-k, -kind KIND",
      description: "Filter symbols by kind.",
      hasValue: true
    }];
  }
  async loadItems(context, token) {
    let {input} = context;
    let args = this.parseArguments(context.args);
    let filterKind = args.kind ? args.kind.toLowerCase() : "";
    if (!context.options.interactive) {
      throw new Error("Symbols only works on interactive mode");
    }
    let symbols3 = await languages_default.getWorkspaceSymbols(input, token);
    if (!symbols3) {
      throw new Error("No workspace symbols provider registed");
    }
    let config = this.getConfig();
    let excludes = config.get("excludes", []);
    let items = [];
    for (let s of symbols3) {
      let kind = getSymbolKind(s.kind);
      if (filterKind && kind.toLowerCase() != filterKind) {
        continue;
      }
      let file = URI.parse(s.location.uri).fsPath;
      if (isParentFolder(workspace_default.cwd, file)) {
        file = path51.default.relative(workspace_default.cwd, file);
      }
      if (excludes.some((p) => minimatch9.default(file, p))) {
        continue;
      }
      items.push({
        label: [s.name, `[${kind}]`, file],
        filterText: `${s.name}`,
        location: s.location,
        data: {original: s, kind: s.kind, file, score: score2(input, s.name)}
      });
    }
    items.sort((a, b) => {
      if (a.data.score != b.data.score) {
        return b.data.score - a.data.score;
      }
      if (a.data.kind != b.data.kind) {
        return a.data.kind - b.data.kind;
      }
      return a.data.file.length - b.data.file.length;
    });
    return formatListItems(this.alignColumns, items);
  }
  async resolveItem(item) {
    let s = item.data.original;
    if (!s)
      return null;
    let tokenSource = new vscode_languageserver_protocol61.CancellationTokenSource();
    let resolved = await languages_default.resolveWorkspaceSymbol(s, tokenSource.token);
    if (!resolved)
      return null;
    let kind = getSymbolKind(resolved.kind);
    let file = URI.parse(resolved.location.uri).fsPath;
    if (isParentFolder(workspace_default.cwd, file)) {
      file = path51.default.relative(workspace_default.cwd, file);
    }
    return {
      label: `${s.name} [${kind}]	${file}`,
      filterText: `${s.name}`,
      location: s.location
    };
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocSymbolsName /\\v^\\s*\\S+/ contained containedin=CocSymbolsLine", true);
    nvim.command("syntax match CocSymbolsKind /\\[\\w\\+\\]\\s*\\t/ contained containedin=CocSymbolsLine", true);
    nvim.command("syntax match CocSymbolsFile /\\S\\+$/ contained containedin=CocSymbolsLine", true);
    nvim.command("highlight default link CocSymbolsName Normal", true);
    nvim.command("highlight default link CocSymbolsKind Typedef", true);
    nvim.command("highlight default link CocSymbolsFile Comment", true);
    nvim.resumeNotification().catch((_e) => {
    });
  }
};
var symbols_default = Symbols;

// src/list/manager.ts
var logger63 = require_logger2()("list-manager");
var mouseKeys = ["<LeftMouse>", "<LeftDrag>", "<LeftRelease>", "<2-LeftMouse>"];
var ListManager = class {
  constructor() {
    this.plugTs = 0;
    this.sessionsMap = new Map();
    this.disposables = [];
    this.listMap = new Map();
  }
  init(nvim) {
    this.nvim = nvim;
    this.config = new configuration_default2();
    this.prompt = new prompt_default(nvim, this.config);
    this.mappings = new mappings_default(this, nvim, this.config);
    let signText = this.config.get("selectedSignText", "*");
    nvim.command(`sign define CocSelected text=${signText} texthl=CocSelectedText linehl=CocSelectedLine`, true);
    events_default.on("InputChar", this.onInputChar, this, this.disposables);
    events_default.on("FocusGained", debounce15.default(async () => {
      let session4 = await this.getCurrentSession();
      if (session4)
        this.prompt.drawPrompt();
    }, 100), null, this.disposables);
    let timer;
    events_default.on("WinEnter", (winid) => {
      let session4 = this.getSessionByWinid(winid);
      if (session4)
        this.prompt.start(session4.listOptions);
    }, null, this.disposables);
    events_default.on("WinLeave", (winid) => {
      let session4 = this.getSessionByWinid(winid);
      if (session4)
        this.prompt.cancel();
    });
    this.disposables.push(vscode_languageserver_protocol62.Disposable.create(() => {
      if (timer)
        clearTimeout(timer);
    }));
    this.prompt.onDidChangeInput(() => {
      let {session: session4} = this;
      if (!session4)
        return;
      session4.onInputChange();
      session4.history.filter();
    });
    this.registerList(new links_default(nvim));
    this.registerList(new location_default(nvim));
    this.registerList(new symbols_default(nvim));
    this.registerList(new outline_default(nvim));
    this.registerList(new commands_default2(nvim));
    this.registerList(new extensions_default2(nvim));
    this.registerList(new diagnostics_default(nvim));
    this.registerList(new sources_default2(nvim));
    this.registerList(new services_default2(nvim));
    this.registerList(new lists_default(nvim, this.listMap));
    this.registerList(new folders_default(nvim));
  }
  async start(args) {
    let res = this.parseArgs(args);
    if (!res)
      return;
    let {name: name2} = res.list;
    let curr = this.sessionsMap.get(name2);
    if (curr)
      curr.dispose();
    this.prompt.start(res.options);
    let session4 = new session_default(this.nvim, this.prompt, res.list, res.options, res.listArgs, this.config);
    this.sessionsMap.set(name2, session4);
    this.lastSession = session4;
    try {
      await session4.start(args);
    } catch (e) {
      this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
      let msg = e instanceof Error ? e.message : e.toString();
      window_default.showMessage(`Error on "CocList ${name2}": ${msg}`, "error");
      logger63.error(e);
    }
  }
  getSessionByWinid(winid) {
    for (let session4 of this.sessionsMap.values()) {
      if (session4 && session4.winid == winid) {
        this.lastSession = session4;
        return session4;
      }
    }
    return null;
  }
  async getCurrentSession() {
    let {id} = await this.nvim.window;
    for (let session4 of this.sessionsMap.values()) {
      if (session4 && session4.winid == id) {
        this.lastSession = session4;
        return session4;
      }
    }
    return null;
  }
  async resume(name2) {
    var _a2;
    if (!name2) {
      await ((_a2 = this.session) == null ? void 0 : _a2.resume());
    } else {
      let session4 = this.sessionsMap.get(name2);
      if (!session4) {
        window_default.showMessage(`Can't find exists ${name2} list`);
        return;
      }
      await session4.resume();
    }
  }
  async doAction(name2) {
    let lastSession = this.lastSession;
    if (!lastSession)
      return;
    await lastSession.doAction(name2);
  }
  async first(name2) {
    let s = this.getSession(name2);
    if (s)
      await s.first();
  }
  async last(name2) {
    let s = this.getSession(name2);
    if (s)
      await s.last();
  }
  async previous(name2) {
    let s = this.getSession(name2);
    if (s)
      await s.previous();
  }
  async next(name2) {
    let s = this.getSession(name2);
    if (s)
      await s.next();
  }
  getSession(name2) {
    if (!name2)
      return this.session;
    return this.sessionsMap.get(name2);
  }
  async cancel(close = true) {
    this.prompt.cancel();
    if (!close)
      return;
    if (this.session)
      await this.session.hide();
  }
  reset() {
    this.prompt.cancel();
    this.lastSession = void 0;
    for (let session4 of this.sessionsMap.values()) {
      session4.dispose();
    }
    this.sessionsMap.clear();
    this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
  }
  switchMatcher() {
    var _a2;
    (_a2 = this.session) == null ? void 0 : _a2.switchMatcher();
  }
  async togglePreview() {
    let {nvim} = this;
    let winid = await nvim.call("coc#list#get_preview", [0]);
    if (winid != -1) {
      let win = nvim.createWindow(winid);
      await win.close(true);
      await nvim.command("redraw");
    } else {
      await this.doAction("preview");
    }
  }
  async chooseAction() {
    let {lastSession} = this;
    if (lastSession)
      await lastSession.chooseAction();
  }
  parseArgs(args) {
    let options = [];
    let interactive = false;
    let autoPreview = false;
    let numberSelect = false;
    let noQuit = false;
    let first = false;
    let name2;
    let input = "";
    let matcher = "fuzzy";
    let position15 = "bottom";
    let listArgs = [];
    let listOptions = [];
    for (let arg of args) {
      if (!name2 && arg.startsWith("-")) {
        listOptions.push(arg);
      } else if (!name2) {
        if (!/^\w+$/.test(arg)) {
          window_default.showMessage(`Invalid list option: "${arg}"`, "error");
          return null;
        }
        name2 = arg;
      } else {
        listArgs.push(arg);
      }
    }
    name2 = name2 || "lists";
    let config = workspace_default.getConfiguration(`list.source.${name2}`);
    if (!listOptions.length && !listArgs.length)
      listOptions = config.get("defaultOptions", []);
    if (!listArgs.length)
      listArgs = config.get("defaultArgs", []);
    for (let opt of listOptions) {
      if (opt.startsWith("--input")) {
        input = opt.slice(8);
      } else if (opt == "--number-select" || opt == "-N") {
        numberSelect = true;
      } else if (opt == "--auto-preview" || opt == "-A") {
        autoPreview = true;
      } else if (opt == "--regex" || opt == "-R") {
        matcher = "regex";
      } else if (opt == "--strict" || opt == "-S") {
        matcher = "strict";
      } else if (opt == "--interactive" || opt == "-I") {
        interactive = true;
      } else if (opt == "--top") {
        position15 = "top";
      } else if (opt == "--tab") {
        position15 = "tab";
      } else if (opt == "--ignore-case" || opt == "--normal" || opt == "--no-sort") {
        options.push(opt.slice(2));
      } else if (opt == "--first") {
        first = true;
      } else if (opt == "--no-quit") {
        noQuit = true;
      } else {
        window_default.showMessage(`Invalid option "${opt}" of list`, "error");
        return null;
      }
    }
    let list2 = this.listMap.get(name2);
    if (!list2) {
      window_default.showMessage(`List ${name2} not found`, "error");
      return null;
    }
    if (interactive && !list2.interactive) {
      window_default.showMessage(`Interactive mode of "${name2}" list not supported`, "error");
      return null;
    }
    return {
      list: list2,
      listArgs,
      options: {
        numberSelect,
        autoPreview,
        noQuit,
        first,
        input,
        interactive,
        matcher,
        position: position15,
        ignorecase: options.includes("ignore-case") ? true : false,
        mode: !options.includes("normal") ? "insert" : "normal",
        sort: !options.includes("no-sort") ? true : false
      }
    };
  }
  async onInputChar(session4, ch, charmod) {
    if (session4 != "list")
      return;
    let {mode} = this.prompt;
    let now = Date.now();
    if (ch == "<plug>" || this.plugTs && now - this.plugTs < 20) {
      this.plugTs = now;
      return;
    }
    if (!ch)
      return;
    if (ch == "<esc>") {
      await this.cancel();
      return;
    }
    try {
      if (mode == "insert") {
        await this.onInsertInput(ch, charmod);
      } else {
        await this.onNormalInput(ch, charmod);
      }
    } catch (e) {
      window_default.showMessage(`Error on input ${ch}: ${e}`);
      logger63.error(e);
    }
  }
  async onInsertInput(ch, charmod) {
    let {session: session4} = this;
    if (!session4)
      return;
    if (mouseKeys.includes(ch)) {
      await this.onMouseEvent(ch);
      return;
    }
    let n = await session4.doNumberSelect(ch);
    if (n)
      return;
    let done = await this.mappings.doInsertKeymap(ch);
    if (done || charmod)
      return;
    if (ch.startsWith("<") && ch.endsWith(">"))
      return;
    for (let s of ch) {
      let code = s.codePointAt(0);
      if (code == 65533)
        return;
      if (code < 32 || code >= 127 && code <= 159)
        return;
      await this.prompt.acceptCharacter(s);
    }
  }
  async onNormalInput(ch, _charmod) {
    if (mouseKeys.includes(ch)) {
      await this.onMouseEvent(ch);
      return;
    }
    let used = await this.mappings.doNormalKeymap(ch);
    if (!used)
      await this.feedkeys(ch);
  }
  onMouseEvent(key) {
    if (this.session)
      return this.session.onMouseEvent(key);
  }
  async feedkeys(key, remap = true) {
    let {nvim} = this;
    key = key.startsWith("<") && key.endsWith(">") ? `\\${key}` : key;
    await nvim.call("coc#prompt#stop_prompt", ["list"]);
    await nvim.call("eval", [`feedkeys("${key}", "${remap ? "i" : "in"}")`]);
    this.prompt.start();
  }
  async command(command) {
    let {nvim} = this;
    await nvim.call("coc#prompt#stop_prompt", ["list"]);
    await nvim.command(command);
    this.prompt.start();
  }
  async normal(command, bang = true) {
    let {nvim} = this;
    await nvim.call("coc#prompt#stop_prompt", ["list"]);
    await nvim.command(`normal${bang ? "!" : ""} ${command}`);
    this.prompt.start();
  }
  async call(fname) {
    if (this.session)
      return await this.session.call(fname);
  }
  get session() {
    return this.lastSession;
  }
  registerList(list2) {
    const {name: name2} = list2;
    let exists = this.listMap.get(name2);
    if (this.listMap.has(name2)) {
      if (exists) {
        if (typeof exists.dispose == "function") {
          exists.dispose();
        }
        this.listMap.delete(name2);
      }
      window_default.showMessage(`list "${name2}" recreated.`);
    }
    this.listMap.set(name2, list2);
    extensions_default.addSchemeProperty(`list.source.${name2}.defaultOptions`, {
      type: "array",
      default: list2.interactive ? ["--interactive"] : [],
      description: `Default list options of "${name2}" list, only used when both list option and argument are empty.`,
      uniqueItems: true,
      items: {
        type: "string",
        enum: [
          "--top",
          "--normal",
          "--no-sort",
          "--input",
          "--tab",
          "--strict",
          "--regex",
          "--ignore-case",
          "--number-select",
          "--interactive",
          "--auto-preview",
          "--first",
          "--no-quit"
        ]
      }
    });
    extensions_default.addSchemeProperty(`list.source.${name2}.defaultArgs`, {
      type: "array",
      default: [],
      description: `Default argument list of "${name2}" list, only used when list argument is empty.`,
      uniqueItems: true,
      items: {type: "string"}
    });
    return vscode_languageserver_protocol62.Disposable.create(() => {
      if (typeof list2.dispose == "function") {
        list2.dispose();
      }
      this.listMap.delete(name2);
    });
  }
  get names() {
    return Array.from(this.listMap.keys());
  }
  get descriptions() {
    let d = {};
    for (let name2 of this.listMap.keys()) {
      let list2 = this.listMap.get(name2);
      d[name2] = list2.description;
    }
    return d;
  }
  async loadItems(name2) {
    let args = [name2];
    let res = this.parseArgs(args);
    if (!res)
      return;
    let {list: list2, options, listArgs} = res;
    let source3 = new vscode_languageserver_protocol62.CancellationTokenSource();
    let token = source3.token;
    let arr = await this.nvim.eval('[win_getid(),bufnr("%")]');
    let items = await list2.loadItems({
      options,
      args: listArgs,
      input: "",
      cwd: workspace_default.cwd,
      window: this.nvim.createWindow(arr[0]),
      buffer: this.nvim.createBuffer(arr[1]),
      listWindow: null
    }, token);
    return items;
  }
  toggleMode() {
    let lastSession = this.lastSession;
    if (lastSession)
      lastSession.toggleMode();
  }
  get isActivated() {
    var _a2;
    return ((_a2 = this.session) == null ? void 0 : _a2.winid) != null;
  }
  stop() {
    let lastSession = this.lastSession;
    if (lastSession)
      lastSession.stop();
  }
  dispose() {
    for (let session4 of this.sessionsMap.values()) {
      session4.dispose();
    }
    this.sessionsMap.clear();
    if (this.config) {
      this.config.dispose();
    }
    this.lastSession = void 0;
    disposeAll(this.disposables);
  }
};
var manager_default4 = new ListManager();

// src/util/factory.ts
function makeRequireFunction() {
  const req = (p) => {
    if (p === "coc.nvim") {
      return require_src4();
    }
    return this.require(p);
  };
  req.resolve = (request2) => Module._resolveFilename(request2, this);
  req.main = process.mainModule;
  req.extensions = Module._extensions;
  req.cache = Module._cache;
  return req;
}
function compileInSandbox(sandbox) {
  return function(content, filename) {
    const require2 = makeRequireFunction.call(this);
    const dirname4 = path53.dirname(filename);
    const newContent = content.replace(/^\#\!.*/, "");
    const wrapper = Module.wrap(newContent);
    const compiledWrapper = vm.runInContext(wrapper, sandbox, {filename});
    const args = [this.exports, require2, this, filename, dirname4];
    return compiledWrapper.apply(this.exports, args);
  };
}
function createSandbox(filename, logger93) {
  const module2 = new Module(filename);
  module2.paths = Module._nodeModulePaths(filename);
  const sandbox = vm.createContext({
    module: module2,
    Buffer,
    console: {
      debug: (...args) => {
        logger93.debug.apply(logger93, args);
      },
      log: (...args) => {
        logger93.debug.apply(logger93, args);
      },
      error: (...args) => {
        logger93.error.apply(logger93, args);
      },
      info: (...args) => {
        logger93.info.apply(logger93, args);
      },
      warn: (...args) => {
        logger93.warn.apply(logger93, args);
      }
    }
  });
  defaults(sandbox, global);
  sandbox.Reflect = Reflect;
  sandbox.require = function sandboxRequire(p) {
    const oldCompile = Module.prototype._compile;
    Module.prototype._compile = compileInSandbox(sandbox);
    const moduleExports = sandbox.module.require(p);
    Module.prototype._compile = oldCompile;
    return moduleExports;
  };
  sandbox.process = new process.constructor();
  for (let key of Object.keys(process)) {
    sandbox.process[key] = process[key];
  }
  REMOVED_GLOBALS.forEach((name2) => {
    sandbox.process[name2] = removedGlobalStub(name2);
  });
  sandbox.process["chdir"] = () => {
  };
  sandbox.process.umask = (mask) => {
    if (typeof mask !== "undefined") {
      throw new Error("Cannot use process.umask() to change mask (read-only)");
    }
    return process.umask();
  };
  return sandbox;
}
function createExtension(id, filename, isEmpty = false) {
  if (isEmpty || !fs44.default.existsSync(filename))
    return {
      activate: () => {
      },
      deactivate: null
    };
  const sandbox = createSandbox(filename, createLogger(`extension:${id}`));
  delete Module._cache[require.resolve(filename)];
  const defaultImport = sandbox.require(filename);
  const activate = defaultImport && defaultImport.activate || defaultImport;
  if (typeof activate !== "function") {
    return {activate: () => {
    }, deactivate: null};
  }
  return {
    activate,
    deactivate: typeof defaultImport.deactivate === "function" ? defaultImport.deactivate : null
  };
}

// src/extensions.ts
var createLogger2 = require_logger2();
var logger65 = createLogger2("extensions");
function loadJson(file) {
  try {
    let content = fs_extra9.default.readFileSync(file, "utf8");
    return JSON.parse(content);
  } catch (e) {
    return null;
  }
}
var Extensions = class {
  constructor() {
    this.extensions = new Map();
    this.disabled = new Set();
    this._onDidLoadExtension = new vscode_languageserver_protocol63.Emitter();
    this._onDidActiveExtension = new vscode_languageserver_protocol63.Emitter();
    this._onDidUnloadExtension = new vscode_languageserver_protocol63.Emitter();
    this._additionalSchemes = {};
    this.activated = false;
    this.disposables = [];
    this.ready = true;
    this.onDidLoadExtension = this._onDidLoadExtension.event;
    this.onDidActiveExtension = this._onDidActiveExtension.event;
    this.onDidUnloadExtension = this._onDidUnloadExtension.event;
    let folder = global.hasOwnProperty("__TEST__") ? path54.default.join(__dirname, "__tests__") : process.env.COC_DATA_HOME;
    let root = this.root = path54.default.join(folder, "extensions");
    if (!fs_extra9.default.existsSync(root)) {
      fs_extra9.default.mkdirpSync(root);
    }
    let jsonFile = path54.default.join(root, "package.json");
    if (!fs_extra9.default.existsSync(jsonFile)) {
      fs_extra9.default.writeFileSync(jsonFile, '{"dependencies":{}}', "utf8");
    }
    let filepath = path54.default.join(root, "db.json");
    this.db = new db_default(filepath);
  }
  async init() {
    let data = loadJson(this.db.filepath) || {};
    let keys = Object.keys(data.extension || {});
    this.outputChannel = window_default.createOutputChannel("extensions");
    for (let key of keys) {
      if (data.extension[key].disabled == true) {
        this.disabled.add(key);
      }
    }
    if (process.env.COC_NO_PLUGINS)
      return;
    let stats = await this.globalExtensionStats();
    let localStats = await this.localExtensionStats(stats.map((o) => o.id));
    stats = stats.concat(localStats);
    this.memos = new memos_default(path54.default.resolve(this.root, "../memos.json"));
    stats.map((stat) => {
      let extensionType = stat.isLocal ? ExtensionType.Local : ExtensionType.Global;
      try {
        this.createExtension(stat.root, stat.packageJSON, extensionType);
      } catch (e) {
        logger65.error(`Error on create ${stat.root}:`, e);
      }
    });
    await this.loadFileExtensions();
    commands_default.register({
      id: "extensions.forceUpdateAll",
      execute: async () => {
        let arr = await this.cleanExtensions();
        logger65.info(`Force update extensions: ${arr}`);
        await this.installExtensions(arr);
      }
    }, false, "remove all global extensions and install them");
    workspace_default.onDidRuntimePathChange(async (paths) => {
      for (let p of paths) {
        if (p && this.checkDirectory(p) === true) {
          await this.loadExtension(p);
        }
      }
    }, null, this.disposables);
  }
  async activateExtensions() {
    this.activated = true;
    for (let item of this.extensions.values()) {
      let {id, packageJSON} = item.extension;
      await this.setupActiveEvents(id, packageJSON);
    }
    let floatFactory5 = new floatFactory_default(workspace_default.nvim);
    events_default.on("CursorMoved", debounce17.debounce(async (bufnr) => {
      if (this.installBuffer && bufnr == this.installBuffer.bufnr) {
        let lnum = await workspace_default.nvim.call("line", ["."]);
        let msgs = this.installBuffer.getMessages(lnum - 1);
        let docs = msgs && msgs.length ? [{content: msgs.join("\n"), filetype: "txt"}] : [];
        await floatFactory5.show(docs, {modes: ["n"]});
      }
    }, 500));
    if (global.hasOwnProperty("__TEST__"))
      return;
    this.checkExtensions().logError();
    let config = workspace_default.getConfiguration("coc.preferences");
    let interval = config.get("extensionUpdateCheck", "never");
    let silent = config.get("silentAutoupdate", true);
    if (interval != "never") {
      let now = new Date();
      let day = new Date(now.getFullYear(), now.getMonth(), now.getDate() - (interval == "daily" ? 0 : 7));
      let ts = this.db.fetch("lastUpdate");
      if (ts && Number(ts) > day.getTime())
        return;
      this.outputChannel.appendLine("Start auto update...");
      this.updateExtensions(false, silent).logError();
    }
  }
  async updateExtensions(sync, silent = false) {
    if (!this.npm)
      return;
    let lockedList = await this.getLockedList();
    let stats = await this.globalExtensionStats();
    stats = stats.filter((o) => ![...lockedList, ...this.disabled].includes(o.id));
    this.db.push("lastUpdate", Date.now());
    if (silent) {
      window_default.showMessage("Updating extensions, checkout output:///extensions for details.", "more");
    }
    let installBuffer2 = this.installBuffer = new installBuffer_default(true, sync, silent ? this.outputChannel : void 0);
    installBuffer2.setExtensions(stats.map((o) => o.id));
    await installBuffer2.show(workspace_default.nvim);
    let createInstaller = createInstallerFactory(this.npm, this.modulesFolder);
    let fn = (stat) => {
      let {id} = stat;
      installBuffer2.startProgress([id]);
      let url2 = stat.exotic ? stat.uri : null;
      let installer2 = createInstaller(id);
      installer2.on("message", (msg, isProgress) => {
        installBuffer2.addMessage(id, msg, isProgress);
      });
      return installer2.update(url2).then((directory) => {
        installBuffer2.finishProgress(id, true);
        if (directory) {
          this.loadExtension(directory).logError();
        }
      }, (err) => {
        installBuffer2.addMessage(id, err.message);
        installBuffer2.finishProgress(id, false);
      });
    };
    await concurrent(stats, fn, silent ? 1 : 3);
  }
  async checkExtensions() {
    let {globalExtensions} = workspace_default.env;
    if (globalExtensions && globalExtensions.length) {
      let names = this.filterGlobalExtensions(globalExtensions);
      this.installExtensions(names).logError();
    }
  }
  async installExtensions(list2 = []) {
    let {npm} = this;
    if (!npm || !list2.length)
      return;
    list2 = distinct(list2);
    let installBuffer2 = this.installBuffer = new installBuffer_default();
    installBuffer2.setExtensions(list2);
    await installBuffer2.show(workspace_default.nvim);
    let createInstaller = createInstallerFactory(this.npm, this.modulesFolder);
    let fn = (key) => {
      installBuffer2.startProgress([key]);
      let installer2 = createInstaller(key);
      installer2.on("message", (msg, isProgress) => {
        installBuffer2.addMessage(key, msg, isProgress);
      });
      return installer2.install().then((name2) => {
        installBuffer2.finishProgress(key, true);
        let directory = path54.default.join(this.modulesFolder, name2);
        this.loadExtension(directory).logError();
      }, (err) => {
        installBuffer2.addMessage(key, err.message);
        installBuffer2.finishProgress(key, false);
        logger65.error(`Error on install ${key}`, err);
      });
    };
    await concurrent(list2, fn);
  }
  getMissingExtensions() {
    let json = this.loadJson() || {dependencies: {}};
    let ids = [];
    for (let key of Object.keys(json.dependencies)) {
      let folder = path54.default.join(this.modulesFolder, key);
      if (!fs_extra9.default.existsSync(folder)) {
        let val = json.dependencies[key];
        if (val.startsWith("http")) {
          ids.push(val);
        } else {
          ids.push(key);
        }
      }
    }
    return ids;
  }
  get npm() {
    let npm = workspace_default.getConfiguration("npm").get("binPath", "npm");
    npm = workspace_default.expand(npm);
    for (let exe of [npm, "yarnpkg", "yarn", "npm"]) {
      try {
        let res = which7.default.sync(exe);
        return res;
      } catch (e) {
        continue;
      }
    }
    window_default.showMessage(`Can't find npm or yarn in your $PATH`, "error");
    return null;
  }
  get all() {
    return Array.from(this.extensions.values()).map((o) => o.extension).filter((o) => !this.isDisabled(o.id));
  }
  getExtension(id) {
    return this.extensions.get(id);
  }
  getExtensionState(id) {
    let disabled = this.isDisabled(id);
    if (disabled)
      return "disabled";
    let item = this.extensions.get(id);
    if (!item)
      return "unknown";
    let {extension} = item;
    return extension.isActive ? "activated" : "loaded";
  }
  async getExtensionStates() {
    let globalStats = await this.globalExtensionStats();
    let localStats = await this.localExtensionStats([]);
    return globalStats.concat(localStats);
  }
  async getLockedList() {
    let obj = await this.db.fetch("extension");
    obj = obj || {};
    return Object.keys(obj).filter((id) => obj[id].locked === true);
  }
  async toggleLock(id) {
    let key = `extension.${id}.locked`;
    let locked = await this.db.fetch(key);
    if (locked) {
      this.db.delete(key);
    } else {
      this.db.push(key, true);
    }
  }
  async toggleExtension(id) {
    let state = this.getExtensionState(id);
    if (state == null)
      return;
    if (state == "activated") {
      await this.deactivate(id);
    }
    let key = `extension.${id}.disabled`;
    this.db.push(key, state == "disabled" ? false : true);
    if (state != "disabled") {
      this.disabled.add(id);
      await this.unloadExtension(id);
    } else {
      this.disabled.delete(id);
      let folder = path54.default.join(this.modulesFolder, id);
      if (fs_extra9.default.existsSync(folder)) {
        await this.loadExtension(folder);
      }
    }
    await wait(200);
  }
  async reloadExtension(id) {
    let item = this.extensions.get(id);
    if (!item) {
      window_default.showMessage(`Extension ${id} not registered`, "error");
      return;
    }
    if (item.type == ExtensionType.Internal) {
      window_default.showMessage(`Can't reload internal extension "${item.id}"`, "warning");
      return;
    }
    if (item.type == ExtensionType.SingleFile) {
      await this.loadExtensionFile(item.filepath);
    } else if (item.directory) {
      await this.loadExtension(item.directory);
    } else {
      window_default.showMessage(`Can't reload extension ${item.id}`, "warning");
    }
  }
  async cleanExtensions() {
    let dir = this.modulesFolder;
    if (!fs_extra9.default.existsSync(dir))
      return [];
    let ids = this.globalExtensions;
    let res = [];
    for (let id of ids) {
      let directory = path54.default.join(dir, id);
      let stat = await fs_extra9.default.lstat(directory);
      if (!stat || stat && stat.isSymbolicLink())
        continue;
      await this.unloadExtension(id);
      await fs_extra9.default.remove(directory);
      res.push(id);
    }
    return res;
  }
  async uninstallExtension(ids) {
    try {
      if (!ids.length)
        return;
      let [globals2, filtered] = splitArray(ids, (id) => this.globalExtensions.includes(id));
      if (filtered.length) {
        window_default.showMessage(`Extensions ${filtered} not global extensions, can't uninstall!`, "warning");
      }
      let json = this.loadJson() || {dependencies: {}};
      for (let id of globals2) {
        await this.unloadExtension(id);
        delete json.dependencies[id];
        let folder = path54.default.join(this.modulesFolder, id);
        if (fs_extra9.default.existsSync(folder)) {
          await fs_extra9.default.remove(folder);
        }
      }
      const sortedObj = {dependencies: {}};
      Object.keys(json.dependencies).sort().forEach((k) => {
        sortedObj.dependencies[k] = json.dependencies[k];
      });
      let jsonFile = path54.default.join(this.root, "package.json");
      fs_extra9.default.writeFileSync(jsonFile, JSON.stringify(sortedObj, null, 2), {encoding: "utf8"});
      window_default.showMessage(`Removed: ${globals2.join(" ")}`);
    } catch (e) {
      window_default.showMessage(`Uninstall failed: ${e.message}`, "error");
    }
  }
  isDisabled(id) {
    return this.disabled.has(id);
  }
  has(id) {
    return this.extensions.has(id);
  }
  isActivated(id) {
    let item = this.extensions.get(id);
    if (item && item.extension.isActive) {
      return true;
    }
    return false;
  }
  async loadExtension(folder) {
    try {
      let parentFolder = path54.default.dirname(folder);
      let isLocal = path54.default.normalize(parentFolder) != path54.default.normalize(this.modulesFolder);
      let jsonFile = path54.default.join(folder, "package.json");
      let packageJSON = JSON.parse(fs_extra9.default.readFileSync(jsonFile, "utf8"));
      let {name: name2} = packageJSON;
      if (this.isDisabled(name2))
        return false;
      await this.unloadExtension(name2);
      this.createExtension(folder, Object.freeze(packageJSON), isLocal ? ExtensionType.Local : ExtensionType.Global);
      return true;
    } catch (e) {
      window_default.showMessage(`Error on load extension from "${folder}": ${e.message}`, "error");
      logger65.error(`Error on load extension from ${folder}`, e);
      return false;
    }
  }
  async loadFileExtensions() {
    if (!process.env.COC_VIMCONFIG)
      return;
    let folder = path54.default.join(process.env.COC_VIMCONFIG, "coc-extensions");
    if (!fs_extra9.default.existsSync(folder))
      return;
    let files = await fs_extra9.default.readdir(folder);
    files = files.filter((f) => f.endsWith(".js"));
    for (let file of files) {
      await this.loadExtensionFile(path54.default.join(folder, file));
    }
  }
  loadedExtensions() {
    return Array.from(this.extensions.keys());
  }
  async watchExtension(id) {
    let item = this.extensions.get(id);
    if (!item) {
      window_default.showMessage(`extension ${id} not found`, "error");
      return;
    }
    if (id.startsWith("single-")) {
      window_default.showMessage(`watching ${item.filepath}`);
      this.disposables.push(watchFile(item.filepath, async () => {
        await this.loadExtensionFile(item.filepath);
        window_default.showMessage(`reloaded ${id}`);
      }));
    } else {
      let watchmanPath = workspace_default.getWatchmanPath();
      if (!watchmanPath) {
        window_default.showMessage("watchman not found", "error");
        return;
      }
      let client8 = await watchman_default.createClient(watchmanPath, item.directory);
      if (!client8) {
        window_default.showMessage(`Can't create watchman client, check output:///watchman`);
        return;
      }
      window_default.showMessage(`watching ${item.directory}`);
      this.disposables.push(client8);
      client8.subscribe("**/*.js", async () => {
        await this.reloadExtension(id);
        window_default.showMessage(`reloaded ${id}`);
      }).then((disposable) => {
        this.disposables.push(disposable);
      }, (e) => {
        logger65.error(e);
      });
    }
  }
  async loadExtensionFile(filepath) {
    let filename = path54.default.basename(filepath);
    let name2 = "single-" + path54.default.basename(filepath, ".js");
    if (this.isDisabled(name2))
      return;
    let root = path54.default.dirname(filepath);
    let packageJSON = {
      name: name2,
      main: filename,
      engines: {coc: "^0.0.79"}
    };
    await this.unloadExtension(name2);
    this.createExtension(root, packageJSON, ExtensionType.SingleFile);
  }
  async activate(id) {
    if (this.isDisabled(id)) {
      throw new Error(`Extension ${id} is disabled!`);
    }
    let item = this.extensions.get(id);
    if (!item) {
      throw new Error(`Extension ${id} not registered!`);
    }
    let {extension} = item;
    if (extension.isActive)
      return true;
    await Promise.resolve(extension.activate());
    if (extension.isActive) {
      this._onDidActiveExtension.fire(extension);
      return true;
    }
    return false;
  }
  async deactivate(id) {
    let item = this.extensions.get(id);
    if (!item)
      return false;
    await Promise.resolve(item.deactivate());
    return true;
  }
  async call(id, method, args) {
    let item = this.extensions.get(id);
    if (!item)
      throw new Error(`extension ${id} not registered`);
    let {extension} = item;
    if (!extension.isActive) {
      await this.activate(id);
    }
    let {exports: exports2} = extension;
    if (!exports2 || !exports2.hasOwnProperty(method)) {
      throw new Error(`method ${method} not found on extension ${id}`);
    }
    return await Promise.resolve(exports2[method].apply(null, args));
  }
  getExtensionApi(id) {
    let item = this.extensions.get(id);
    if (!item)
      return null;
    let {extension} = item;
    return extension.isActive ? extension.exports : null;
  }
  registerExtension(extension, deactivate) {
    let {id, packageJSON} = extension;
    this.extensions.set(id, {id, type: ExtensionType.Internal, extension, deactivate, isLocal: true});
    let {contributes} = packageJSON;
    if (contributes) {
      let {configuration: configuration7} = contributes;
      if (configuration7 && configuration7.properties) {
        let {properties} = configuration7;
        let props = {};
        for (let key of Object.keys(properties)) {
          let val = properties[key].default;
          if (val != null)
            props[key] = val;
        }
        workspace_default.configurations.extendsDefaults(props);
      }
    }
    this._onDidLoadExtension.fire(extension);
    this.setupActiveEvents(id, packageJSON).logError();
  }
  get globalExtensions() {
    let json = this.loadJson();
    if (!json || !json.dependencies)
      return [];
    return Object.keys(json.dependencies);
  }
  async globalExtensionStats() {
    let json = this.loadJson();
    if (!json || !json.dependencies)
      return [];
    let {modulesFolder} = this;
    let res = await Promise.all(Object.keys(json.dependencies).map((key) => new Promise(async (resolve3) => {
      try {
        let val = json.dependencies[key];
        let root = path54.default.join(modulesFolder, key);
        let res2 = this.checkDirectory(root);
        if (res2 instanceof Error) {
          window_default.showMessage(`Unable to load global extension at ${root}: ${res2.message}`, "error");
          logger65.error(`Error on load ${root}`, res2);
          return resolve3(null);
        }
        let content = await readFile(path54.default.join(root, "package.json"), "utf8");
        root = await fs_extra9.default.realpath(root);
        let obj = JSON.parse(content);
        let version2 = obj ? obj.version || "" : "";
        let description = obj ? obj.description || "" : "";
        let uri = isuri3.default.isValid(val) ? val : "";
        resolve3({
          id: key,
          isLocal: false,
          version: version2,
          description,
          exotic: /^https?:/.test(val),
          uri: uri.replace(/\.git(#master)?$/, ""),
          root,
          state: this.getExtensionState(key),
          packageJSON: Object.freeze(obj)
        });
      } catch (e) {
        logger65.error(e);
        resolve3(null);
      }
    })));
    return res.filter((info) => info != null);
  }
  async localExtensionStats(excludes) {
    let runtimepath = await workspace_default.nvim.eval("&runtimepath");
    let paths = runtimepath.split(",");
    let res = await Promise.all(paths.map((root) => new Promise(async (resolve3) => {
      try {
        let res2 = this.checkDirectory(root);
        if (res2 !== true)
          return resolve3(null);
        let jsonFile = path54.default.join(root, "package.json");
        let content = await readFile(jsonFile, "utf8");
        let obj = JSON.parse(content);
        let exist = this.extensions.get(obj.name);
        if (exist && !exist.isLocal) {
          logger65.info(`Extension "${obj.name}" in runtimepath already loaded.`);
          return resolve3(null);
        }
        if (excludes.includes(obj.name)) {
          logger65.info(`Skipped load vim plugin from "${root}", "${obj.name}" already global extension.`);
          return resolve3(null);
        }
        let version2 = obj ? obj.version || "" : "";
        let description = obj ? obj.description || "" : "";
        resolve3({
          id: obj.name,
          isLocal: true,
          version: version2,
          description,
          exotic: false,
          root,
          state: this.getExtensionState(obj.name),
          packageJSON: Object.freeze(obj)
        });
      } catch (e) {
        logger65.error(e);
        resolve3(null);
      }
    })));
    return res.filter((info) => info != null);
  }
  loadJson() {
    let {root} = this;
    let jsonFile = path54.default.join(root, "package.json");
    if (!fs_extra9.default.existsSync(jsonFile))
      return null;
    return loadJson(jsonFile);
  }
  get schemes() {
    return this._additionalSchemes;
  }
  addSchemeProperty(key, def) {
    this._additionalSchemes[key] = def;
    workspace_default.configurations.extendsDefaults({[key]: def.default});
  }
  async setupActiveEvents(id, packageJSON) {
    let {activationEvents} = packageJSON;
    if (!this.canActivate(id))
      return;
    if (!activationEvents || Array.isArray(activationEvents) && activationEvents.includes("*")) {
      await this.activate(id).catch((e) => {
        window_default.showMessage(`Error on activate extension ${id}: ${e.message}`);
        logger65.error(`Error on activate extension ${id}`, e);
      });
      return;
    }
    let disposables = [];
    let active = () => {
      disposeAll(disposables);
      return new Promise((resolve3) => {
        if (!this.canActivate(id))
          return resolve3();
        let timer = setTimeout(() => {
          logger65.warn(`Extension ${id} activate cost more than 1s`);
          resolve3();
        }, 1e3);
        this.activate(id).then(() => {
          clearTimeout(timer);
          resolve3();
        }, (e) => {
          clearTimeout(timer);
          window_default.showMessage(`Error on activate extension ${id}: ${e.message}`);
          logger65.error(`Error on activate extension ${id}`, e);
          resolve3();
        });
      });
    };
    for (let eventName of activationEvents) {
      let parts = eventName.split(":");
      let ev = parts[0];
      if (ev == "onLanguage") {
        if (workspace_default.filetypes.has(parts[1])) {
          await active();
          return;
        }
        workspace_default.onDidOpenTextDocument((document3) => {
          if (document3.languageId == parts[1]) {
            active().logError();
          }
        }, null, disposables);
      } else if (ev == "onCommand") {
        events_default.on("Command", (command) => {
          if (command == parts[1]) {
            active().logError();
            return new Promise((resolve3) => {
              setTimeout(resolve3, 500);
            });
          }
        }, null, disposables);
      } else if (ev == "workspaceContains") {
        let check = async () => {
          let folders2 = workspace_default.workspaceFolders.map((o) => URI.parse(o.uri).fsPath);
          for (let folder of folders2) {
            if (inDirectory(folder, parts[1].split(/\s+/))) {
              await active();
              return true;
            }
          }
        };
        let res = await check();
        if (res)
          return;
        workspace_default.onDidChangeWorkspaceFolders(check, null, disposables);
      } else if (ev == "onFileSystem") {
        for (let doc of workspace_default.documents) {
          let u = URI.parse(doc.uri);
          if (u.scheme == parts[1]) {
            await active();
            return;
          }
        }
        workspace_default.onDidOpenTextDocument((document3) => {
          let u = URI.parse(document3.uri);
          if (u.scheme == parts[1]) {
            active().logError();
          }
        }, null, disposables);
      } else {
        window_default.showMessage(`Unsupported event ${eventName} of ${id}`, "error");
      }
    }
  }
  createExtension(root, packageJSON, type) {
    let id = packageJSON.name;
    let isActive = false;
    let exports2 = null;
    let filename = path54.default.join(root, packageJSON.main || "index.js");
    let ext;
    let subscriptions = [];
    let extension = {
      activate: async () => {
        if (isActive)
          return exports2;
        let context = {
          subscriptions,
          extensionPath: root,
          globalState: this.memos.createMemento(`${id}|global`),
          workspaceState: this.memos.createMemento(`${id}|${workspace_default.rootPath}`),
          asAbsolutePath: (relativePath) => path54.default.join(root, relativePath),
          storagePath: path54.default.join(this.root, `${id}-data`),
          logger: createLogger2(id)
        };
        isActive = true;
        if (!ext) {
          try {
            let isEmpty = !(packageJSON.engines || {}).hasOwnProperty("coc");
            ext = createExtension(id, filename, isEmpty);
          } catch (e) {
            logger65.error(`Error on createExtension ${id} from ${filename}`, e);
            return;
          }
        }
        try {
          exports2 = await Promise.resolve(ext.activate(context));
          logger65.debug("activate:", id);
        } catch (e) {
          isActive = false;
          logger65.error(`Error on active extension ${id}: ${e.stack}`, e);
        }
        return exports2;
      }
    };
    Object.defineProperties(extension, {
      id: {
        get: () => id
      },
      packageJSON: {
        get: () => packageJSON
      },
      extensionPath: {
        get: () => root
      },
      isActive: {
        get: () => isActive
      },
      exports: {
        get: () => exports2
      }
    });
    this.extensions.set(id, {
      id,
      type,
      isLocal: type == ExtensionType.Local,
      extension,
      directory: root,
      filepath: filename,
      deactivate: () => {
        if (!isActive)
          return;
        isActive = false;
        disposeAll(subscriptions);
        subscriptions.splice(0, subscriptions.length);
        subscriptions = [];
        if (ext && ext.deactivate) {
          try {
            return Promise.resolve(ext.deactivate()).catch((e) => {
              logger65.error(`Error on ${id} deactivate: `, e);
            });
          } catch (e) {
            logger65.error(`Error on ${id} deactivate: `, e);
          }
        }
      }
    });
    let {contributes} = packageJSON;
    if (contributes) {
      let {configuration: configuration7, rootPatterns, commands: commands10} = contributes;
      if (configuration7 && configuration7.properties) {
        let {properties} = configuration7;
        let props = {};
        for (let key of Object.keys(properties)) {
          let val = properties[key].default;
          if (val != null)
            props[key] = val;
        }
        workspace_default.configurations.extendsDefaults(props);
      }
      if (rootPatterns && rootPatterns.length) {
        for (let item of rootPatterns) {
          workspace_default.addRootPattern(item.filetype, item.patterns);
        }
      }
      if (commands10 && commands10.length) {
        for (let cmd of commands10) {
          commands_default.titles.set(cmd.command, cmd.title);
        }
      }
    }
    this._onDidLoadExtension.fire(extension);
    if (this.activated) {
      this.setupActiveEvents(id, packageJSON).logError();
    }
  }
  filterGlobalExtensions(names) {
    names = names.map((s) => s.replace(/@.*$/, ""));
    let filtered = names.filter((name2) => !this.disabled.has(name2));
    filtered = filtered.filter((name2) => !this.extensions.has(name2));
    let json = this.loadJson();
    let urls = [];
    let exists = [];
    if (json && json.dependencies) {
      for (let key of Object.keys(json.dependencies)) {
        let val = json.dependencies[key];
        if (typeof val !== "string")
          continue;
        if (fs_extra9.default.existsSync(path54.default.join(this.modulesFolder, key, "package.json"))) {
          exists.push(key);
          if (/^https?:/.test(val)) {
            urls.push(val);
          }
        }
      }
    }
    filtered = filtered.filter((str) => {
      if (/^https?:/.test(str))
        return !urls.some((url2) => url2.startsWith(str));
      return !exists.includes(str);
    });
    return filtered;
  }
  get modulesFolder() {
    return path54.default.join(this.root, global.hasOwnProperty("__TEST__") ? "" : "node_modules");
  }
  canActivate(id) {
    return !this.disabled.has(id) && this.extensions.has(id);
  }
  async unloadExtension(id) {
    let item = this.extensions.get(id);
    if (item) {
      await this.deactivate(id);
      this.extensions.delete(id);
      this._onDidUnloadExtension.fire(id);
    }
  }
  checkDirectory(folder) {
    try {
      let jsonFile = path54.default.join(folder, "package.json");
      if (!fs_extra9.default.existsSync(jsonFile))
        throw new Error("package.json not found");
      let packageJSON = JSON.parse(fs_extra9.default.readFileSync(jsonFile, "utf8"));
      let {name: name2, engines, main} = packageJSON;
      if (!name2 || !engines)
        throw new Error(`can't find name & engines in package.json`);
      if (!engines || !objectLiteral(engines)) {
        throw new Error(`invalid engines in ${jsonFile}`);
      }
      if (main && !fs_extra9.default.existsSync(path54.default.join(folder, main))) {
        throw new Error(`main file ${main} not found, you may need to build the project.`);
      }
      let keys = Object.keys(engines);
      if (!keys.includes("coc") && !keys.includes("vscode")) {
        throw new Error(`Engines in package.json doesn't have coc or vscode`);
      }
      if (keys.includes("coc")) {
        let required = engines["coc"].replace(/^\^/, ">=");
        if (!semver5.default.satisfies(workspace_default.version, required)) {
          throw new Error(`Please update coc.nvim, ${packageJSON.name} requires coc.nvim ${engines["coc"]}`);
        }
      }
      return true;
    } catch (e) {
      return e;
    }
  }
  dispose() {
    disposeAll(this.disposables);
  }
};
var extensions_default = new Extensions();

// src/model/source.ts
var logger66 = require_logger2()("model-source");
var Source = class {
  constructor(option) {
    this._disabled = false;
    this.nvim = workspace_default.nvim;
    this.name = option.name;
    this.filepath = option.filepath || "";
    this.sourceType = option.sourceType || SourceType.Native;
    this.isSnippet = !!option.isSnippet;
    this.defaults = option;
  }
  get priority() {
    return this.getConfig("priority", 1);
  }
  get triggerOnly() {
    let triggerOnly = this.defaults["triggerOnly"];
    if (typeof triggerOnly == "boolean")
      return triggerOnly;
    if (!this.triggerCharacters && !this.triggerPatterns)
      return false;
    return Array.isArray(this.triggerPatterns) && this.triggerPatterns.length != 0;
  }
  get triggerCharacters() {
    return this.getConfig("triggerCharacters", null);
  }
  get optionalFns() {
    return this.defaults["optionalFns"] || [];
  }
  get triggerPatterns() {
    let patterns = this.getConfig("triggerPatterns", null);
    if (!patterns || patterns.length == 0)
      return null;
    return patterns.map((s) => typeof s === "string" ? new RegExp(s + "$") : s);
  }
  get shortcut() {
    let shortcut = this.getConfig("shortcut", "");
    return shortcut ? shortcut : this.name.slice(0, 3);
  }
  get enable() {
    if (this._disabled)
      return false;
    return this.getConfig("enable", true);
  }
  get filetypes() {
    return this.getConfig("filetypes", null);
  }
  get disableSyntaxes() {
    return this.getConfig("disableSyntaxes", []);
  }
  getConfig(key, defaultValue) {
    let config = workspace_default.getConfiguration(`coc.source.${this.name}`);
    defaultValue = this.defaults.hasOwnProperty(key) ? this.defaults[key] : defaultValue;
    return config.get(key, defaultValue);
  }
  toggle() {
    this._disabled = !this._disabled;
  }
  get firstMatch() {
    return this.getConfig("firstMatch", true);
  }
  get menu() {
    let {shortcut} = this;
    return shortcut ? `[${shortcut}]` : "";
  }
  filterWords(words, opt) {
    let {firstMatch} = this;
    let res = [];
    let {input} = opt;
    let cword = opt.word;
    if (!input.length)
      return [];
    let cFirst = input[0];
    for (let word of words) {
      if (!word || word.length < 3)
        continue;
      if (firstMatch && cFirst != word[0])
        continue;
      if (!firstMatch && cFirst.toLowerCase() != word[0].toLowerCase())
        continue;
      if (word == cword || word == input)
        continue;
      res.push(word);
    }
    return res;
  }
  fixStartcol(opt, valids) {
    let {col, input, line, bufnr} = opt;
    let start = byteSlice(line, 0, col);
    let document3 = workspace_default.getDocument(bufnr);
    if (!document3)
      return col;
    let {chars: chars2} = document3;
    for (let i = start.length - 1; i >= 0; i--) {
      let c = start[i];
      if (!chars2.isKeywordChar(c) && !valids.includes(c)) {
        break;
      }
      input = `${c}${input}`;
      col = col - 1;
    }
    opt.col = col;
    opt.input = input;
    return col;
  }
  async shouldComplete(opt) {
    let {disableSyntaxes} = this;
    if (opt.synname && disableSyntaxes && disableSyntaxes.length) {
      let synname = (opt.synname || "").toLowerCase();
      if (disableSyntaxes.findIndex((s) => synname.includes(s.toLowerCase())) !== -1) {
        return false;
      }
    }
    let fn = this.defaults["shouldComplete"];
    if (fn)
      return await Promise.resolve(fn.call(this, opt));
    return true;
  }
  async refresh() {
    let fn = this.defaults["refresh"];
    if (fn)
      await Promise.resolve(fn.call(this));
  }
  async onCompleteDone(item, opt) {
    let fn = this.defaults["onCompleteDone"];
    if (fn)
      await Promise.resolve(fn.call(this, item, opt));
  }
  async doComplete(opt, token) {
    let fn = this.defaults["doComplete"];
    if (fn)
      return await Promise.resolve(fn.call(this, opt, token));
    return null;
  }
};
var source_default = Source;

// src/model/source-vim.ts
var logger67 = require_logger2()("model-source-vim");
var VimSource = class extends source_default {
  async callOptinalFunc(fname, args) {
    let exists = this.optionalFns.includes(fname);
    if (!exists)
      return null;
    let name2 = `coc#source#${this.name}#${fname}`;
    let res;
    try {
      res = await this.nvim.call(name2, args);
    } catch (e) {
      window_default.showMessage(`Vim error from source ${this.name}: ${e.message}`, "error");
      return null;
    }
    return res;
  }
  async shouldComplete(opt) {
    let shouldRun = await super.shouldComplete(opt);
    if (!shouldRun)
      return false;
    if (!this.optionalFns.includes("should_complete"))
      return true;
    let res = await this.callOptinalFunc("should_complete", [opt]);
    return !!res;
  }
  async refresh() {
    await this.callOptinalFunc("refresh", []);
  }
  async onCompleteDone(item, opt) {
    await super.onCompleteDone(item, opt);
    if (!this.optionalFns.includes("on_complete"))
      return;
    await this.callOptinalFunc("on_complete", [item]);
  }
  onEnter(bufnr) {
    if (!this.optionalFns.includes("on_enter"))
      return;
    let doc = workspace_default.getDocument(bufnr);
    if (!doc)
      return;
    let {filetypes} = this;
    if (filetypes && !filetypes.includes(doc.filetype))
      return;
    this.callOptinalFunc("on_enter", [{
      bufnr,
      uri: doc.uri,
      languageId: doc.filetype
    }]).logError();
  }
  async doComplete(opt, token) {
    let {col, input, line, colnr} = opt;
    let startcol = await this.callOptinalFunc("get_startcol", [opt]);
    if (token.isCancellationRequested)
      return;
    if (startcol) {
      if (startcol < 0)
        return null;
      startcol = Number(startcol);
      if (isNaN(startcol) || startcol < 0)
        startcol = col;
      if (startcol !== col) {
        input = byteSlice(line, startcol, colnr - 1);
        opt = Object.assign({}, opt, {
          col: startcol,
          changed: col - startcol,
          input
        });
      }
    }
    let items = await this.nvim.callAsync("coc#util#do_complete", [this.name, opt]);
    if (!items || items.length == 0 || token.isCancellationRequested)
      return null;
    if (this.firstMatch && input.length) {
      let ch = input[0];
      items = items.filter((item) => {
        let cfirst = item.filterText ? item.filterText[0] : item.word[0];
        return fuzzyChar(ch, cfirst);
      });
    }
    items = items.map((item) => {
      if (typeof item == "string") {
        return {word: item, menu: this.menu, isSnippet: this.isSnippet};
      }
      let menu2 = item.menu ? item.menu + " " : "";
      item.menu = `${menu2}${this.menu}`;
      item.isSnippet = this.isSnippet;
      delete item.user_data;
      return item;
    });
    let res = {items};
    if (startcol)
      res.startcol = startcol;
    return res;
  }
};
var source_vim_default = VimSource;

// src/sources.ts
var logger68 = require_logger2()("sources");
var Sources = class {
  constructor() {
    this.sourceMap = new Map();
    this.disposables = [];
    this.remoteSourcePaths = [];
  }
  get nvim() {
    return workspace_default.nvim;
  }
  createNativeSources() {
    try {
      this.disposables.push(require_around().regist(this.sourceMap));
      this.disposables.push(require_buffer2().regist(this.sourceMap));
      this.disposables.push(require_file4().regist(this.sourceMap));
    } catch (e) {
      console.error("Create source error:" + e.message);
    }
  }
  async createVimSourceExtension(nvim, filepath) {
    let name2 = path56.default.basename(filepath, ".vim");
    try {
      await nvim.command(`source ${filepath}`);
      let fns = await nvim.call("coc#util#remote_fns", name2);
      for (let fn of ["init", "complete"]) {
        if (!fns.includes(fn)) {
          window_default.showMessage(`${fn} not found for source ${name2}`, "error");
          return null;
        }
      }
      let props = await nvim.call(`coc#source#${name2}#init`, []);
      let packageJSON = {
        name: `coc-source-${name2}`,
        engines: {
          coc: ">= 0.0.1"
        },
        activationEvents: props.filetypes ? props.filetypes.map((f) => `onLanguage:${f}`) : ["*"],
        contributes: {
          configuration: {
            properties: {
              [`coc.source.${name2}.enable`]: {
                type: "boolean",
                default: true
              },
              [`coc.source.${name2}.firstMatch`]: {
                type: "boolean",
                default: !!props.firstMatch
              },
              [`coc.source.${name2}.triggerCharacters`]: {
                type: "number",
                default: props.triggerCharacters || []
              },
              [`coc.source.${name2}.priority`]: {
                type: "number",
                default: props.priority || 9
              },
              [`coc.source.${name2}.shortcut`]: {
                type: "string",
                default: props.shortcut || name2.slice(0, 3).toUpperCase(),
                description: "Shortcut text shown in complete menu."
              },
              [`coc.source.${name2}.disableSyntaxes`]: {
                type: "array",
                default: [],
                items: {
                  type: "string"
                }
              },
              [`coc.source.${name2}.filetypes`]: {
                type: "array",
                default: props.filetypes || null,
                description: "Enabled filetypes.",
                items: {
                  type: "string"
                }
              }
            }
          }
        }
      };
      let source3 = new source_vim_default({
        name: name2,
        filepath,
        sourceType: SourceType.Remote,
        optionalFns: fns.filter((n) => !["init", "complete"].includes(n))
      });
      let isActive = false;
      let extension = {
        id: packageJSON.name,
        packageJSON,
        exports: void 0,
        extensionPath: filepath,
        activate: () => {
          isActive = true;
          this.addSource(source3);
          return Promise.resolve();
        }
      };
      Object.defineProperty(extension, "isActive", {
        get: () => isActive
      });
      extensions_default.registerExtension(extension, () => {
        isActive = false;
        this.removeSource(source3);
      });
    } catch (e) {
      window_default.showMessage(`Error on create vim source ${name2}: ${e.message}`, "error");
    }
  }
  createRemoteSources() {
    let {runtimepath} = workspace_default.env;
    let paths = runtimepath.split(",");
    for (let path66 of paths) {
      this.createVimSources(path66).logError();
    }
  }
  async createVimSources(pluginPath) {
    if (this.remoteSourcePaths.includes(pluginPath))
      return;
    this.remoteSourcePaths.push(pluginPath);
    let folder = path56.default.join(pluginPath, "autoload/coc/source");
    let stat = await statAsync(folder);
    if (stat && stat.isDirectory()) {
      let arr = await util36.default.promisify(fs48.default.readdir)(folder);
      arr = arr.filter((s) => s.endsWith(".vim"));
      let files = arr.map((s) => path56.default.join(folder, s));
      if (files.length == 0)
        return;
      await Promise.all(files.map((p) => this.createVimSourceExtension(this.nvim, p)));
    }
  }
  init() {
    this.createNativeSources();
    this.createRemoteSources();
    events_default.on("BufEnter", this.onDocumentEnter, this, this.disposables);
    workspace_default.watchOption("runtimepath", async (oldValue, newValue) => {
      let result = fast_diff3.default(oldValue, newValue);
      for (let [changeType, value] of result) {
        if (changeType == 1) {
          let paths = value.replace(/,$/, "").split(",");
          for (let p of paths) {
            if (p)
              await this.createVimSources(p);
          }
        }
      }
    }, this.disposables);
  }
  get names() {
    return Array.from(this.sourceMap.keys());
  }
  get sources() {
    return Array.from(this.sourceMap.values());
  }
  has(name2) {
    return this.names.findIndex((o) => o == name2) != -1;
  }
  getSource(name2) {
    if (!name2)
      return null;
    return this.sourceMap.get(name2) || null;
  }
  async doCompleteResolve(item, token) {
    let source3 = this.getSource(item.source);
    if (source3 && typeof source3.onCompleteResolve == "function") {
      try {
        await Promise.resolve(source3.onCompleteResolve(item, token));
      } catch (e) {
        logger68.error("Error on complete resolve:", e.stack);
      }
    }
  }
  async doCompleteDone(item, opt) {
    let data = JSON.parse(item.user_data);
    let source3 = this.getSource(data.source);
    if (source3 && typeof source3.onCompleteDone === "function") {
      await Promise.resolve(source3.onCompleteDone(item, opt));
    }
  }
  shouldCommit(item, commitCharacter) {
    if (!item || !item.source)
      return false;
    let source3 = this.getSource(item.source);
    if (source3 && source3.sourceType == SourceType.Service && typeof source3.shouldCommit === "function") {
      return source3.shouldCommit(item, commitCharacter);
    }
    return false;
  }
  getCompleteSources(opt) {
    let {filetype} = opt;
    let pre = byteSlice(opt.line, 0, opt.colnr - 1);
    let isTriggered = opt.input == "" && !!opt.triggerCharacter;
    if (isTriggered)
      return this.getTriggerSources(pre, filetype);
    return this.getNormalSources(opt.filetype);
  }
  getNormalSources(filetype) {
    return this.sources.filter((source3) => {
      let {filetypes, triggerOnly, enable} = source3;
      if (!enable || triggerOnly || filetypes && !filetypes.includes(filetype)) {
        return false;
      }
      if (this.disabledByLanguageId(source3, filetype)) {
        return false;
      }
      return true;
    });
  }
  checkTrigger(source3, pre, character) {
    let {triggerCharacters, triggerPatterns} = source3;
    if (!triggerCharacters && !triggerPatterns)
      return false;
    if (character && triggerCharacters && triggerCharacters.includes(character)) {
      return true;
    }
    if (triggerPatterns && triggerPatterns.findIndex((p) => p.test(pre)) !== -1) {
      return true;
    }
    return false;
  }
  shouldTrigger(pre, languageId) {
    let sources6 = this.getTriggerSources(pre, languageId);
    return sources6.length > 0;
  }
  getTriggerSources(pre, languageId) {
    let character = pre.length ? pre[pre.length - 1] : "";
    if (!character)
      return [];
    return this.sources.filter((source3) => {
      let {filetypes, enable} = source3;
      if (!enable || filetypes && !filetypes.includes(languageId)) {
        return false;
      }
      if (this.disabledByLanguageId(source3, languageId))
        return false;
      return this.checkTrigger(source3, pre, character);
    });
  }
  addSource(source3) {
    let {name: name2} = source3;
    if (this.names.includes(name2)) {
      window_default.showMessage(`Source "${name2}" recreated`, "warning");
    }
    this.sourceMap.set(name2, source3);
    return vscode_languageserver_protocol64.Disposable.create(() => {
      this.sourceMap.delete(name2);
    });
  }
  removeSource(source3) {
    let name2 = typeof source3 == "string" ? source3 : source3.name;
    if (source3 == this.sourceMap.get(name2)) {
      this.sourceMap.delete(name2);
    }
  }
  async refresh(name2) {
    for (let source3 of this.sources) {
      if (!name2 || source3.name == name2) {
        if (typeof source3.refresh === "function") {
          await Promise.resolve(source3.refresh());
        }
      }
    }
  }
  toggleSource(name2) {
    if (!name2)
      return;
    let source3 = this.getSource(name2);
    if (!source3)
      return;
    if (typeof source3.toggle === "function") {
      source3.toggle();
    }
  }
  sourceStats() {
    let res = [];
    let items = this.sources;
    for (let item of items) {
      res.push({
        name: item.name,
        priority: item.priority,
        triggerCharacters: item.triggerCharacters || [],
        shortcut: item.shortcut || "",
        filetypes: item.filetypes || [],
        filepath: item.filepath || "",
        type: item.sourceType == SourceType.Native ? "native" : item.sourceType == SourceType.Remote ? "remote" : "service",
        disabled: !item.enable
      });
    }
    return res;
  }
  onDocumentEnter(bufnr) {
    let {sources: sources6} = this;
    for (let s of sources6) {
      if (!s.enable)
        continue;
      if (typeof s.onEnter == "function") {
        s.onEnter(bufnr);
      }
    }
  }
  createSource(config) {
    if (!config.name || !config.doComplete) {
      console.error(`name and doComplete required for createSource`);
      return;
    }
    let source3 = new source_default(Object.assign({sourceType: SourceType.Service}, config));
    return this.addSource(source3);
  }
  disabledByLanguageId(source3, languageId) {
    let map = workspace_default.env.disabledSources;
    let list2 = map ? map[languageId] : [];
    return Array.isArray(list2) && list2.includes(source3.name);
  }
  dispose() {
    disposeAll(this.disposables);
  }
};
var sources_default = new Sources();

// src/completion/complete.ts
var vscode_languageserver_protocol65 = __toModule(require_main3());

// src/completion/match.ts
function nextWordIndex(start = 0, codes) {
  for (let i = start; i < codes.length; i++) {
    if (isWordIndex(i, codes)) {
      return i;
    }
  }
  return -1;
}
function upperCase(code) {
  return code >= 65 && code <= 90;
}
function isWordIndex(index, codes) {
  if (index == 0)
    return true;
  let curr = codes[index];
  if (!wordChar(curr))
    return false;
  let pre = codes[index - 1];
  if (!wordChar(pre))
    return true;
  if (upperCase(curr) && !upperCase(pre))
    return true;
  return false;
}
function matchScore(word, input) {
  if (input.length == 0 || word.length < input.length)
    return 0;
  let codes = getCharCodes(word);
  let curr = codes[0];
  let score6 = 0;
  let first = input[0];
  let idx = 1;
  let allowFuzzy = true;
  if (caseMatch(first, curr)) {
    score6 = first == curr ? 5 : 2.5;
    idx = 1;
  } else {
    let next2 = nextWordIndex(1, codes);
    if (next2 != -1) {
      if (caseMatch(first, codes[next2])) {
        score6 = first == codes[next2] ? 2.5 : 2;
        idx = next2 + 1;
      }
    }
    if (score6 == 0) {
      for (let i = 1; i < codes.length; i++) {
        if (caseMatch(first, codes[i])) {
          score6 = first == codes[i] ? 1 : 0.5;
          idx = i + 1;
          allowFuzzy = false;
        }
      }
    }
  }
  if (input.length == 1 || score6 == 0)
    return score6;
  let next = nextScore(codes, idx, input.slice(1), allowFuzzy);
  return next == 0 ? 0 : score6 + next;
}
function nextScore(codes, index, inputCodes, allowFuzzy = true) {
  if (index >= codes.length)
    return 0;
  let scores = [];
  let input = inputCodes[0];
  let len = codes.length;
  let isFinal = inputCodes.length == 1;
  if (!wordChar(input)) {
    for (let i = index; i < len; i++) {
      if (codes[i] == input) {
        if (isFinal)
          return 1;
        let next = nextScore(codes, i + 1, inputCodes.slice(1), allowFuzzy);
        return next == 0 ? 0 : 1 + next;
      }
    }
    return 0;
  }
  let curr = codes[index];
  let match3 = caseMatch(input, curr);
  if (match3) {
    let score6 = input == curr ? 1 : 0.5;
    if (!isFinal) {
      let next = nextScore(codes, index + 1, inputCodes.slice(1), allowFuzzy);
      score6 = next == 0 ? 0 : score6 + next;
    }
    scores.push(score6);
  }
  if (wordChar(input) && !isWordIndex(index, codes)) {
    let idx = nextWordIndex(index + 1, codes);
    if (idx !== -1) {
      let next = codes[idx];
      if (caseMatch(input, next)) {
        let score6 = input == next ? 1 : 0.75;
        if (!isFinal) {
          let next2 = nextScore(codes, idx + 1, inputCodes.slice(1), allowFuzzy);
          score6 = next2 == 0 ? 0 : score6 + next2;
        }
        scores.push(score6);
      }
    }
  }
  if (!match3 && allowFuzzy) {
    for (let i = index + 1; i < len; i++) {
      let code = codes[i];
      if (caseMatch(input, code)) {
        let score6 = input == code ? 0.1 : 0.05;
        if (!isFinal) {
          let next = nextScore(codes, i + 1, inputCodes.slice(1), false);
          score6 = next == 0 ? 0 : score6 + next;
        }
        scores.push(score6);
      }
    }
  }
  if (!scores.length)
    return 0;
  return Math.max(...scores);
}

// src/completion/complete.ts
var logger69 = require_logger2()("completion-complete");
var FIRST_TIMEOUT = 500;
var Complete = class {
  constructor(option, document3, recentScores, config, sources6, nvim) {
    this.option = option;
    this.document = document3;
    this.config = config;
    this.sources = sources6;
    this.nvim = nvim;
    this.results = [];
    this.completing = new Set();
    this._canceled = false;
    this.tokenSources = new Map();
    this._onDidComplete = new vscode_languageserver_protocol65.Emitter();
    this.onDidComplete = this._onDidComplete.event;
    Object.defineProperty(this, "recentScores", {
      get: () => recentScores || {}
    });
  }
  get isCompleting() {
    return this.completing.size > 0;
  }
  get isCanceled() {
    return this._canceled;
  }
  get isEmpty() {
    return this.results.length == 0;
  }
  get startcol() {
    return this.option.col || 0;
  }
  get input() {
    return this.option.input;
  }
  get isIncomplete() {
    return this.results.findIndex((o) => o.isIncomplete) !== -1;
  }
  async completeSource(source3) {
    let {col} = this.option;
    let opt = Object.assign({}, this.option);
    let timeout = this.config.timeout;
    timeout = Math.max(Math.min(timeout, 15e3), 500);
    try {
      if (typeof source3.shouldComplete === "function") {
        let shouldRun = await Promise.resolve(source3.shouldComplete(opt));
        if (!shouldRun)
          return null;
      }
      let start = Date.now();
      let oldSource = this.tokenSources.get(source3.name);
      if (oldSource)
        oldSource.cancel();
      let tokenSource = new vscode_languageserver_protocol65.CancellationTokenSource();
      this.tokenSources.set(source3.name, tokenSource);
      await new Promise((resolve3, reject) => {
        let {name: name2} = source3;
        let timer = setTimeout(() => {
          this.nvim.command(`echohl WarningMsg| echom 'source ${source3.name} timeout after ${timeout}ms'|echohl None`, true);
          tokenSource.cancel();
        }, timeout);
        let cancelled = false;
        let called = false;
        let empty = false;
        let ft = setTimeout(() => {
          if (called)
            return;
          empty = true;
          resolve3(void 0);
        }, FIRST_TIMEOUT);
        let onFinished = () => {
          if (called)
            return;
          called = true;
          disposable.dispose();
          clearTimeout(ft);
          clearTimeout(timer);
          this.tokenSources.delete(name2);
        };
        let disposable = tokenSource.token.onCancellationRequested(() => {
          disposable.dispose();
          this.completing.delete(name2);
          cancelled = true;
          onFinished();
          logger69.debug(`Source "${name2}" cancelled`);
          resolve3(void 0);
        });
        this.completing.add(name2);
        Promise.resolve(source3.doComplete(opt, tokenSource.token)).then((result) => {
          this.completing.delete(name2);
          if (cancelled)
            return;
          onFinished();
          let dt = Date.now() - start;
          logger69.debug(`Source "${name2}" takes ${dt}ms`);
          if (result && result.items && result.items.length) {
            result.priority = source3.priority;
            result.source = name2;
            if (empty && result.startcol && result.startcol != col) {
              this.results = [result];
            } else {
              let {results} = this;
              let idx = results.findIndex((o) => o.source == name2);
              if (idx != -1) {
                results.splice(idx, 1, result);
              } else {
                results.push(result);
              }
            }
            if (empty)
              this._onDidComplete.fire();
            resolve3(void 0);
          } else {
            resolve3(void 0);
          }
        }, (err) => {
          this.completing.delete(name2);
          onFinished();
          reject(err);
        });
      });
    } catch (err) {
      this.nvim.command(`echoerr 'Complete ${source3.name} error: ${err.message.replace(/'/g, "''")}'`, true);
      logger69.error("Complete error:", source3.name, err);
    }
  }
  async completeInComplete(resumeInput) {
    let {results, document: document3} = this;
    let remains = results.filter((res) => !res.isIncomplete);
    remains.forEach((res) => {
      res.items.forEach((item) => delete item.user_data);
    });
    let arr = results.filter((res) => res.isIncomplete);
    let names = arr.map((o) => o.source);
    let {input, colnr, linenr} = this.option;
    Object.assign(this.option, {
      input: resumeInput,
      line: document3.getline(linenr - 1),
      colnr: colnr + (resumeInput.length - input.length),
      triggerCharacter: null,
      triggerForInComplete: true
    });
    let sources6 = this.sources.filter((s) => names.includes(s.name));
    await Promise.all(sources6.map((s) => this.completeSource(s)));
    return this.filterResults(resumeInput, Math.floor(Date.now() / 1e3));
  }
  filterResults(input, cid = 0) {
    let {results} = this;
    results.sort((a, b) => {
      if (a.source == "tabnine")
        return 1;
      if (b.source == "tabnine")
        return -1;
      return b.priority - a.priority;
    });
    let now = Date.now();
    let {bufnr} = this.option;
    let {snippetIndicator, removeDuplicateItems, fixInsertedWord, asciiCharactersOnly} = this.config;
    let followPart = !fixInsertedWord || cid == 0 ? "" : this.getFollowPart();
    if (results.length == 0)
      return [];
    let arr = [];
    let codes = getCharCodes(input);
    let words = new Set();
    for (let i = 0, l = results.length; i < l; i++) {
      let res = results[i];
      let {items, source: source3, priority} = res;
      for (let idx = 0; idx < items.length; idx++) {
        let item = items[idx];
        if (!item || typeof item.word !== "string") {
          continue;
        }
        let {word} = item;
        if (asciiCharactersOnly && !/^[\x00-\x7F]*$/.test(word)) {
          continue;
        }
        if (!item.dup && words.has(word))
          continue;
        if (removeDuplicateItems && !item.isSnippet && words.has(word) && item.line == void 0)
          continue;
        let filterText = item.filterText || item.word;
        item.filterText = filterText;
        if (filterText.length < input.length)
          continue;
        let score6 = item.kind && filterText == input ? 64 : matchScore(filterText, codes);
        if (input.length && score6 == 0)
          continue;
        if (followPart.length && !item.isSnippet) {
          if (item.word.endsWith(followPart)) {
            let {word: word2} = item;
            item.word = item.word.slice(0, -followPart.length);
            item.abbr = item.abbr || word2;
          }
        }
        if (!item.user_data) {
          let user_data = {cid, source: source3};
          user_data.index = item.index || idx;
          if (item.isSnippet) {
            let abbr = item.abbr || item.word;
            if (!abbr.endsWith(snippetIndicator)) {
              item.abbr = `${item.abbr || item.word}${snippetIndicator}`;
            }
          }
          if (item.signature)
            user_data.signature = item.signature;
          item.user_data = JSON.stringify(user_data);
          item.source = source3;
          let recentScore = this.recentScores[`${bufnr}|${word}`];
          if (recentScore && now - recentScore < 60 * 1e3) {
            item.recentScore = recentScore;
          } else {
            item.recentScore = 0;
          }
        }
        item.priority = priority;
        item.abbr = item.abbr || item.word;
        item.score = input.length ? score6 * (item.sourceScore || 1) : 0;
        item.localBonus = this.localBonus ? this.localBonus.get(filterText) || 0 : 0;
        words.add(word);
        if (item.isSnippet && item.word == input) {
          item.preselect = true;
        }
        arr.push(item);
      }
    }
    arr.sort((a, b) => {
      let sa = a.sortText;
      let sb = b.sortText;
      let wa = a.filterText;
      let wb = b.filterText;
      if (a.score != b.score)
        return b.score - a.score;
      if (a.priority != b.priority)
        return b.priority - a.priority;
      if (sa && sb && sa != sb)
        return sa < sb ? -1 : 1;
      if (a.recentScore != b.recentScore)
        return b.recentScore - a.recentScore;
      if (a.localBonus != b.localBonus) {
        if (a.localBonus && b.localBonus && wa != wb) {
          if (wa.startsWith(wb))
            return 1;
          if (wb.startsWith(wa))
            return -1;
        }
        return b.localBonus - a.localBonus;
      }
      switch (this.config.defaultSortMethod) {
        case "alphabetical":
          return a.filterText.localeCompare(b.filterText);
        case "length":
        default:
          return a.filterText.length - b.filterText.length;
      }
    });
    return this.limitCompleteItems(arr.slice(0, this.config.maxItemCount));
  }
  limitCompleteItems(items) {
    let {highPrioritySourceLimit, lowPrioritySourceLimit} = this.config;
    if (!highPrioritySourceLimit && !lowPrioritySourceLimit)
      return items;
    let counts = new Map();
    return items.filter((item) => {
      let {priority, source: source3} = item;
      let isLow = priority < 90;
      let curr = counts.get(source3) || 0;
      if (lowPrioritySourceLimit && isLow && curr == lowPrioritySourceLimit || highPrioritySourceLimit && !isLow && curr == highPrioritySourceLimit) {
        return false;
      }
      counts.set(source3, curr + 1);
      return true;
    });
  }
  hasMatch(input) {
    let {results} = this;
    if (!results)
      return false;
    let codes = getCharCodes(input);
    for (let i = 0, l = results.length; i < l; i++) {
      let items = results[i].items;
      let idx = items.findIndex((item) => fuzzyMatch(codes, item.filterText || item.word));
      if (idx !== -1)
        return true;
    }
    return false;
  }
  async doComplete() {
    let opts = this.option;
    let {line, colnr, linenr, col} = this.option;
    if (this.config.localityBonus) {
      let line2 = linenr - 1;
      this.localBonus = this.document.getLocalifyBonus(vscode_languageserver_protocol65.Position.create(line2, opts.col - 1), vscode_languageserver_protocol65.Position.create(line2, colnr));
    } else {
      this.localBonus = new Map();
    }
    await Promise.all(this.sources.map((s) => this.completeSource(s)));
    let {results} = this;
    if (results.length == 0)
      return [];
    let engrossResult = results.find((r) => r.startcol != null && r.startcol != col);
    if (engrossResult) {
      let {startcol} = engrossResult;
      opts.col = startcol;
      opts.input = byteSlice(line, startcol, colnr - 1);
      this.results = [engrossResult];
    }
    logger69.info(`Results from: ${this.results.map((s) => s.source).join(",")}`);
    return this.filterResults(opts.input, Math.floor(Date.now() / 1e3));
  }
  resolveCompletionItem(item) {
    let {results} = this;
    if (!results)
      return null;
    try {
      if (item.user_data) {
        let {source: source3} = JSON.parse(item.user_data);
        let result = results.find((res) => res.source == source3);
        return result.items.find((o) => o.user_data == item.user_data);
      }
      for (let result of results) {
        let res = result.items.find((o) => o.abbr == item.abbr && o.info == item.info);
        if (res)
          return res;
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getFollowPart() {
    let {colnr, line} = this.option;
    let idx = characterIndex(line, colnr - 1);
    if (idx == line.length)
      return "";
    let part = line.slice(idx - line.length);
    return part.match(/^\S?[\w-]*/)[0];
  }
  dispose() {
    if (this._canceled)
      return;
    this._onDidComplete.dispose();
    this._canceled = true;
    for (let tokenSource of this.tokenSources.values()) {
      tokenSource.cancel();
    }
    this.tokenSources.clear();
    this.sources = [];
    this.results = [];
  }
};
var complete_default = Complete;

// src/completion/floating.ts
var logger70 = require_logger2()("floating");
var Floating = class {
  constructor(nvim, isVim5) {
    this.nvim = nvim;
    this.isVim = isVim5;
    this.winid = 0;
    this.bufnr = 0;
  }
  async show(docs, bounding, config, token) {
    let {nvim} = this;
    docs = docs.filter((o) => o.content.trim().length > 0);
    let {lines, codes, highlights: highlights2} = parseDocuments(docs);
    if (lines.length == 0) {
      this.close();
      return;
    }
    let res = await nvim.call("coc#float#create_pum_float", [this.winid, this.bufnr, lines, {
      codes,
      highlights: highlights2,
      maxWidth: config.maxPreviewWidth,
      pumbounding: bounding
    }]);
    if (this.isVim)
      nvim.command("redraw", true);
    if (!res || res.length == 0)
      return;
    this.winid = res[0];
    this.bufnr = res[1];
    if (token.isCancellationRequested) {
      this.close();
      return;
    }
  }
  close() {
    let {winid, nvim} = this;
    this.winid = 0;
    if (!winid)
      return;
    nvim.call("coc#float#close", [winid], true);
    if (this.isVim)
      nvim.command("redraw", true);
  }
};
var floating_default = Floating;

// src/util/throttle.ts
function throttle(func2, wait2) {
  let args;
  let rtn;
  let timeoutID;
  let last = 0;
  function fn() {
    args = arguments;
    let delta = Date.now() - last;
    if (!timeoutID) {
      if (last != 0 && delta >= wait2) {
        call();
      } else {
        timeoutID = setTimeout(call, wait2 - delta);
      }
    }
    return rtn;
  }
  function call() {
    timeoutID = 0;
    last = Date.now();
    rtn = func2.apply(null, args);
    args = null;
  }
  fn.clear = () => {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  };
  return fn;
}

// src/completion/index.ts
var logger71 = require_logger2()("completion");
var completeItemKeys = ["abbr", "menu", "info", "kind", "icase", "dup", "empty", "user_data"];
var Completion = class {
  constructor() {
    this.activated = false;
    this.disposables = [];
    this.complete = null;
    this.recentScores = {};
    this.changedTick = 0;
    this.insertCharTs = 0;
    this.insertLeaveTs = 0;
  }
  init() {
    this.config = this.getCompleteConfig();
    this.floating = new floating_default(workspace_default.nvim, workspace_default.env.isVim);
    events_default.on(["InsertCharPre", "MenuPopupChanged", "TextChangedI", "CursorMovedI", "InsertLeave"], () => {
      if (this.triggerTimer) {
        clearTimeout(this.triggerTimer);
        this.triggerTimer = null;
      }
    }, this, this.disposables);
    events_default.on("InsertCharPre", this.onInsertCharPre, this, this.disposables);
    events_default.on("InsertLeave", this.onInsertLeave, this, this.disposables);
    events_default.on("InsertEnter", this.onInsertEnter, this, this.disposables);
    events_default.on("TextChangedP", this.onTextChangedP, this, this.disposables);
    events_default.on("TextChangedI", this.onTextChangedI, this, this.disposables);
    let fn = throttle(this.onPumChange.bind(this), workspace_default.isVim ? 200 : 100);
    events_default.on("CompleteDone", async (item) => {
      this.currItem = null;
      this.cancelResolve();
      this.floating.close();
      await this.onCompleteDone(item);
    }, this, this.disposables);
    events_default.on("MenuPopupChanged", (ev) => {
      if (!this.activated || this.isCommandLine)
        return;
      let {completed_item} = ev;
      let item = completed_item.hasOwnProperty("word") ? completed_item : null;
      if (equals(item, this.currItem))
        return;
      this.cancelResolve();
      this.currItem = item;
      fn(ev);
    }, this, this.disposables);
    workspace_default.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("suggest")) {
        this.config = this.getCompleteConfig();
      }
    }, null, this.disposables);
  }
  get nvim() {
    return workspace_default.nvim;
  }
  get option() {
    if (!this.complete)
      return null;
    return this.complete.option;
  }
  get isCommandLine() {
    var _a2;
    return (_a2 = this.document) == null ? void 0 : _a2.uri.endsWith("%5BCommand%20Line%5D");
  }
  addRecent(word, bufnr) {
    if (!word)
      return;
    this.recentScores[`${bufnr}|${word}`] = Date.now();
  }
  get isActivated() {
    return this.activated;
  }
  get document() {
    if (!this.option)
      return null;
    return workspace_default.getDocument(this.option.bufnr);
  }
  getCompleteConfig() {
    let suggest = workspace_default.getConfiguration("suggest");
    function getConfig(key, defaultValue) {
      return suggest.get(key, defaultValue);
    }
    let keepCompleteopt = getConfig("keepCompleteopt", false);
    let autoTrigger = getConfig("autoTrigger", "always");
    if (keepCompleteopt && autoTrigger != "none") {
      let {completeOpt} = workspace_default;
      if (!completeOpt.includes("noinsert") && !completeOpt.includes("noselect")) {
        autoTrigger = "none";
      }
    }
    let floatEnable = workspace_default.floatSupported && getConfig("floatEnable", true);
    let acceptSuggestionOnCommitCharacter = workspace_default.env.pumevent && getConfig("acceptSuggestionOnCommitCharacter", false);
    return {
      autoTrigger,
      floatEnable,
      keepCompleteopt,
      defaultSortMethod: getConfig("defaultSortMethod", "length"),
      removeDuplicateItems: getConfig("removeDuplicateItems", false),
      disableMenuShortcut: getConfig("disableMenuShortcut", false),
      acceptSuggestionOnCommitCharacter,
      disableKind: getConfig("disableKind", false),
      disableMenu: getConfig("disableMenu", false),
      previewIsKeyword: getConfig("previewIsKeyword", "@,48-57,_192-255"),
      enablePreview: getConfig("enablePreview", false),
      enablePreselect: getConfig("enablePreselect", false),
      maxPreviewWidth: getConfig("maxPreviewWidth", 80),
      triggerCompletionWait: getConfig("triggerCompletionWait", 100),
      labelMaxLength: getConfig("labelMaxLength", 200),
      triggerAfterInsertEnter: getConfig("triggerAfterInsertEnter", false),
      noselect: getConfig("noselect", true),
      numberSelect: getConfig("numberSelect", false),
      maxItemCount: getConfig("maxCompleteItemCount", 50),
      timeout: getConfig("timeout", 500),
      minTriggerInputLength: getConfig("minTriggerInputLength", 1),
      snippetIndicator: getConfig("snippetIndicator", "~"),
      fixInsertedWord: getConfig("fixInsertedWord", true),
      localityBonus: getConfig("localityBonus", true),
      highPrioritySourceLimit: getConfig("highPrioritySourceLimit", null),
      lowPrioritySourceLimit: getConfig("lowPrioritySourceLimit", null),
      asciiCharactersOnly: getConfig("asciiCharactersOnly", false)
    };
  }
  async startCompletion(option) {
    this.pretext = byteSlice(option.line, 0, option.colnr - 1);
    try {
      await this._doComplete(option);
    } catch (e) {
      this.stop(false);
      logger71.error("Complete error:", e.stack);
    }
  }
  async resumeCompletion(force = false) {
    let {document: document3, complete: complete3} = this;
    if (!document3 || complete3.isCanceled || !complete3.results || complete3.results.length == 0)
      return;
    let search2 = this.getResumeInput();
    if (search2 == this.input && !force)
      return;
    if (!search2 || search2.endsWith(" ") || !search2.startsWith(complete3.input)) {
      this.stop();
      return;
    }
    this.input = search2;
    let items = [];
    if (complete3.isIncomplete) {
      await document3.patchChange();
      let {changedtick} = document3;
      items = await complete3.completeInComplete(search2);
      if (complete3.isCanceled || document3.changedtick != changedtick)
        return;
    } else {
      items = complete3.filterResults(search2);
    }
    if (!complete3.isCompleting && items.length === 0) {
      this.stop();
      return;
    }
    await this.showCompletion(complete3.option.col, items);
  }
  hasSelected() {
    if (workspace_default.env.pumevent)
      return this.currItem != null;
    if (!this.config.noselect)
      return true;
    return false;
  }
  async showCompletion(col, items) {
    let {nvim, document: document3, option} = this;
    let {numberSelect, disableKind, labelMaxLength, disableMenuShortcut, disableMenu} = this.config;
    let preselect = this.config.enablePreselect ? items.findIndex((o) => o.preselect) : -1;
    if (numberSelect && option.input.length && !/^\d/.test(option.input)) {
      items = items.map((item, i) => {
        let idx = i + 1;
        if (i < 9) {
          return Object.assign({}, item, {
            abbr: item.abbr ? `${idx} ${item.abbr}` : `${idx} ${item.word}`
          });
        }
        return item;
      });
      nvim.call("coc#_map", [], true);
    }
    this.changedTick = document3.changedtick;
    let validKeys2 = completeItemKeys.slice();
    if (disableKind)
      validKeys2 = validKeys2.filter((s) => s != "kind");
    if (disableMenu)
      validKeys2 = validKeys2.filter((s) => s != "menu");
    let vimItems = items.map((item) => {
      let obj = {word: item.word, equal: 1};
      for (let key of validKeys2) {
        if (item.hasOwnProperty(key)) {
          if (disableMenuShortcut && key == "menu") {
            obj[key] = item[key].replace(/\[.+\]$/, "");
          } else if (key == "abbr" && item[key].length > labelMaxLength) {
            obj[key] = item[key].slice(0, labelMaxLength);
          } else {
            obj[key] = item[key];
          }
        }
      }
      return obj;
    });
    nvim.call("coc#_do_complete", [col, vimItems, preselect], true);
  }
  async _doComplete(option) {
    let {source: source3} = option;
    let {nvim, config} = this;
    let doc = workspace_default.getDocument(option.bufnr);
    if (!doc || !doc.attached)
      return;
    option.filetype = doc.filetype;
    this.input = option.input;
    let arr = [];
    if (source3 == null) {
      arr = sources_default.getCompleteSources(option);
    } else {
      let s = sources_default.getSource(source3);
      if (s)
        arr.push(s);
    }
    if (!arr.length)
      return;
    await doc.patchChange();
    if (doc.changedtick != option.changedtick)
      return;
    let complete3 = new complete_default(option, doc, this.recentScores, config, arr, nvim);
    this.start(complete3);
    let items = await this.complete.doComplete();
    if (complete3.isCanceled)
      return;
    if (items.length == 0 && !complete3.isCompleting) {
      this.stop();
      return;
    }
    complete3.onDidComplete(async () => {
      if (this.currItem != null)
        return;
      let search2 = this.getResumeInput();
      if (complete3.isCanceled || search2 == null)
        return;
      let {input} = this.option;
      if (search2 == input) {
        let items2 = complete3.filterResults(search2, Math.floor(Date.now() / 1e3));
        await this.showCompletion(option.col, items2);
      } else {
        await this.resumeCompletion();
      }
    });
    if (items.length) {
      let search2 = this.getResumeInput();
      if (search2 == option.input) {
        await this.showCompletion(option.col, items);
      } else {
        await this.resumeCompletion(true);
      }
    }
  }
  async onTextChangedP(bufnr, info) {
    let {option, document: document3} = this;
    let pretext = this.pretext = info.pre;
    if (!option || option.bufnr != bufnr || info.changedtick == this.changedTick)
      return;
    let hasInsert = this.latestInsert != null;
    this.lastInsert = null;
    if (info.pre.match(/^\s*/)[0] !== option.line.match(/^\s*/)[0]) {
      logger71.warn("Complete stopped by indent change.");
      this.stop();
      return;
    }
    if (!hasInsert || !pretext)
      return;
    if (sources_default.shouldTrigger(pretext, document3.filetype)) {
      await this.triggerCompletion(document3, pretext);
    } else {
      await this.resumeCompletion();
    }
  }
  async onTextChangedI(bufnr, info) {
    let {nvim, latestInsertChar, option} = this;
    let noChange = this.pretext == info.pre;
    let pretext = this.pretext = info.pre;
    this.lastInsert = null;
    let doc = workspace_default.getDocument(bufnr);
    if (!doc)
      return;
    if (!this.activated) {
      if (!latestInsertChar)
        return;
      let triggerSources = sources_default.getTriggerSources(pretext, doc.filetype);
      if (triggerSources.length) {
        await this.triggerCompletion(doc, this.pretext);
        return;
      }
      this.triggerTimer = setTimeout(async () => {
        await this.triggerCompletion(doc, pretext);
      }, this.config.triggerCompletionWait);
      return;
    }
    if (!option || bufnr != option.bufnr)
      return;
    if (option.linenr != info.lnum || option.col >= info.col - 1) {
      this.stop();
      return;
    }
    if (noChange && !latestInsertChar) {
      this.stop(false);
      return;
    }
    if (pretext && this.currItem && this.config.acceptSuggestionOnCommitCharacter && latestInsertChar) {
      let resolvedItem = this.getCompleteItem(this.currItem);
      let last = pretext[pretext.length - 1];
      if (sources_default.shouldCommit(resolvedItem, last)) {
        let {linenr, col, line, colnr} = this.option;
        this.stop();
        let {word} = resolvedItem;
        let newLine = `${line.slice(0, col)}${word}${latestInsertChar}${line.slice(colnr - 1)}`;
        await nvim.call("coc#util#setline", [linenr, newLine]);
        let curcol = col + word.length + 2;
        await nvim.call("cursor", [linenr, curcol]);
        await doc.patchChange();
        return;
      }
    }
    if (sources_default.shouldTrigger(pretext, doc.filetype)) {
      await this.triggerCompletion(doc, pretext);
    } else {
      await this.resumeCompletion();
    }
  }
  async triggerCompletion(doc, pre) {
    if (!doc || !doc.attached) {
      logger71.warn("Document not attached, suggest disabled.");
      return;
    }
    let shouldTrigger = this.shouldTrigger(doc, pre);
    if (!shouldTrigger)
      return;
    if (doc.getVar("suggest_disable")) {
      logger71.warn(`Suggest disabled by b:coc_suggest_disable`);
      return;
    }
    await doc.patchChange();
    let [disabled, option] = await this.nvim.eval('[get(b:,"coc_suggest_disable",0),coc#util#get_complete_option()]');
    if (disabled == 1) {
      logger71.warn(`Suggest disabled by b:coc_suggest_disable`);
      return;
    }
    if (option.blacklist && option.blacklist.includes(option.input)) {
      logger71.warn(`Suggest disabled by b:coc_suggest_blacklist`, option.blacklist);
      return;
    }
    if (pre.length) {
      option.triggerCharacter = pre.slice(-1);
    }
    logger71.debug("trigger completion with", option);
    await this.startCompletion(option);
  }
  async onCompleteDone(item) {
    let {document: document3, isActivated} = this;
    if (!isActivated || !document3 || !item.hasOwnProperty("word"))
      return;
    let opt = Object.assign({}, this.option);
    let resolvedItem = this.getCompleteItem(item);
    this.stop(false);
    if (!resolvedItem)
      return;
    let timestamp = this.insertCharTs;
    let insertLeaveTs = this.insertLeaveTs;
    try {
      await sources_default.doCompleteResolve(resolvedItem, new vscode_languageserver_protocol66.CancellationTokenSource().token);
      this.addRecent(resolvedItem.word, document3.bufnr);
      await wait(50);
      if (this.insertCharTs != timestamp || this.insertLeaveTs != insertLeaveTs)
        return;
      let [visible, lnum, pre] = await this.nvim.eval(`[pumvisible(),line('.'),strpart(getline('.'), 0, col('.') - 1)]`);
      if (visible || lnum != opt.linenr || this.activated || !pre.endsWith(resolvedItem.word))
        return;
      await document3.patchChange();
      await sources_default.doCompleteDone(resolvedItem, opt);
    } catch (e) {
      logger71.error(`error on complete done`, e.stack);
    }
  }
  async onInsertLeave() {
    this.insertLeaveTs = Date.now();
    this.stop(false);
  }
  async onInsertEnter(bufnr) {
    if (!this.config.triggerAfterInsertEnter || this.config.autoTrigger !== "always")
      return;
    let doc = workspace_default.getDocument(bufnr);
    if (!doc)
      return;
    let pre = await this.nvim.eval(`strpart(getline('.'), 0, col('.') - 1)`);
    if (!pre)
      return;
    await this.triggerCompletion(doc, pre);
  }
  async onInsertCharPre(character) {
    this.lastInsert = {
      character,
      timestamp: Date.now()
    };
    this.insertCharTs = this.lastInsert.timestamp;
  }
  get latestInsert() {
    let {lastInsert} = this;
    if (!lastInsert || Date.now() - lastInsert.timestamp > 500) {
      return null;
    }
    return lastInsert;
  }
  get latestInsertChar() {
    let {latestInsert} = this;
    if (!latestInsert)
      return "";
    return latestInsert.character;
  }
  shouldTrigger(document3, pre) {
    if (pre.length == 0 || /\s/.test(pre[pre.length - 1]))
      return false;
    let autoTrigger = this.config.autoTrigger;
    if (autoTrigger == "none")
      return false;
    if (sources_default.shouldTrigger(pre, document3.filetype))
      return true;
    if (autoTrigger !== "always" || this.isActivated)
      return false;
    let last = pre.slice(-1);
    if (last && (document3.isWord(pre.slice(-1)) || last.codePointAt(0) > 255)) {
      let minLength = this.config.minTriggerInputLength;
      if (minLength == 1)
        return true;
      let input = this.getInput(document3, pre);
      return input.length >= minLength;
    }
    return false;
  }
  async onPumChange(ev) {
    if (!this.activated)
      return;
    let {completed_item, col, row, height, width, scrollbar} = ev;
    let bounding = {col, row, height, width, scrollbar};
    let resolvedItem = this.getCompleteItem(completed_item);
    if (!resolvedItem) {
      this.floating.close();
      return;
    }
    let source3 = this.resolveTokenSource = new vscode_languageserver_protocol66.CancellationTokenSource();
    let {token} = source3;
    await sources_default.doCompleteResolve(resolvedItem, token);
    this.resolveTokenSource = null;
    if (token.isCancellationRequested)
      return;
    let docs = resolvedItem.documentation;
    if (!docs && resolvedItem.info) {
      let {info} = resolvedItem;
      let isText = /^[\w-\s.,\t]+$/.test(info);
      docs = [{filetype: isText ? "txt" : this.document.filetype, content: info}];
    }
    if (!this.isActivated)
      return;
    if (!docs || docs.length == 0) {
      this.floating.close();
    } else {
      if (this.config.floatEnable) {
        await this.floating.show(docs, bounding, {maxPreviewWidth: this.config.maxPreviewWidth}, token);
      }
      if (!this.isActivated) {
        this.floating.close();
      }
    }
  }
  start(complete3) {
    let {activated} = this;
    this.activated = true;
    if (activated) {
      this.complete.dispose();
    }
    this.complete = complete3;
    if (!this.config.keepCompleteopt) {
      this.nvim.command(`noa set completeopt=${this.completeOpt}`, true);
    }
  }
  cancelResolve() {
    if (this.resolveTokenSource) {
      this.resolveTokenSource.cancel();
      this.resolveTokenSource = null;
    }
  }
  stop(hide = true) {
    let {nvim} = this;
    if (!this.activated)
      return;
    this.cancelResolve();
    this.currItem = null;
    this.activated = false;
    if (this.complete) {
      this.complete.dispose();
      this.complete = null;
    }
    nvim.pauseNotification();
    if (hide) {
      nvim.call("coc#_hide", [], true);
    }
    this.floating.close();
    if (this.config.numberSelect) {
      nvim.call("coc#_unmap", [], true);
    }
    if (!this.config.keepCompleteopt) {
      this.nvim.command(`noa set completeopt=${workspace_default.completeOpt}`, true);
    }
    nvim.command(`let g:coc#_context['candidates'] = []`, true);
    nvim.call("coc#_cancel", [], true);
    nvim.resumeNotification(false, true);
  }
  getInput(document3, pre) {
    let input = "";
    for (let i = pre.length - 1; i >= 0; i--) {
      let ch = i == 0 ? null : pre[i - 1];
      if (!ch || !document3.isWord(ch)) {
        input = pre.slice(i, pre.length);
        break;
      }
    }
    return input;
  }
  getResumeInput() {
    let {option, pretext} = this;
    if (!option)
      return null;
    let buf = Buffer.from(pretext, "utf8");
    if (buf.length < option.col)
      return null;
    let input = buf.slice(option.col).toString("utf8");
    if (option.blacklist && option.blacklist.includes(input))
      return null;
    return input;
  }
  get completeOpt() {
    let {noselect, enablePreview} = this.config;
    let preview = enablePreview && !workspace_default.env.pumevent ? ",preview" : "";
    if (noselect)
      return `noselect,menuone${preview}`;
    return `noinsert,menuone${preview}`;
  }
  getCompleteItem(item) {
    if (!this.complete || item == null)
      return null;
    return this.complete.resolveCompletionItem(item);
  }
  dispose() {
    disposeAll(this.disposables);
  }
};
var completion_default = new Completion();

// src/snippets/snippet.ts
var vscode_languageserver_protocol67 = __toModule(require_main3());
var logger72 = require_logger2()("snippets-snipet");
var CocSnippet = class {
  constructor(_snippetString, position15, _variableResolver) {
    this._snippetString = _snippetString;
    this.position = position15;
    this._variableResolver = _variableResolver;
    this._parser = new SnippetParser();
  }
  async init() {
    const snippet2 = this._parser.parse(this._snippetString, true);
    let {_variableResolver} = this;
    if (_variableResolver) {
      await snippet2.resolveVariables(_variableResolver);
    }
    this.tmSnippet = snippet2;
    this.update();
  }
  adjustPosition(characterCount, lineCount) {
    let {line, character} = this.position;
    this.position = {
      line: line + lineCount,
      character: character + characterCount
    };
    this.update();
  }
  adjustTextEdit(edit2) {
    let {range: range2, newText} = edit2;
    if (comparePosition(this.range.start, range2.end) < 0)
      return false;
    if (!newText.includes("\n") && comparePosition(range2.start, range2.end) == 0 && comparePosition(this.range.start, range2.start) == 0) {
      let idx = this._placeholders.findIndex((o) => comparePosition(o.range.start, range2.start) == 0);
      if (idx !== -1)
        return false;
    }
    let changed = getChangedPosition(this.range.start, edit2);
    if (changed.line == 0 && changed.character == 0)
      return true;
    this.adjustPosition(changed.character, changed.line);
    return true;
  }
  get isPlainText() {
    if (this._placeholders.length > 1)
      return false;
    return this._placeholders.every((o) => o.value == "");
  }
  get finalCount() {
    return this._placeholders.filter((o) => o.isFinalTabstop).length;
  }
  toString() {
    return this.tmSnippet.toString();
  }
  get range() {
    let {position: position15} = this;
    const content = this.tmSnippet.toString();
    const doc = TextDocument.create("untitled:/1", "snippet", 0, content);
    const pos = doc.positionAt(content.length);
    const end = pos.line == 0 ? position15.character + pos.character : pos.character;
    return vscode_languageserver_protocol67.Range.create(position15, vscode_languageserver_protocol67.Position.create(position15.line + pos.line, end));
  }
  get firstPlaceholder() {
    let index = 0;
    for (let p of this._placeholders) {
      if (p.index == 0)
        continue;
      if (index == 0 || p.index < index) {
        index = p.index;
      }
    }
    return this.getPlaceholder(index);
  }
  get lastPlaceholder() {
    let index = 0;
    for (let p of this._placeholders) {
      if (index == 0 || p.index > index) {
        index = p.index;
      }
    }
    return this.getPlaceholder(index);
  }
  getPlaceholderById(id) {
    return this._placeholders.find((o) => o.id == id);
  }
  getPlaceholder(index) {
    let placeholders = this._placeholders.filter((o) => o.index == index);
    let filtered = placeholders.filter((o) => !o.transform);
    return filtered.length ? filtered[0] : placeholders[0];
  }
  getPrevPlaceholder(index) {
    if (index == 0)
      return this.lastPlaceholder;
    let prev = this.getPlaceholder(index - 1);
    if (!prev)
      return this.getPrevPlaceholder(index - 1);
    return prev;
  }
  getNextPlaceholder(index) {
    let indexes = this._placeholders.map((o) => o.index);
    let max = Math.max.apply(null, indexes);
    if (index >= max)
      return this.finalPlaceholder;
    let next = this.getPlaceholder(index + 1);
    if (!next)
      return this.getNextPlaceholder(index + 1);
    return next;
  }
  get finalPlaceholder() {
    return this._placeholders.find((o) => o.isFinalTabstop);
  }
  getPlaceholderByRange(range2) {
    return this._placeholders.find((o) => rangeInRange(range2, o.range));
  }
  insertSnippet(placeholder, snippet2, range2) {
    let {start} = placeholder.range;
    let editStart = vscode_languageserver_protocol67.Position.create(range2.start.line - start.line, range2.start.line == start.line ? range2.start.character - start.character : range2.start.character);
    let editEnd = vscode_languageserver_protocol67.Position.create(range2.end.line - start.line, range2.end.line == start.line ? range2.end.character - start.character : range2.end.character);
    let editRange2 = vscode_languageserver_protocol67.Range.create(editStart, editEnd);
    let first = this.tmSnippet.insertSnippet(snippet2, placeholder.id, editRange2);
    this.update();
    return first;
  }
  updatePlaceholder(placeholder, edit2) {
    let {start, end} = edit2.range;
    let {range: range2} = this;
    let {value, id, index} = placeholder;
    let newText = editRange(placeholder.range, value, edit2);
    let delta = 0;
    if (!newText.includes("\n")) {
      for (let p of this._placeholders) {
        if (p.index == index && p.id < id && p.line == placeholder.range.start.line) {
          let text = this.tmSnippet.getPlaceholderText(p.id, newText);
          delta = delta + byteLength(text) - byteLength(p.value);
        }
      }
    }
    if (placeholder.isVariable) {
      this.tmSnippet.updateVariable(id, newText);
    } else {
      this.tmSnippet.updatePlaceholder(id, newText);
    }
    let endPosition = adjustPosition(range2.end, edit2);
    let snippetEdit = {
      range: vscode_languageserver_protocol67.Range.create(range2.start, endPosition),
      newText: this.tmSnippet.toString()
    };
    this.update();
    return {edits: [snippetEdit], delta};
  }
  update() {
    const snippet2 = this.tmSnippet;
    const {line, character} = this.position;
    const document3 = TextDocument.create("untitled:/1", "snippet", 0, snippet2.toString());
    const {placeholders, variables, maxIndexNumber} = snippet2;
    const variableIndexMap = new Map();
    let variableIndex = maxIndexNumber + 1;
    this._placeholders = [...placeholders, ...variables].map((p, idx) => {
      const offset = snippet2.offset(p);
      const position15 = document3.positionAt(offset);
      const start = {
        line: line + position15.line,
        character: position15.line == 0 ? character + position15.character : position15.character
      };
      let index;
      if (p instanceof Variable) {
        let key = p.name;
        if (variableIndexMap.has(key)) {
          index = variableIndexMap.get(key);
        } else {
          variableIndexMap.set(key, variableIndex);
          index = variableIndex;
          variableIndex = variableIndex + 1;
        }
      } else {
        index = p.index;
      }
      const value = p.toString();
      const lines = value.split("\n");
      let res = {
        range: vscode_languageserver_protocol67.Range.create(start, {
          line: start.line + lines.length - 1,
          character: lines.length == 1 ? start.character + value.length : lines[lines.length - 1].length
        }),
        transform: p.transform != null,
        line: start.line,
        id: idx,
        index,
        value,
        isVariable: p instanceof Variable,
        isFinalTabstop: p.index === 0
      };
      Object.defineProperty(res, "snippet", {
        enumerable: false
      });
      if (p instanceof Placeholder && p.choice) {
        let {options} = p.choice;
        if (options && options.length) {
          res.choice = options.map((o) => o.value);
        }
      }
      return res;
    });
  }
};

// src/snippets/variableResolve.ts
var clipboardy3 = __toModule(require_clipboardy());
var path58 = __toModule(require("path"));
var logger73 = require_logger2()("snippets-variable");
var SnippetVariableResolver = class {
  constructor() {
    this._variableToValue = {};
    const currentDate = new Date();
    Object.assign(this._variableToValue, {
      CURRENT_YEAR: currentDate.getFullYear().toString(),
      CURRENT_YEAR_SHORT: currentDate.getFullYear().toString().slice(-2),
      CURRENT_MONTH: (currentDate.getMonth() + 1).toString(),
      CURRENT_DATE: currentDate.getDate().toString(),
      CURRENT_HOUR: currentDate.getHours().toString(),
      CURRENT_MINUTE: currentDate.getMinutes().toString(),
      CURRENT_SECOND: currentDate.getSeconds().toString(),
      CURRENT_DAY_NAME: currentDate.toLocaleString("en-US", {weekday: "long"}),
      CURRENT_DAY_NAME_SHORT: currentDate.toLocaleString("en-US", {weekday: "short"}),
      CURRENT_MONTH_NAME: currentDate.toLocaleString("en-US", {month: "long"}),
      CURRENT_MONTH_NAME_SHORT: currentDate.toLocaleString("en-US", {month: "short"}),
      TM_FILENAME: null,
      TM_FILENAME_BASE: null,
      TM_DIRECTORY: null,
      TM_FILEPATH: null,
      YANK: null,
      TM_LINE_INDEX: null,
      TM_LINE_NUMBER: null,
      TM_CURRENT_LINE: null,
      TM_CURRENT_WORD: null,
      TM_SELECTED_TEXT: null,
      CLIPBOARD: null
    });
  }
  async resovleValue(name2) {
    let {nvim} = window_default;
    if (["TM_FILENAME", "TM_FILENAME_BASE", "TM_DIRECTORY", "TM_FILEPATH"].includes(name2)) {
      let filepath = await nvim.eval('expand("%:p")');
      if (name2 == "TM_FILENAME")
        return path58.default.basename(filepath);
      if (name2 == "TM_FILENAME_BASE")
        return path58.default.basename(filepath, path58.default.extname(filepath));
      if (name2 == "TM_DIRECTORY")
        return path58.default.dirname(filepath);
      if (name2 == "TM_FILEPATH")
        return filepath;
    }
    if (name2 == "YANK") {
      let yank = await nvim.call("getreg", ['""']);
      return yank;
    }
    if (name2 == "TM_LINE_INDEX") {
      let lnum = await nvim.call("line", ["."]);
      return (lnum - 1).toString();
    }
    if (name2 == "TM_LINE_NUMBER") {
      let lnum = await nvim.call("line", ["."]);
      return lnum.toString();
    }
    if (name2 == "TM_CURRENT_LINE") {
      let line = await nvim.call("getline", ["."]);
      return line;
    }
    if (name2 == "TM_CURRENT_WORD") {
      let word = await nvim.eval(`expand('<cword>')`);
      return word;
    }
    if (name2 == "TM_SELECTED_TEXT") {
      let text = await nvim.eval(`get(g:,'coc_selected_text', '')`);
      return text;
    }
    if (name2 == "CLIPBOARD") {
      let clipboard = "";
      try {
        clipboard = await clipboardy3.default.read();
      } catch (e) {
        logger73.error(`Error with clipboardy:`, e.message);
      }
      return clipboard;
    }
  }
  async resolve(variable) {
    const name2 = variable.name;
    let resolved = this._variableToValue[name2];
    if (resolved != null)
      return resolved.toString();
    let value = await this.resovleValue(name2);
    if (value)
      return value;
    if (variable.children && variable.children.length) {
      return variable.toString();
    }
    if (!this._variableToValue.hasOwnProperty(name2)) {
      return name2;
    }
    return "";
  }
};

// src/snippets/session.ts
var logger74 = require_logger2()("snippets-session");
var SnippetSession = class {
  constructor(nvim, bufnr) {
    this.nvim = nvim;
    this.bufnr = bufnr;
    this._isActive = false;
    this._currId = 0;
    this.applying = false;
    this.preferComplete = false;
    this._snippet = null;
    this._onCancelEvent = new vscode_languageserver_protocol68.Emitter();
    this.onCancel = this._onCancelEvent.event;
    let config = workspace_default.getConfiguration("coc.preferences");
    let suggest = workspace_default.getConfiguration("suggest");
    this.preferComplete = config.get("preferCompleteThanJumpPlaceholder", suggest.get("preferCompleteThanJumpPlaceholder", false));
  }
  async start(snippetString, select = true, range2) {
    const {document: document3} = this;
    if (!document3 || !document3.attached)
      return false;
    events_default.fire("InsertSnippet", []).logError();
    if (!range2) {
      let position16 = await window_default.getCursorPosition();
      range2 = vscode_languageserver_protocol68.Range.create(position16, position16);
    }
    let position15 = range2.start;
    const formatOptions = await workspace_default.getFormatOptions(this.document.uri);
    await document3.patchChange(true);
    const currentLine = document3.getline(position15.line);
    const currentIndent = currentLine.match(/^\s*/)[0];
    let inserted = normalizeSnippetString(snippetString, currentIndent, formatOptions);
    const resolver2 = new SnippetVariableResolver();
    const snippet2 = new CocSnippet(inserted, position15, resolver2);
    await snippet2.init();
    const edit2 = vscode_languageserver_protocol68.TextEdit.replace(range2, snippet2.toString());
    if (snippetString.endsWith("\n") && currentLine.slice(position15.character).length) {
      edit2.newText = edit2.newText + currentIndent;
      inserted = inserted + currentIndent;
    }
    this.applying = true;
    await document3.applyEdits([edit2]);
    this.applying = false;
    if (this._isActive) {
      let placeholder = this.findPlaceholder(range2);
      if (placeholder && !placeholder.isFinalTabstop) {
        let index = this.snippet.insertSnippet(placeholder, inserted, range2);
        let p = this.snippet.getPlaceholder(index);
        this._currId = p.id;
        if (select)
          await this.selectPlaceholder(p);
        return true;
      }
    }
    if (snippet2.isPlainText) {
      this.deactivate();
      let placeholder = snippet2.finalPlaceholder;
      await window_default.moveTo(placeholder.range.start);
      return false;
    }
    this._snippet = snippet2;
    this._currId = snippet2.firstPlaceholder.id;
    if (select)
      await this.selectPlaceholder(snippet2.firstPlaceholder);
    this.activate();
    return true;
  }
  activate() {
    if (this._isActive)
      return;
    this._isActive = true;
    this.nvim.call("coc#snippet#enable", [], true);
  }
  deactivate() {
    if (this._isActive) {
      this._isActive = false;
      this._snippet = null;
      this.nvim.call("coc#snippet#disable", [], true);
      logger74.debug("[SnippetManager::cancel]");
    }
    this._onCancelEvent.fire(void 0);
    this._onCancelEvent.dispose();
  }
  get isActive() {
    return this._isActive;
  }
  async nextPlaceholder() {
    if (!this.isActive)
      return;
    await this.document.patchChange();
    let curr = this.placeholder;
    let next = this.snippet.getNextPlaceholder(curr.index);
    await this.selectPlaceholder(next);
  }
  async previousPlaceholder() {
    if (!this.isActive)
      return;
    await this.document.patchChange();
    let curr = this.placeholder;
    let prev = this.snippet.getPrevPlaceholder(curr.index);
    await this.selectPlaceholder(prev);
  }
  async synchronizeUpdatedPlaceholders(change) {
    if (!this.isActive || !this.document || this.applying)
      return;
    let edit2 = {range: change.range, newText: change.text};
    let {snippet: snippet2} = this;
    let adjusted = snippet2.adjustTextEdit(edit2);
    if (adjusted)
      return;
    if (comparePosition(edit2.range.start, snippet2.range.end) > 0) {
      if (!edit2.newText)
        return;
      logger74.info("Content change after snippet, cancelling snippet session");
      this.deactivate();
      return;
    }
    let placeholder = this.findPlaceholder(edit2.range);
    if (!placeholder) {
      logger74.info("Change outside placeholder, cancelling snippet session");
      this.deactivate();
      return;
    }
    if (placeholder.isFinalTabstop && snippet2.finalCount <= 1) {
      logger74.info("Change final placeholder, cancelling snippet session");
      this.deactivate();
      return;
    }
    this._currId = placeholder.id;
    let {edits, delta} = snippet2.updatePlaceholder(placeholder, edit2);
    if (!edits.length)
      return;
    this.applying = true;
    await this.document.applyEdits(edits);
    this.applying = false;
    if (delta) {
      await this.nvim.call("coc#util#move_cursor", delta);
    }
  }
  async selectCurrentPlaceholder(triggerAutocmd = true) {
    let placeholder = this.snippet.getPlaceholderById(this._currId);
    if (placeholder)
      await this.selectPlaceholder(placeholder, triggerAutocmd);
  }
  async selectPlaceholder(placeholder, triggerAutocmd = true) {
    let {nvim, document: document3} = this;
    if (!document3 || !placeholder)
      return;
    let {start, end} = placeholder.range;
    const len = end.character - start.character;
    const col = byteLength(document3.getline(start.line).slice(0, start.character)) + 1;
    this._currId = placeholder.id;
    if (placeholder.choice) {
      await nvim.call("coc#snippet#show_choices", [start.line + 1, col, len, placeholder.choice]);
      if (triggerAutocmd)
        nvim.call("coc#util#do_autocmd", ["CocJumpPlaceholder"], true);
    } else {
      await this.select(placeholder, triggerAutocmd);
    }
  }
  async select(placeholder, triggerAutocmd = true) {
    let {range: range2, value, isFinalTabstop} = placeholder;
    let {document: document3, nvim} = this;
    let {start, end} = range2;
    let {textDocument} = document3;
    let len = textDocument.offsetAt(end) - textDocument.offsetAt(start);
    let line = document3.getline(start.line);
    let col = line ? byteLength(line.slice(0, start.character)) : 0;
    let endLine = document3.getline(end.line);
    let endCol = endLine ? byteLength(endLine.slice(0, end.character)) : 0;
    nvim.setVar("coc_last_placeholder", {
      current_text: value,
      start: {line: start.line, col},
      end: {line: end.line, col: endCol}
    }, true);
    let [ve, selection, pumvisible, mode] = await nvim.eval("[&virtualedit, &selection, pumvisible(), mode()]");
    let move_cmd = "";
    if (pumvisible && this.preferComplete) {
      let pre = completion_default.hasSelected() ? "" : "\\<C-n>";
      await nvim.eval(`feedkeys("${pre}\\<C-y>", 'in')`);
      return;
    }
    if (mode != "n")
      move_cmd += "\\<Esc>";
    if (len == 0) {
      if (col == 0 || !mode.startsWith("i") && col < byteLength(line)) {
        move_cmd += "i";
      } else {
        move_cmd += "a";
      }
    } else {
      move_cmd += "v";
      endCol = await this.getVirtualCol(end.line + 1, endCol);
      if (selection == "inclusive") {
        if (end.character == 0) {
          move_cmd += `${end.line}G`;
        } else {
          move_cmd += `${end.line + 1}G${endCol}|`;
        }
      } else if (selection == "old") {
        move_cmd += `${end.line + 1}G${endCol}|`;
      } else {
        move_cmd += `${end.line + 1}G${endCol + 1}|`;
      }
      col = await this.getVirtualCol(start.line + 1, col);
      move_cmd += `o${start.line + 1}G${col + 1}|o\\<c-g>`;
    }
    if (mode == "i" && move_cmd == "\\<Esc>a") {
      move_cmd = "";
    }
    nvim.pauseNotification();
    nvim.setOption("virtualedit", "onemore", true);
    nvim.call("cursor", [start.line + 1, col + (move_cmd == "a" ? 0 : 1)], true);
    if (move_cmd) {
      nvim.call("eval", [`feedkeys("${move_cmd}", 'in')`], true);
    }
    if (mode == "i") {
      nvim.call("coc#_cancel", [], true);
    }
    nvim.setOption("virtualedit", ve, true);
    if (isFinalTabstop) {
      if (this.snippet.finalCount == 1) {
        logger74.info("Jump to final placeholder, cancelling snippet session");
        this.deactivate();
      } else {
        nvim.call("coc#snippet#disable", [], true);
      }
    }
    if (workspace_default.env.isVim)
      nvim.command("redraw", true);
    await nvim.resumeNotification();
    if (triggerAutocmd)
      nvim.call("coc#util#do_autocmd", ["CocJumpPlaceholder"], true);
  }
  async getVirtualCol(line, col) {
    let {nvim} = this;
    return await nvim.eval(`virtcol([${line}, ${col}])`);
  }
  async checkPosition() {
    if (!this.isActive)
      return;
    let position15 = await window_default.getCursorPosition();
    if (this.snippet && positionInRange(position15, this.snippet.range) != 0) {
      logger74.info("Cursor insert out of range, cancelling snippet session");
      this.deactivate();
    }
  }
  findPlaceholder(range2) {
    if (!this.snippet)
      return null;
    let {placeholder} = this;
    if (placeholder && rangeInRange(range2, placeholder.range))
      return placeholder;
    return this.snippet.getPlaceholderByRange(range2) || null;
  }
  get placeholder() {
    if (!this.snippet)
      return null;
    return this.snippet.getPlaceholderById(this._currId);
  }
  get snippet() {
    return this._snippet;
  }
  get document() {
    return workspace_default.getDocument(this.bufnr);
  }
};
function normalizeSnippetString(snippet2, indent, opts) {
  let lines = snippet2.split(/\r?\n/);
  let ind = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
  let tabSize = opts.tabSize || 2;
  lines = lines.map((line, idx) => {
    let space = line.match(/^\s*/)[0];
    let pre = space;
    let isTab = space.startsWith("	");
    if (isTab && opts.insertSpaces) {
      pre = ind.repeat(space.length);
    } else if (!isTab && !opts.insertSpaces) {
      pre = ind.repeat(space.length / tabSize);
    }
    return (idx == 0 || line.length == 0 ? "" : indent) + pre + line.slice(space.length);
  });
  return lines.join("\n");
}

// src/snippets/manager.ts
var logger75 = require_logger2()("snippets-manager");
var SnippetManager = class {
  constructor() {
    this.sessionMap = new Map();
    this.disposables = [];
    workspace_default.onDidChangeTextDocument(async (e) => {
      let session4 = this.getSession(e.bufnr);
      if (session4) {
        await session4.synchronizeUpdatedPlaceholders(e.contentChanges[0]);
      }
    }, null, this.disposables);
    workspace_default.onDidCloseTextDocument((textDocument) => {
      let doc = workspace_default.getDocument(textDocument.uri);
      if (!doc)
        return;
      let session4 = this.getSession(doc.bufnr);
      if (session4)
        session4.deactivate();
    }, null, this.disposables);
    events_default.on("BufEnter", async (bufnr) => {
      let session4 = this.getSession(bufnr);
      if (!this.statusItem)
        return;
      if (session4 && session4.isActive) {
        this.statusItem.show();
      } else {
        this.statusItem.hide();
      }
    }, null, this.disposables);
    events_default.on("InsertEnter", async () => {
      let {session: session4} = this;
      if (!session4)
        return;
      await session4.checkPosition();
    }, null, this.disposables);
  }
  init() {
    let config = workspace_default.getConfiguration("coc.preferences");
    this.statusItem = window_default.createStatusBarItem(0);
    this.statusItem.text = config.get("snippetStatusText", "SNIP");
  }
  async insertSnippet(snippet2, select = true, range2) {
    let {bufnr} = workspace_default;
    let session4 = this.getSession(bufnr);
    if (!session4) {
      session4 = new SnippetSession(workspace_default.nvim, bufnr);
      this.sessionMap.set(bufnr, session4);
      session4.onCancel(() => {
        this.sessionMap.delete(bufnr);
        if (workspace_default.bufnr == bufnr) {
          this.statusItem.hide();
        }
      });
    }
    let isActive = await session4.start(snippet2, select, range2);
    if (isActive)
      this.statusItem.show();
    return isActive;
  }
  async selectCurrentPlaceholder(triggerAutocmd = true) {
    let {session: session4} = this;
    if (session4)
      return await session4.selectCurrentPlaceholder(triggerAutocmd);
  }
  async nextPlaceholder() {
    let {session: session4} = this;
    if (session4)
      return await session4.nextPlaceholder();
    workspace_default.nvim.call("coc#snippet#disable", [], true);
    this.statusItem.hide();
  }
  async previousPlaceholder() {
    let {session: session4} = this;
    if (session4)
      return await session4.previousPlaceholder();
    workspace_default.nvim.call("coc#snippet#disable", [], true);
    this.statusItem.hide();
  }
  cancel() {
    let session4 = this.getSession(workspace_default.bufnr);
    if (session4)
      return session4.deactivate();
    workspace_default.nvim.call("coc#snippet#disable", [], true);
    if (this.statusItem)
      this.statusItem.hide();
  }
  get session() {
    let session4 = this.getSession(workspace_default.bufnr);
    return session4 && session4.isActive ? session4 : null;
  }
  isActived(bufnr) {
    let session4 = this.getSession(bufnr);
    return session4 && session4.isActive;
  }
  jumpable() {
    let {session: session4} = this;
    if (!session4)
      return false;
    let placeholder = session4.placeholder;
    if (placeholder && !placeholder.isFinalTabstop) {
      return true;
    }
    return false;
  }
  getSession(bufnr) {
    return this.sessionMap.get(bufnr);
  }
  async resolveSnippet(body) {
    let parser4 = new SnippetParser();
    const snippet2 = parser4.parse(body, true);
    const resolver2 = new SnippetVariableResolver();
    await snippet2.resolveVariables(resolver2);
    return snippet2;
  }
  dispose() {
    this.cancel();
    for (let d of this.disposables) {
      d.dispose();
    }
  }
};
var manager_default3 = new SnippetManager();

// src/commands.ts
var logger76 = require_logger2()("commands");
var CommandItem = class {
  constructor(id, impl, thisArg, internal = false) {
    this.id = id;
    this.impl = impl;
    this.thisArg = thisArg;
    this.internal = internal;
  }
  execute(...args) {
    let {impl, thisArg} = this;
    return impl.apply(thisArg, args || []);
  }
  dispose() {
    this.thisArg = null;
    this.impl = null;
  }
};
var CommandManager = class {
  constructor() {
    this.commands = new Map();
    this.titles = new Map();
  }
  init(nvim, plugin) {
    this.mru = workspace_default.createMru("commands");
    this.register({
      id: "vscode.open",
      execute: async (url2) => {
        nvim.call("coc#util#open_url", url2.toString(), true);
      }
    }, true);
    this.register({
      id: "workbench.action.reloadWindow",
      execute: async () => {
        await nvim.command("edit");
      }
    }, true);
    this.register({
      id: "editor.action.insertSnippet",
      execute: async (edit2) => {
        nvim.call("coc#_cancel", [], true);
        return await manager_default3.insertSnippet(edit2.newText, true, edit2.range);
      }
    }, true);
    this.register({
      id: "editor.action.doCodeAction",
      execute: async (action) => {
        await plugin.cocAction("doCodeAction", action);
      }
    }, true);
    this.register({
      id: "editor.action.triggerSuggest",
      execute: async () => {
        await wait(60);
        nvim.call("coc#start", [], true);
      }
    }, true);
    this.register({
      id: "editor.action.triggerParameterHints",
      execute: async () => {
        await wait(60);
        await plugin.cocAction("showSignatureHelp");
      }
    }, true);
    this.register({
      id: "editor.action.addRanges",
      execute: async (ranges) => {
        await plugin.cocAction("addRanges", ranges);
      }
    }, true);
    this.register({
      id: "editor.action.restart",
      execute: async () => {
        await wait(30);
        nvim.command("CocRestart", true);
      }
    }, true);
    this.register({
      id: "editor.action.showReferences",
      execute: async (_filepath, _position, references) => {
        await workspace_default.showLocations(references);
      }
    }, true);
    this.register({
      id: "editor.action.rename",
      execute: async (uri, position15) => {
        await workspace_default.jumpTo(uri, position15);
        await plugin.cocAction("rename");
      }
    }, true);
    this.register({
      id: "editor.action.format",
      execute: async () => {
        await plugin.cocAction("format");
      }
    }, true);
    this.register({
      id: "workspace.diffDocument",
      execute: async () => {
        let document3 = await workspace_default.document;
        if (!document3)
          return;
        await nvim.call("coc#util#diff_content", [document3.getLines()]);
      }
    });
    this.register({
      id: "workspace.clearWatchman",
      execute: async () => {
        let res = await window_default.runTerminalCommand("watchman watch-del-all");
        if (res.success)
          window_default.showMessage("Cleared watchman watching directories.");
      }
    }, false, "run watch-del-all for watchman to free up memory.");
    this.register({
      id: "workspace.workspaceFolders",
      execute: async () => {
        let folders2 = workspace_default.workspaceFolders;
        let lines = folders2.map((folder) => URI.parse(folder.uri).fsPath);
        await window_default.echoLines(lines);
      }
    }, false, "show opened workspaceFolders.");
    this.register({
      id: "workspace.renameCurrentFile",
      execute: async () => {
        await workspace_default.renameCurrent();
      }
    }, false, "change current filename to a new name and reload it.");
    this.register({
      id: "extensions.toggleAutoUpdate",
      execute: async () => {
        let config = workspace_default.getConfiguration("coc.preferences");
        let interval = config.get("extensionUpdateCheck", "daily");
        if (interval == "never") {
          config.update("extensionUpdateCheck", "daily", true);
          window_default.showMessage("Extension auto update enabled.", "more");
        } else {
          config.update("extensionUpdateCheck", "never", true);
          window_default.showMessage("Extension auto update disabled.", "more");
        }
      }
    }, false, "toggle auto update of extensions.");
    this.register({
      id: "workspace.diagnosticRelated",
      execute: () => manager_default.jumpRelated()
    }, false, "jump to related locations of current diagnostic.");
    this.register({
      id: "workspace.showOutput",
      execute: async (name2) => {
        if (name2) {
          window_default.showOutputChannel(name2);
        } else {
          let names = workspace_default.channelNames;
          if (names.length == 0)
            return;
          if (names.length == 1) {
            window_default.showOutputChannel(names[0]);
          } else {
            let idx = await window_default.showQuickpick(names);
            if (idx == -1)
              return;
            let name3 = names[idx];
            window_default.showOutputChannel(name3);
          }
        }
      }
    }, false, "open output buffer to show output from languageservers or extensions.");
    this.register({
      id: "document.echoFiletype",
      execute: async () => {
        let bufnr = await nvim.call("bufnr", "%");
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return;
        await window_default.echoLines([doc.filetype]);
      }
    }, false, "echo the mapped filetype of the current buffer");
    this.register({
      id: "document.renameCurrentWord",
      execute: async () => {
        let bufnr = await nvim.call("bufnr", "%");
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return;
        let edit2 = await plugin.cocAction("getWordEdit");
        if (!edit2) {
          window_default.showMessage("Invalid position", "warning");
          return;
        }
        let ranges = [];
        let {changes, documentChanges} = edit2;
        if (changes) {
          let edits = changes[doc.uri];
          if (edits)
            ranges = edits.map((e) => e.range);
        } else if (documentChanges) {
          for (let c of documentChanges) {
            if (vscode_languageserver_protocol69.TextDocumentEdit.is(c) && c.textDocument.uri == doc.uri) {
              ranges = c.edits.map((e) => e.range);
            }
          }
        }
        if (ranges.length) {
          await plugin.cocAction("addRanges", ranges);
        }
      }
    }, false, "rename word under cursor in current buffer by use multiple cursors.");
    this.register({
      id: "document.jumpToNextSymbol",
      execute: async () => {
        let doc = await workspace_default.document;
        if (!doc)
          return;
        let ranges = await plugin.cocAction("symbolRanges");
        if (!ranges)
          return;
        let {textDocument} = doc;
        let offset = await window_default.getOffset();
        ranges.sort((a, b) => {
          if (a.start.line != b.start.line) {
            return a.start.line - b.start.line;
          }
          return a.start.character - b.start.character;
        });
        for (let i = 0; i <= ranges.length - 1; i++) {
          if (textDocument.offsetAt(ranges[i].start) > offset) {
            await window_default.moveTo(ranges[i].start);
            return;
          }
        }
        await window_default.moveTo(ranges[0].start);
      }
    }, false, "Jump to next symbol highlight position.");
    this.register({
      id: "document.jumpToPrevSymbol",
      execute: async () => {
        let doc = await workspace_default.document;
        if (!doc)
          return;
        let ranges = await plugin.cocAction("symbolRanges");
        if (!ranges)
          return;
        let {textDocument} = doc;
        let offset = await window_default.getOffset();
        ranges.sort((a, b) => {
          if (a.start.line != b.start.line) {
            return a.start.line - b.start.line;
          }
          return a.start.character - b.start.character;
        });
        for (let i = ranges.length - 1; i >= 0; i--) {
          if (textDocument.offsetAt(ranges[i].end) < offset) {
            await window_default.moveTo(ranges[i].start);
            return;
          }
        }
        await window_default.moveTo(ranges[ranges.length - 1].start);
      }
    }, false, "Jump to previous symbol highlight position.");
  }
  get commandList() {
    let res = [];
    for (let item of this.commands.values()) {
      if (!item.internal)
        res.push(item);
    }
    return res;
  }
  dispose() {
    for (const registration of this.commands.values()) {
      registration.dispose();
    }
    this.commands.clear();
  }
  execute(command) {
    let args = [command.command];
    let arr = command.arguments;
    if (arr)
      args.push(...arr);
    this.executeCommand.apply(this, args);
  }
  register(command, internal = false, description) {
    for (const id of Array.isArray(command.id) ? command.id : [command.id]) {
      this.registerCommand(id, command.execute, command, internal);
      if (description)
        this.titles.set(id, description);
    }
    return command;
  }
  has(id) {
    return this.commands.has(id);
  }
  unregister(id) {
    let item = this.commands.get(id);
    if (!item)
      return;
    item.dispose();
    this.commands.delete(id);
  }
  registerCommand(id, impl, thisArg, internal = false) {
    if (id.startsWith("_"))
      internal = true;
    this.commands.set(id, new CommandItem(id, impl, thisArg, internal));
    return vscode_languageserver_protocol69.Disposable.create(() => {
      this.commands.delete(id);
    });
  }
  executeCommand(command, ...rest) {
    let cmd = this.commands.get(command);
    if (!cmd) {
      window_default.showMessage(`Command: ${command} not found`, "error");
      return;
    }
    return Promise.resolve(cmd.execute.apply(cmd, rest)).catch((e) => {
      window_default.showMessage(`Command error: ${e.message}`, "error");
      logger76.error(e.stack);
    });
  }
  async addRecent(cmd) {
    await this.mru.add(cmd);
    await workspace_default.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
  }
  async repeatCommand() {
    let mruList = await this.mru.load();
    let first = mruList[0];
    if (first) {
      await this.executeCommand(first);
      await workspace_default.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
    }
  }
};
var commands_default = new CommandManager();

// src/cursors/index.ts
var vscode_languageserver_types6 = __toModule(require_main2());

// src/cursors/session.ts
var fast_diff4 = __toModule(require_diff2());
var vscode_languageserver_protocol71 = __toModule(require_main3());

// src/cursors/range.ts
var vscode_languageserver_types5 = __toModule(require_main2());
var logger77 = require_logger2()("cursors-range");
var TextRange = class {
  constructor(line, start, end, text, preCount) {
    this.line = line;
    this.start = start;
    this.end = end;
    this.text = text;
    this.preCount = preCount;
    this.currStart = start;
    this.currEnd = end;
  }
  add(offset, add) {
    let {text, preCount} = this;
    let pre = offset == 0 ? "" : text.slice(0, offset);
    let post = text.slice(offset);
    this.text = `${pre}${add}${post}`;
    this.currStart = this.currStart + preCount * add.length;
    this.currEnd = this.currEnd + (preCount + 1) * add.length;
  }
  replace(begin, end, add = "") {
    let {text, preCount} = this;
    let pre = begin == 0 ? "" : text.slice(0, begin);
    let post = text.slice(end);
    this.text = pre + add + post;
    let l = end - begin - add.length;
    this.currStart = this.currStart - preCount * l;
    this.currEnd = this.currEnd - (preCount + 1) * l;
  }
  get range() {
    return vscode_languageserver_types5.Range.create(this.line, this.start, this.line, this.end);
  }
  get currRange() {
    return vscode_languageserver_types5.Range.create(this.line, this.currStart, this.line, this.currEnd);
  }
  applyEdit(edit2) {
    let {range: range2, newText} = edit2;
    let start = range2.start.character;
    let end = range2.end.character;
    let isAdd = start == end;
    if (isAdd) {
      this.add(start - this.currStart, newText);
    } else {
      this.replace(start - this.currStart, end - this.currStart, newText);
    }
  }
  adjustFromEdit(edit2) {
    let {range: range2, newText} = edit2;
    if (comparePosition(range2.start, vscode_languageserver_types5.Position.create(this.line, this.currEnd)) > 0) {
      return;
    }
    let newLines = newText.split("\n");
    let changeCount = newLines.length - (range2.end.line - range2.start.line + 1);
    this.line = this.line + changeCount;
    if (range2.end.line == this.line) {
      let remove = range2.start.line == range2.end.line ? range2.end.character - range2.start.character : range2.end.character;
      if (newLines.length > 1 && range2.start.line == range2.end.line) {
        remove = remove + range2.start.character;
      }
      let add = 0;
      if (newLines.length > 1) {
        add = newLines[newLines.length - 1].length;
      } else {
        if (range2.start.line == range2.end.line) {
          add = newText.length;
        } else {
          add = range2.start.character + newText.length;
        }
      }
      let delta = add - remove;
      for (let key of ["start", "end", "currStart", "currEnd"]) {
        this[key] += delta;
      }
    }
  }
  sync() {
    this.start = this.currStart;
    this.end = this.currEnd;
  }
  get textEdit() {
    return {
      range: this.range,
      newText: this.text
    };
  }
};
var range_default = TextRange;

// src/cursors/util.ts
var vscode_languageserver_protocol70 = __toModule(require_main3());
function splitRange(doc, range2) {
  let splited = [];
  for (let i = range2.start.line; i <= range2.end.line; i++) {
    let curr = doc.getline(i) || "";
    let sc = i == range2.start.line ? range2.start.character : 0;
    let ec = i == range2.end.line ? range2.end.character : curr.length;
    if (sc == ec)
      continue;
    splited.push(vscode_languageserver_protocol70.Range.create(i, sc, i, ec));
  }
  return splited;
}
function getVisualRanges(doc, range2) {
  let {start, end} = range2;
  if (start.line > end.line) {
    [start, end] = [end, start];
  }
  let sc = start.character < end.character ? start.character : end.character;
  let ec = start.character < end.character ? end.character : start.character;
  let ranges = [];
  for (let i = start.line; i <= end.line; i++) {
    let line = doc.getline(i);
    ranges.push(vscode_languageserver_protocol70.Range.create(i, sc, i, Math.min(line.length, ec)));
  }
  return ranges;
}
function adjustPosition2(position15, delta) {
  let {line, character} = delta;
  return vscode_languageserver_protocol70.Position.create(position15.line + line, line == 0 ? position15.character + character : character);
}
function equalEdit(one, two) {
  if (one.newText.length != two.newText.length)
    return false;
  let {range: range2} = one;
  if (range2.end.character - range2.start.character != two.range.end.character - two.range.start.character) {
    return false;
  }
  return true;
}

// src/cursors/session.ts
var logger78 = require_logger2()("cursors-session");
var CursorSession = class {
  constructor(nvim, doc, config) {
    this.nvim = nvim;
    this.doc = doc;
    this.config = config;
    this._onDidCancel = new vscode_languageserver_protocol71.Emitter();
    this.onDidCancel = this._onDidCancel.event;
    this.disposables = [];
    this.ranges = [];
    this.activated = true;
    this.changing = false;
    this.changed = false;
    this.doc.forceSync();
    this.textDocument = this.doc.textDocument;
    this.buffer.setVar("coc_cursors_activated", 1, true);
    let {cancelKey, nextKey, previousKey} = this.config;
    this.disposables.push(workspace_default.registerLocalKeymap("n", cancelKey, () => {
      this.cancel();
    }, true));
    this.disposables.push(workspace_default.registerLocalKeymap("n", nextKey, async () => {
      if (!this.activated)
        return;
      let ranges = this.ranges.map((o) => o.currRange);
      let curr = await window_default.getCursorPosition();
      for (let r of ranges) {
        if (comparePosition(r.start, curr) > 0) {
          await window_default.moveTo(r.start);
          return;
        }
      }
      if (ranges.length)
        await window_default.moveTo(ranges[0].start);
    }, true));
    this.disposables.push(workspace_default.registerLocalKeymap("n", previousKey, async () => {
      if (!this.activated)
        return;
      let ranges = this.ranges.map((o) => o.currRange);
      ranges.reverse();
      let curr = await window_default.getCursorPosition();
      for (let r of ranges) {
        if (comparePosition(r.end, curr) < 0) {
          await window_default.moveTo(r.start);
          return;
        }
      }
      if (ranges.length)
        await window_default.moveTo(ranges[ranges.length - 1].start);
    }, true));
    this.doc.onDocumentChange(this.onChange, this, this.disposables);
  }
  async onChange(e) {
    if (!this.activated || this.ranges.length == 0)
      return;
    if (this.changing)
      return;
    let change = e.contentChanges[0];
    let {text, range: range2} = change;
    let intersect2 = this.ranges.some((r) => rangeIntersect(range2, r.currRange));
    let begin = this.ranges[0].currRange.start;
    if (text.endsWith("\n") && comparePosition(begin, range2.end) == 0) {
      intersect2 = false;
    }
    if (!intersect2) {
      this.ranges.forEach((r) => {
        r.adjustFromEdit({range: range2, newText: text});
      });
      this.doHighlights();
      this.textDocument = this.doc.textDocument;
      return;
    }
    this.changed = true;
    let textRange = this.getTextRange(range2, text);
    if (textRange) {
      await this.applySingleEdit(textRange, {range: range2, newText: text});
    } else {
      this.applyComposedEdit(e.original, {range: range2, newText: text});
      if (this.activated) {
        this.ranges.forEach((r) => {
          r.sync();
        });
        this.textDocument = this.doc.textDocument;
      }
    }
  }
  doHighlights() {
    let {nvim, buffer: buffer4, ranges} = this;
    buffer4.clearNamespace("cursors");
    let arr = ranges.map((o) => o.currRange);
    buffer4.highlightRanges("cursors", "CocCursorRange", arr);
    nvim.command("redraw", true);
  }
  addRanges(ranges) {
    let {nvim, doc} = this;
    if (this.changed) {
      window_default.showMessage(`Can't add ranges after range change.`);
      return false;
    }
    this.ranges = this.ranges.filter((r) => {
      let {currRange} = r;
      return !ranges.some((range2) => rangeOverlap(range2, currRange));
    });
    let {textDocument} = doc;
    for (let range2 of ranges) {
      let {line} = range2.start;
      let textRange = new range_default(line, range2.start.character, range2.end.character, textDocument.getText(range2), 0);
      this.ranges.push(textRange);
    }
    this.ranges.sort((a, b) => comparePosition(a.range.start, b.range.start));
    let preCount = 0;
    let currline = -1;
    for (let range2 of this.ranges) {
      let {line} = range2;
      if (line != currline) {
        preCount = 0;
      }
      range2.preCount = preCount;
      preCount = preCount + 1;
      currline = line;
    }
    nvim.pauseNotification();
    this.doHighlights();
    nvim.resumeNotification(false, true);
    return true;
  }
  cancel() {
    if (!this.activated)
      return;
    let {nvim} = this;
    this.activated = false;
    let {cancelKey, nextKey, previousKey} = this.config;
    nvim.pauseNotification();
    this.buffer.clearNamespace("cursors");
    this.buffer.setVar("coc_cursors_activated", 0, true);
    nvim.command("redraw", true);
    nvim.resumeNotification(false, true);
    this._onDidCancel.fire();
  }
  dispose() {
    if (!this.doc)
      return;
    this._onDidCancel.dispose();
    for (let disposable of this.disposables) {
      disposable.dispose();
    }
    this.ranges = [];
    this.doc = null;
    this.textDocument = null;
  }
  get buffer() {
    return this.nvim.createBuffer(this.doc.bufnr);
  }
  getTextRange(range2, text) {
    let {ranges} = this;
    if (text.indexOf("\n") !== -1 || range2.start.line != range2.end.line) {
      return null;
    }
    ranges.sort((a, b) => {
      if (a.line != b.line)
        return a.line - b.line;
      return a.currRange.start.character - b.currRange.start.character;
    });
    for (let i = 0; i < ranges.length; i++) {
      let r = ranges[i];
      if (rangeInRange(range2, r.currRange)) {
        return r;
      }
      if (r.line != range2.start.line) {
        continue;
      }
      if (text.length && range2.start.character == r.currRange.end.character) {
        let next = ranges[i + 1];
        if (!next)
          return r;
        return positionInRange(next.currRange.start, range2) ? null : r;
      }
    }
    return null;
  }
  adjustRanges(textRange, range2, text) {
    let {ranges} = this;
    if (range2.start.character == range2.end.character) {
      let isEnd = textRange.currRange.end.character == range2.start.character;
      if (isEnd) {
        ranges.forEach((r) => {
          r.add(r.text.length, text);
        });
      } else {
        let d = range2.start.character - textRange.currRange.start.character;
        ranges.forEach((r) => {
          r.add(Math.min(r.text.length, d), text);
        });
      }
    } else {
      let d = range2.end.character - range2.start.character;
      let isEnd = textRange.currRange.end.character == range2.end.character;
      if (isEnd) {
        if (textRange.currRange.start.character == range2.start.character) {
          if (text.includes(textRange.text)) {
            let idx = text.indexOf(textRange.text);
            let pre = idx == 0 ? "" : text.slice(0, idx);
            let post = text.slice(idx + textRange.text.length);
            if (pre)
              ranges.forEach((r) => r.add(0, pre));
            if (post)
              ranges.forEach((r) => r.add(r.text.length, post));
          } else if (textRange.text.includes(text)) {
            let idx = textRange.text.indexOf(text);
            let offset = textRange.text.length - (idx + text.length);
            if (idx != 0)
              ranges.forEach((r) => r.replace(0, idx));
            if (offset > 0)
              ranges.forEach((r) => r.replace(r.text.length - offset, r.text.length));
          } else {
            this.cancel();
          }
        } else {
          ranges.forEach((r) => {
            let l = r.text.length;
            r.replace(Math.max(0, l - d), l, text);
          });
        }
      } else {
        let start = range2.start.character - textRange.currRange.start.character;
        ranges.forEach((r) => {
          let l = r.text.length;
          r.replace(start, Math.min(start + d, l), text);
        });
      }
    }
  }
  addRange(range2, text) {
    if (this.changed) {
      window_default.showMessage(`Can't add range after range change.`);
      return;
    }
    let {ranges} = this;
    let idx = ranges.findIndex((o) => rangeIntersect(o.range, range2));
    if (idx !== -1) {
      ranges.splice(idx, 1);
      for (let r of ranges) {
        if (r.line == range2.start.line && r.start > range2.start.character) {
          r.preCount = r.preCount - 1;
        }
      }
    } else {
      let preCount = 0;
      let idx2 = 0;
      let {line} = range2.start;
      for (let r of ranges) {
        if (r.line > line || r.line == line && r.start > range2.end.character) {
          break;
        }
        if (r.line == line)
          preCount++;
        idx2++;
      }
      let created = new range_default(line, range2.start.character, range2.end.character, text, preCount);
      ranges.splice(idx2, 0, created);
      for (let r of ranges) {
        if (r.line == range2.start.line && r.start > range2.start.character) {
          r.preCount = r.preCount + 1;
        }
      }
    }
    if (this.ranges.length == 0) {
      this.cancel();
    } else {
      this.doHighlights();
    }
  }
  async applySingleEdit(textRange, edit2) {
    let {range: range2, newText} = edit2;
    let {doc} = this;
    this.adjustRanges(textRange, range2, newText);
    if (this.ranges.length == 1) {
      this.doHighlights();
      return;
    }
    let edits = this.ranges.map((o) => o.textEdit);
    let content = TextDocument.applyEdits(this.textDocument, edits);
    let newLines = content.split("\n");
    let changedLnum = new Set();
    let arr = [];
    for (let r of this.ranges) {
      if (!changedLnum.has(r.line)) {
        changedLnum.add(r.line);
        arr.push([r.line, newLines[r.line]]);
      }
    }
    let {nvim} = this;
    this.changing = true;
    await doc.changeLines(arr);
    this.changing = false;
    if (this.activated) {
      this.ranges.forEach((r) => {
        r.sync();
      });
      this.textDocument = this.doc.textDocument;
    }
    nvim.pauseNotification();
    let {cursor} = events_default;
    if (textRange.preCount > 0 && cursor.bufnr == doc.bufnr && textRange.line + 1 == cursor.lnum) {
      let changed = textRange.preCount * (newText.length - (range2.end.character - range2.start.character));
      nvim.call("cursor", [cursor.lnum, cursor.col + changed], true);
    }
    this.doHighlights();
    nvim.resumeNotification(false, true);
  }
  applyComposedEdit(original, edit2) {
    let {range: range2, newText} = edit2;
    let {ranges} = this;
    let doc = TextDocument.create("file:///1", "", 0, original);
    let edits = [];
    let diffs = fast_diff4.default(original, newText);
    let offset = 0;
    for (let i = 0; i < diffs.length; i++) {
      let diff3 = diffs[i];
      let pos = adjustPosition2(range2.start, doc.positionAt(offset));
      if (diff3[0] == fast_diff4.default.EQUAL) {
        offset = offset + diff3[1].length;
      } else if (diff3[0] == fast_diff4.default.DELETE) {
        let end = adjustPosition2(range2.start, doc.positionAt(offset + diff3[1].length));
        if (diffs[i + 1] && diffs[i + 1][0] == fast_diff4.default.INSERT) {
          edits.push({range: vscode_languageserver_protocol71.Range.create(pos, end), newText: diffs[i + 1][1]});
          i = i + 1;
        } else {
          edits.push({range: vscode_languageserver_protocol71.Range.create(pos, end), newText: ""});
        }
        offset = offset + diff3[1].length;
      } else if (diff3[0] == fast_diff4.default.INSERT) {
        edits.push({range: vscode_languageserver_protocol71.Range.create(pos, pos), newText: diff3[1]});
      }
    }
    if (edits.some((edit3) => edit3.newText.includes("\n") || edit3.range.start.line != edit3.range.end.line)) {
      this.cancel();
      return;
    }
    if (edits.length == ranges.length) {
      let last;
      for (let i = 0; i < edits.length; i++) {
        let edit3 = edits[i];
        let textRange = this.ranges[i];
        if (!rangeIntersect(textRange.currRange, edit3.range)) {
          this.cancel();
          return;
        }
        if (last && !equalEdit(edit3, last)) {
          this.cancel();
          return;
        }
        textRange.applyEdit(edit3);
        last = edit3;
      }
    } else if (edits.length == ranges.length * 2) {
      for (let i = 0; i < edits.length - 1; i = i + 2) {
        let edit3 = edits[i];
        let next = edits[i + 1];
        if (edit3.newText.length == 0 && next.newText.length == 0) {
          let textRange = this.ranges[i / 2];
          if (comparePosition(textRange.currRange.end, next.range.end) != 0) {
            this.cancel();
            return;
          }
          let start = edit3.range.start.character - textRange.currRange.start.character;
          textRange.replace(start, edit3.range.end.character - edit3.range.start.character, "");
          let offset2 = next.range.end.character - next.range.start.character;
          let len = textRange.text.length;
          textRange.replace(len - offset2, len);
        } else if (emptyRange(edit3.range) && emptyRange(next.range)) {
          let textRange = this.ranges[i / 2];
          if (comparePosition(textRange.currRange.end, next.range.start) != 0) {
            this.cancel();
            return;
          }
          let start = edit3.range.start.character - textRange.currRange.start.character;
          textRange.add(start, edit3.newText);
          let len = textRange.text.length;
          textRange.add(len, next.newText);
        } else {
          this.cancel();
          return;
        }
      }
    } else {
      this.cancel();
      return;
    }
    this.doHighlights();
  }
};
var session_default2 = CursorSession;

// src/cursors/index.ts
var logger79 = require_logger2()("cursors");
var Cursors = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.sessionsMap = new Map();
    this.disposables = [];
    this.loadConfig();
    workspace_default.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("cursors")) {
        this.loadConfig();
      }
    }, null, this.disposables);
    events_default.on("BufUnload", (bufnr) => {
      let session4 = this.getSession(bufnr);
      if (!session4)
        return;
      session4.dispose();
      this.sessionsMap.delete(bufnr);
    }, null, this.disposables);
  }
  loadConfig() {
    let config = workspace_default.getConfiguration("cursors");
    this.config = {
      nextKey: config.get("nextKey", "<C-n>"),
      previousKey: config.get("previousKey", "<C-p>"),
      cancelKey: config.get("cancelKey", "<esc>")
    };
  }
  getSession(bufnr) {
    return this.sessionsMap.get(bufnr);
  }
  async isActivated() {
    let bufnr = await this.nvim.call("bufnr", ["%"]);
    return this.sessionsMap.get(bufnr) != null;
  }
  async select(bufnr, kind, mode) {
    let doc = workspace_default.getDocument(bufnr);
    if (!doc || !doc.attached) {
      window_default.showMessage(`buffer ${bufnr} not attached.`);
      return;
    }
    let {nvim} = this;
    let session4 = this.createSession(doc);
    let pos = await window_default.getCursorPosition();
    let range2;
    if (kind == "operator") {
      await nvim.command(`normal! ${mode == "line" ? `'[` : "`["}`);
      let start = await window_default.getCursorPosition();
      await nvim.command(`normal! ${mode == "line" ? `']` : "`]"}`);
      let end = await window_default.getCursorPosition();
      await window_default.moveTo(pos);
      let relative = comparePosition(start, end);
      if (relative == 0)
        return;
      if (relative >= 0)
        [start, end] = [end, start];
      let line = doc.getline(end.line);
      if (end.character < line.length) {
        end.character = end.character + 1;
      }
      let ranges = splitRange(doc, vscode_languageserver_types6.Range.create(start, end));
      for (let r of ranges) {
        let text = doc.textDocument.getText(r);
        session4.addRange(r, text);
      }
    } else if (kind == "word") {
      range2 = doc.getWordRangeAtPosition(pos);
      if (!range2) {
        let line2 = doc.getline(pos.line);
        if (pos.character == line2.length) {
          range2 = vscode_languageserver_types6.Range.create(pos.line, Math.max(0, line2.length - 1), pos.line, line2.length);
        } else {
          range2 = vscode_languageserver_types6.Range.create(pos.line, pos.character, pos.line, pos.character + 1);
        }
      }
      let line = doc.getline(pos.line);
      let text = line.slice(range2.start.character, range2.end.character);
      session4.addRange(range2, text);
    } else if (kind == "position") {
      let line = doc.getline(pos.line);
      if (pos.character >= line.length) {
        range2 = vscode_languageserver_types6.Range.create(pos.line, line.length - 1, pos.line, line.length);
      } else {
        range2 = vscode_languageserver_types6.Range.create(pos.line, pos.character, pos.line, pos.character + 1);
      }
      session4.addRange(range2, line.slice(range2.start.character, range2.end.character));
    } else if (kind == "range") {
      await nvim.call("eval", 'feedkeys("\\<esc>", "in")');
      let range3 = await workspace_default.getSelectedRange(mode, doc);
      if (!range3 || comparePosition(range3.start, range3.end) == 0)
        return;
      let ranges = mode == "" ? getVisualRanges(doc, range3) : splitRange(doc, range3);
      for (let r of ranges) {
        let text = doc.textDocument.getText(r);
        session4.addRange(r, text);
      }
    } else {
      window_default.showMessage(`${kind} not supported`, "error");
      return;
    }
    if (kind == "word" || kind == "position") {
      await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
    }
  }
  createSession(doc) {
    let session4 = this.getSession(doc.bufnr);
    if (session4)
      return session4;
    session4 = new session_default2(this.nvim, doc, this.config);
    this.sessionsMap.set(doc.bufnr, session4);
    session4.onDidCancel(() => {
      session4.dispose();
      this.sessionsMap.delete(doc.bufnr);
    });
    return session4;
  }
  async addRanges(ranges) {
    let {nvim} = this;
    let bufnr = await nvim.call("bufnr", ["%"]);
    let doc = workspace_default.getDocument(bufnr);
    if (!doc || !doc.attached) {
      window_default.showMessage("Document not attached", "error");
      return false;
    }
    let session4 = this.createSession(doc);
    return session4.addRanges(ranges);
  }
  reset() {
    for (let session4 of this.sessionsMap.values()) {
      session4.cancel();
    }
    this.sessionsMap.clear();
  }
  dispose() {
    for (let session4 of this.sessionsMap.values()) {
      session4.dispose();
    }
    this.sessionsMap.clear();
    for (let disposable of this.disposables) {
      disposable.dispose();
    }
  }
};
var cursors_default = Cursors;

// src/handler/index.ts
var vscode_languageserver_protocol82 = __toModule(require_main3());

// src/handler/codelens/buffer.ts
var debounce19 = __toModule(require_debounce());
var vscode_languageserver_protocol72 = __toModule(require_main3());
var logger80 = require_logger2()("codelens-buffer");
var CodeLensBuffer = class {
  constructor(nvim, bufnr, config) {
    this.nvim = nvim;
    this.bufnr = bufnr;
    this.config = config;
    this._disposed = false;
    this.fetchCodelenses = debounce19.default(() => {
      this._fetchCodeLenses().logError();
    }, global.hasOwnProperty("__TEST__") ? 10 : 100);
    this.resolveCodeLens = debounce19.default(() => {
      this._resolveCodeLenses().logError();
    }, global.hasOwnProperty("__TEST__") ? 10 : 100);
    this.forceFetch().logError();
  }
  async forceFetch() {
    this.fetchCodelenses.clear();
    await this._fetchCodeLenses();
  }
  get textDocument() {
    var _a2;
    return (_a2 = workspace_default.getDocument(this.bufnr)) == null ? void 0 : _a2.textDocument;
  }
  get hasProvider() {
    let {textDocument} = this;
    if (!textDocument)
      return false;
    return languages_default.hasProvider("codeLens", textDocument);
  }
  async _fetchCodeLenses() {
    if (!this.config.enabled || !this.hasProvider)
      return;
    let {textDocument} = this;
    let version2 = textDocument.version;
    if (this.codeLenses && version2 == this.codeLenses.version) {
      let res = await this._resolveCodeLenses(true);
      if (!res)
        this.clear();
      return;
    }
    this.cancel();
    let tokenSource = this.tokenSource = new vscode_languageserver_protocol72.CancellationTokenSource();
    let token = tokenSource.token;
    let codeLenses = await languages_default.getCodeLens(textDocument, token);
    this.tokenSource = void 0;
    if (token.isCancellationRequested)
      return;
    if (Array.isArray(codeLenses)) {
      this.codeLenses = {version: version2, codeLenses};
      this.resolveCodeLens.clear();
      let res = await this._resolveCodeLenses(true);
      if (!res)
        this.clear();
    }
  }
  async _resolveCodeLenses(clear = false) {
    if (!this.config.enabled || !this.codeLenses || this._disposed)
      return false;
    let {codeLenses, version: version2} = this.codeLenses;
    let [bufnr, start, end] = await this.nvim.eval(`[bufnr('%'),line('w0'),line('w$')]`);
    if (!this.textDocument || this.textDocument.version != version2)
      return false;
    if (bufnr != this.bufnr)
      return false;
    codeLenses = codeLenses.filter((o) => {
      let lnum = o.range.start.line + 1;
      return lnum >= start && lnum <= end;
    });
    if (!clear)
      codeLenses = codeLenses.filter((o) => o.command == null);
    if (!codeLenses.length)
      return false;
    let tokenSource = new vscode_languageserver_protocol72.CancellationTokenSource();
    let token = tokenSource.token;
    let timer = setTimeout(() => {
      tokenSource.cancel();
    }, 1e3);
    await Promise.all(codeLenses.map((codeLens) => languages_default.resolveCodeLens(codeLens, token)));
    clearTimeout(timer);
    this.tokenSource = void 0;
    if (token.isCancellationRequested || this._disposed)
      return false;
    this.srcId = await this.nvim.createNamespace("coc-codelens");
    this.nvim.pauseNotification();
    if (clear)
      this.clear();
    this.setVirtualText(codeLenses);
    let res = await this.nvim.resumeNotification();
    if (Array.isArray(res) && res[1] != null) {
      logger80.error(`Error on resolve codeLens`, res[1][2]);
      return false;
    }
    return true;
  }
  setVirtualText(codeLenses) {
    if (codeLenses.length == 0)
      return;
    let list2 = new Map();
    for (let codeLens of codeLenses) {
      let {range: range2, command} = codeLens;
      if (!command)
        continue;
      let {line} = range2.start;
      if (list2.has(line)) {
        list2.get(line).push(codeLens);
      } else {
        list2.set(line, [codeLens]);
      }
    }
    for (let lnum of list2.keys()) {
      let codeLenses2 = list2.get(lnum);
      let commands10 = codeLenses2.map((codeLens) => codeLens.command);
      commands10 = commands10.filter((c) => c && c.title);
      let chunks = [];
      let n_commands = commands10.length;
      for (let i = 0; i < n_commands; i++) {
        let c = commands10[i];
        chunks.push([c.title.replace(/(\r\n|\r|\n) */g, " "), "CocCodeLens"]);
        if (i != n_commands - 1) {
          chunks.push([this.config.subseparator, "CocCodeLens"]);
        }
      }
      chunks.unshift([`${this.config.separator} `, "CocCodeLens"]);
      this.nvim.call("nvim_buf_set_virtual_text", [this.bufnr, this.srcId, lnum, chunks, {}], true);
    }
  }
  clear() {
    if (!this.srcId)
      return;
    let buf = this.nvim.createBuffer(this.bufnr);
    buf.clearNamespace(this.srcId);
  }
  getCodelenses() {
    var _a2;
    return (_a2 = this.codeLenses) == null ? void 0 : _a2.codeLenses;
  }
  async doAction(line) {
    let {codeLenses} = this.codeLenses;
    if (!codeLenses || codeLenses.length == 0) {
      window_default.showMessage("No codeLenses available", "warning");
      return;
    }
    let list2 = new Map();
    for (let codeLens of codeLenses) {
      let {range: range2, command} = codeLens;
      if (!command)
        continue;
      let {line: line2} = range2.start;
      if (list2.has(line2)) {
        list2.get(line2).push(codeLens);
      } else {
        list2.set(line2, [codeLens]);
      }
    }
    let current = null;
    for (let i = line; i >= 0; i--) {
      if (list2.has(i)) {
        current = list2.get(i);
        break;
      }
    }
    if (!current) {
      window_default.showMessage("No codeLenses available", "warning");
      return;
    }
    let commands10 = current.map((o) => o.command);
    commands10 = commands10.filter((c) => c.command != null && c.command != "");
    if (commands10.length == 0) {
      window_default.showMessage("CodeLenses command not found", "warning");
    } else if (commands10.length == 1) {
      commands_default.execute(commands10[0]);
    } else {
      let res = await window_default.showMenuPicker(commands10.map((c) => c.title));
      if (res == -1)
        return;
      commands_default.execute(commands10[res]);
    }
  }
  cancel() {
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource.dispose();
      this.tokenSource = null;
    }
  }
  onChange() {
    if (!this.config.enabled)
      return;
    this.cancel();
    this.resolveCodeLens.clear();
  }
  dispose() {
    this._disposed = true;
    this.codeLenses = void 0;
    this.cancel();
    this.fetchCodelenses.clear();
    this.resolveCodeLens.clear();
  }
};
var buffer_default = CodeLensBuffer;

// src/handler/codelens/index.ts
var logger81 = require_logger2()("codelens");
var CodeLensManager2 = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.disposables = [];
    this.setConfiguration();
    workspace_default.onDidChangeConfiguration((e) => {
      this.setConfiguration(e);
    }, null, this.disposables);
    this.buffers = workspace_default.registerBufferSync((doc) => {
      if (doc.buftype != "")
        return void 0;
      return new buffer_default(nvim, doc.bufnr, this.config);
    });
    events_default.on("ready", () => {
      this.checkProvider();
    }, null, this.disposables);
    events_default.on("CursorMoved", (bufnr) => {
      let buf = this.buffers.getItem(bufnr);
      if (buf)
        buf.resolveCodeLens();
    }, null, this.disposables);
    let forceFetch = async (bufnr) => {
      let buf = this.buffers.getItem(bufnr);
      if (buf)
        await buf.forceFetch();
    };
    events_default.on("CursorHold", forceFetch, this, this.disposables);
  }
  checkProvider() {
    for (let buf of this.buffers.items) {
      if (buf.hasProvider) {
        buf.fetchCodelenses();
      }
    }
  }
  setConfiguration(e) {
    if (e && !e.affectsConfiguration("codeLens"))
      return;
    let config = workspace_default.getConfiguration("codeLens");
    let enable = this.nvim.hasFunction("nvim_buf_set_virtual_text") && config.get("enable", false);
    if (e && enable != this.config.enabled) {
      for (let buf of this.buffers.items) {
        if (enable) {
          buf.forceFetch().logError();
        } else {
          buf.clear();
        }
      }
    }
    this.config = Object.assign(this.config || {}, {
      enabled: enable,
      separator: config.get("separator", "\u2023"),
      subseparator: config.get("subseparator", " ")
    });
  }
  async doAction() {
    let {nvim} = this;
    let bufnr = await nvim.call("bufnr", "%");
    let line = await nvim.call("line", ".") - 1;
    let buf = this.buffers.getItem(bufnr);
    await (buf == null ? void 0 : buf.doAction(line));
  }
  dispose() {
    this.buffers.dispose();
    disposeAll(this.disposables);
  }
};
var codelens_default = CodeLensManager2;

// src/handler/colors/index.ts
var vscode_languageserver_protocol75 = __toModule(require_main3());

// src/handler/helper.ts
var vscode_languageserver_protocol73 = __toModule(require_main3());
function getPreviousContainer(containerName, symbols3) {
  if (!symbols3.length)
    return null;
  let i = symbols3.length - 1;
  let last = symbols3[i];
  if (last.text == containerName) {
    return last;
  }
  while (i >= 0) {
    let sym = symbols3[i];
    if (sym.text == containerName) {
      return sym;
    }
    i--;
  }
  return null;
}
function sortDocumentSymbols(a, b) {
  let ra = a.selectionRange;
  let rb = b.selectionRange;
  if (ra.start.line < rb.start.line) {
    return -1;
  }
  if (ra.start.line > rb.start.line) {
    return 1;
  }
  return ra.start.character - rb.start.character;
}
function addDoucmentSymbol(res, sym, level) {
  let {name: name2, selectionRange: selectionRange2, kind, children, range: range2} = sym;
  let {start} = selectionRange2;
  res.push({
    col: start.character + 1,
    lnum: start.line + 1,
    text: name2,
    level,
    kind: getSymbolKind(kind),
    range: range2,
    selectionRange: selectionRange2
  });
  if (children && children.length) {
    children.sort(sortDocumentSymbols);
    for (let sym2 of children) {
      addDoucmentSymbol(res, sym2, level + 1);
    }
  }
}
function sortSymbolInformations(a, b) {
  let sa = a.location.range.start;
  let sb = b.location.range.start;
  let d = sa.line - sb.line;
  return d == 0 ? sa.character - sb.character : d;
}
function isDocumentSymbol(a) {
  return a && !a.hasOwnProperty("location");
}
function isDocumentSymbols(a) {
  return isDocumentSymbol(a[0]);
}
function isMarkdown(content) {
  if (vscode_languageserver_protocol73.MarkupContent.is(content) && content.kind == vscode_languageserver_protocol73.MarkupKind.Markdown) {
    return true;
  }
  return false;
}
function addDocument(docs, text, filetype, isPreview = false) {
  let content = text.trim();
  if (!content.length)
    return;
  if (isPreview && filetype !== "markdown") {
    content = "``` " + filetype + "\n" + content + "\n```";
  }
  docs.push({content, filetype});
}
async function synchronizeDocument(doc) {
  let {changedtick} = doc;
  await doc.patchChange();
  if (changedtick != doc.changedtick) {
    await wait(50);
  }
}
function toHexString(color) {
  let c = toHexColor(color);
  return `${pad(c.red.toString(16))}${pad(c.green.toString(16))}${pad(c.blue.toString(16))}`;
}
function pad(str) {
  return str.length == 1 ? `0${str}` : str;
}
function toHexColor(color) {
  let {red, green, blue: blue2} = color;
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue2 * 255)
  };
}
function isDark(color) {
  let rgb = [color.red, color.green, color.blue];
  let lum = [];
  for (let i = 0; i < rgb.length; i++) {
    let chan = rgb[i];
    lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
  }
  let luma = 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  return luma <= 0.5;
}

// src/handler/colors/colorBuffer.ts
var debounce21 = __toModule(require_debounce());
var vscode_languageserver_protocol74 = __toModule(require_main3());
var logger82 = require_logger2()("colors-buffer");
var ColorBuffer = class {
  constructor(nvim, bufnr, enabled, usedColors) {
    this.nvim = nvim;
    this.bufnr = bufnr;
    this.enabled = enabled;
    this.usedColors = usedColors;
    this._colors = [];
    this.highlight = debounce21.default(() => {
      this.doHighlight().catch((e) => {
        logger82.error("Error on color highlight:", e.stack);
      });
    }, global.hasOwnProperty("__TEST__") ? 10 : 500);
  }
  onChange() {
    this.cancel();
    this.highlight();
  }
  get buffer() {
    return this.nvim.createBuffer(this.bufnr);
  }
  get colors() {
    return this._colors;
  }
  hasColor() {
    return this._colors.length > 0;
  }
  setState(enabled) {
    this.enabled = enabled;
    if (enabled) {
      this.highlight();
    } else {
      this.clearHighlight();
    }
  }
  async doHighlight() {
    let doc = workspace_default.getDocument(this.bufnr);
    if (!doc || !this.enabled)
      return;
    try {
      this.tokenSource = new vscode_languageserver_protocol74.CancellationTokenSource();
      let {token} = this.tokenSource;
      if (this.version && doc.version == this.version)
        return;
      let {version: version2} = doc;
      let colors2;
      colors2 = await languages_default.provideDocumentColors(doc.textDocument, token);
      colors2 = colors2 || [];
      if (token.isCancellationRequested)
        return;
      this.version = version2;
      await this.addHighlight(colors2, token);
    } catch (e) {
      logger82.error("Error on highlight:", e);
    }
  }
  async addHighlight(colors2, token) {
    colors2 = colors2 || [];
    if (equals(this._colors, colors2))
      return;
    let {nvim} = this;
    this._colors = colors2;
    let groups = group(colors2, 100);
    nvim.pauseNotification();
    this.buffer.clearNamespace("color");
    this.defineColors(colors2);
    nvim.resumeNotification(false, true);
    for (let colors3 of groups) {
      if (token.isCancellationRequested) {
        this._colors = [];
        return;
      }
      nvim.pauseNotification();
      let colorRanges = this.getColorRanges(colors3);
      for (let o of colorRanges) {
        this.highlightColor(o.ranges, o.color);
      }
      nvim.resumeNotification(false, true);
    }
    if (workspace_default.isVim) {
      this.nvim.command("redraw", true);
    }
  }
  highlightColor(ranges, color) {
    let {red, green, blue: blue2} = toHexColor(color);
    let hlGroup = `BG${toHexString(color)}`;
    this.buffer.highlightRanges("color", hlGroup, ranges);
  }
  defineColors(colors2) {
    for (let color of colors2) {
      let hex = toHexString(color.color);
      if (!this.usedColors.has(hex)) {
        this.nvim.command(`hi BG${hex} guibg=#${hex} guifg=#${isDark(color.color) ? "ffffff" : "000000"}`, true);
        this.usedColors.add(hex);
      }
    }
  }
  getColorRanges(infos) {
    let res = [];
    for (let info of infos) {
      let {color, range: range2} = info;
      let idx = res.findIndex((o) => equals(toHexColor(o.color), toHexColor(color)));
      if (idx == -1) {
        res.push({
          color,
          ranges: [range2]
        });
      } else {
        let r = res[idx];
        r.ranges.push(range2);
      }
    }
    return res;
  }
  clearHighlight() {
    this.highlight.clear();
    this._colors = [];
    this.version = null;
    this.buffer.clearNamespace("color");
  }
  hasColorAtPostion(position15) {
    let {colors: colors2} = this;
    return colors2.some((o) => positionInRange(position15, o.range) == 0);
  }
  cancel() {
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource = null;
    }
  }
  dispose() {
    this.highlight.clear();
    this.cancel();
  }
};
var colorBuffer_default = ColorBuffer;

// src/handler/colors/index.ts
var logger83 = require_logger2()("colors");
var Colors = class {
  constructor(nvim) {
    this.nvim = nvim;
    this._enabled = true;
    this.disposables = [];
    let config = workspace_default.getConfiguration("coc.preferences");
    this._enabled = config.get("colorSupport", true);
    if (workspace_default.isVim && !workspace_default.env.textprop) {
      this._enabled = false;
    }
    let usedColors = new Set();
    this.highlighters = workspace_default.registerBufferSync((doc) => {
      let buf = new colorBuffer_default(this.nvim, doc.bufnr, this._enabled, usedColors);
      buf.highlight();
      return buf;
    });
    extensions_default.onDidActiveExtension(() => {
      this.highlightAll();
    }, null, this.disposables);
    workspace_default.onDidChangeConfiguration(async (e) => {
      if (workspace_default.isVim && !workspace_default.env.textprop)
        return;
      if (e.affectsConfiguration("coc.preferences.colorSupport")) {
        let config2 = workspace_default.getConfiguration("coc.preferences");
        let enabled = config2.get("colorSupport", true);
        if (enabled != this._enabled) {
          this._enabled = enabled;
          for (let buf of this.highlighters.items) {
            buf.setState(enabled);
          }
        }
      }
    }, null, this.disposables);
  }
  async pickPresentation() {
    let info = await this.currentColorInfomation();
    if (!info)
      return window_default.showMessage("Color not found at current position", "warning");
    let document3 = await workspace_default.document;
    let tokenSource = new vscode_languageserver_protocol75.CancellationTokenSource();
    let presentations = await languages_default.provideColorPresentations(info, document3.textDocument, tokenSource.token);
    if (!presentations || presentations.length == 0)
      return;
    let res = await window_default.showMenuPicker(presentations.map((o) => o.label), "choose color:");
    if (res == -1)
      return;
    let presentation = presentations[res];
    let {textEdit, additionalTextEdits, label} = presentation;
    if (!textEdit)
      textEdit = {range: info.range, newText: label};
    await document3.applyEdits([textEdit]);
    if (additionalTextEdits) {
      await document3.applyEdits(additionalTextEdits);
    }
  }
  async pickColor() {
    let info = await this.currentColorInfomation();
    if (!info)
      return window_default.showMessage("Color not found at current position", "warning");
    let {color} = info;
    let colorArr = [(color.red * 255).toFixed(0), (color.green * 255).toFixed(0), (color.blue * 255).toFixed(0)];
    let res = await this.nvim.call("coc#util#pick_color", [colorArr]);
    if (res === false) {
      return;
    }
    if (!res || res.length != 3) {
      window_default.showMessage("Failed to get color", "warning");
      return;
    }
    let hex = toHexString({
      red: res[0] / 65535,
      green: res[1] / 65535,
      blue: res[2] / 65535,
      alpha: 1
    });
    let document3 = await workspace_default.document;
    await document3.applyEdits([{
      range: info.range,
      newText: `#${hex}`
    }]);
  }
  get enabled() {
    return this._enabled;
  }
  clearHighlight(bufnr) {
    let highlighter = this.highlighters.getItem(bufnr);
    if (!highlighter)
      return;
    highlighter.clearHighlight();
  }
  hasColor(bufnr) {
    let highlighter = this.highlighters.getItem(bufnr);
    if (!highlighter)
      return false;
    return highlighter.hasColor();
  }
  hasColorAtPostion(bufnr, position15) {
    let highlighter = this.highlighters.getItem(bufnr);
    if (!highlighter)
      return false;
    return highlighter.hasColorAtPostion(position15);
  }
  highlightAll() {
    for (let buf of this.highlighters.items) {
      buf.highlight();
    }
  }
  async doHighlight(bufnr) {
    let highlighter = this.highlighters.getItem(bufnr);
    if (!highlighter)
      return;
    await highlighter.doHighlight();
  }
  async currentColorInfomation() {
    let bufnr = await this.nvim.call("bufnr", "%");
    let highlighter = this.highlighters.getItem(bufnr);
    if (!highlighter)
      return null;
    let position15 = await window_default.getCursorPosition();
    for (let info of highlighter.colors) {
      let {range: range2} = info;
      let {start, end} = range2;
      if (position15.line == start.line && position15.character >= start.character && position15.character <= end.character) {
        return info;
      }
    }
    return null;
  }
  dispose() {
    this.highlighters.dispose();
    disposeAll(this.disposables);
  }
};
var colors_default = Colors;

// src/handler/format.ts
var vscode_languageserver_protocol76 = __toModule(require_main3());
var logger84 = require_logger2()("handler-format");
var pairs = new Map([
  ["<", ">"],
  [">", "<"],
  ["{", "}"],
  ["[", "]"],
  ["(", ")"]
]);
var FormatHandler = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.disposables = [];
    this.requestStatusItem = window_default.createStatusBarItem(0, {progress: true});
    this.loadPreferences();
    workspace_default.onDidChangeConfiguration(this.loadPreferences, this, this.disposables);
    workspace_default.onWillSaveTextDocument((event) => {
      let {languageId} = event.document;
      let filetypes = this.preferences.formatOnSaveFiletypes;
      if (filetypes.includes(languageId) || filetypes.some((item) => item === "*")) {
        let willSaveWaitUntil = async () => {
          if (!languages_default.hasFormatProvider(event.document)) {
            logger84.warn(`Format provider not found for ${event.document.uri}`);
            return void 0;
          }
          let options = await workspace_default.getFormatOptions(event.document.uri);
          let tokenSource = new vscode_languageserver_protocol76.CancellationTokenSource();
          let timer = setTimeout(() => {
            tokenSource.cancel();
          }, 1e3);
          let textEdits = await languages_default.provideDocumentFormattingEdits(event.document, options, tokenSource.token);
          clearTimeout(timer);
          return textEdits;
        };
        event.waitUntil(willSaveWaitUntil());
      }
    }, null, this.disposables);
    events_default.on(["CursorMoved", "CursorMovedI", "InsertEnter", "TextChangedI", "TextChangedP", "TextChanged"], () => {
      if (this.requestTokenSource) {
        this.requestTokenSource.cancel();
        this.requestTokenSource = null;
      }
    }, null, this.disposables);
    events_default.on("Enter", async (bufnr) => {
      let {bracketEnterImprove} = this.preferences;
      await this.tryFormatOnType("\n", bufnr);
      if (bracketEnterImprove) {
        let line = await nvim.call("line", ".") - 1;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return;
        let pre = doc.getline(line - 1);
        let curr = doc.getline(line);
        let prevChar = pre[pre.length - 1];
        if (prevChar && pairs.has(prevChar)) {
          let nextChar = curr.trim()[0];
          if (nextChar && pairs.get(prevChar) == nextChar) {
            let edits = [];
            let opts = await workspace_default.getFormatOptions(doc.uri);
            let space = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
            let preIndent = pre.match(/^\s*/)[0];
            let currIndent = curr.match(/^\s*/)[0];
            let newText = "\n" + preIndent + space;
            let pos = vscode_languageserver_protocol76.Position.create(line - 1, pre.length);
            if (preIndent != currIndent) {
              let newText2 = doc.filetype == "vim" ? "  \\ " + preIndent : preIndent;
              edits.push({range: vscode_languageserver_protocol76.Range.create(vscode_languageserver_protocol76.Position.create(line, 0), vscode_languageserver_protocol76.Position.create(line, currIndent.length)), newText: newText2});
            } else if (doc.filetype == "vim") {
              edits.push({range: vscode_languageserver_protocol76.Range.create(line, currIndent.length, line, currIndent.length), newText: "  \\ "});
            }
            if (doc.filetype == "vim") {
              newText = newText + "\\ ";
            }
            edits.push({range: vscode_languageserver_protocol76.Range.create(pos, pos), newText});
            await doc.applyEdits(edits);
            await window_default.moveTo(vscode_languageserver_protocol76.Position.create(line, newText.length - 1));
          }
        }
      }
    }, null, this.disposables);
    let changedTs;
    let lastInsert;
    events_default.on("InsertCharPre", async () => {
      lastInsert = Date.now();
    }, null, this.disposables);
    events_default.on("TextChangedI", async (bufnr, info) => {
      changedTs = Date.now();
      if (!lastInsert || changedTs - lastInsert > 300)
        return;
      lastInsert = null;
      let doc = workspace_default.getDocument(bufnr);
      if (!doc)
        return;
      let pre = info.pre[info.pre.length - 1];
      if (!pre || !languages_default.hasProvider("onTypeEdit", doc.textDocument))
        return;
      await this.tryFormatOnType(pre, bufnr);
    }, null, this.disposables);
    let lastEnterBufnr;
    let lastEnterTs;
    events_default.on("InsertEnter", (bufnr) => {
      lastEnterBufnr = bufnr;
      lastEnterTs = Date.now();
    });
    events_default.on("TextChangedI", async (bufnr, info) => {
      if (!this.preferences.formatOnType && !/^\s*$/.test(info.pre))
        return;
      if (lastEnterBufnr != bufnr || !lastEnterTs || Date.now() - lastEnterTs > 30)
        return;
      await this.tryFormatOnType("\n", bufnr, true);
    });
  }
  loadPreferences(e) {
    if (!e || e.affectsConfiguration("coc.preferences")) {
      let config = workspace_default.getConfiguration("coc.preferences");
      this.preferences = {
        formatOnType: config.get("formatOnType", false),
        formatOnSaveFiletypes: config.get("formatOnSaveFiletypes", []),
        formatOnTypeFiletypes: config.get("formatOnTypeFiletypes", []),
        bracketEnterImprove: config.get("bracketEnterImprove", true)
      };
    }
  }
  async withRequestToken(name2, fn) {
    if (this.requestTokenSource) {
      this.requestTokenSource.cancel();
      this.requestTokenSource.dispose();
    }
    let statusItem = this.requestStatusItem;
    this.requestTokenSource = new vscode_languageserver_protocol76.CancellationTokenSource();
    let {token} = this.requestTokenSource;
    token.onCancellationRequested(() => {
      statusItem.text = `${name2} request canceled`;
      statusItem.isProgress = false;
      statusItem.hide();
    });
    statusItem.isProgress = true;
    statusItem.text = `requesting ${name2}`;
    statusItem.show();
    let res;
    try {
      res = await Promise.resolve(fn(token));
    } catch (e) {
      window_default.showMessage(e.message, "error");
      logger84.error(`Error on ${name2}`, e);
    }
    if (this.requestTokenSource) {
      this.requestTokenSource.dispose();
      this.requestTokenSource = void 0;
    }
    if (token.isCancellationRequested)
      return null;
    statusItem.hide();
    if (res == null) {
      logger84.warn(`${name2} provider not found!`);
    }
    return res;
  }
  async tryFormatOnType(ch, bufnr, newLine = false) {
    if (!ch || isWord(ch) || !this.preferences.formatOnType)
      return;
    if (manager_default3.getSession(bufnr) != null)
      return;
    let doc = workspace_default.getDocument(bufnr);
    if (!doc || !doc.attached || doc.isCommandLine)
      return;
    const filetypes = this.preferences.formatOnTypeFiletypes;
    if (filetypes.length && !filetypes.includes(doc.filetype)) {
      return;
    }
    if (!languages_default.hasOnTypeProvider(ch, doc.textDocument))
      return;
    let position15;
    let edits = await this.withRequestToken("onTypeFormat ", async (token) => {
      position15 = await window_default.getCursorPosition();
      let origLine = doc.getline(position15.line - 1);
      if (newLine && /^\s*$/.test(origLine))
        return;
      let pos = newLine ? {line: position15.line - 1, character: origLine.length} : position15;
      await synchronizeDocument(doc);
      return await languages_default.provideDocumentOnTypeEdits(ch, doc.textDocument, pos, token);
    });
    if (!edits || !edits.length)
      return;
    let changed = getChangedFromEdits(position15, edits);
    await doc.applyEdits(edits);
    let to = changed ? vscode_languageserver_protocol76.Position.create(position15.line + changed.line, position15.character + changed.character) : null;
    if (to && !newLine)
      await window_default.moveTo(to);
  }
  async documentFormat() {
    let doc = await workspace_default.document;
    if (!doc || !doc.attached)
      return false;
    await synchronizeDocument(doc);
    let options = await workspace_default.getFormatOptions(doc.uri);
    let textEdits = await this.withRequestToken("format", (token) => {
      return languages_default.provideDocumentFormattingEdits(doc.textDocument, options, token);
    });
    if (textEdits && textEdits.length > 0) {
      await doc.applyEdits(textEdits);
      return true;
    }
    return false;
  }
  async documentRangeFormat(mode) {
    let doc = await workspace_default.document;
    if (!doc || !doc.attached)
      return -1;
    await synchronizeDocument(doc);
    let range2;
    if (mode) {
      range2 = await workspace_default.getSelectedRange(mode, doc);
      if (!range2)
        return -1;
    } else {
      let [lnum, count, mode2] = await this.nvim.eval("[v:lnum,v:count,mode()]");
      if (count == 0 || mode2 == "i" || mode2 == "R")
        return -1;
      range2 = vscode_languageserver_protocol76.Range.create(lnum - 1, 0, lnum - 1 + count, 0);
    }
    let options = await workspace_default.getFormatOptions(doc.uri);
    let textEdits = await this.withRequestToken("format", (token) => {
      return languages_default.provideDocumentRangeFormattingEdits(doc.textDocument, range2, options, token);
    });
    if (textEdits && textEdits.length > 0) {
      await doc.applyEdits(textEdits);
      return 0;
    }
    return -1;
  }
  dispose() {
    disposeAll(this.disposables);
  }
};
var format_default = FormatHandler;

// src/handler/highlights.ts
var vscode_languageserver_protocol77 = __toModule(require_main3());
var logger85 = require_logger2()("documentHighlight");
var namespaceKey = "coc-highlight";
var Highlights = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.disposables = [];
    this.highlights = new Map();
    events_default.on(["WinLeave", "TextChanged", "CursorMoved", "InsertEnter"], () => {
      this.cancel();
    }, null, this.disposables);
    events_default.on("BufUnload", (bufnr) => {
      this.highlights.delete(bufnr);
    }, null, this.disposables);
  }
  clearHighlight(bufnr) {
    let {nvim} = workspace_default;
    let buf = nvim.createBuffer(bufnr);
    buf.clearNamespace(namespaceKey);
    if (workspace_default.isVim)
      nvim.command("redraw", true);
    this.highlights.delete(bufnr);
  }
  async highlight() {
    let {nvim} = this;
    this.cancel();
    let [bufnr, cursors2] = await nvim.eval(`[bufnr('%'),get(b:,'coc_cursors_activated',0)]`);
    let doc = workspace_default.getDocument(bufnr);
    if (!doc || !doc.attached || !languages_default.hasProvider("documentHighlight", doc.textDocument))
      return;
    if (cursors2) {
      this.clearHighlight(bufnr);
      return;
    }
    let position15 = await window_default.getCursorPosition();
    let highlights2 = await this.getHighlights(doc, position15);
    if (!highlights2) {
      this.clearHighlight(bufnr);
      return;
    }
    let groups = {};
    for (let hl of highlights2) {
      if (!hl.range)
        continue;
      let hlGroup = hl.kind == vscode_languageserver_protocol77.DocumentHighlightKind.Text ? "CocHighlightText" : hl.kind == vscode_languageserver_protocol77.DocumentHighlightKind.Read ? "CocHighlightRead" : "CocHighlightWrite";
      groups[hlGroup] = groups[hlGroup] || [];
      groups[hlGroup].push(hl.range);
    }
    let buffer4 = nvim.createBuffer(bufnr);
    nvim.pauseNotification();
    buffer4.clearNamespace(namespaceKey);
    for (let hlGroup of Object.keys(groups)) {
      buffer4.highlightRanges(namespaceKey, hlGroup, groups[hlGroup]);
    }
    if (workspace_default.isVim)
      nvim.command("redraw", true);
    let res = this.nvim.resumeNotification();
    if (Array.isArray(res) && res[1] != null) {
      logger85.error(`Error on highlight`, res[1][2]);
    } else {
      this.highlights.set(bufnr, highlights2);
    }
  }
  hasHighlights(bufnr) {
    return this.highlights.get(bufnr) != null;
  }
  async getHighlights(doc, position15) {
    if (!doc || !doc.attached || doc.isCommandLine)
      return null;
    let line = doc.getline(position15.line);
    let ch = line[position15.character];
    if (!ch || !doc.isWord(ch))
      return null;
    try {
      this.tokenSource = new vscode_languageserver_protocol77.CancellationTokenSource();
      doc.forceSync();
      let {token} = this.tokenSource;
      let highlights2 = await languages_default.getDocumentHighLight(doc.textDocument, position15, token);
      this.tokenSource = null;
      if (token.isCancellationRequested)
        return null;
      return highlights2;
    } catch (_e) {
      return null;
    }
  }
  cancel() {
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource.dispose();
      this.tokenSource = null;
    }
  }
  dispose() {
    if (this.tokenSource)
      this.tokenSource.dispose();
    disposeAll(this.disposables);
  }
};
var highlights_default = Highlights;

// src/handler/refactor/index.ts
var vscode_languageserver_protocol79 = __toModule(require_main3());

// src/handler/refactor/buffer.ts
var fast_diff5 = __toModule(require_diff2());
var path60 = __toModule(require("path"));
var vscode_languageserver_protocol78 = __toModule(require_main3());
var logger86 = require_logger2()("handler-refactorBuffer");
var SEPARATOR = "\u3000";
var RefactorBuffer = class {
  constructor(bufnr, srcId, nvim, config, opts) {
    this.bufnr = bufnr;
    this.srcId = srcId;
    this.nvim = nvim;
    this.config = config;
    this.opts = opts;
    this.mutex = new Mutex();
    this._disposed = false;
    this.disposables = [];
    this._fileItems = [];
    this.matchIds = new Set();
    this.changing = false;
    this.disposables.push(workspace_default.registerLocalKeymap("n", "<CR>", this.splitOpen.bind(this), true));
    workspace_default.onDidChangeTextDocument(this.onDocumentChange, this, this.disposables);
  }
  get fileItems() {
    return this._fileItems;
  }
  onChange(e) {
    if (this.changing)
      return;
    let doc = this.document;
    let {nvim, _fileItems: fileItems} = this;
    if (!fileItems.length)
      return;
    let change = e.contentChanges[0];
    if (!("range" in change))
      return;
    let {original} = e;
    if (change.range.end.line < 2)
      return;
    doc.buffer.setOption("modified", true, true);
    let {range: range2, text} = change;
    let lines = text.split("\n");
    let lineChange = lines.length - (range2.end.line - range2.start.line) - 1;
    if (lineChange == 0)
      return;
    let lineChanges = [];
    if (text.includes("\u3000")) {
      let startLine = range2.start.line;
      let diffs = fast_diff5.default(original, text);
      let offset = 0;
      let orig = TextDocument.create("file:///1", "", 0, original);
      for (let i = 0; i < diffs.length; i++) {
        let diff3 = diffs[i];
        let pos = orig.positionAt(offset);
        if (diff3[0] == fast_diff5.default.EQUAL) {
          offset = offset + diff3[1].length;
        } else if (diff3[0] == fast_diff5.default.DELETE) {
          let end = orig.positionAt(offset + diff3[1].length);
          if (diffs[i + 1] && diffs[i + 1][0] == fast_diff5.default.INSERT) {
            let delta = diffs[i + 1][1].split("\n").length - (end.line - pos.line) - 1;
            if (delta != 0)
              lineChanges.push({delta, lnum: pos.line + startLine});
            i = i + 1;
          } else {
            let delta = -(end.line - pos.line);
            if (delta != 0)
              lineChanges.push({delta, lnum: pos.line + startLine});
          }
          offset = offset + diff3[1].length;
        } else if (diff3[0] == fast_diff5.default.INSERT) {
          let delta = diff3[1].split("\n").length - 1;
          if (delta != 0)
            lineChanges.push({delta, lnum: pos.line + startLine});
        }
      }
    } else {
      lineChanges = [{delta: lineChange, lnum: range2.start.line}];
    }
    let changed = false;
    for (let item of fileItems) {
      for (let range3 of item.ranges) {
        let arr = lineChanges.filter((o) => o.lnum < range3.lnum - 1);
        if (arr.length) {
          let total = arr.reduce((p, c) => p + c.delta, 0);
          range3.lnum = range3.lnum + total;
          changed = true;
        }
      }
    }
    if (!changed)
      return;
    nvim.pauseNotification();
    this.highlightLineNr();
    nvim.resumeNotification().then((res) => {
      if (Array.isArray(res) && res[1] != null) {
        logger86.error(`Error on highlightLineNr:`, res[1]);
      }
    }).logError();
  }
  async onDocumentChange(e) {
    if (e.bufnr == this.bufnr || this.changing)
      return;
    let {uri} = e.textDocument;
    let {range: range2, text} = e.contentChanges[0];
    let filepath = URI.parse(uri).fsPath;
    let fileItem = this._fileItems.find((o) => o.filepath == filepath);
    if (!fileItem)
      return;
    let lineChange = text.split("\n").length - (range2.end.line - range2.start.line) - 1;
    let edits = [];
    for (let i = 0; i < fileItem.ranges.length; i++) {
      let r = fileItem.ranges[i];
      if (range2.start.line >= r.end) {
        continue;
      }
      if (range2.end.line < r.start) {
        if (lineChange == 0) {
          continue;
        } else {
          r.start = r.start + lineChange;
          r.end = r.end + lineChange;
        }
      } else {
        let doc = workspace_default.getDocument(uri);
        let newLines = doc.getLines(r.start, r.end);
        if (!newLines.length) {
          fileItem.ranges.splice(i, 1);
          edits.push({
            range: this.getFileRangeRange(r, false),
            newText: ""
          });
        } else {
          r.end = r.start + newLines.length;
          edits.push({
            range: this.getFileRangeRange(r, true),
            newText: newLines.join("\n") + "\n"
          });
        }
      }
    }
    this._fileItems = this._fileItems.filter((o) => o.ranges && o.ranges.length > 0);
    if (edits.length) {
      this.changing = true;
      await this.document.applyEdits(edits);
      this.changing = false;
    }
    this.nvim.pauseNotification();
    this.highlightLineNr();
    this.buffer.setOption("modified", false, true);
    await this.nvim.resumeNotification();
  }
  async getFileChanges() {
    if (this._disposed)
      return [];
    let changes = [];
    let lines = await this.buffer.lines;
    lines.push(SEPARATOR);
    let arr = [];
    let fsPath;
    let lnum;
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      if (line.startsWith(SEPARATOR)) {
        if (fsPath) {
          changes.push({
            filepath: fsPath,
            lines: arr.slice(),
            lnum
          });
          fsPath = void 0;
          arr = [];
        }
        if (line.length > 1) {
          let ms = line.match(/^\u3000(.*)/);
          if (ms) {
            fsPath = this.getAbsolutePath(ms[1].replace(/\s+$/, ""));
            lnum = i + 1;
            arr = [];
          }
        }
      } else {
        arr.push(line);
      }
    }
    return changes;
  }
  async splitOpen() {
    let {nvim} = this;
    let win = nvim.createWindow(this.opts.fromWinid);
    let valid = await win.valid;
    let lines = await nvim.eval('getline(1,line("."))');
    let len = lines.length;
    for (let i = 0; i < len; i++) {
      let line = lines[len - i - 1];
      let ms = line.match(/^\u3000(.+)/);
      if (ms) {
        let filepath = ms[1].trim();
        let r = this.getLinesRange(len - i);
        if (!r)
          return;
        let lnum = r[0] + i - 1;
        let bufname = this.getAbsolutePath(filepath);
        nvim.pauseNotification();
        if (valid) {
          nvim.call("win_gotoid", [this.opts.fromWinid], true);
          this.nvim.call("coc#util#jump", ["edit", bufname, [lnum, 1]], true);
        } else {
          this.nvim.call("coc#util#jump", ["belowright vs", bufname, [lnum, 1]], true);
        }
        nvim.command("normal! zz", true);
        let [, err] = await nvim.resumeNotification();
        if (err)
          window_default.showMessage(`Error on open ${filepath}: ${err}`, "error");
        if (!valid) {
          this.opts.fromWinid = await nvim.call("win_getid");
        }
        break;
      }
    }
  }
  async addFileItems(items) {
    if (this._disposed)
      return;
    let {cwd} = this.opts;
    let {document: document3} = this;
    const release = await this.mutex.acquire();
    try {
      if (document3.dirty)
        document3.forceSync();
      for (let item of items) {
        let fileItem = this._fileItems.find((o) => o.filepath == item.filepath);
        if (fileItem) {
          fileItem.ranges.push(...item.ranges);
        } else {
          this._fileItems.push(item);
        }
      }
      let count = document3.lineCount;
      let highligher4 = new highligher_default();
      let hlRanges = [];
      for (let item of items) {
        for (let range2 of item.ranges) {
          highligher4.addLine(SEPARATOR);
          highligher4.addLine(SEPARATOR);
          range2.lnum = count + highligher4.length;
          highligher4.addText(`${isParentFolder(cwd, item.filepath) ? path60.default.relative(cwd, item.filepath) : item.filepath}`);
          let n = String(range2.start + 1).length + String(range2.end).length + 4;
          if (!this.srcId)
            highligher4.addText(" ".repeat(n));
          let base = 0 - highligher4.length - count;
          if (range2.highlights) {
            hlRanges.push(...range2.highlights.map((r) => adjustRange(r, base)));
          }
          let {lines} = range2;
          if (!lines) {
            lines = await this.getLines(item.filepath, range2.start, range2.end);
            range2.lines = lines;
          }
          highligher4.addLines(lines);
        }
      }
      let {nvim, buffer: buffer4} = this;
      this.changing = true;
      nvim.pauseNotification();
      highligher4.render(buffer4, count);
      this.highlightLineNr();
      buffer4.setOption("modified", false, true);
      buffer4.setOption("undolevels", 1e3, true);
      if (count == 2 && hlRanges.length) {
        let pos = hlRanges[0].start;
        nvim.call("coc#util#jumpTo", [pos.line, pos.character], true);
      }
      if (workspace_default.isVim) {
        nvim.command("redraw", true);
      }
      let [, err] = await nvim.resumeNotification();
      if (err)
        throw new Error(err[2]);
      await document3.patchChange();
      this.changing = false;
      await commands_default.executeCommand("editor.action.addRanges", hlRanges);
    } catch (e) {
      this.changing = false;
      logger86.error(`Error on add file item:`, e);
    }
    release();
  }
  async save() {
    let {nvim} = this;
    let doc = this.document;
    let {buffer: buffer4} = doc;
    await doc.patchChange();
    let changes = await this.getFileChanges();
    if (!changes)
      return;
    changes.sort((a, b) => a.lnum - b.lnum);
    let removeList = [];
    let deltaMap = new Map();
    for (let i = 0; i < changes.length; i++) {
      let change = changes[i];
      let {filepath, lnum} = change;
      let curr = deltaMap.get(filepath) || 0;
      let item = this._fileItems.find((o) => o.filepath == filepath);
      let range2 = item ? item.ranges.find((o) => o.lnum == lnum) : null;
      if (!range2 || equals(range2.lines, change.lines)) {
        removeList.push(i);
        if (curr && range2) {
          range2.start = range2.start + curr;
          range2.end = range2.end + curr;
        }
        continue;
      }
      change.start = range2.start;
      change.end = range2.end;
      if (curr != 0)
        range2.start = range2.start + curr;
      if (change.lines.length != range2.lines.length) {
        let delta = change.lines.length - range2.lines.length;
        let total = delta + curr;
        deltaMap.set(filepath, total);
        range2.end = range2.end + total;
      } else {
        range2.end = range2.end + curr;
      }
      range2.lines = change.lines;
    }
    if (removeList.length)
      changes = changes.filter((_, i) => !removeList.includes(i));
    if (changes.length == 0) {
      window_default.showMessage("No change.", "more");
      await buffer4.setOption("modified", false);
      return false;
    }
    let changeMap = {};
    for (let change of changes) {
      let uri = URI.file(change.filepath).toString();
      let edits = changeMap[uri] || [];
      edits.push({
        range: vscode_languageserver_protocol78.Range.create(change.start, 0, change.end, 0),
        newText: change.lines.join("\n") + "\n"
      });
      changeMap[uri] = edits;
    }
    this.changing = true;
    await workspace_default.applyEdit({changes: changeMap});
    this.changing = false;
    nvim.pauseNotification();
    buffer4.setOption("modified", false, true);
    if (this.config.saveToFile) {
      nvim.command("silent noa wa", true);
    }
    this.highlightLineNr();
    await nvim.resumeNotification();
    return true;
  }
  getFileRange(lnum) {
    for (let item of this._fileItems) {
      for (let r of item.ranges) {
        if (r.lnum == lnum) {
          return r;
        }
      }
    }
    return null;
  }
  getLinesRange(lnum) {
    for (let item of this._fileItems) {
      for (let range2 of item.ranges) {
        if (range2.lnum == lnum) {
          return [range2.start, range2.end];
        }
      }
    }
    return null;
  }
  async getLines(fsPath, start, end) {
    let uri = URI.file(fsPath).toString();
    let doc = workspace_default.getDocument(uri);
    if (doc)
      return doc.getLines(start, end);
    return await readFileLines(fsPath, start, end - 1);
  }
  getAbsolutePath(filepath) {
    if (path60.default.isAbsolute(filepath))
      return filepath;
    return path60.default.join(this.opts.cwd, filepath);
  }
  getFileRangeRange(range2, lineOnly = true) {
    let {document: document3} = this;
    if (!document3)
      return null;
    let {lnum} = range2;
    let first = document3.getline(lnum - 1);
    if (!first.startsWith("\u3000"))
      return null;
    let start = lineOnly ? lnum : lnum - 1;
    let end = document3.lineCount;
    for (let i = lnum; i < document3.lineCount; i++) {
      let line = document3.getline(i);
      if (line.startsWith("\u3000")) {
        end = lineOnly ? i : i + 1;
        break;
      }
    }
    return vscode_languageserver_protocol78.Range.create(start, 0, end, 0);
  }
  highlightLineNr() {
    let {_fileItems: fileItems, nvim, srcId, bufnr} = this;
    let {winid, cwd} = this.opts;
    let info = {};
    if (srcId) {
      nvim.call("nvim_buf_clear_namespace", [bufnr, srcId, 0, -1], true);
      for (let item of fileItems) {
        for (let range2 of item.ranges) {
          let text = `${range2.start + 1}:${range2.end}`;
          info[range2.lnum] = [range2.start + 1, range2.end];
          nvim.call("nvim_buf_set_virtual_text", [bufnr, srcId, range2.lnum - 1, [[text, "LineNr"]], {}], true);
        }
      }
    } else {
      if (this.matchIds.size) {
        nvim.call("coc#highlight#clear_matches", [winid, Array.from(this.matchIds)], true);
        this.matchIds.clear();
      }
      let id = 2e3;
      for (let item of fileItems) {
        let filename = `${cwd ? path60.default.relative(cwd, item.filepath) : item.filepath}`;
        let col = byteLength(filename) + 1;
        for (let range2 of item.ranges) {
          let text = `:${range2.start + 1}:${range2.end}`;
          for (let i = 0; i < text.length; i++) {
            let ch = text[i];
            this.matchIds.add(id);
            info[range2.lnum] = [range2.start + 1, range2.end];
            nvim.call("matchaddpos", ["Conceal", [[range2.lnum, col + i]], 99, id, {conceal: ch, window: winid}], true);
            id++;
          }
        }
      }
    }
    this.buffer.setVar("line_infos", info, true);
  }
  get valid() {
    return this.buffer.valid;
  }
  get buffer() {
    return this.nvim.createBuffer(this.bufnr);
  }
  get document() {
    if (this._disposed)
      return null;
    return workspace_default.getDocument(this.bufnr);
  }
  dispose() {
    this._disposed = true;
    disposeAll(this.disposables);
  }
};
var buffer_default2 = RefactorBuffer;
function adjustRange(range2, offset) {
  let {start, end} = range2;
  return vscode_languageserver_protocol78.Range.create(start.line - offset, start.character, end.line - offset, end.character);
}

// src/handler/search.ts
var child_process6 = __toModule(require("child_process"));
var events30 = __toModule(require("events"));
var path62 = __toModule(require("path"));
var readline9 = __toModule(require("readline"));
var vscode_languageserver_types7 = __toModule(require_main2());
var which9 = __toModule(require_which());
var logger87 = require_logger2()("handler-search");
var defaultArgs = ["--color", "ansi", "--colors", "path:fg:black", "--colors", "line:fg:green", "--colors", "match:fg:red", "--no-messages", "--heading", "-n"];
var controlCode2 = "";
var Task2 = class extends events30.EventEmitter {
  start(cmd, args, cwd) {
    this.process = child_process6.spawn(cmd, args, {cwd});
    this.process.on("error", (e) => {
      this.emit("error", e.message);
    });
    const rl = readline9.default.createInterface(this.process.stdout);
    let start;
    let fileItem;
    let lines = [];
    let highlights2 = [];
    let create = true;
    rl.on("line", (content) => {
      if (content.includes(controlCode2)) {
        let items = ansiparse(content);
        if (items[0].foreground == "black") {
          fileItem = {filepath: path62.default.join(cwd, items[0].text), ranges: []};
          return;
        }
        let normalLine = items[0].foreground == "green";
        if (normalLine) {
          let lnum = parseInt(items[0].text, 10) - 1;
          let padlen2 = items[0].text.length + 1;
          if (create) {
            start = lnum;
            create = false;
          }
          let line = "";
          for (let item of items) {
            if (item.foreground == "red") {
              let l = lnum - start;
              let c = line.length - padlen2;
              highlights2.push(vscode_languageserver_types7.Range.create(l, c, l, c + item.text.length));
            }
            line += item.text;
          }
          let currline = line.slice(padlen2);
          lines.push(currline);
        }
      } else {
        let fileEnd = content.trim().length == 0;
        if (fileItem && (fileEnd || content.trim() == "--")) {
          let fileRange = {
            lines,
            highlights: highlights2,
            start,
            end: start + lines.length
          };
          fileItem.ranges.push(fileRange);
        }
        if (fileEnd) {
          this.emit("item", fileItem);
          fileItem = null;
        }
        lines = [];
        highlights2 = [];
        create = true;
      }
    });
    rl.on("close", () => {
      if (fileItem) {
        if (lines.length) {
          let fileRange = {
            lines,
            highlights: highlights2,
            start,
            end: start + lines.length
          };
          fileItem.ranges.push(fileRange);
        }
        this.emit("item", fileItem);
      }
      lines = highlights2 = fileItem = null;
      this.emit("end");
    });
  }
  dispose() {
    if (this.process) {
      this.process.kill();
    }
  }
};
var Search = class {
  constructor(nvim, cmd = "rg") {
    this.nvim = nvim;
    this.cmd = cmd;
  }
  run(args, cwd, refactorBuf) {
    let {nvim, cmd} = this;
    let {afterContext, beforeContext} = refactorBuf.config;
    let argList = ["-A", afterContext.toString(), "-B", beforeContext.toString()].concat(defaultArgs, args);
    argList.push("--", "./");
    try {
      cmd = which9.default.sync(cmd);
    } catch (e) {
      window_default.showMessage(`Please install ripgrep and make sure ${this.cmd} is in your $PATH`, "error");
      return Promise.reject(e);
    }
    this.task = new Task2();
    this.task.start(cmd, argList, cwd);
    let mutex7 = new Mutex();
    let files = 0;
    let matches = 0;
    let start = Date.now();
    let fileItems = [];
    const addFileItems = async () => {
      if (fileItems.length == 0)
        return;
      let items = fileItems.slice();
      fileItems = [];
      const release = await mutex7.acquire();
      try {
        await refactorBuf.addFileItems(items);
      } catch (e) {
        logger87.error(e);
      }
      release();
    };
    return new Promise((resolve3, reject) => {
      let interval = setInterval(addFileItems, 100);
      this.task.on("item", async (fileItem) => {
        files++;
        matches = matches + fileItem.ranges.reduce((p, r) => p + r.highlights.length, 0);
        fileItems.push(fileItem);
      });
      this.task.on("error", (message) => {
        clearInterval(interval);
        window_default.showMessage(`Error on command "${cmd}": ${message}`, "error");
        this.task = null;
        reject(new Error(message));
      });
      this.task.on("end", async () => {
        clearInterval(interval);
        try {
          await addFileItems();
          const release = await mutex7.acquire();
          release();
          this.task.removeAllListeners();
          this.task = null;
          let buf = refactorBuf.buffer;
          if (buf) {
            nvim.pauseNotification();
            if (files == 0) {
              buf.setLines(["No match found"], {start: 1, end: 2, strictIndexing: false}, true);
              buf.addHighlight({line: 1, srcId: -1, colEnd: -1, colStart: 0, hlGroup: "Error"}).logError();
              buf.setOption("modified", false, true);
            } else {
              let highligher4 = new highligher_default();
              highligher4.addText("Files", "MoreMsg");
              highligher4.addText(": ");
              highligher4.addText(`${files} `, "Number");
              highligher4.addText("Matches", "MoreMsg");
              highligher4.addText(": ");
              highligher4.addText(`${matches} `, "Number");
              highligher4.addText("Duration", "MoreMsg");
              highligher4.addText(": ");
              highligher4.addText(`${Date.now() - start}ms`, "Number");
              highligher4.render(buf, 1, 2);
            }
            buf.setOption("modified", false, true);
            await nvim.resumeNotification(false, true);
          }
        } catch (e) {
          reject(e);
          return;
        }
        resolve3();
      });
    });
  }
};
var search_default = Search;

// src/handler/refactor/index.ts
var logger88 = require_logger2()("handler-refactor");
var name = "__coc_refactor__";
var refactorId = 0;
var Refactor = class {
  constructor() {
    this.optionsMap = new Map();
    this.disposables = [];
    this._onCreate = new vscode_languageserver_protocol79.Emitter();
    this.onCreate = this._onCreate.event;
    this.nvim = workspace_default.nvim;
    if (workspace_default.isNvim && this.nvim.hasFunction("nvim_buf_set_virtual_text")) {
      this.srcId = workspace_default.createNameSpace("coc-refactor");
    }
    this.setConfiguration();
    workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
    this.buffers = new bufferSync_default((doc) => {
      if (!/__coc_refactor__\d+$/.test(doc.uri))
        return void 0;
      let {bufnr} = doc;
      this._onCreate.fire(bufnr);
      return new buffer_default2(bufnr, this.srcId, this.nvim, this.config, this.optionsMap.get(doc.bufnr));
    }, workspace_default);
  }
  setConfiguration(e) {
    if (e && !e.affectsConfiguration("refactor"))
      return;
    let config = workspace_default.getConfiguration("refactor");
    this.config = Object.assign(this.config || {}, {
      afterContext: config.get("afterContext", 3),
      beforeContext: config.get("beforeContext", 3),
      openCommand: config.get("openCommand", "edit"),
      saveToFile: config.get("saveToFile", true)
    });
  }
  async ensureBuffer(bufnr) {
    let buf = this.getBuffer(bufnr);
    if (buf)
      return buf;
    return new Promise((resolve3, reject) => {
      let timer = this.timer = setTimeout(() => {
        reject(new Error("Document create timeout after 2s."));
      }, 2e3);
      this.onCreate((e) => {
        if (e == bufnr) {
          clearTimeout(timer);
          this.timer = null;
          setImmediate(() => {
            resolve3(this.buffers.getItem(bufnr));
          });
        }
      });
    });
  }
  getBuffer(bufnr) {
    return this.buffers.getItem(bufnr);
  }
  async search(args) {
    let buf = await this.createRefactorBuffer();
    if (!buf)
      return;
    let cwd = await this.nvim.call("getcwd", []);
    let search2 = new search_default(this.nvim);
    await search2.run(args, cwd, buf);
  }
  async createRefactorBuffer(filetype) {
    let {nvim} = this;
    let [fromWinid, cwd] = await nvim.eval("[win_getid(),getcwd()]");
    let {openCommand} = this.config;
    nvim.pauseNotification();
    nvim.command(`${openCommand} ${name}${refactorId++}`, true);
    nvim.command(`setl buftype=acwrite nobuflisted bufhidden=wipe nofen wrap conceallevel=2 concealcursor=n`, true);
    nvim.command(`setl undolevels=-1 nolist nospell noswapfile foldmethod=expr foldexpr=coc#util#refactor_foldlevel(v:lnum)`, true);
    nvim.command(`setl foldtext=coc#util#refactor_fold_text(v:foldstart)`, true);
    nvim.call("setline", [1, ["Save current buffer to make changes", SEPARATOR]], true);
    nvim.call("matchadd", ["Comment", "\\%1l"], true);
    nvim.call("matchadd", ["Conceal", "^\\%u3000"], true);
    nvim.call("matchadd", ["Label", "^\\%u3000\\zs\\S\\+"], true);
    nvim.command("setl nomod", true);
    if (filetype)
      nvim.command(`runtime! syntax/${filetype}.vim`, true);
    nvim.call("coc#util#do_autocmd", ["CocRefactorOpen"], true);
    let [, err] = await nvim.resumeNotification();
    if (err) {
      logger88.error(err);
      window_default.showMessage(`Error on open refactor window: ${err}`, "error");
      return;
    }
    let [bufnr, win] = await nvim.eval('[bufnr("%"),win_getid()]');
    this.optionsMap.set(bufnr, {fromWinid, winid: win, cwd});
    return await this.ensureBuffer(bufnr);
  }
  async fromLines(lines) {
    let buf = await this.createRefactorBuffer();
    if (buf)
      await buf.buffer.setLines(lines, {start: 0, end: -1, strictIndexing: false});
    return buf;
  }
  async fromLocations(locations, filetype) {
    if (!locations || locations.length == 0)
      return null;
    let changes = {};
    let edit2 = {changes};
    for (let location5 of locations) {
      let edits = changes[location5.uri] || [];
      edits.push({range: location5.range, newText: ""});
      changes[location5.uri] = edits;
    }
    return await this.fromWorkspaceEdit(edit2, filetype);
  }
  async fromWorkspaceEdit(edit2, filetype) {
    if (!edit2 || emptyWorkspaceEdit(edit2))
      return void 0;
    let items = [];
    let {beforeContext, afterContext} = this.config;
    let {changes, documentChanges} = edit2;
    if (!changes) {
      changes = {};
      for (let change of documentChanges || []) {
        if (vscode_languageserver_protocol79.TextDocumentEdit.is(change)) {
          let {textDocument, edits} = change;
          if (textDocument.uri.startsWith("file:")) {
            changes[textDocument.uri] = edits;
          }
        }
      }
    }
    for (let key of Object.keys(changes)) {
      let max = await this.getLineCount(key);
      let edits = changes[key];
      let ranges = [];
      let start = null;
      let end = null;
      let highlights2 = [];
      edits.sort((a, b) => a.range.start.line - b.range.start.line);
      for (let edit3 of edits) {
        let {line} = edit3.range.start;
        let s = Math.max(0, line - beforeContext);
        if (start != null && s < end) {
          end = Math.min(max, line + afterContext + 1);
          highlights2.push(adjustRange2(edit3.range, start));
        } else {
          if (start != null)
            ranges.push({start, end, highlights: highlights2});
          start = s;
          end = Math.min(max, line + afterContext + 1);
          highlights2 = [adjustRange2(edit3.range, start)];
        }
      }
      if (start != null)
        ranges.push({start, end, highlights: highlights2});
      items.push({
        ranges,
        filepath: URI.parse(key).fsPath
      });
    }
    let buf = await this.createRefactorBuffer(filetype);
    await buf.addFileItems(items);
    return buf;
  }
  async save(bufnr) {
    let buf = this.buffers.getItem(bufnr);
    if (buf)
      return await buf.save();
  }
  async getLineCount(uri) {
    let doc = workspace_default.getDocument(uri);
    if (doc)
      return doc.lineCount;
    return await getFileLineCount(URI.parse(uri).fsPath);
  }
  reset() {
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.optionsMap.clear();
    this.buffers.reset();
  }
  dispose() {
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.optionsMap.clear();
    this._onCreate.dispose();
    this.buffers.dispose();
    disposeAll(this.disposables);
  }
};
var refactor_default = Refactor;
function adjustRange2(range2, offset) {
  let {start, end} = range2;
  return vscode_languageserver_protocol79.Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
function emptyWorkspaceEdit(edit2) {
  let {changes, documentChanges} = edit2;
  if (documentChanges && documentChanges.length)
    return false;
  if (changes && Object.keys(changes).length)
    return false;
  return true;
}

// src/handler/signature.ts
var vscode_languageserver_protocol80 = __toModule(require_main3());
var logger89 = require_logger2()("handler-signature");
var Signature = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.disposables = [];
    this.signatureFactory = new floatFactory_default(nvim);
    this.loadConfiguration();
    this.disposables.push(this.signatureFactory);
    workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
    events_default.on("CursorMovedI", async (bufnr, cursor) => {
      if (!this.signaturePosition)
        return;
      let doc = workspace_default.getDocument(bufnr);
      if (!doc)
        return;
      let {line, character} = this.signaturePosition;
      if (cursor[0] - 1 == line) {
        let currline = doc.getline(cursor[0] - 1);
        let col = byteLength(currline.slice(0, character)) + 1;
        if (cursor[1] >= col)
          return;
      }
      this.signatureFactory.close();
    }, null, this.disposables);
    events_default.on(["InsertLeave", "BufEnter"], () => {
      var _a2;
      (_a2 = this.tokenSource) == null ? void 0 : _a2.cancel();
      this.signatureFactory.close();
    }, null, this.disposables);
    events_default.on(["TextChangedI", "TextChangedP"], async () => {
      if (this.config.hideOnChange) {
        this.signatureFactory.close();
      }
    }, null, this.disposables);
    let lastInsert;
    events_default.on("InsertCharPre", async () => {
      lastInsert = Date.now();
    }, null, this.disposables);
    events_default.on("TextChangedI", async (bufnr, info) => {
      if (!this.config.trigger)
        return;
      if (!lastInsert || Date.now() - lastInsert > 300)
        return;
      lastInsert = null;
      let doc = workspace_default.getDocument(bufnr);
      if (!doc || doc.isCommandLine || !doc.attached)
        return;
      let pre = info.pre[info.pre.length - 1];
      if (!pre)
        return;
      if (languages_default.shouldTriggerSignatureHelp(doc.textDocument, pre)) {
        await this.triggerSignatureHelp(doc, {line: info.lnum - 1, character: info.pre.length}, false);
      }
    }, null, this.disposables);
  }
  loadConfiguration(e) {
    if (!e || e.affectsConfiguration("signature")) {
      let config = workspace_default.getConfiguration("signature");
      let target = config.get("target", "float");
      if (target == "float" && !workspace_default.floatSupported) {
        target = "echo";
      }
      this.config = {
        target,
        trigger: config.get("enable", true),
        wait: Math.max(config.get("triggerSignatureWait", 500), 200),
        maxWindowHeight: config.get("maxWindowHeight", 80),
        maxWindowWidth: config.get("maxWindowWidth", 80),
        preferAbove: config.get("preferShownAbove", true),
        hideOnChange: config.get("hideOnTextChange", false)
      };
    }
  }
  async triggerSignatureHelp(doc, position15, invoke = true) {
    var _a2;
    (_a2 = this.tokenSource) == null ? void 0 : _a2.cancel();
    let tokenSource = this.tokenSource = new vscode_languageserver_protocol80.CancellationTokenSource();
    let token = tokenSource.token;
    token.onCancellationRequested(() => {
      tokenSource.dispose();
      this.tokenSource = void 0;
    });
    let {target} = this.config;
    let timer = this.timer = setTimeout(() => {
      tokenSource.cancel();
    }, this.config.wait);
    let {changedtick} = doc;
    await doc.patchChange();
    if (changedtick != doc.changedtick) {
      await wait(30);
    }
    if (token.isCancellationRequested) {
      return false;
    }
    let signatureHelp = await languages_default.getSignatureHelp(doc.textDocument, position15, token, {
      isRetrigger: false,
      triggerKind: invoke ? vscode_languageserver_protocol80.SignatureHelpTriggerKind.Invoked : vscode_languageserver_protocol80.SignatureHelpTriggerKind.TriggerCharacter
    });
    clearTimeout(timer);
    if (token.isCancellationRequested)
      return false;
    if (!signatureHelp || signatureHelp.signatures.length == 0) {
      this.signatureFactory.close();
      return false;
    }
    let {activeSignature, signatures} = signatureHelp;
    if (activeSignature) {
      let [active] = signatures.splice(activeSignature, 1);
      if (active)
        signatures.unshift(active);
    }
    if (target == "echo") {
      this.echoSignature(signatureHelp);
    } else {
      await this.showSignatureHelp(doc, position15, signatureHelp);
    }
  }
  async showSignatureHelp(doc, position15, signatureHelp) {
    let {signatures, activeParameter} = signatureHelp;
    let offset = 0;
    let paramDoc = null;
    let docs = signatures.reduce((p, c, idx) => {
      var _a2;
      let activeIndexes = null;
      let nameIndex = c.label.indexOf("(");
      if (idx == 0 && activeParameter != null) {
        let active = (_a2 = c.parameters) == null ? void 0 : _a2[activeParameter];
        if (active) {
          let after = c.label.slice(nameIndex == -1 ? 0 : nameIndex);
          paramDoc = active.documentation;
          if (typeof active.label === "string") {
            let str = after.slice(0);
            let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
            let index = ms ? ms.index : str.indexOf(active.label);
            if (index != -1) {
              activeIndexes = [
                index + nameIndex,
                index + active.label.length + nameIndex
              ];
            }
          } else {
            activeIndexes = active.label;
          }
        }
      }
      if (activeIndexes == null) {
        activeIndexes = [nameIndex + 1, nameIndex + 1];
      }
      if (offset == 0) {
        offset = activeIndexes[0] + 1;
      }
      p.push({
        content: c.label,
        filetype: doc.filetype,
        active: activeIndexes
      });
      if (paramDoc) {
        let content = typeof paramDoc === "string" ? paramDoc : paramDoc.value;
        if (content.trim().length) {
          p.push({
            content,
            filetype: isMarkdown2(c.documentation) ? "markdown" : "txt"
          });
        }
      }
      if (idx == 0 && c.documentation) {
        let {documentation} = c;
        let content = typeof documentation === "string" ? documentation : documentation.value;
        if (content.trim().length) {
          p.push({
            content,
            filetype: isMarkdown2(c.documentation) ? "markdown" : "txt"
          });
        }
      }
      return p;
    }, []);
    let session4 = manager_default3.getSession(doc.bufnr);
    if (session4 && session4.isActive) {
      let {value} = session4.placeholder;
      if (!value.includes("\n"))
        offset += value.length;
      this.signaturePosition = vscode_languageserver_protocol80.Position.create(position15.line, position15.character - value.length);
    } else {
      this.signaturePosition = position15;
    }
    let {preferAbove, maxWindowHeight, maxWindowWidth} = this.config;
    await this.signatureFactory.show(docs, {
      maxWidth: maxWindowWidth,
      maxHeight: maxWindowHeight,
      preferTop: preferAbove,
      autoHide: false,
      offsetX: offset,
      modes: ["i", "ic", "s"]
    });
  }
  echoSignature(signatureHelp) {
    var _a2;
    let {signatures, activeParameter} = signatureHelp;
    let columns = workspace_default.env.columns;
    signatures = signatures.slice(0, workspace_default.env.cmdheight);
    let signatureList = [];
    for (let signature2 of signatures) {
      let parts = [];
      let {label} = signature2;
      label = label.replace(/\n/g, " ");
      if (label.length >= columns - 16) {
        label = label.slice(0, columns - 16) + "...";
      }
      let nameIndex = label.indexOf("(");
      if (nameIndex == -1) {
        parts = [{text: label, type: "Normal"}];
      } else {
        parts.push({
          text: label.slice(0, nameIndex),
          type: "Label"
        });
        let after = label.slice(nameIndex);
        if (signatureList.length == 0 && activeParameter != null) {
          let active = (_a2 = signature2.parameters) == null ? void 0 : _a2[activeParameter];
          if (active) {
            let start;
            let end;
            if (typeof active.label === "string") {
              let str = after.slice(0);
              let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
              let idx = ms ? ms.index : str.indexOf(active.label);
              if (idx == -1) {
                parts.push({text: after, type: "Normal"});
              } else {
                start = idx;
                end = idx + active.label.length;
              }
            } else {
              [start, end] = active.label;
              start = start - nameIndex;
              end = end - nameIndex;
            }
            if (start != null && end != null) {
              parts.push({text: after.slice(0, start), type: "Normal"});
              parts.push({text: after.slice(start, end), type: "MoreMsg"});
              parts.push({text: after.slice(end), type: "Normal"});
            }
          }
        } else {
          parts.push({
            text: after,
            type: "Normal"
          });
        }
      }
      signatureList.push(parts);
    }
    this.nvim.callTimer("coc#util#echo_signatures", [signatureList], true);
  }
  dispose() {
    disposeAll(this.disposables);
    if (this.timer) {
      clearTimeout(this.timer);
    }
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource.dispose();
    }
  }
};
var signature_default = Signature;
function isMarkdown2(content) {
  if (vscode_languageserver_protocol80.MarkupContent.is(content) && content.kind == vscode_languageserver_protocol80.MarkupKind.Markdown) {
    return true;
  }
  return false;
}

// src/handler/symbols.ts
var debounce23 = __toModule(require_debounce());
var vscode_languageserver_protocol81 = __toModule(require_main3());
var Symbols2 = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.disposables = [];
    this.buffers = workspace_default.registerBufferSync((doc) => {
      if (doc.buftype != "")
        return void 0;
      let buf = new SymbolsBuffer(doc.bufnr);
      buf.onDidUpdate(async (symbols3) => {
        await events_default.fire("SymbolsUpdate", [buf.bufnr, symbols3]);
      });
      return buf;
    });
    events_default.on("CursorHold", async (bufnr) => {
      if (!this.functionUpdate || this.buffers.getItem(bufnr) == null)
        return;
      await this.getCurrentFunctionSymbol(bufnr);
    }, null, this.disposables);
  }
  get functionUpdate() {
    let config = workspace_default.getConfiguration("coc.preferences");
    return config.get("currentFunctionSymbolAutoUpdate", false);
  }
  get labels() {
    return workspace_default.getConfiguration("suggest").get("completionItemKindLabels", {});
  }
  async getDocumentSymbols(bufnr) {
    let buf = this.buffers.getItem(bufnr);
    return buf == null ? void 0 : buf.getSymbols();
  }
  async getCurrentFunctionSymbol(bufnr) {
    if (!bufnr)
      bufnr = await this.nvim.call("bufnr", ["%"]);
    let position15 = await window_default.getCursorPosition();
    let symbols3 = await this.getDocumentSymbols(bufnr);
    let buffer4 = this.nvim.createBuffer(bufnr);
    if (!symbols3 || symbols3.length === 0) {
      buffer4.setVar("coc_current_function", "", true);
      this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
      return "";
    }
    symbols3 = symbols3.filter((s) => [
      "Class",
      "Method",
      "Function",
      "Struct"
    ].includes(s.kind));
    let functionName = "";
    for (let sym of symbols3.reverse()) {
      if (sym.range && positionInRange(position15, sym.range) == 0 && !sym.text.endsWith(") callback")) {
        functionName = sym.text;
        let label = this.labels[sym.kind.toLowerCase()];
        if (label)
          functionName = `${label} ${functionName}`;
        break;
      }
    }
    if (this.functionUpdate) {
      buffer4.setVar("coc_current_function", functionName, true);
      this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
    }
    return functionName;
  }
  async selectSymbolRange(inner, visualmode, supportedSymbols) {
    let bufnr = await this.nvim.call("bufnr", ["%"]);
    let doc = workspace_default.getDocument(bufnr);
    if (!doc || !doc.attached)
      return;
    let range2;
    if (visualmode) {
      range2 = await workspace_default.getSelectedRange(visualmode, doc);
    } else {
      let pos = await window_default.getCursorPosition();
      range2 = vscode_languageserver_protocol81.Range.create(pos, pos);
    }
    let symbols3 = await this.getDocumentSymbols(bufnr);
    if (!symbols3 || symbols3.length === 0) {
      window_default.showMessage("No symbols found", "warning");
      return;
    }
    let properties = symbols3.filter((s) => s.kind == "Property");
    symbols3 = symbols3.filter((s) => supportedSymbols.includes(s.kind));
    let selectRange;
    for (let sym of symbols3.reverse()) {
      if (sym.range && !equals(sym.range, range2) && rangeInRange(range2, sym.range)) {
        selectRange = sym.range;
        break;
      }
    }
    if (!selectRange) {
      for (let sym of properties) {
        if (sym.range && !equals(sym.range, range2) && rangeInRange(range2, sym.range)) {
          selectRange = sym.range;
          break;
        }
      }
    }
    if (inner && selectRange) {
      let {start, end} = selectRange;
      let line = doc.getline(start.line + 1);
      let endLine = doc.getline(end.line - 1);
      selectRange = vscode_languageserver_protocol81.Range.create(start.line + 1, line.match(/^\s*/)[0].length, end.line - 1, endLine.length);
    }
    if (selectRange)
      await workspace_default.selectRange(selectRange);
  }
  dispose() {
    this.buffers.dispose();
    disposeAll(this.disposables);
  }
};
var symbols_default2 = Symbols2;
var SymbolsBuffer = class {
  constructor(bufnr) {
    this.bufnr = bufnr;
    this.disposables = [];
    this.autoUpdate = false;
    this.symbols = [];
    this._onDidUpdate = new vscode_languageserver_protocol81.Emitter();
    this.onDidUpdate = this._onDidUpdate.event;
    this.fetchSymbols = debounce23.default(() => {
      this._fetchSymbols().logError();
    }, global.hasOwnProperty("__TEST__") ? 10 : 500);
  }
  async getSymbols() {
    let doc = workspace_default.getDocument(this.bufnr);
    if (!doc)
      return [];
    doc.forceSync();
    this.autoUpdate = true;
    if (doc.version == this.version)
      return this.symbols;
    this.cancel();
    await this._fetchSymbols();
    return this.symbols;
  }
  onChange() {
    this.cancel();
  }
  get textDocument() {
    var _a2;
    return (_a2 = workspace_default.getDocument(this.bufnr)) == null ? void 0 : _a2.textDocument;
  }
  async _fetchSymbols() {
    let {textDocument} = this;
    if (!textDocument || textDocument.version == this.version)
      return;
    let {version: version2} = textDocument;
    let tokenSource = this.tokenSource = new vscode_languageserver_protocol81.CancellationTokenSource();
    let {token} = tokenSource;
    let symbols3 = await languages_default.getDocumentSymbol(textDocument, token);
    this.tokenSource = void 0;
    if (symbols3 == null || token.isCancellationRequested)
      return;
    let level = 0;
    let res = [];
    let pre = null;
    if (isDocumentSymbols(symbols3)) {
      symbols3.sort(sortDocumentSymbols);
      symbols3.forEach((s) => addDoucmentSymbol(res, s, level));
    } else {
      symbols3.sort(sortSymbolInformations);
      for (let sym of symbols3) {
        let {name: name2, kind, location: location5, containerName} = sym;
        if (!containerName || !pre) {
          level = 0;
        } else {
          if (pre.containerName == containerName) {
            level = pre.level || 0;
          } else {
            let container = getPreviousContainer(containerName, res);
            level = container ? container.level + 1 : 0;
          }
        }
        let {start} = location5.range;
        let o = {
          col: start.character + 1,
          lnum: start.line + 1,
          text: name2,
          level,
          kind: getSymbolKind(kind),
          range: location5.range,
          containerName
        };
        res.push(o);
        pre = o;
      }
    }
    this.version = version2;
    this.symbols = res;
    if (isDocumentSymbols(symbols3)) {
      this._onDidUpdate.fire(symbols3);
    } else {
      this._onDidUpdate.fire(symbols3.map((o) => {
        return vscode_languageserver_protocol81.DocumentSymbol.create(o.name, "", o.kind, o.location.range, o.location.range);
      }));
    }
  }
  cancel() {
    this.fetchSymbols.clear();
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource = null;
    }
  }
  dispose() {
    this.cancel();
    this.symbols = void 0;
    this._onDidUpdate.dispose();
    disposeAll(this.disposables);
  }
};

// src/handler/index.ts
var logger90 = require_logger2()("Handler");
var Handler = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.documentLines = [];
    this.selectionRange = null;
    this.disposables = [];
    this.getPreferences();
    this.requestStatusItem = window_default.createStatusBarItem(0, {progress: true});
    workspace_default.onDidChangeConfiguration(() => {
      this.getPreferences();
    });
    this.refactor = new refactor_default();
    this.hoverFactory = new floatFactory_default(nvim);
    this.signature = new signature_default(nvim);
    this.format = new format_default(nvim);
    this.symbols = new symbols_default2(nvim);
    events_default.on(["CursorMoved", "CursorMovedI", "InsertEnter", "InsertSnippet", "InsertLeave"], () => {
      if (this.requestTokenSource) {
        this.requestTokenSource.cancel();
      }
    }, null, this.disposables);
    let provider = {
      onDidChange: null,
      provideTextDocumentContent: async () => {
        nvim.pauseNotification();
        nvim.command("setlocal conceallevel=2 nospell nofoldenable wrap", true);
        nvim.command("setlocal bufhidden=wipe nobuflisted", true);
        nvim.command("setfiletype markdown", true);
        nvim.command(`if winnr('j') != winnr('k') | exe "normal! z${Math.min(this.documentLines.length, this.preferences.previewMaxHeight)}\\<cr> | endif"`, true);
        await nvim.resumeNotification();
        return this.documentLines.join("\n");
      }
    };
    this.disposables.push(workspace_default.registerTextDocumentContentProvider("coc", provider));
    this.codeLens = new codelens_default(nvim);
    this.colors = new colors_default(nvim);
    this.documentHighlighter = new highlights_default(nvim);
    this.disposables.push(commands_default.registerCommand("editor.action.pickColor", () => {
      return this.colors.pickColor();
    }));
    commands_default.titles.set("editor.action.pickColor", "pick color from system color picker when possible.");
    this.disposables.push(commands_default.registerCommand("editor.action.colorPresentation", () => {
      return this.colors.pickPresentation();
    }));
    commands_default.titles.set("editor.action.colorPresentation", "change color presentation.");
    this.disposables.push(commands_default.registerCommand("editor.action.organizeImport", async (bufnr) => {
      if (!bufnr)
        bufnr = await nvim.call("bufnr", "%");
      let doc = workspace_default.getDocument(bufnr);
      if (!doc || !doc.attached)
        return false;
      await synchronizeDocument(doc);
      let actions = await this.getCodeActions(doc, void 0, [vscode_languageserver_protocol82.CodeActionKind.SourceOrganizeImports]);
      if (actions && actions.length) {
        await this.applyCodeAction(actions[0]);
        return true;
      }
      window_default.showMessage(`Organize import action not found.`, "warning");
      return false;
    }));
    commands_default.titles.set("editor.action.organizeImport", "run organize import code action.");
  }
  async withRequestToken(name2, fn, checkEmpty) {
    if (this.requestTokenSource) {
      this.requestTokenSource.cancel();
      this.requestTokenSource.dispose();
    }
    if (this.requestTimer) {
      clearTimeout(this.requestTimer);
    }
    let statusItem = this.requestStatusItem;
    this.requestTokenSource = new vscode_languageserver_protocol82.CancellationTokenSource();
    let {token} = this.requestTokenSource;
    token.onCancellationRequested(() => {
      statusItem.text = `${name2} request canceled`;
      statusItem.isProgress = false;
      this.requestTimer = setTimeout(() => {
        statusItem.hide();
      }, 500);
    });
    statusItem.isProgress = true;
    statusItem.text = `requesting ${name2}`;
    statusItem.show();
    let res;
    try {
      res = await Promise.resolve(fn(token));
    } catch (e) {
      window_default.showMessage(e.message, "error");
      logger90.error(`Error on ${name2}`, e);
    }
    if (this.requestTokenSource) {
      this.requestTokenSource.dispose();
      this.requestTokenSource = void 0;
    }
    if (token.isCancellationRequested)
      return null;
    statusItem.hide();
    if (res == null) {
      logger90.warn(`${name2} provider not found!`);
    } else if (checkEmpty && Array.isArray(res) && res.length == 0) {
      window_default.showMessage(`${name2} not found`, "warning");
      return null;
    }
    return res;
  }
  async getCurrentFunctionSymbol() {
    return await this.symbols.getCurrentFunctionSymbol();
  }
  async selectSymbolRange(inner, visualmode, supportedSymbols) {
    return await this.symbols.selectSymbolRange(inner, visualmode, supportedSymbols);
  }
  async getDocumentSymbols(bufnr) {
    return await this.symbols.getDocumentSymbols(bufnr);
  }
  async hasProvider(id) {
    let bufnr = await this.nvim.call("bufnr", "%");
    let doc = workspace_default.getDocument(bufnr);
    if (!doc)
      return false;
    return languages_default.hasProvider(id, doc.textDocument);
  }
  async onHover(hoverTarget) {
    let {doc, position: position15, winid} = await this.getCurrentState();
    if (doc == null)
      return;
    let target = hoverTarget != null ? hoverTarget : this.preferences.hoverTarget;
    if (target == "float") {
      this.hoverFactory.close();
    }
    await synchronizeDocument(doc);
    let hovers = await this.withRequestToken("hover", (token) => {
      return languages_default.getHover(doc.textDocument, position15, token);
    }, true);
    if (hovers == null)
      return false;
    let hover = hovers.find((o) => vscode_languageserver_protocol82.Range.is(o.range));
    if (hover == null ? void 0 : hover.range) {
      let win = this.nvim.createWindow(winid);
      let ids = await win.highlightRanges("CocHoverRange", [hover.range], 99);
      setTimeout(() => {
        if (ids.length)
          win.clearMatches(ids);
        if (workspace_default.isVim)
          this.nvim.command("redraw", true);
      }, 1e3);
    }
    await this.previewHover(hovers, target);
    return true;
  }
  async getHover() {
    let result = [];
    let {doc, position: position15} = await this.getCurrentState();
    if (!languages_default.hasProvider("hover", doc.textDocument)) {
      return result;
    }
    await synchronizeDocument(doc);
    let tokenSource = new vscode_languageserver_protocol82.CancellationTokenSource();
    let hovers = await languages_default.getHover(doc.textDocument, position15, tokenSource.token);
    if (Array.isArray(hovers)) {
      for (let h of hovers) {
        let {contents} = h;
        if (Array.isArray(contents)) {
          contents.forEach((c) => {
            result.push(typeof c === "string" ? c : c.value);
          });
        } else if (vscode_languageserver_protocol82.MarkupContent.is(contents)) {
          result.push(contents.value);
        } else {
          result.push(typeof contents === "string" ? contents : contents.value);
        }
      }
    }
    result = result.filter((s) => s != null && s.length > 0);
    return result;
  }
  async gotoDefinition(openCommand) {
    let {doc, position: position15} = await this.getCurrentState();
    if (doc == null)
      return false;
    await synchronizeDocument(doc);
    let definition = await this.withRequestToken("definition", (token) => {
      return languages_default.getDefinition(doc.textDocument, position15, token);
    }, true);
    if (definition == null)
      return false;
    await this.handleLocations(definition, openCommand);
    return true;
  }
  async gotoDeclaration(openCommand) {
    let {doc, position: position15} = await this.getCurrentState();
    if (doc == null)
      return false;
    await synchronizeDocument(doc);
    let definition = await this.withRequestToken("declaration", (token) => {
      return languages_default.getDeclaration(doc.textDocument, position15, token);
    }, true);
    if (definition == null)
      return false;
    await this.handleLocations(definition, openCommand);
    return true;
  }
  async gotoTypeDefinition(openCommand) {
    let {doc, position: position15} = await this.getCurrentState();
    if (doc == null)
      return false;
    await synchronizeDocument(doc);
    let definition = await this.withRequestToken("type definition", (token) => {
      return languages_default.getTypeDefinition(doc.textDocument, position15, token);
    }, true);
    if (definition == null)
      return false;
    await this.handleLocations(definition, openCommand);
    return true;
  }
  async gotoImplementation(openCommand) {
    let {doc, position: position15} = await this.getCurrentState();
    if (doc == null)
      return false;
    await synchronizeDocument(doc);
    let definition = await this.withRequestToken("implementation", (token) => {
      return languages_default.getImplementation(doc.textDocument, position15, token);
    }, true);
    if (definition == null)
      return false;
    await this.handleLocations(definition, openCommand);
    return true;
  }
  async gotoReferences(openCommand, includeDeclaration = true) {
    let {doc, position: position15} = await this.getCurrentState();
    if (doc == null)
      return false;
    await synchronizeDocument(doc);
    let definition = await this.withRequestToken("references", (token) => {
      return languages_default.getReferences(doc.textDocument, {includeDeclaration}, position15, token);
    }, true);
    if (definition == null)
      return false;
    await this.handleLocations(definition, openCommand);
    return true;
  }
  async getWordEdit() {
    let {doc, position: position15} = await this.getCurrentState();
    if (doc == null)
      return null;
    let range2 = doc.getWordRangeAtPosition(position15);
    if (!range2 || emptyRange(range2))
      return null;
    let curname = doc.textDocument.getText(range2);
    if (languages_default.hasProvider("rename", doc.textDocument)) {
      await synchronizeDocument(doc);
      let requestTokenSource = new vscode_languageserver_protocol82.CancellationTokenSource();
      let res = await languages_default.prepareRename(doc.textDocument, position15, requestTokenSource.token);
      if (res === false)
        return null;
      let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position15, curname, requestTokenSource.token);
      if (edit2)
        return edit2;
    }
    window_default.showMessage("Rename provider not found, extract word ranges from current buffer", "more");
    let ranges = doc.getSymbolRanges(curname);
    return {
      changes: {
        [doc.uri]: ranges.map((r) => ({range: r, newText: curname}))
      }
    };
  }
  async rename(newName) {
    let {doc, position: position15} = await this.getCurrentState();
    if (doc == null)
      return false;
    let {nvim} = this;
    if (!languages_default.hasProvider("rename", doc.textDocument)) {
      window_default.showMessage(`Rename provider not found for current document`, "warning");
      return false;
    }
    await synchronizeDocument(doc);
    let statusItem = this.requestStatusItem;
    try {
      let token = new vscode_languageserver_protocol82.CancellationTokenSource().token;
      let res = await languages_default.prepareRename(doc.textDocument, position15, token);
      if (res === false) {
        statusItem.hide();
        window_default.showMessage("Invalid position for rename", "warning");
        return false;
      }
      if (token.isCancellationRequested)
        return false;
      let curname;
      if (!newName) {
        if (vscode_languageserver_protocol82.Range.is(res)) {
          curname = doc.textDocument.getText(res);
          await window_default.moveTo(res.start);
        } else if (res && typeof res.placeholder === "string") {
          curname = res.placeholder;
        } else {
          curname = await nvim.eval('expand("<cword>")');
        }
        newName = await window_default.requestInput("New name", curname);
      }
      if (!newName) {
        statusItem.hide();
        return false;
      }
      let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position15, newName, token);
      if (token.isCancellationRequested)
        return false;
      statusItem.hide();
      if (!edit2) {
        window_default.showMessage("Invalid position for rename", "warning");
        return false;
      }
      await workspace_default.applyEdit(edit2);
      return true;
    } catch (e) {
      statusItem.hide();
      window_default.showMessage(`Error on rename: ${e.message}`, "error");
      logger90.error(e);
      return false;
    }
  }
  async documentFormatting() {
    return await this.format.documentFormat();
  }
  async documentRangeFormatting(mode) {
    return await this.format.documentRangeFormat(mode);
  }
  async getTagList() {
    let {doc, position: position15} = await this.getCurrentState();
    let word = await this.nvim.call("expand", "<cword>");
    if (!word || doc == null)
      return null;
    if (!languages_default.hasProvider("definition", doc.textDocument))
      return null;
    let tokenSource = new vscode_languageserver_protocol82.CancellationTokenSource();
    let definitions = await languages_default.getDefinition(doc.textDocument, position15, tokenSource.token);
    if (!definitions || !definitions.length)
      return null;
    return definitions.map((location5) => {
      let parsedURI = URI.parse(location5.uri);
      const filename = parsedURI.scheme == "file" ? parsedURI.fsPath : parsedURI.toString();
      return {
        name: word,
        cmd: `keepjumps ${location5.range.start.line + 1} | normal ${location5.range.start.character + 1}|`,
        filename
      };
    });
  }
  async runCommand(id, ...args) {
    if (id) {
      await events_default.fire("Command", [id]);
      let res = await commands_default.executeCommand(id, ...args);
      if (args.length == 0) {
        await commands_default.addRecent(id);
      }
      return res;
    } else {
      await manager_default4.start(["commands"]);
    }
  }
  async getCodeActions(doc, range2, only) {
    range2 = range2 || vscode_languageserver_protocol82.Range.create(0, 0, doc.lineCount, 0);
    let diagnostics2 = manager_default.getDiagnosticsInRange(doc.textDocument, range2);
    let context = {diagnostics: diagnostics2};
    if (only && Array.isArray(only))
      context.only = only;
    let codeActions = await this.withRequestToken("code action", (token) => {
      return languages_default.getCodeActions(doc.textDocument, range2, context, token);
    });
    if (!codeActions || codeActions.length == 0)
      return [];
    codeActions.sort((a, b) => {
      if (a.isPreferred && !b.isPreferred) {
        return -1;
      }
      if (b.isPreferred && !a.isPreferred) {
        return 1;
      }
      return 0;
    });
    return codeActions;
  }
  async doCodeAction(mode, only) {
    let {doc} = await this.getCurrentState();
    if (!doc)
      return;
    let range2;
    if (mode)
      range2 = await workspace_default.getSelectedRange(mode, doc);
    await synchronizeDocument(doc);
    let codeActions = await this.getCodeActions(doc, range2, Array.isArray(only) ? only : null);
    if (only && typeof only == "string") {
      codeActions = codeActions.filter((o) => o.title == only || o.command && o.command.title == only);
    }
    if (!codeActions || codeActions.length == 0) {
      window_default.showMessage(`No${only ? " " + only : ""} code action available`, "warning");
      return;
    }
    let idx = await window_default.showMenuPicker(codeActions.map((o) => o.title), "Choose action");
    let action = codeActions[idx];
    if (action)
      await this.applyCodeAction(action);
  }
  async getCurrentCodeActions(mode, only) {
    let {doc} = await this.getCurrentState();
    if (!doc)
      return [];
    let range2;
    if (mode)
      range2 = await workspace_default.getSelectedRange(mode, doc);
    return await this.getCodeActions(doc, range2, only);
  }
  async doQuickfix() {
    let actions = await this.getCurrentCodeActions("n", [vscode_languageserver_protocol82.CodeActionKind.QuickFix]);
    if (!actions || actions.length == 0) {
      window_default.showMessage("No quickfix action available", "warning");
      return false;
    }
    await this.applyCodeAction(actions[0]);
    await this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-fix-current)", -1)`);
    return true;
  }
  async applyCodeAction(action) {
    let {command, edit: edit2} = action;
    if (edit2)
      await workspace_default.applyEdit(edit2);
    if (command) {
      if (commands_default.has(command.command)) {
        commands_default.execute(command);
      } else {
        let clientId = action.clientId;
        let service = services_default.getService(clientId);
        let params = {
          command: command.command,
          arguments: command.arguments
        };
        if (service.client) {
          let {client: client8} = service;
          client8.sendRequest(vscode_languageserver_protocol82.ExecuteCommandRequest.type, params).then(void 0, (error) => {
            window_default.showMessage(`Execute '${command.command} error: ${error}'`, "error");
          });
        }
      }
    }
  }
  async doCodeLensAction() {
    await this.codeLens.doAction();
  }
  async fold(kind) {
    let {doc, winid} = await this.getCurrentState();
    if (!doc)
      return false;
    await synchronizeDocument(doc);
    let win = this.nvim.createWindow(winid);
    let [foldmethod, foldlevel] = await this.nvim.eval("[&foldmethod,&foldlevel]");
    if (foldmethod != "manual") {
      window_default.showMessage("foldmethod option should be manual!", "warning");
      return false;
    }
    let ranges = await this.withRequestToken("folding range", (token) => {
      return languages_default.provideFoldingRanges(doc.textDocument, {}, token);
    }, true);
    if (!ranges)
      return false;
    if (kind)
      ranges = ranges.filter((o) => o.kind == kind);
    if (ranges.length) {
      ranges.sort((a, b) => b.startLine - a.startLine);
      this.nvim.pauseNotification();
      for (let range2 of ranges) {
        let {startLine, endLine} = range2;
        let cmd = `${startLine + 1}, ${endLine + 1}fold`;
        this.nvim.command(cmd, true);
      }
      win.setOption("foldlevel", foldlevel, true);
      await this.nvim.resumeNotification();
      return true;
    }
    return false;
  }
  async pickColor() {
    await this.colors.pickColor();
  }
  async pickPresentation() {
    await this.colors.pickPresentation();
  }
  async highlight() {
    await this.documentHighlighter.highlight();
  }
  async getSymbolsRanges() {
    let {doc, position: position15} = await this.getCurrentState();
    let highlights2 = await this.documentHighlighter.getHighlights(doc, position15);
    if (!highlights2)
      return null;
    return highlights2.map((o) => o.range);
  }
  async links() {
    let {doc} = await this.getCurrentState();
    if (!doc)
      return [];
    let links3 = await this.withRequestToken("links", (token) => {
      return languages_default.getDocumentLinks(doc.textDocument, token);
    });
    links3 = links3 || [];
    let res = [];
    for (let link of links3) {
      if (link.target) {
        res.push(link);
      } else {
        link = await languages_default.resolveDocumentLink(link);
        res.push(link);
      }
    }
    return links3;
  }
  async openLink() {
    let {doc, position: position15} = await this.getCurrentState();
    let links3 = await this.withRequestToken("links", (token) => {
      return languages_default.getDocumentLinks(doc.textDocument, token);
    });
    if (!links3 || links3.length == 0)
      return false;
    for (let link of links3) {
      if (positionInRange(position15, link.range)) {
        let {target} = link;
        if (!target) {
          link = await languages_default.resolveDocumentLink(link);
          target = link.target;
        }
        if (target) {
          await workspace_default.openResource(target);
          return true;
        }
        return false;
      }
    }
    return false;
  }
  async getCommands() {
    let list2 = commands_default.commandList;
    let res = [];
    let {titles} = commands_default;
    for (let item of list2) {
      res.push({
        id: item.id,
        title: titles.get(item.id) || ""
      });
    }
    return res;
  }
  async showSignatureHelp() {
    let {doc, position: position15} = await this.getCurrentState();
    if (!doc)
      return false;
    return await this.signature.triggerSignatureHelp(doc, position15);
  }
  async findLocations(id, method, params, openCommand) {
    let {doc, position: position15} = await this.getCurrentState();
    if (!doc)
      return null;
    params = params || {};
    Object.assign(params, {
      textDocument: {uri: doc.uri},
      position: position15
    });
    let res = await services_default.sendRequest(id, method, params);
    res = res || [];
    let locations = [];
    if (Array.isArray(res)) {
      locations = res;
    } else if (res.hasOwnProperty("location") && res.hasOwnProperty("children")) {
      let getLocation2 = (item) => {
        locations.push(item.location);
        if (item.children && item.children.length) {
          for (let loc of item.children) {
            getLocation2(loc);
          }
        }
      };
      getLocation2(res);
    }
    await this.handleLocations(locations, openCommand);
  }
  async handleLocations(definition, openCommand) {
    if (!definition)
      return;
    let locations = Array.isArray(definition) ? definition : [definition];
    let len = locations.length;
    if (len == 0)
      return;
    if (len == 1 && openCommand !== false) {
      let location5 = definition[0];
      if (vscode_languageserver_protocol82.LocationLink.is(definition[0])) {
        let link = definition[0];
        location5 = vscode_languageserver_protocol82.Location.create(link.targetUri, link.targetRange);
      }
      let {uri, range: range2} = location5;
      await workspace_default.jumpTo(uri, range2.start, openCommand);
    } else {
      await workspace_default.showLocations(definition);
    }
  }
  async getSelectionRanges() {
    let {doc, position: position15} = await this.getCurrentState();
    await synchronizeDocument(doc);
    let selectionRanges = await this.withRequestToken("selection ranges", (token) => {
      return languages_default.getSelectionRanges(doc.textDocument, [position15], token);
    });
    if (selectionRanges && selectionRanges.length)
      return selectionRanges;
    return null;
  }
  async selectRange(visualmode, forward) {
    let {nvim} = this;
    let {doc} = await this.getCurrentState();
    if (!doc)
      return;
    let positions2 = [];
    if (!forward && (!this.selectionRange || !visualmode))
      return;
    if (visualmode) {
      let range2 = await workspace_default.getSelectedRange(visualmode, doc);
      positions2.push(range2.start, range2.end);
    } else {
      let position15 = await window_default.getCursorPosition();
      positions2.push(position15);
    }
    if (!forward) {
      let curr = vscode_languageserver_protocol82.Range.create(positions2[0], positions2[1]);
      let {selectionRange: selectionRange3} = this;
      while (selectionRange3 && selectionRange3.parent) {
        if (equals(selectionRange3.parent.range, curr)) {
          break;
        }
        selectionRange3 = selectionRange3.parent;
      }
      if (selectionRange3 && selectionRange3.parent) {
        await workspace_default.selectRange(selectionRange3.range);
      }
      return;
    }
    await synchronizeDocument(doc);
    let selectionRanges = await this.withRequestToken("selection ranges", (token) => {
      return languages_default.getSelectionRanges(doc.textDocument, positions2, token);
    });
    if (!selectionRanges || selectionRanges.length == 0)
      return;
    let mode = await nvim.eval("mode()");
    if (mode != "n")
      await nvim.eval(`feedkeys("\\<Esc>", 'in')`);
    let selectionRange2;
    if (selectionRanges.length == 1) {
      selectionRange2 = selectionRanges[0];
    } else if (positions2.length > 1) {
      let r = vscode_languageserver_protocol82.Range.create(positions2[0], positions2[1]);
      selectionRange2 = selectionRanges[0];
      while (selectionRange2) {
        if (equals(r, selectionRange2.range)) {
          selectionRange2 = selectionRange2.parent;
          continue;
        }
        if (positionInRange(positions2[1], selectionRange2.range) == 0) {
          break;
        }
        selectionRange2 = selectionRange2.parent;
      }
    }
    if (!selectionRange2)
      return;
    this.selectionRange = selectionRanges[0];
    await workspace_default.selectRange(selectionRange2.range);
  }
  async codeActionRange(start, end, only) {
    let {doc} = await this.getCurrentState();
    if (!doc)
      return;
    await synchronizeDocument(doc);
    let line = doc.getline(end - 1);
    let range2 = vscode_languageserver_protocol82.Range.create(start - 1, 0, end - 1, line.length);
    let codeActions = await this.getCodeActions(doc, range2, only ? [only] : null);
    if (!codeActions || codeActions.length == 0) {
      window_default.showMessage(`No${only ? " " + only : ""} code action available`, "warning");
      return;
    }
    let idx = await window_default.showMenuPicker(codeActions.map((o) => o.title), "Choose action");
    let action = codeActions[idx];
    if (action)
      await this.applyCodeAction(action);
  }
  async doRefactor() {
    let [bufnr, cursor, filetype] = await this.nvim.eval('[bufnr("%"),coc#util#cursor(),&filetype]');
    let doc = workspace_default.getDocument(bufnr);
    if (!doc || !doc.attached)
      return;
    await synchronizeDocument(doc);
    let position15 = {line: cursor[0], character: cursor[1]};
    let edit2 = await this.withRequestToken("refactor", async (token) => {
      let res = await languages_default.prepareRename(doc.textDocument, position15, token);
      if (token.isCancellationRequested)
        return null;
      if (res === false) {
        window_default.showMessage("Invalid position", "warning");
        return null;
      }
      let edit3 = await languages_default.provideRenameEdits(doc.textDocument, position15, "NewName", token);
      if (token.isCancellationRequested)
        return null;
      if (!edit3) {
        window_default.showMessage("Empty workspaceEdit from language server", "warning");
        return null;
      }
      return edit3;
    });
    if (edit2) {
      await this.refactor.fromWorkspaceEdit(edit2, filetype);
    }
  }
  async saveRefactor(bufnr) {
    await this.refactor.save(bufnr);
  }
  async search(args) {
    await this.refactor.search(args);
  }
  async previewHover(hovers, target) {
    let docs = [];
    let isPreview = target === "preview";
    for (let hover of hovers) {
      let {contents} = hover;
      if (Array.isArray(contents)) {
        for (let item of contents) {
          if (typeof item === "string") {
            addDocument(docs, item, "markdown", isPreview);
          } else {
            addDocument(docs, item.value, item.language, isPreview);
          }
        }
      } else if (vscode_languageserver_protocol82.MarkedString.is(contents)) {
        if (typeof contents == "string") {
          addDocument(docs, contents, "markdown", isPreview);
        } else {
          addDocument(docs, contents.value, contents.language, isPreview);
        }
      } else if (vscode_languageserver_protocol82.MarkupContent.is(contents)) {
        addDocument(docs, contents.value, isMarkdown(contents) ? "markdown" : "txt", isPreview);
      }
    }
    if (target == "float") {
      await this.hoverFactory.show(docs, {modes: ["n"]});
      return;
    }
    let lines = docs.reduce((p, c) => {
      let arr = c.content.split(/\r?\n/);
      if (p.length > 0)
        p.push("---");
      p.push(...arr);
      return p;
    }, []);
    if (target == "echo") {
      const msg = lines.join("\n").trim();
      if (msg.length) {
        await this.nvim.call("coc#util#echo_hover", msg);
      }
    } else {
      this.documentLines = lines;
      await this.nvim.command(`noswapfile pedit coc://document`);
    }
  }
  getPreferences() {
    let config = workspace_default.getConfiguration("coc.preferences");
    let hoverTarget = config.get("hoverTarget", "float");
    if (hoverTarget == "float" && !workspace_default.floatSupported) {
      hoverTarget = "preview";
    }
    this.preferences = {
      hoverTarget,
      previewMaxHeight: config.get("previewMaxHeight", 12),
      previewAutoClose: config.get("previewAutoClose", false),
      floatActions: config.get("floatActions", true)
    };
  }
  async getCurrentState() {
    let {nvim} = this;
    let [bufnr, [line, character], winid] = await nvim.eval("[bufnr('%'),coc#util#cursor(),win_getid()]");
    let doc = workspace_default.getDocument(bufnr);
    return {
      doc: doc && doc.attached ? doc : null,
      position: vscode_languageserver_protocol82.Position.create(line, character),
      winid
    };
  }
  dispose() {
    if (this.requestTimer) {
      clearTimeout(this.requestTimer);
      this.requestTimer = void 0;
    }
    this.refactor.dispose();
    this.signature.dispose();
    this.symbols.dispose();
    this.hoverFactory.dispose();
    this.colors.dispose();
    this.format.dispose();
    this.documentHighlighter.dispose();
    disposeAll(this.disposables);
  }
};
var handler_default = Handler;

// src/plugin.ts
var logger91 = require_logger2()("plugin");
var Plugin = class extends events34.EventEmitter {
  constructor(nvim) {
    super();
    this.nvim = nvim;
    this._ready = false;
    this.actions = new Map();
    Object.defineProperty(workspace_default, "nvim", {
      get: () => this.nvim
    });
    this.cursors = new cursors_default(nvim);
    this.addAction("hasProvider", (id) => this.handler.hasProvider(id));
    this.addAction("getTagList", async () => await this.handler.getTagList());
    this.addAction("hasSelected", () => completion_default.hasSelected());
    this.addAction("listNames", () => manager_default4.names);
    this.addAction("listDescriptions", () => manager_default4.descriptions);
    this.addAction("listLoadItems", async (name2) => await manager_default4.loadItems(name2));
    this.addAction("search", (...args) => this.handler.search(args));
    this.addAction("cursorsSelect", (bufnr, kind, mode) => this.cursors.select(bufnr, kind, mode));
    this.addAction("fillDiagnostics", (bufnr) => manager_default.setLocationlist(bufnr));
    this.addAction("getConfig", async (key) => {
      let document3 = await workspace_default.document;
      return workspace_default.getConfiguration(key, document3 ? document3.uri : void 0);
    });
    this.addAction("rootPatterns", (bufnr) => {
      let doc = workspace_default.getDocument(bufnr);
      if (!doc)
        return null;
      return {
        buffer: workspace_default.getRootPatterns(doc, PatternType.Buffer),
        server: workspace_default.getRootPatterns(doc, PatternType.LanguageServer),
        global: workspace_default.getRootPatterns(doc, PatternType.Global)
      };
    });
    this.addAction("installExtensions", async (...list2) => {
      await extensions_default.installExtensions(list2);
    });
    this.addAction("saveRefactor", async (bufnr) => {
      await this.handler.saveRefactor(bufnr);
    });
    this.addAction("updateExtensions", async (sync) => {
      await extensions_default.updateExtensions(sync);
    });
    this.addAction("commandList", () => commands_default.commandList.map((o) => o.id));
    this.addAction("openList", async (...args) => {
      await this.ready;
      await manager_default4.start(args);
    });
    this.addAction("selectSymbolRange", (inner, visualmode, supportedSymbols) => this.handler.selectSymbolRange(inner, visualmode, supportedSymbols));
    this.addAction("listResume", (name2) => manager_default4.resume(name2));
    this.addAction("listCancel", () => manager_default4.cancel(true));
    this.addAction("listPrev", (name2) => manager_default4.previous(name2));
    this.addAction("listNext", (name2) => manager_default4.next(name2));
    this.addAction("listFirst", (name2) => manager_default4.first(name2));
    this.addAction("listLast", (name2) => manager_default4.last(name2));
    this.addAction("sendRequest", (id, method, params) => services_default.sendRequest(id, method, params));
    this.addAction("sendNotification", (id, method, params) => {
      return services_default.sendNotification(id, method, params);
    });
    this.addAction("registNotification", (id, method) => {
      return services_default.registNotification(id, method);
    });
    this.addAction("doAutocmd", async (id, ...args) => {
      let autocmd = workspace_default.autocmds.get(id);
      if (autocmd) {
        try {
          await Promise.resolve(autocmd.callback.apply(autocmd.thisArg, args));
        } catch (e) {
          logger91.error(`Error on autocmd ${autocmd.event}`, e);
          window_default.showMessage(`Error on autocmd ${autocmd.event}: ${e.message}`);
        }
      }
    });
    this.addAction("updateConfig", (section2, val) => {
      workspace_default.configurations.updateUserConfig({[section2]: val});
    });
    this.addAction("snippetNext", async () => {
      await manager_default3.nextPlaceholder();
      return "";
    });
    this.addAction("snippetPrev", async () => {
      await manager_default3.previousPlaceholder();
      return "";
    });
    this.addAction("snippetCancel", () => {
      manager_default3.cancel();
    });
    this.addAction("openLocalConfig", async () => {
      await window_default.openLocalConfig();
    });
    this.addAction("openLog", async () => {
      let file = logger91.getLogFile();
      await workspace_default.jumpTo(URI.file(file).toString());
    });
    this.addAction("attach", () => {
      return workspace_default.attach();
    });
    this.addAction("detach", () => {
      return workspace_default.detach();
    });
    this.addAction("doKeymap", async (key, defaultReturn = "", pressed) => {
      let keymap = workspace_default.keymaps.get(key);
      if (!keymap) {
        logger91.error(`keymap for ${key} not found`);
        this.nvim.command(`silent! unmap <buffer> ${pressed.startsWith("{") && pressed.endsWith("}") ? `<${pressed.slice(1, -1)}>` : pressed}`, true);
        return defaultReturn;
      }
      let [fn, repeat2] = keymap;
      let res = await Promise.resolve(fn());
      if (repeat2)
        await nvim.command(`silent! call repeat#set("\\<Plug>(coc-${key})", -1)`);
      return res != null ? res : defaultReturn;
    });
    this.addAction("registExtensions", async (...folders2) => {
      for (let folder of folders2) {
        await extensions_default.loadExtension(folder);
      }
    });
    this.addAction("snippetCheck", async (checkExpand, checkJump) => {
      if (checkExpand && !extensions_default.has("coc-snippets")) {
        console.error("coc-snippets required for check expand status!");
        return false;
      }
      if (checkJump) {
        let jumpable = manager_default3.jumpable();
        if (jumpable)
          return true;
      }
      if (checkExpand) {
        let api = extensions_default.getExtensionApi("coc-snippets");
        if (api && api.hasOwnProperty("expandable")) {
          let expandable = await Promise.resolve(api.expandable());
          if (expandable)
            return true;
        }
      }
      return false;
    });
    this.addAction("showInfo", async () => {
      if (!this.infoChannel) {
        this.infoChannel = window_default.createOutputChannel("info");
      } else {
        this.infoChannel.clear();
      }
      let channel = this.infoChannel;
      channel.appendLine("## versions");
      channel.appendLine("");
      let out = await this.nvim.call("execute", ["version"]);
      let first = out.trim().split("\n", 2)[0].replace(/\(.*\)/, "").trim();
      channel.appendLine("vim version: " + first + `${workspace_default.isVim ? " " + workspace_default.env.version : ""}`);
      channel.appendLine("node version: " + process.version);
      channel.appendLine("coc.nvim version: " + this.version);
      channel.appendLine("coc.nvim directory: " + path64.default.dirname(__dirname));
      channel.appendLine("term: " + (process.env.TERM_PROGRAM || process.env.TERM));
      channel.appendLine("platform: " + process.platform);
      channel.appendLine("");
      channel.appendLine("## Log of coc.nvim");
      channel.appendLine("");
      let file = logger91.getLogFile();
      if (fs53.default.existsSync(file)) {
        let content = fs53.default.readFileSync(file, {encoding: "utf8"});
        channel.appendLine(content);
      }
      channel.show();
    });
    this.addAction("findLocations", (id, method, params, openCommand) => {
      return this.handler.findLocations(id, method, params, openCommand);
    });
    this.addAction("links", () => {
      return this.handler.links();
    });
    this.addAction("openLink", () => {
      return this.handler.openLink();
    });
    this.addAction("pickColor", () => {
      return this.handler.pickColor();
    });
    this.addAction("colorPresentation", () => {
      return this.handler.pickPresentation();
    });
    this.addAction("highlight", async () => {
      await this.handler.highlight();
    });
    this.addAction("fold", (kind) => {
      return this.handler.fold(kind);
    });
    this.addAction("startCompletion", async (option) => {
      await completion_default.startCompletion(option);
    });
    this.addAction("stopCompletion", () => {
      completion_default.stop(false);
    });
    this.addAction("sourceStat", () => {
      return sources_default.sourceStats();
    });
    this.addAction("refreshSource", async (name2) => {
      await sources_default.refresh(name2);
    });
    this.addAction("toggleSource", (name2) => {
      sources_default.toggleSource(name2);
    });
    this.addAction("diagnosticInfo", async () => {
      await manager_default.echoMessage();
    });
    this.addAction("diagnosticToggle", () => {
      manager_default.toggleDiagnostic();
    });
    this.addAction("diagnosticNext", async (severity) => {
      await manager_default.jumpNext(severity);
    });
    this.addAction("diagnosticPrevious", async (severity) => {
      await manager_default.jumpPrevious(severity);
    });
    this.addAction("diagnosticPreview", async () => {
      await manager_default.preview();
    });
    this.addAction("diagnosticList", () => {
      return manager_default.getDiagnosticList();
    });
    this.addAction("jumpDefinition", (openCommand) => {
      return this.handler.gotoDefinition(openCommand);
    });
    this.addAction("jumpDeclaration", (openCommand) => {
      return this.handler.gotoDeclaration(openCommand);
    });
    this.addAction("jumpImplementation", (openCommand) => {
      return this.handler.gotoImplementation(openCommand);
    });
    this.addAction("jumpTypeDefinition", (openCommand) => {
      return this.handler.gotoTypeDefinition(openCommand);
    });
    this.addAction("jumpReferences", (openCommand) => {
      return this.handler.gotoReferences(openCommand);
    });
    this.addAction("jumpUsed", (openCommand) => {
      return this.handler.gotoReferences(openCommand, false);
    });
    this.addAction("doHover", (hoverTarget) => {
      return this.handler.onHover(hoverTarget);
    });
    this.addAction("getHover", () => {
      return this.handler.getHover();
    });
    this.addAction("showSignatureHelp", () => {
      return this.handler.showSignatureHelp();
    });
    this.addAction("documentSymbols", async (bufnr) => {
      if (!bufnr)
        bufnr = await nvim.call("bufnr", ["%"]);
      return await this.handler.getDocumentSymbols(bufnr);
    });
    this.addAction("symbolRanges", () => {
      return this.handler.getSymbolsRanges();
    });
    this.addAction("selectionRanges", () => {
      return this.handler.getSelectionRanges();
    });
    this.addAction("rangeSelect", (visualmode, forward) => {
      return this.handler.selectRange(visualmode, forward);
    });
    this.addAction("rename", (newName) => {
      return this.handler.rename(newName);
    });
    this.addAction("getWorkspaceSymbols", async (input) => {
      let tokenSource = new vscode_languageserver_protocol83.CancellationTokenSource();
      return await languages_default.getWorkspaceSymbols(input, tokenSource.token);
    });
    this.addAction("formatSelected", (mode) => {
      return this.handler.documentRangeFormatting(mode);
    });
    this.addAction("format", () => {
      return this.handler.documentFormatting();
    });
    this.addAction("commands", () => {
      return this.handler.getCommands();
    });
    this.addAction("services", () => {
      return services_default.getServiceStats();
    });
    this.addAction("toggleService", (name2) => {
      return services_default.toggle(name2);
    });
    this.addAction("codeAction", (mode, only) => {
      return this.handler.doCodeAction(mode, only);
    });
    this.addAction("organizeImport", () => {
      return this.handler.doCodeAction(null, [vscode_languageserver_protocol83.CodeActionKind.SourceOrganizeImports]);
    });
    this.addAction("fixAll", () => {
      return this.handler.doCodeAction(null, [vscode_languageserver_protocol83.CodeActionKind.SourceFixAll]);
    });
    this.addAction("doCodeAction", (codeAction) => {
      return this.handler.applyCodeAction(codeAction);
    });
    this.addAction("codeActions", (mode, only) => {
      return this.handler.getCurrentCodeActions(mode, only);
    });
    this.addAction("quickfixes", (mode) => {
      return this.handler.getCurrentCodeActions(mode, [vscode_languageserver_protocol83.CodeActionKind.QuickFix]);
    });
    this.addAction("codeLensAction", () => {
      return this.handler.doCodeLensAction();
    });
    this.addAction("runCommand", (...args) => {
      return this.handler.runCommand(...args);
    });
    this.addAction("doQuickfix", () => {
      return this.handler.doQuickfix();
    });
    this.addAction("refactor", () => {
      return this.handler.doRefactor();
    });
    this.addAction("repeatCommand", () => {
      return commands_default.repeatCommand();
    });
    this.addAction("extensionStats", () => {
      return extensions_default.getExtensionStates();
    });
    this.addAction("loadedExtensions", () => {
      return extensions_default.loadedExtensions();
    });
    this.addAction("watchExtension", (id) => {
      return extensions_default.watchExtension(id);
    });
    this.addAction("activeExtension", (name2) => {
      return extensions_default.activate(name2);
    });
    this.addAction("deactivateExtension", (name2) => {
      return extensions_default.deactivate(name2);
    });
    this.addAction("reloadExtension", (name2) => {
      return extensions_default.reloadExtension(name2);
    });
    this.addAction("toggleExtension", (name2) => {
      return extensions_default.toggleExtension(name2);
    });
    this.addAction("uninstallExtension", (...args) => {
      return extensions_default.uninstallExtension(args);
    });
    this.addAction("getCurrentFunctionSymbol", () => {
      return this.handler.getCurrentFunctionSymbol();
    });
    this.addAction("getWordEdit", () => {
      return this.handler.getWordEdit();
    });
    this.addAction("addRanges", async (ranges) => {
      await this.cursors.addRanges(ranges);
    });
    this.addAction("currentWorkspacePath", () => {
      return workspace_default.rootPath;
    });
    this.addAction("addCommand", (cmd) => {
      this.addCommand(cmd);
    });
    this.addAction("selectCurrentPlaceholder", (triggerAutocmd) => {
      return manager_default3.selectCurrentPlaceholder(!!triggerAutocmd);
    });
    this.addAction("codeActionRange", (start, end, only) => this.handler.codeActionRange(start, end, only));
    workspace_default.onDidChangeWorkspaceFolders(() => {
      nvim.setVar("WorkspaceFolders", workspace_default.folderPaths, true);
    });
    commands_default.init(nvim, this);
  }
  addAction(key, fn) {
    if (this.actions.has(key)) {
      throw new Error(`Action ${key} already exists`);
    }
    this.actions.set(key, fn);
  }
  addCommand(cmd) {
    let id = `vim.${cmd.id}`;
    commands_default.registerCommand(id, async () => {
      await this.nvim.command(cmd.cmd);
    });
    if (cmd.title)
      commands_default.titles.set(id, cmd.title);
  }
  async init() {
    let {nvim} = this;
    let s = Date.now();
    try {
      await extensions_default.init();
      await workspace_default.init();
      languages_default.init();
      for (let item of workspace_default.env.vimCommands) {
        this.addCommand(item);
      }
      manager_default3.init();
      completion_default.init();
      manager_default.init();
      manager_default4.init(nvim);
      nvim.setVar("coc_workspace_initialized", 1, true);
      nvim.setVar("WorkspaceFolders", workspace_default.folderPaths, true);
      sources_default.init();
      this.handler = new handler_default(nvim);
      services_default.init();
      await extensions_default.activateExtensions();
      workspace_default.setupDynamicAutocmd(true);
      nvim.setVar("coc_service_initialized", 1, true);
      nvim.call("coc#util#do_autocmd", ["CocNvimInit"], true);
      this._ready = true;
      await events_default.fire("ready", []);
      logger91.info(`coc.nvim ${this.version} initialized with node: ${process.version} after ${Date.now() - s}ms`);
      this.emit("ready");
    } catch (e) {
      console.error(`Error on initialize: ${e.stack}`);
      logger91.error(e.stack);
    }
    workspace_default.onDidOpenTextDocument(async (doc) => {
      if (!doc.uri.endsWith(CONFIG_FILE_NAME))
        return;
      if (extensions_default.has("coc-json"))
        return;
      window_default.showMessage(`Run :CocInstall coc-json for json intellisense`, "more");
    });
  }
  get isReady() {
    return this._ready;
  }
  get ready() {
    if (this._ready)
      return Promise.resolve();
    return new Promise((resolve3) => {
      this.once("ready", () => {
        resolve3();
      });
    });
  }
  get version() {
    return workspace_default.version + "-59f84d444c";
  }
  hasAction(method) {
    return this.actions.has(method);
  }
  async cocAction(method, ...args) {
    let fn = this.actions.get(method);
    if (!fn)
      throw new Error(`Action "${method}" not exists`);
    return await Promise.resolve(fn.apply(null, args));
  }
  getHandler() {
    return this.handler;
  }
  dispose() {
    this.removeAllListeners();
    extensions_default.dispose();
    manager_default4.dispose();
    workspace_default.dispose();
    window_default.dispose();
    sources_default.dispose();
    services_default.stopAll();
    services_default.dispose();
    if (this.handler) {
      this.handler.dispose();
    }
    manager_default3.dispose();
    commands_default.dispose();
    completion_default.dispose();
    manager_default.dispose();
  }
};
var plugin_default = Plugin;

// src/main.ts
var attach = require_attach2().default;
attach({reader: process.stdin, writer: process.stdout});
process.on("uncaughtException", function(err) {
  let msg = "Uncaught exception: " + err.message;
  console.error(msg);
  logger92.error("uncaughtException", err.stack);
});
process.on("unhandledRejection", function(reason, p) {
  if (reason instanceof Error) {
    console.error("UnhandledRejection: " + reason.message + "\n" + reason.stack);
  } else {
    console.error("UnhandledRejection: " + reason);
  }
  logger92.error("unhandledRejection ", p, reason);
});
